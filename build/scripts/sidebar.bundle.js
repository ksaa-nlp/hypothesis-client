/**
 * Return a parsed `js-hypothesis-config` object from the document, or `{}`.
 *
 * Find all `<script class="js-hypothesis-config">` tags in the given document,
 * parse them as JSON, and return the parsed object.
 *
 * If there are no `js-hypothesis-config` tags in the document then return
 * `{}`.
 *
 * If there are multiple `js-hypothesis-config` tags in the document then merge
 * them into a single returned object (when multiple scripts contain the same
 * setting names, scripts further down in the document override those further
 * up).
 *
 * @param {Document|Element} document - The root element to search.
 */
function parseJsonConfig(document) {
  /** @type {Record<string, unknown>} */
  var config = {};
  var settingsElements = document.querySelectorAll('script.js-hypothesis-config');
  for (var i = 0; i < settingsElements.length; i++) {
    var settings = void 0;
    try {
      settings = JSON.parse(settingsElements[i].textContent || '');
    } catch (err) {
      console.warn('Could not parse settings from js-hypothesis-config tags', err);
      settings = {};
    }
    Object.assign(config, settings);
  }
  return config;
}

/**
 * Encode app configuration in a URL fragment.
 *
 * This is used by the annotator to pass configuration to the sidebar and
 * notebook apps, which they can easily read on startup. The configuration is
 * passed in the fragment to avoid invalidating cache entries for the URL
 * or adding noise to server logs.
 *
 * @param {string} baseURL
 * @param {object} config
 * @return {string} URL with added fragment
 */
function addConfigFragment(baseURL, config) {
  const url = new URL(baseURL);
  const params = new URLSearchParams();
  params.append('config', JSON.stringify(config));
  url.hash = params.toString();
  return url.toString();
}

/**
 * Parse configuration from a URL generated by {@link addConfigFragment}.
 *
 * @param {string} url
 * @return {Record<string, unknown>}
 */
function parseConfigFragment(url) {
  const configStr = new URL(url).hash.slice(1);
  const configJSON = new URLSearchParams(configStr).get('config');
  return JSON.parse(configJSON || '{}');
}

/**
 * Perform checks for situations in which the Hypothesis client might not work
 * properly.
 *
 * This function does not check for supported browser features. That is handled
 * by the boot script.
 *
 * @param {Window} window
 * @return {boolean} `true` if the checks passed
 */
function checkEnvironment(window) {
  const {
    version,
    origin
  } = parseConfigFragment(window.location.href);

  // If the sidebar and annotator code are using different versions of the
  // client, there might be a protocol mismatch in sidebar <-> guest/host RPC
  // calls. This can happen if an old version of the client has been cached
  // on the host/sidebar side. We try to set appropriate headers on the boot
  // script to minimize the chances of this happening, but there are still
  // situations beyond our control where it can happen.
  if (version !== '1.0.0-dummy-version') {
    console.warn(`The Hypothesis sidebar is using a different version (1.0.0-dummy-version) than the host page (${version}). It may not work.`);
    return false;
  }

  // The sidebar can't work if loaded in the wrong origin or an opaque origin
  // because various cross-frame messaging (eg. login window, host <-> sidebar
  // RPC) set an origin filter on `postMessage` calls to the sidebar frame for
  // security.
  if (window.origin === 'null') {
    console.warn(`Hypothesis has been loaded in a sandboxed frame. This is not supported.`);
    return false;
  } else if (window.origin !== origin) {
    console.warn(`The Hypothesis sidebar is running in a different origin (${window.origin}) than expected (${origin}). It may not work.`);
    return false;
  }
  return true;
}

/**
 * @typedef {import('../../types/config').SidebarSettings} SidebarSettings
 * @typedef {import('../../types/config').Service} Service
 */

/**
 * Return the configuration for the annotation service which the client would retrieve
 * annotations from which may contain the authority, grantToken and icon.
 *
 * @param {SidebarSettings} settings
 * @return {Service|null}
 */

function serviceConfig({
  services
}) {
  if (Array.isArray(services) && services[0]) {
    return services[0];
  }
  return null;
}

/** @typedef {import('../../types/config').SidebarSettings} SidebarSettings */

/**
 * Function that returns apiUrl from the settings object.
 *
 * @param {SidebarSettings} settings - The settings object
 * @return {string} The apiUrl from the service or the default apiUrl from the settings
 * @throws {Error} If the settings has a service but the service doesn't have an apiUrl
 *
 */
function getApiUrl(settings) {
  const service = serviceConfig(settings);
  if (service) {
    // If the host page contains a service setting then the client should default to
    // using that apiUrl.
    if (service.apiUrl) {
      return service.apiUrl;
    } else {
      throw new Error('Service should contain an apiUrl value.');
    }
  }
  return settings.apiUrl;
}

/**
 * Type conversion methods that coerce incoming configuration values to an
 * expected type or format that other parts of the UI may make assumptions
 * on. This is needed for incoming configuration values that are otherwise
 * not sanitized.
 *
 * Note that if the values passed are plain javascript values (such as ones
 * produced from JSON.parse), then these methods do not throw errors.
 */

/**
 * Returns a boolean
 *
 * @param {any} value - initial value
 * @return {boolean}
 */
function toBoolean(value) {
  if (typeof value === 'string') {
    if (value.trim().toLocaleLowerCase() === 'false') {
      // "false", "False", " false", "FALSE" all return false
      return false;
    }
  }
  const numericalVal = Number(value);
  if (!isNaN(numericalVal)) {
    return Boolean(numericalVal);
  }
  // Any non numerical or falsely string should return true, otherwise return false
  return typeof value === 'string';
}

/**
 * Returns either an integer or NaN
 *
 * @param {any} value - initial value
 * @return {number}
 */
function toInteger(value) {
  // Acts as a simple wrapper
  return parseInt(value);
}

/**
 * Returns either the value if its an object or an empty object
 *
 * @param {any} value - initial value
 * @return {object}
 */
function toObject$1(value) {
  if (typeof value === 'object' && value !== null) {
    return value;
  }
  // Don't attempt to fix the values, just ensure type correctness
  return {};
}

/**
 * Returns the value as a string or an empty string if the
 * value undefined, null or otherwise falsely.
 *
 * @param {any} value - initial value
 * @return {string}
 */
function toString(value) {
  if (value && typeof value.toString === 'function') {
    return value.toString();
  }
  return '';
}

/**
 * @template T
 * @typedef {import('preact').Ref<T>} Ref
 */

/**
 * Helper for downcasting a ref to a more specific type, where that is safe
 * to do.
 *
 * This is mainly useful to cast a generic `Ref<HTMLElement>` to a more specific
 * element type (eg. `Ref<HTMLDivElement>`) for use with the `ref` prop of a JSX element.
 * Since Preact only writes to the `ref` prop, such a cast is safe.
 *
 * @template T
 * @template {T} U
 * @param {Ref<T>|undefined} ref
 * @return {Ref<U>|undefined}
 */
function downcastRef$1(ref) {
  return (/** @type {Ref<U>|undefined} */ref
  );
}

/** @typedef {import('../../types/config').ConfigFromAnnotator} ConfigFromAnnotator */

/**
 * Return the app configuration specified by the frame embedding the Hypothesis
 * client.
 *
 * @param {Window} window
 * @return {ConfigFromAnnotator}
 */
function hostPageConfig(window) {
  const config = parseConfigFragment(window.location.href);

  // Known configuration parameters which we will import from the host page.
  // Note that since the host page is untrusted code, the filtering needs to
  // be done here.
  const paramWhiteList = [
  // Direct-linked annotation ID
  'annotations',
  // Direct-linked group ID
  'group',
  // Default query passed by url
  'query',
  // Config param added by the extension, Via etc.  indicating how Hypothesis
  // was added to the page.
  'appType',
  // Config params documented at
  // https://h.readthedocs.io/projects/client/en/latest/publishers/config/
  'openSidebar', 'showHighlights', 'services', 'branding',
  // New note button override.
  // This should be removed once new note button is enabled for everybody.
  'enableExperimentalNewNoteButton',
  // Forces the sidebar to filter annotations to a single user.
  'focus',
  // Fetch config from a parent frame.
  'requestConfigFromFrame',
  // Theme which can either be specified as 'clean'.
  // If nothing is the specified the classic look is applied.
  'theme', 'usernameUrl'];

  // We need to coerce incoming values from the host config for 2 reasons:
  //
  // 1. New versions of via may no longer support passing any type other than
  // string and our client is set up to expect values that are in fact not a
  // string in some cases. This will help cast these values to the expected
  // type if they can be.
  //
  // 2. A publisher of our sidebar could accidentally pass un-sanitized values
  // into the config and this ensures they safely work downstream even if they
  // are incorrect.
  //
  // Currently we are only handling the following config values do to the fact
  // that via3 will soon discontinue passing boolean types or integer types.
  //  - requestConfigFromFrame
  //  - openSidebar
  //
  // It is assumed we should expand this list and coerce and eventually
  // even validate all such config values.
  // See https://github.com/hypothesis/client/issues/1968

  /** @type {Record<string, (value: unknown) => unknown>} */
  const coercions = {
    openSidebar: toBoolean,
    /** @param {unknown} value */
    requestConfigFromFrame: value => {
      if (typeof value === 'string') {
        // Legacy `requestConfigFromFrame` value which holds only the origin.
        return value;
      }
      const objectVal = /** @type {{ origin: unknown, ancestorLevel: unknown }} */
      toObject$1(value);
      return {
        origin: toString(objectVal.origin),
        ancestorLevel: toInteger(objectVal.ancestorLevel)
      };
    }
  };

  /** @type {Record<string, unknown>} */
  const result = {};
  for (let [key, value] of Object.entries(config)) {
    if (!paramWhiteList.includes(key)) {
      continue;
    }

    // Ignore `null` values as these indicate a default value.
    // In this case the config value set in the sidebar app HTML config is
    // used.
    if (value === null) {
      continue;
    }
    if (coercions[key]) {
      result[key] = coercions[key](value);
    } else {
      result[key] = value;
    }
  }
  return result;
}

/** @param {number} val */
function byteToHex(val) {
  const str = val.toString(16);
  return str.length === 1 ? '0' + str : str;
}

/**
 * Generate a random hex string of `len` chars.
 *
 * @param {number} len - An even-numbered length string to generate.
 * @return {string}
 */
function generateHexString(len) {
  const bytes = new Uint8Array(len / 2);
  window.crypto.getRandomValues(bytes);
  return Array.from(bytes).map(byteToHex).join('');
}

/**
 * Return a Promise that rejects with an error after `delay` ms.
 *
 * @param {number} delay
 * @param {string} message
 */
function createTimeout(delay, message) {
  return new Promise((_, reject) => {
    setTimeout(() => reject(new Error(message)), delay);
  });
}

/**
 * Make a JSON-RPC call to a server in another frame using `postMessage`.
 *
 * @param {Window} frame - Frame to send call to
 * @param {string} origin - Origin filter for `window.postMessage` call
 * @param {string} method - Name of the JSON-RPC method
 * @param {unknown[]} params - Parameters of the JSON-RPC method
 * @param {number} [timeout] - Maximum time to wait in ms
 * @param {Window} [window_] - Test seam.
 * @return {Promise<unknown>} - A Promise for the response to the call
 */
function call(frame, origin, method, params = [], timeout = 2000, /* istanbul ignore next */
window_ = window) {
  const id = generateHexString(10);

  // Send RPC request.
  const request = {
    jsonrpc: '2.0',
    method,
    params,
    id
  };
  try {
    frame.postMessage(request, origin);
  } catch (err) {
    return Promise.reject(err);
  }

  // Await response or timeout.
  /** @type {(e: MessageEvent) => void} */
  let listener;
  const response = new Promise((resolve, reject) => {
    listener = event => {
      if (event.origin !== origin) {
        // Not from the frame that we sent the request to.
        return;
      }
      if (!(event.data instanceof Object) || event.data.jsonrpc !== '2.0' || event.data.id !== id) {
        // Not a valid JSON-RPC response.
        return;
      }
      const {
        error,
        result
      } = event.data;
      if (error !== undefined) {
        reject(error);
      } else if (result !== undefined) {
        resolve(result);
      } else {
        reject(new Error('RPC reply had no result or error'));
      }
    };
    window_.addEventListener('message', listener);
  });
  const responseOrTimeout = [response];
  if (timeout) {
    responseOrTimeout.push(createTimeout(timeout, `Request to ${origin} timed out`));
  }

  // Cleanup and return.
  // FIXME: If we added a `Promise.finally` polyfill we could simplify this.
  return Promise.race(responseOrTimeout).then(result => {
    window_.removeEventListener('message', listener);
    return result;
  }).catch(err => {
    window_.removeEventListener('message', listener);
    throw err;
  });
}

/**
 * Send a JSON-RPC 2.0 notification request to another frame via `postMessage`.
 * No response is expected.
 *
 * @param {Window} frame - Frame to send call to
 * @param {string} origin - Origin filter for `window.postMessage` call
 * @param {string} method - Name of the JSON-RPC method
 * @param {unknown[]} params - Parameters of the JSON-RPC method
 */
function notify(frame, origin, method, params = []) {
  const request = {
    jsonrpc: '2.0',
    method,
    params
  };
  frame.postMessage(request, origin);
}

/**
 * @typedef {import('../../types/config').ConfigFromHost} ConfigFromHost
 * @typedef {import('../../types/config').ConfigFromAnnotator} ConfigFromAnnotator
 * @typedef {import('../../types/config').ConfigFromEmbedder} ConfigFromEmbedder
 * @typedef {import('../../types/config').ConfigFromSidebar} ConfigFromSidebar
 * @typedef {import('../../types/config').RPCSettings} RPCSettings
 * @typedef {import('../../types/config').SidebarSettings} SidebarSettings
 * @typedef {import('../../types/config').Service['groups']} ServiceGroups
 */

/**
 * Ascend `levels` from `window_` to find the designated embedder frame.
 *
 * @param {number} levels - Number of ancestors levels to ascend
 * @param {Window=} window_
 * @return {Window}
 */
function getEmbedderFrame(levels, window_ = window) {
  let ancestorWindow = window_;
  for (let i = 0; i < levels; i++) {
    if (ancestorWindow === ancestorWindow.top) {
      throw new Error('The target parent frame has exceeded the ancestor tree. Try reducing the `requestConfigFromFrame.ancestorLevel` value in the `hypothesisConfig`');
    }
    ancestorWindow = ancestorWindow.parent;
  }
  return ancestorWindow;
}

/**
 * Which groups to load and show in the sidebar may be dictated in
 * ConfigFromHost configuration: the special value `$rpc:requestGroups`
 * indicates that the list of groups should be requested asynchronously.
 *
 * This function (maybe) mutates values in the provided `configFromHost`'s
 * ServiceGroups: `$rpc:requestGroups` values are replaced with
 * `Promise<string[]>`.
 *
 * @see ServiceGroups
 *
 * @param {ConfigFromHost} configFromHost
 * @param {RPCSettings} rpcSettings
 * @return {ConfigFromHost}
 */
function fetchServiceGroups(configFromHost, rpcSettings) {
  const services = configFromHost.services;
  if (!Array.isArray(services)) {
    return configFromHost;
  }
  services.forEach((service, index) => {
    if (service.groups === '$rpc:requestGroups') {
      // The `groups` need to be fetched from a secondary RPC call and
      // there should be no timeout as it may be waiting for user input.
      service.groups = /** @type {Promise<string[]>} */
      call(rpcSettings.targetFrame, rpcSettings.origin, 'requestGroups', [index], 0 // no timeout
      ).catch(() => {
        throw new Error('Unable to fetch groups');
      });
    }
  });
  return configFromHost;
}

/**
 * Derive RPC settings from the provided `ConfigFromAnnotator`, if any are present.
 *
 * @param {ConfigFromAnnotator} configFromAnnotator
 * @param {Window} window_
 * @return {import('../../types/config').RPCSettings|null}
 */
function buildRPCSettings(configFromAnnotator, window_) {
  const rpcConfig = configFromAnnotator.requestConfigFromFrame;
  if (!rpcConfig) {
    return null;
  } else if (typeof rpcConfig.ancestorLevel !== 'number' || typeof rpcConfig.origin !== 'string') {
    throw new Error('Improper `requestConfigFromFrame` object. Both `ancestorLevel` and `origin` need to be specified');
  }
  return {
    targetFrame: getEmbedderFrame(rpcConfig.ancestorLevel, window_),
    origin: rpcConfig.origin
  };
}

/**
 * Retrieve host configuration from embedder frame
 *
 * @param {ConfigFromAnnotator} configFromAnnotator
 * @param {RPCSettings} rpcSettings
 * @return {Promise<ConfigFromEmbedder>}
 */
async function getEmbedderConfig(configFromAnnotator, rpcSettings) {
  const configFromEmbedder = /** @type {ConfigFromEmbedder} */
  await call(rpcSettings.targetFrame, rpcSettings.origin, 'requestConfig', [], 3000);

  // In cases where host configuration is requested from the embedder frame
  // (`ConfigFromEmbedder`), `ConfigFromAnnotator` values are discarded.
  //
  // The `group` property, however, is currently not provided by
  // `ConfigFromEmbedder` and needs to be restored. This property is used by the
  // Notebook.
  // TODO: Notebook group should be set by alternate means
  return {
    ...configFromEmbedder,
    ...(configFromAnnotator.group ? {
      group: configFromAnnotator.group
    } : {})
  };
}

/**
 * Build a `SidebarSettings` object by merging the provided `ConfigFromSidebar`
 * with host configuration (`ConfigFromAnnotator` OR `ConfigFromEmbedder`).
 *
 * @see {ConfigFromAnnotator}
 * @see {ConfigFromEmbedder}
 * @see {ConfigFromHost}
 *
 * @param {ConfigFromSidebar} configFromSidebar
 * @param {Window} window_ - Test seam
 * @return {Promise<SidebarSettings>} - The merged settings
 */
async function buildSettings(configFromSidebar, window_ = window) {
  const configFromAnnotator = hostPageConfig(window);
  const rpcSettings = buildRPCSettings(configFromAnnotator, window_);
  let configFromHost;
  if (rpcSettings) {
    // The presence of RPCSettings indicates that we should
    // source the ConfigFromHost from another frame, and potentially load
    // the correct groups asynchronously as well.
    const configFromEmbedder = await getEmbedderConfig(configFromAnnotator, rpcSettings);
    configFromHost = fetchServiceGroups(configFromEmbedder, rpcSettings);
  } else {
    configFromHost = configFromAnnotator;
  }

  /** @type {SidebarSettings} */
  const sidebarSettings = {
    ...configFromSidebar,
    ...configFromHost
  };
  if (rpcSettings) {
    sidebarSettings.rpc = rpcSettings;
  }
  sidebarSettings.apiUrl = getApiUrl(sidebarSettings);
  return sidebarSettings;
}

/** @type {Set<string>} */
let shownWarnings = new Set();

/**
 * Log a warning if it has not already been reported.
 *
 * This is useful to avoid spamming the console if a warning is emitted in a
 * context that may be called frequently.
 *
 * @param {...unknown} args -
 *   Arguments to forward to `console.warn`. The arguments `toString()` values
 *   are concatenated into a string key which is used to determine if the warning
 *   has been logged before.
 */
function warnOnce(...args) {
  const key = args.join();
  if (shownWarnings.has(key)) {
    return;
  }
  console.warn(...args);
  shownWarnings.add(key);
}
warnOnce.reset = () => {
  shownWarnings.clear();
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

function getAugmentedNamespace(n) {
  var f = n.default;
	if (typeof f == "function") {
		var a = function () {
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

'use strict';

var escapeStringRegexp = string => {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	// Escape characters with special meaning either inside or outside character sets.
	// Use a simple backslash escape when it’s always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
	return string
		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
		.replace(/-/g, '\\x2d');
};

/**
 * @typedef {import('../../types/config').SidebarSettings} SidebarSettings
 * @typedef {import('../../types/api').Group} Group
 * @typedef {import('../../types/api').GroupIdentifier} GroupIdentifier
 */

/**
 * Should users be able to leave private groups of which they
 * are a member? Users may leave private groups unless
 * explicitly disallowed in the service configuration of the
 * `settings` object.
 *
 * @param {SidebarSettings} settings
 * @return {boolean}
 */
function allowLeavingGroups(settings) {
  const config = serviceConfig(settings);
  if (!config) {
    return true;
  }
  return !!config.allowLeavingGroups;
}

/**
 * Combine groups from multiple api calls together to form a unique list of groups.
 * Add an isMember property to each group indicating whether the logged in user is a member.
 * Add an isScopedToUri property to each group indicating whether the uri matches the group's
 *   uri patterns. If no uri patterns are specified, defaults to True.
 *
 * @param {Group[]} userGroups - groups the user is a member of
 * @param {Group[]} featuredGroups - all other groups, may include some duplicates from the userGroups
 * @param {string|null} uri - uri of the current page
 * @param {SidebarSettings} settings
 */
function combineGroups(userGroups, featuredGroups, uri, settings) {
  const worldGroup = featuredGroups.find(g => g.id === '__world__');
  if (worldGroup) {
    userGroups.unshift(worldGroup);
  }
  const myGroupIds = userGroups.map(g => g.id);
  featuredGroups = featuredGroups.filter(g => !myGroupIds.includes(g.id));

  // Set the isMember property indicating user membership.
  featuredGroups.forEach(group => group.isMember = false);
  userGroups.forEach(group => group.isMember = true);
  const groups = userGroups.concat(featuredGroups);

  // Set the `canLeave` property. Groups can be left if they are private unless
  // the global `allowLeavingGroups` value is false in the config settings object.
  groups.forEach(group => {
    group.canLeave = !allowLeavingGroups(settings) ? false : group.type === 'private';
  });

  // Add isScopedToUri property indicating whether a group is within scope
  // of the given uri. If the scope check cannot be performed, isScopedToUri
  // defaults to true.
  groups.forEach(group => group.isScopedToUri = isScopedToUri(group, uri));
  return groups;
}

/**
 * @param {Group} group
 * @param {string|null} uri
 */
function isScopedToUri(group, uri) {
  /* If a scope check cannot be performed, meaning:
   * - the group doesn't have a scopes attribute
   * - the group has no scopes.uri_patterns present
   * - there is no uri to compare against (aka: uri=null)
   * the group is defaulted to in-scope.
   */
  if (group.scopes && group.scopes.uri_patterns.length > 0 && uri) {
    return uriMatchesScopes(uri, group.scopes.uri_patterns);
  }
  return true;
}

/**
 * @param {string} uri
 * @param {string[]} scopes
 */
function uriMatchesScopes(uri, scopes) {
  return scopes.find(uriRegex => uri.match(
  // Convert *'s to .*'s for regex matching and escape all other special characters.
  uriRegex.split('*').map(escapeStringRegexp).join('.*'))) !== undefined;
}

/**
 * Find groups in `groups` by GroupIdentifier, which may be either an `id` or
 * `groupid`.
 *
 * @param {GroupIdentifier[]} groupIds
 * @param {Group[]} groups
 * @return {Group[]}
 */
function findGroupsByAnyIds(groupIds, groups) {
  return groups.filter(g => groupIds.includes(g.id) || g.groupid && groupIds.includes(g.groupid));
}

/**
 * Attempt to convert a list in which each entry might be either an `id`
 * (pubid) or a `groupid` into a list of `id`s by locating associated groups
 * in the set of all `groups`. Only return entries for groups that can be
 * found in `groups`.
 *
 * @param {GroupIdentifier[]} groupIds
 * @param {Group[]} groups
 * @return {Group["id"][]}
 */
function normalizeGroupIds(groupIds, groups) {
  return findGroupsByAnyIds(groupIds, groups).map(g => g.id);
}

/**
 * @typedef {import('../types/annotator').ContentInfoConfig} ContentInfoConfig
 * @typedef {import('../types/rpc').FocusUserInfo} FocusUserInfo
 */

/**
 * List of not-yet-processed messages received during application startup.
 *
 * @type {MessageEvent[]}
 */
let preStartQueue = [];

/**
 * Return the mapped methods that can be called remotely via this server.
 *
 * @param {import('./store').SidebarStore} store - The global store
 */
const registeredMethods = store => {
  return {
    /** @param {FocusUserInfo} userInfo */
    changeFocusModeUser: userInfo => {
      var _userInfo$groups;
      store.changeFocusModeUser(userInfo);
      const groupIds = (_userInfo$groups = userInfo === null || userInfo === void 0 ? void 0 : userInfo.groups) !== null && _userInfo$groups !== void 0 ? _userInfo$groups : [];
      const filteredGroupIds = normalizeGroupIds(groupIds, store.allGroups());
      if (groupIds.length && !filteredGroupIds.length) {
        console.error('No matching groups found in list of filtered group IDs');
      }
      store.filterGroups(filteredGroupIds);
    },
    /** @param {ContentInfoConfig} contentInfo */
    showContentInfo: contentInfo => {
      store.setContentInfo(contentInfo);
    }
  };
};

/**
 * See https://www.jsonrpc.org/specification#request_object.
 *
 * @typedef JSONRPCRequest
 * @prop {string} jsonrpc
 * @prop {string} id
 * @prop {string} method
 * @prop {unknown[]} [params]
 */

/**
 * Return true if `data` "looks like" a JSON-RPC message.
 *
 * @param {any} data
 * @return {data is JSONRPCRequest}
 */
function isJSONRPCRequest(data) {
  // eslint-disable-next-line eqeqeq
  if (data == null || typeof data !== 'object') {
    return false;
  }
  return data.jsonrpc === '2.0';
}

/**
 * Begin responding to JSON-RPC requests from frames on other origins.
 *
 * Register a window.postMessage() event listener that receives and responds to
 * JSON-RPC requests sent by frames on other origins using postMessage() as the
 * transport layer.
 *
 * Only frames whose origin is in the rpcAllowedOrigins config setting will be
 * responded to.
 *
 * This is a very partial implementation of a JSON-RPC 2.0 server:
 *
 * http://www.jsonrpc.org/specification
 *
 * The only part that we support so far is receiving JSON-RPC 2.0 requests (not
 * notifications) and sending back a successful "ok" response.
 *
 * All methods called upon must be mapped in the `registeredMethods` function.
 *
 * @param {import('./store').SidebarStore} store
 * @param {import('../types/config').SidebarSettings} settings
 * @param {Window} $window
 * @inject
 */
function startServer(store, settings, $window) {
  /** @type {Record<string, (...args: any[]) => void>} */
  const methods = registeredMethods(store);

  // Process the pre-start incoming RPC requests
  preStartQueue.forEach(event => {
    receiveMessage(event);
  });
  // Clear the queue and remove the preStartMessageListener
  preStartQueue = [];
  window.removeEventListener('message', preStartMessageListener);

  // Start listening to new RPC requests
  $window.addEventListener('message', receiveMessage);

  /** @param {MessageEvent} event */
  function receiveMessage(event) {
    let allowedOrigins = settings.rpcAllowedOrigins || [];
    if (!isJSONRPCRequest(event.data)) {
      return;
    }
    if (!allowedOrigins.includes(event.origin)) {
      warnOnce(`Ignoring JSON-RPC request from non-whitelisted origin ${event.origin}`);
      return;
    }

    // The entire JSON-RPC request object is contained in the postMessage()
    // data param.
    let jsonRpcRequest = event.data;
    const source = /** @type {Window} */event.source;
    source.postMessage(jsonRpcResponse(jsonRpcRequest), event.origin);
  }

  /**
   * Return a JSON-RPC response to the given JSON-RPC request object.
   *
   * @param {JSONRPCRequest} request
   */
  function jsonRpcResponse(request) {
    const method = methods[request.method];

    // Return an error response if the method name is not registered with
    // registeredMethods.
    if (method === undefined) {
      return {
        jsonrpc: '2.0',
        id: request.id,
        error: {
          code: -32601,
          message: 'Method not found'
        }
      };
    }

    // Call the method and return the result response.
    if (request.params) {
      method(...request.params);
    } else {
      method();
    }
    return {
      jsonrpc: '2.0',
      result: 'ok',
      id: request.id
    };
  }
}

/**
 * Queues all incoming RPC requests so they can be handled later.
 *
 * @param {MessageEvent} event - RPC event payload
 */
startServer.$inject = ["store", "settings", "$window"];
function preStartMessageListener(event) {
  preStartQueue.push(event);
}

/**
 * Start listening to incoming RPC requests right away so they don't timeout. These
 * requests are saved until the server starts up and then they can be handled accordingly.
 *
 * Why?
 *
 * This allows the client to fetch its config from the parent app frame and potentially
 * receive new unsolicited incoming requests that the parent app may send before this
 * RPC server starts.
 *
 * @param {Window} window_ - Test seam
 */
function preStartServer(window_ = window) {
  window_.addEventListener('message', preStartMessageListener);
}

/**
 * Prevent windows or tabs opened via links under `root` from accessing their
 * opening `Window`.
 *
 * This makes links with `target="blank"` attributes act as if they also had
 * the `rel="noopener"` [1] attribute set.
 *
 * In addition to preventing tab-jacking [2], this also enables multi-process
 * browsers to more easily use a new process for instances of Hypothesis in the
 * newly-opened tab and works around a bug in Chrome [3]
 *
 * [1] https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types#noopener
 * [2] https://mathiasbynens.github.io/rel-noopener/
 * [3] https://bugs.chromium.org/p/chromium/issues/detail?id=753314
 *
 * @param {Element} root - Root element
 */
function disableOpenerForExternalLinks(root) {
  root.addEventListener('click', event => {
    const target = /** @type {HTMLElement} */event.target;
    if (target.tagName === 'A') {
      const linkEl = /** @type {HTMLAnchorElement} */target;
      if (linkEl.target === '_blank') {
        linkEl.rel = 'noopener';
      }
    }
  });
}

// eslint-disable-next-line @typescript-eslint/unbound-method
const objectToString$1 = Object.prototype.toString;

/**
 * Checks whether given value's type is one of a few Error or Error-like
 * {@link isError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isError$1(wat) {
  switch (objectToString$1.call(wat)) {
    case '[object Error]':
    case '[object Exception]':
    case '[object DOMException]':
      return true;
    default:
      return isInstanceOf(wat, Error);
  }
}
/**
 * Checks whether given value is an instance of the given built-in class.
 *
 * @param wat The value to be checked
 * @param className
 * @returns A boolean representing the result.
 */
function isBuiltin(wat, className) {
  return objectToString$1.call(wat) === `[object ${className}]`;
}

/**
 * Checks whether given value's type is ErrorEvent
 * {@link isErrorEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isErrorEvent(wat) {
  return isBuiltin(wat, 'ErrorEvent');
}

/**
 * Checks whether given value's type is DOMError
 * {@link isDOMError}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isDOMError(wat) {
  return isBuiltin(wat, 'DOMError');
}

/**
 * Checks whether given value's type is DOMException
 * {@link isDOMException}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isDOMException(wat) {
  return isBuiltin(wat, 'DOMException');
}

/**
 * Checks whether given value's type is a string
 * {@link isString}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isString(wat) {
  return isBuiltin(wat, 'String');
}

/**
 * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)
 * {@link isPrimitive}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isPrimitive(wat) {
  return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');
}

/**
 * Checks whether given value's type is an object literal
 * {@link isPlainObject}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isPlainObject$1(wat) {
  return isBuiltin(wat, 'Object');
}

/**
 * Checks whether given value's type is an Event instance
 * {@link isEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isEvent(wat) {
  return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
}

/**
 * Checks whether given value's type is an Element instance
 * {@link isElement}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isElement(wat) {
  return typeof Element !== 'undefined' && isInstanceOf(wat, Element);
}

/**
 * Checks whether given value's type is an regexp
 * {@link isRegExp}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isRegExp(wat) {
  return isBuiltin(wat, 'RegExp');
}

/**
 * Checks whether given value has a then function.
 * @param wat A value to be checked.
 */
function isThenable(wat) {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
  return Boolean(wat && wat.then && typeof wat.then === 'function');
}

/**
 * Checks whether given value's type is a SyntheticEvent
 * {@link isSyntheticEvent}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isSyntheticEvent(wat) {
  return isPlainObject$1(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;
}

/**
 * Checks whether given value is NaN
 * {@link isNaN}.
 *
 * @param wat A value to be checked.
 * @returns A boolean representing the result.
 */
function isNaN$1(wat) {
  return typeof wat === 'number' && wat !== wat;
}

/**
 * Checks whether given value's type is an instance of provided constructor.
 * {@link isInstanceOf}.
 *
 * @param wat A value to be checked.
 * @param base A constructor to be used in a check.
 * @returns A boolean representing the result.
 */
function isInstanceOf(wat, base) {
  try {
    return wat instanceof base;
  } catch (_e) {
    return false;
  }
}

/** Internal global with common properties and Sentry extensions  */

// The code below for 'isGlobalObj' and 'GLOBAL_OBJ' was copied from core-js before modification
// https://github.com/zloirock/core-js/blob/1b944df55282cdc99c90db5f49eb0b6eda2cc0a3/packages/core-js/internals/global.js
// core-js has the following licence:
//
// Copyright (c) 2014-2022 Denis Pushkarev
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/** Returns 'obj' if it's the global object, otherwise returns undefined */
function isGlobalObj(obj) {
  return obj && obj.Math == Math ? obj : undefined;
}

/** Get's the global object for the current JavaScript runtime */
const GLOBAL_OBJ =
  (typeof globalThis == 'object' && isGlobalObj(globalThis)) ||
  // eslint-disable-next-line no-restricted-globals
  (typeof window == 'object' && isGlobalObj(window)) ||
  (typeof self == 'object' && isGlobalObj(self)) ||
  (typeof global == 'object' && isGlobalObj(global)) ||
  (function () {
    return this;
  })() ||
  {};

/**
 * @deprecated Use GLOBAL_OBJ instead or WINDOW from @sentry/browser. This will be removed in v8
 */
function getGlobalObject() {
  return GLOBAL_OBJ ;
}

/**
 * Returns a global singleton contained in the global `__SENTRY__` object.
 *
 * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory
 * function and added to the `__SENTRY__` object.
 *
 * @param name name of the global singleton on __SENTRY__
 * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`
 * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `GLOBAL_OBJ`'s return value
 * @returns the singleton
 */
function getGlobalSingleton(name, creator, obj) {
  const gbl = (obj || GLOBAL_OBJ) ;
  const __SENTRY__ = (gbl.__SENTRY__ = gbl.__SENTRY__ || {});
  const singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
  return singleton;
}

// eslint-disable-next-line deprecation/deprecation
const WINDOW$4 = getGlobalObject();

/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function htmlTreeAsString(elem, keyAttrs) {

  // try/catch both:
  // - accessing event.target (see getsentry/raven-js#838, #768)
  // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
  // - can throw an exception in some circumstances.
  try {
    let currentElem = elem ;
    const MAX_TRAVERSE_HEIGHT = 5;
    const MAX_OUTPUT_LEN = 80;
    const out = [];
    let height = 0;
    let len = 0;
    const separator = ' > ';
    const sepLength = separator.length;
    let nextStr;

    // eslint-disable-next-line no-plusplus
    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
      nextStr = _htmlElementAsString(currentElem, keyAttrs);
      // bail out if
      // - nextStr is the 'html' element
      // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
      //   (ignore this limit if we are on the first iteration)
      if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {
        break;
      }

      out.push(nextStr);

      len += nextStr.length;
      currentElem = currentElem.parentNode;
    }

    return out.reverse().join(separator);
  } catch (_oO) {
    return '<unknown>';
  }
}

/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function _htmlElementAsString(el, keyAttrs) {
  const elem = el

;

  const out = [];
  let className;
  let classes;
  let key;
  let attr;
  let i;

  if (!elem || !elem.tagName) {
    return '';
  }

  out.push(elem.tagName.toLowerCase());

  // Pairs of attribute keys defined in `serializeAttribute` and their values on element.
  const keyAttrPairs =
    keyAttrs && keyAttrs.length
      ? keyAttrs.filter(keyAttr => elem.getAttribute(keyAttr)).map(keyAttr => [keyAttr, elem.getAttribute(keyAttr)])
      : null;

  if (keyAttrPairs && keyAttrPairs.length) {
    keyAttrPairs.forEach(keyAttrPair => {
      out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
    });
  } else {
    if (elem.id) {
      out.push(`#${elem.id}`);
    }

    // eslint-disable-next-line prefer-const
    className = elem.className;
    if (className && isString(className)) {
      classes = className.split(/\s+/);
      for (i = 0; i < classes.length; i++) {
        out.push(`.${classes[i]}`);
      }
    }
  }
  const allowedAttrs = ['type', 'name', 'title', 'alt'];
  for (i = 0; i < allowedAttrs.length; i++) {
    key = allowedAttrs[i];
    attr = elem.getAttribute(key);
    if (attr) {
      out.push(`[${key}="${attr}"]`);
    }
  }
  return out.join('');
}

/**
 * A safe form of location.href
 */
function getLocationHref() {
  try {
    return WINDOW$4.document.location.href;
  } catch (oO) {
    return '';
  }
}

/**
 * Gets a DOM element by using document.querySelector.
 *
 * This wrapper will first check for the existance of the function before
 * actually calling it so that we don't have to take care of this check,
 * every time we want to access the DOM.
 *
 * Reason: DOM/querySelector is not available in all environments.
 *
 * We have to cast to any because utils can be consumed by a variety of environments,
 * and we don't want to break TS users. If you know what element will be selected by
 * `document.querySelector`, specify it as part of the generic call. For example,
 * `const element = getDomElement<Element>('selector');`
 *
 * @param selector the selector string passed on to document.querySelector
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getDomElement(selector) {
  if (WINDOW$4.document && WINDOW$4.document.querySelector) {
    return WINDOW$4.document.querySelector(selector) ;
  }
  return null;
}

/** An error emitted by Sentry SDKs and related utilities. */
class SentryError extends Error {
  /** Display name of this error instance. */

   constructor( message, logLevel = 'warn') {
    super(message);this.message = message;;

    this.name = new.target.prototype.constructor.name;
    // This sets the prototype to be `Error`, not `SentryError`. It's unclear why we do this, but commenting this line
    // out causes various (seemingly totally unrelated) playwright tests consistently time out. FYI, this makes
    // instances of `SentryError` fail `obj instanceof SentryError` checks.
    Object.setPrototypeOf(this, new.target.prototype);
    this.logLevel = logLevel;
  }
}

/** Regular expression used to parse a Dsn. */
const DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;

function isValidProtocol(protocol) {
  return protocol === 'http' || protocol === 'https';
}

/**
 * Renders the string representation of this Dsn.
 *
 * By default, this will render the public representation without the password
 * component. To get the deprecated private representation, set `withPassword`
 * to true.
 *
 * @param withPassword When set to true, the password will be included.
 */
function dsnToString(dsn, withPassword = false) {
  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;
  return (
    `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` +
    `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`
  );
}

/**
 * Parses a Dsn from a given string.
 *
 * @param str A Dsn as string
 * @returns Dsn as DsnComponents
 */
function dsnFromString(str) {
  const match = DSN_REGEX.exec(str);

  if (!match) {
    throw new SentryError(`Invalid Sentry Dsn: ${str}`);
  }

  const [protocol, publicKey, pass = '', host, port = '', lastPath] = match.slice(1);
  let path = '';
  let projectId = lastPath;

  const split = projectId.split('/');
  if (split.length > 1) {
    path = split.slice(0, -1).join('/');
    projectId = split.pop() ;
  }

  if (projectId) {
    const projectMatch = projectId.match(/^\d+/);
    if (projectMatch) {
      projectId = projectMatch[0];
    }
  }

  return dsnFromComponents({ host, pass, path, projectId, port, protocol: protocol , publicKey });
}

function dsnFromComponents(components) {
  return {
    protocol: components.protocol,
    publicKey: components.publicKey || '',
    pass: components.pass || '',
    host: components.host,
    port: components.port || '',
    path: components.path || '',
    projectId: components.projectId,
  };
}

function validateDsn(dsn) {
  if (!(typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {
    return;
  }

  const { port, projectId, protocol } = dsn;

  const requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];
  requiredComponents.forEach(component => {
    if (!dsn[component]) {
      throw new SentryError(`Invalid Sentry Dsn: ${component} missing`);
    }
  });

  if (!projectId.match(/^\d+$/)) {
    throw new SentryError(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
  }

  if (!isValidProtocol(protocol)) {
    throw new SentryError(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
  }

  if (port && isNaN(parseInt(port, 10))) {
    throw new SentryError(`Invalid Sentry Dsn: Invalid port ${port}`);
  }

  return true;
}

/** The Sentry Dsn, identifying a Sentry instance and project. */
function makeDsn(from) {
  const components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);
  validateDsn(components);
  return components;
}

/** Prefix for logging strings */
const PREFIX = 'Sentry Logger ';

const CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert', 'trace'] ;

/**
 * Temporarily disable sentry console instrumentations.
 *
 * @param callback The function to run against the original `console` messages
 * @returns The results of the callback
 */
function consoleSandbox(callback) {
  if (!('console' in GLOBAL_OBJ)) {
    return callback();
  }

  const originalConsole = GLOBAL_OBJ.console ;
  const wrappedLevels = {};

  // Restore all wrapped console methods
  CONSOLE_LEVELS.forEach(level => {
    // TODO(v7): Remove this check as it's only needed for Node 6
    const originalWrappedFunc =
      originalConsole[level] && (originalConsole[level] ).__sentry_original__;
    if (level in originalConsole && originalWrappedFunc) {
      wrappedLevels[level] = originalConsole[level] ;
      originalConsole[level] = originalWrappedFunc ;
    }
  });

  try {
    return callback();
  } finally {
    // Revert restoration to wrapped state
    Object.keys(wrappedLevels).forEach(level => {
      originalConsole[level] = wrappedLevels[level ];
    });
  }
}

function makeLogger() {
  let enabled = false;
  const logger = {
    enable: () => {
      enabled = true;
    },
    disable: () => {
      enabled = false;
    },
  };

  if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {
    CONSOLE_LEVELS.forEach(name => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      logger[name] = (...args) => {
        if (enabled) {
          consoleSandbox(() => {
            GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
          });
        }
      };
    });
  } else {
    CONSOLE_LEVELS.forEach(name => {
      logger[name] = () => undefined;
    });
  }

  return logger ;
}

// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used
let logger;
if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {
  logger = getGlobalSingleton('logger', makeLogger);
} else {
  logger = makeLogger();
}

/**
 * Truncates given string to the maximum characters count
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string (0 = unlimited)
 * @returns string Encoded
 */
function truncate(str, max = 0) {
  if (typeof str !== 'string' || max === 0) {
    return str;
  }
  return str.length <= max ? str : `${str.substr(0, max)}...`;
}

/**
 * This is basically just `trim_line` from
 * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67
 *
 * @param str An object that contains serializable values
 * @param max Maximum number of characters in truncated string
 * @returns string Encoded
 */
function snipLine(line, colno) {
  let newLine = line;
  const lineLength = newLine.length;
  if (lineLength <= 150) {
    return newLine;
  }
  if (colno > lineLength) {
    // eslint-disable-next-line no-param-reassign
    colno = lineLength;
  }

  let start = Math.max(colno - 60, 0);
  if (start < 5) {
    start = 0;
  }

  let end = Math.min(start + 140, lineLength);
  if (end > lineLength - 5) {
    end = lineLength;
  }
  if (end === lineLength) {
    start = Math.max(end - 140, 0);
  }

  newLine = newLine.slice(start, end);
  if (start > 0) {
    newLine = `'{snip} ${newLine}`;
  }
  if (end < lineLength) {
    newLine += ' {snip}';
  }

  return newLine;
}

/**
 * Join values in array
 * @param input array of values to be joined together
 * @param delimiter string to be placed in-between values
 * @returns Joined values
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function safeJoin(input, delimiter) {
  if (!Array.isArray(input)) {
    return '';
  }

  const output = [];
  // eslint-disable-next-line @typescript-eslint/prefer-for-of
  for (let i = 0; i < input.length; i++) {
    const value = input[i];
    try {
      output.push(String(value));
    } catch (e) {
      output.push('[value cannot be serialized]');
    }
  }

  return output.join(delimiter);
}

/**
 * Checks if the given value matches a regex or string
 *
 * @param value The string to test
 * @param pattern Either a regex or a string against which `value` will be matched
 * @param requireExactStringMatch If true, `value` must match `pattern` exactly. If false, `value` will match
 * `pattern` if it contains `pattern`. Only applies to string-type patterns.
 */
function isMatchingPattern(
  value,
  pattern,
  requireExactStringMatch = false,
) {
  if (!isString(value)) {
    return false;
  }

  if (isRegExp(pattern)) {
    return pattern.test(value);
  }
  if (isString(pattern)) {
    return requireExactStringMatch ? value === pattern : value.includes(pattern);
  }

  return false;
}

/**
 * Test the given string against an array of strings and regexes. By default, string matching is done on a
 * substring-inclusion basis rather than a strict equality basis
 *
 * @param testString The string to test
 * @param patterns The patterns against which to test the string
 * @param requireExactStringMatch If true, `testString` must match one of the given string patterns exactly in order to
 * count. If false, `testString` will match a string pattern if it contains that pattern.
 * @returns
 */
function stringMatchesSomePattern(
  testString,
  patterns = [],
  requireExactStringMatch = false,
) {
  return patterns.some(pattern => isMatchingPattern(testString, pattern, requireExactStringMatch));
}

/**
 * Given a string, escape characters which have meaning in the regex grammar, such that the result is safe to feed to
 * `new RegExp()`.
 *
 * Based on https://github.com/sindresorhus/escape-string-regexp. Vendored to a) reduce the size by skipping the runtime
 * type-checking, and b) ensure it gets down-compiled for old versions of Node (the published package only supports Node
 * 12+).
 *
 * @param regexString The string to escape
 * @returns An version of the string with all special regex characters escaped
 */
function escapeStringForRegex(regexString) {
  // escape the hyphen separately so we can also replace it with a unicode literal hyphen, to avoid the problems
  // discussed in https://github.com/sindresorhus/escape-string-regexp/issues/20.
  return regexString.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
}

/**
 * Replace a method in an object with a wrapped version of itself.
 *
 * @param source An object that contains a method to be wrapped.
 * @param name The name of the method to be wrapped.
 * @param replacementFactory A higher-order function that takes the original version of the given method and returns a
 * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to
 * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other
 * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.
 * @returns void
 */
function fill(source, name, replacementFactory) {
  if (!(name in source)) {
    return;
  }

  const original = source[name] ;
  const wrapped = replacementFactory(original) ;

  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work
  // otherwise it'll throw "TypeError: Object.defineProperties called on non-object"
  if (typeof wrapped === 'function') {
    try {
      markFunctionWrapped(wrapped, original);
    } catch (_Oo) {
      // This can throw if multiple fill happens on a global object like XMLHttpRequest
      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043
    }
  }

  source[name] = wrapped;
}

/**
 * Defines a non-enumerable property on the given object.
 *
 * @param obj The object on which to set the property
 * @param name The name of the property to be set
 * @param value The value to which to set the property
 */
function addNonEnumerableProperty(obj, name, value) {
  Object.defineProperty(obj, name, {
    // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
    value: value,
    writable: true,
    configurable: true,
  });
}

/**
 * Remembers the original function on the wrapped function and
 * patches up the prototype.
 *
 * @param wrapped the wrapper function
 * @param original the original function that gets wrapped
 */
function markFunctionWrapped(wrapped, original) {
  const proto = original.prototype || {};
  wrapped.prototype = original.prototype = proto;
  addNonEnumerableProperty(wrapped, '__sentry_original__', original);
}

/**
 * This extracts the original function if available.  See
 * `markFunctionWrapped` for more information.
 *
 * @param func the function to unwrap
 * @returns the unwrapped version of the function if available.
 */
function getOriginalFunction(func) {
  return func.__sentry_original__;
}

/**
 * Encodes given object into url-friendly format
 *
 * @param object An object that contains serializable values
 * @returns string Encoded
 */
function urlEncode(object) {
  return Object.keys(object)
    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`)
    .join('&');
}

/**
 * Transforms any `Error` or `Event` into a plain object with all of their enumerable properties, and some of their
 * non-enumerable properties attached.
 *
 * @param value Initial source that we have to transform in order for it to be usable by the serializer
 * @returns An Event or Error turned into an object - or the value argurment itself, when value is neither an Event nor
 *  an Error.
 */
function convertToPlainObject(
  value,
)

 {
  if (isError$1(value)) {
    return {
      message: value.message,
      name: value.name,
      stack: value.stack,
      ...getOwnProperties(value),
    };
  } else if (isEvent(value)) {
    const newObj

 = {
      type: value.type,
      target: serializeEventTarget(value.target),
      currentTarget: serializeEventTarget(value.currentTarget),
      ...getOwnProperties(value),
    };

    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {
      newObj.detail = value.detail;
    }

    return newObj;
  } else {
    return value;
  }
}

/** Creates a string representation of the target of an `Event` object */
function serializeEventTarget(target) {
  try {
    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
  } catch (_oO) {
    return '<unknown>';
  }
}

/** Filters out all but an object's own properties */
function getOwnProperties(obj) {
  if (typeof obj === 'object' && obj !== null) {
    const extractedProps = {};
    for (const property in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, property)) {
        extractedProps[property] = (obj )[property];
      }
    }
    return extractedProps;
  } else {
    return {};
  }
}

/**
 * Given any captured exception, extract its keys and create a sorted
 * and truncated list that will be used inside the event message.
 * eg. `Non-error exception captured with keys: foo, bar, baz`
 */
function extractExceptionKeysForMessage(exception, maxLength = 40) {
  const keys = Object.keys(convertToPlainObject(exception));
  keys.sort();

  if (!keys.length) {
    return '[object has no keys]';
  }

  if (keys[0].length >= maxLength) {
    return truncate(keys[0], maxLength);
  }

  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {
    const serialized = keys.slice(0, includedKeys).join(', ');
    if (serialized.length > maxLength) {
      continue;
    }
    if (includedKeys === keys.length) {
      return serialized;
    }
    return truncate(serialized, maxLength);
  }

  return '';
}

/**
 * Given any object, return a new object having removed all fields whose value was `undefined`.
 * Works recursively on objects and arrays.
 *
 * Attention: This function keeps circular references in the returned object.
 */
function dropUndefinedKeys(inputValue) {
  // This map keeps track of what already visited nodes map to.
  // Our Set - based memoBuilder doesn't work here because we want to the output object to have the same circular
  // references as the input object.
  const memoizationMap = new Map();

  // This function just proxies `_dropUndefinedKeys` to keep the `memoBuilder` out of this function's API
  return _dropUndefinedKeys(inputValue, memoizationMap);
}

function _dropUndefinedKeys(inputValue, memoizationMap) {
  if (isPlainObject$1(inputValue)) {
    // If this node has already been visited due to a circular reference, return the object it was mapped to in the new object
    const memoVal = memoizationMap.get(inputValue);
    if (memoVal !== undefined) {
      return memoVal ;
    }

    const returnValue = {};
    // Store the mapping of this value in case we visit it again, in case of circular data
    memoizationMap.set(inputValue, returnValue);

    for (const key of Object.keys(inputValue)) {
      if (typeof inputValue[key] !== 'undefined') {
        returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);
      }
    }

    return returnValue ;
  }

  if (Array.isArray(inputValue)) {
    // If this node has already been visited due to a circular reference, return the array it was mapped to in the new object
    const memoVal = memoizationMap.get(inputValue);
    if (memoVal !== undefined) {
      return memoVal ;
    }

    const returnValue = [];
    // Store the mapping of this value in case we visit it again, in case of circular data
    memoizationMap.set(inputValue, returnValue);

    inputValue.forEach((item) => {
      returnValue.push(_dropUndefinedKeys(item, memoizationMap));
    });

    return returnValue ;
  }

  return inputValue;
}

/**
 * Ensure that something is an object.
 *
 * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper
 * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.
 *
 * @param wat The subject of the objectification
 * @returns A version of `wat` which can safely be used with `Object` class methods
 */
function objectify(wat) {
  let objectified;
  switch (true) {
    case wat === undefined || wat === null:
      objectified = new String(wat);
      break;

    // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason
    // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as
    // an object in order to wrap it.
    case typeof wat === 'symbol' || typeof wat === 'bigint':
      objectified = Object(wat);
      break;

    // this will catch the remaining primitives: `String`, `Number`, and `Boolean`
    case isPrimitive(wat):
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      objectified = new (wat ).constructor(wat);
      break;

    // by process of elimination, at this point we know that `wat` must already be an object
    default:
      objectified = wat;
      break;
  }
  return objectified;
}

/**
 * Polyfill for the nullish coalescing operator (`??`).
 *
 * Note that the RHS is wrapped in a function so that if it's a computed value, that evaluation won't happen unless the
 * LHS evaluates to a nullish value, to mimic the operator's short-circuiting behavior.
 *
 * Adapted from Sucrase (https://github.com/alangpierce/sucrase)
 *
 * @param lhs The value of the expression to the left of the `??`
 * @param rhsFn A function returning the value of the expression to the right of the `??`
 * @returns The LHS value, unless it's `null` or `undefined`, in which case, the RHS value
 */
function _nullishCoalesce(lhs, rhsFn) {
  // by checking for loose equality to `null`, we catch both `null` and `undefined`
  return lhs != null ? lhs : rhsFn();
}

// adapted from Sucrase (https://github.com/alangpierce/sucrase)

/**
 * Polyfill for the nullish coalescing operator (`??`), when used in situations where at least one of the values is the
 * result of an async operation.
 *
 * Note that the RHS is wrapped in a function so that if it's a computed value, that evaluation won't happen unless the
 * LHS evaluates to a nullish value, to mimic the operator's short-circuiting behavior.
 *
 * Adapted from Sucrase (https://github.com/alangpierce/sucrase)
 *
 * @param lhs The value of the expression to the left of the `??`
 * @param rhsFn A function returning the value of the expression to the right of the `??`
 * @returns The LHS value, unless it's `null` or `undefined`, in which case, the RHS value
 */
// eslint-disable-next-line @sentry-internal/sdk/no-async-await
async function _asyncNullishCoalesce(lhs, rhsFn) {
  return _nullishCoalesce(lhs, rhsFn);
}

/**
 * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,
 * descriptors, and functions, for situations in which at least one part of the expression is async.
 *
 * Adapted from Sucrase (https://github.com/alangpierce/sucrase) See
 * https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15
 *
 * @param ops Array result of expression conversion
 * @returns The value of the expression
 */
// eslint-disable-next-line @sentry-internal/sdk/no-async-await
async function _asyncOptionalChain(ops) {
  let lastAccessLHS = undefined;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i] ;
    const fn = ops[i + 1] ;
    i += 2;
    // by checking for loose equality to `null`, we catch both `null` and `undefined`
    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
      // really we're meaning to return `undefined` as an actual value here, but it saves bytes not to write it
      return;
    }
    if (op === 'access' || op === 'optionalAccess') {
      lastAccessLHS = value;
      value = await fn(value);
    } else if (op === 'call' || op === 'optionalCall') {
      value = await fn((...args) => (value ).call(lastAccessLHS, ...args));
      lastAccessLHS = undefined;
    }
  }
  return value;
}

/**
 * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,
 * descriptors, and functions, in cases where the value of the expression is to be deleted.
 *
 * Adapted from Sucrase (https://github.com/alangpierce/sucrase) See
 * https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15
 *
 * @param ops Array result of expression conversion
 * @returns The return value of the `delete` operator: `true`, unless the deletion target is an own, non-configurable
 * property (one which can't be deleted or turned into an accessor, and whose enumerability can't be changed), in which
 * case `false`.
 */
// eslint-disable-next-line @sentry-internal/sdk/no-async-await
async function _asyncOptionalChainDelete(ops) {
  const result = (await _asyncOptionalChain(ops)) ;
  // If `result` is `null`, it means we didn't get to the end of the chain and so nothing was deleted (in which case,
  // return `true` since that's what `delete` does when it no-ops). If it's non-null, we know the delete happened, in
  // which case we return whatever the `delete` returned, which will be a boolean.
  return result == null ? true : (result );
}

/**
 * Copy a property from the given object into `exports`, under the given name.
 *
 * Adapted from Sucrase (https://github.com/alangpierce/sucrase)
 *
 * @param obj The object containing the property to copy.
 * @param localName The name under which to export the property
 * @param importedName The name under which the property lives in `obj`
 */
function _createNamedExportFrom(obj, localName, importedName) {
  exports[localName] = obj[importedName];
}

/**
 * Copy properties from an object into `exports`.
 *
 * Adapted from Sucrase (https://github.com/alangpierce/sucrase)
 *
 * @param obj The object containing the properties to copy.
 */
function _createStarExport(obj) {
  Object.keys(obj)
    .filter(key => key !== 'default' && key !== '__esModule' && !(key in exports))
    .forEach(key => (exports[key] = obj[key]));
}

/**
 * Unwraps a module if it has been wrapped in an object under the key `default`.
 *
 * Adapted from Rollup (https://github.com/rollup/rollup)
 *
 * @param requireResult The result of calling `require` on a module
 * @returns The full module, unwrapped if necessary.
 */
function _interopDefault(requireResult) {
  return requireResult.__esModule ? (requireResult.default ) : requireResult;
}

/**
 * Adds a self-referential `default` property to CJS modules which aren't the result of transpilation from ESM modules.
 *
 * Adapted from Rollup (https://github.com/rollup/rollup)
 *
 * @param requireResult The result of calling `require` on a module
 * @returns Either `requireResult` or a copy of `requireResult` with an added self-referential `default` property
 */
function _interopNamespace(requireResult) {
  return requireResult.__esModule ? requireResult : { ...requireResult, default: requireResult };
}

/**
 * Wrap a module in an object, as the value under the key `default`.
 *
 * Adapted from Rollup (https://github.com/rollup/rollup)
 *
 * @param requireResult The result of calling `require` on a module
 * @returns An object containing the key-value pair (`default`, `requireResult`)
 */
function _interopNamespaceDefaultOnly(requireResult) {
  return {
    __proto__: null,
    default: requireResult,
  };
}

/**
 * Wraps modules which aren't the result of transpiling an ESM module in an object under the key `default`
 *
 * Adapted from Sucrase (https://github.com/alangpierce/sucrase)
 *
 * @param requireResult The result of calling `require` on a module
 * @returns `requireResult` or `requireResult` wrapped in an object, keyed as `default`
 */
function _interopRequireDefault$1(requireResult) {
  return requireResult.__esModule ? requireResult : { default: requireResult };
}

/**
 * Adds a `default` property to CJS modules which aren't the result of transpilation from ESM modules.
 *
 * Adapted from Sucrase (https://github.com/alangpierce/sucrase)
 *
 * @param requireResult The result of calling `require` on a module
 * @returns Either `requireResult` or a copy of `requireResult` with an added self-referential `default` property
 */
function _interopRequireWildcard$1(requireResult) {
  return requireResult.__esModule ? requireResult : { ...requireResult, default: requireResult };
}

/**
 * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,
 * descriptors, and functions.
 *
 * Adapted from Sucrase (https://github.com/alangpierce/sucrase)
 * See https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15
 *
 * @param ops Array result of expression conversion
 * @returns The value of the expression
 */
function _optionalChain(ops) {
  let lastAccessLHS = undefined;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i] ;
    const fn = ops[i + 1] ;
    i += 2;
    // by checking for loose equality to `null`, we catch both `null` and `undefined`
    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
      // really we're meaning to return `undefined` as an actual value here, but it saves bytes not to write it
      return;
    }
    if (op === 'access' || op === 'optionalAccess') {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === 'call' || op === 'optionalCall') {
      value = fn((...args) => (value ).call(lastAccessLHS, ...args));
      lastAccessLHS = undefined;
    }
  }
  return value;
}

/**
 * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,
 * descriptors, and functions, in cases where the value of the expression is to be deleted.
 *
 * Adapted from Sucrase (https://github.com/alangpierce/sucrase) See
 * https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15
 *
 * @param ops Array result of expression conversion
 * @returns The return value of the `delete` operator: `true`, unless the deletion target is an own, non-configurable
 * property (one which can't be deleted or turned into an accessor, and whose enumerability can't be changed), in which
 * case `false`.
 */
function _optionalChainDelete(ops) {
  const result = _optionalChain(ops) ;
  // If `result` is `null`, it means we didn't get to the end of the chain and so nothing was deleted (in which case,
  // return `true` since that's what `delete` does when it no-ops). If it's non-null, we know the delete happened, in
  // which case we return whatever the `delete` returned, which will be a boolean.
  return result == null ? true : result;
}

const STACKTRACE_LIMIT = 50;

/**
 * Creates a stack parser with the supplied line parsers
 *
 * StackFrames are returned in the correct order for Sentry Exception
 * frames and with Sentry SDK internal frames removed from the top and bottom
 *
 */
function createStackParser(...parsers) {
  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);

  return (stack, skipFirst = 0) => {
    const frames = [];

    for (const line of stack.split('\n').slice(skipFirst)) {
      // https://github.com/getsentry/sentry-javascript/issues/5459
      // Remove webpack (error: *) wrappers
      const cleanedLine = line.replace(/\(error: (.*)\)/, '$1');

      for (const parser of sortedParsers) {
        const frame = parser(cleanedLine);

        if (frame) {
          frames.push(frame);
          break;
        }
      }
    }

    return stripSentryFramesAndReverse(frames);
  };
}

/**
 * Gets a stack parser implementation from Options.stackParser
 * @see Options
 *
 * If options contains an array of line parsers, it is converted into a parser
 */
function stackParserFromStackParserOptions(stackParser) {
  if (Array.isArray(stackParser)) {
    return createStackParser(...stackParser);
  }
  return stackParser;
}

/**
 * @hidden
 */
function stripSentryFramesAndReverse(stack) {
  if (!stack.length) {
    return [];
  }

  let localStack = stack;

  const firstFrameFunction = localStack[0].function || '';
  const lastFrameFunction = localStack[localStack.length - 1].function || '';

  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)
  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {
    localStack = localStack.slice(1);
  }

  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)
  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {
    localStack = localStack.slice(0, -1);
  }

  // The frame where the crash happened, should be the last entry in the array
  return localStack
    .slice(0, STACKTRACE_LIMIT)
    .map(frame => ({
      ...frame,
      filename: frame.filename || localStack[0].filename,
      function: frame.function || '?',
    }))
    .reverse();
}

const defaultFunctionName = '<anonymous>';

/**
 * Safely extract function name from itself
 */
function getFunctionName(fn) {
  try {
    if (!fn || typeof fn !== 'function') {
      return defaultFunctionName;
    }
    return fn.name || defaultFunctionName;
  } catch (e) {
    // Just accessing custom props in some Selenium environments
    // can cause a "Permission denied" exception (see raven-js#495).
    return defaultFunctionName;
  }
}

// eslint-disable-next-line complexity
function node(getModule) {
  const FILENAME_MATCH = /^\s*[-]{4,}$/;
  const FULL_MATCH = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/;

  // eslint-disable-next-line complexity
  return (line) => {
    if (line.match(FILENAME_MATCH)) {
      return {
        filename: line,
      };
    }

    const lineMatch = line.match(FULL_MATCH);
    if (!lineMatch) {
      return undefined;
    }

    let object;
    let method;
    let functionName;
    let typeName;
    let methodName;

    if (lineMatch[1]) {
      functionName = lineMatch[1];

      let methodStart = functionName.lastIndexOf('.');
      if (functionName[methodStart - 1] === '.') {
        // eslint-disable-next-line no-plusplus
        methodStart--;
      }

      if (methodStart > 0) {
        object = functionName.substr(0, methodStart);
        method = functionName.substr(methodStart + 1);
        const objectEnd = object.indexOf('.Module');
        if (objectEnd > 0) {
          functionName = functionName.substr(objectEnd + 1);
          object = object.substr(0, objectEnd);
        }
      }
      typeName = undefined;
    }

    if (method) {
      typeName = object;
      methodName = method;
    }

    if (method === '<anonymous>') {
      methodName = undefined;
      functionName = undefined;
    }

    if (functionName === undefined) {
      methodName = methodName || '<anonymous>';
      functionName = typeName ? `${typeName}.${methodName}` : methodName;
    }

    const filename = _optionalChain([lineMatch, 'access', _ => _[2], 'optionalAccess', _2 => _2.startsWith, 'call', _3 => _3('file://')]) ? lineMatch[2].substr(7) : lineMatch[2];
    const isNative = lineMatch[5] === 'native';
    const isInternal =
      isNative || (filename && !filename.startsWith('/') && !filename.startsWith('.') && filename.indexOf(':\\') !== 1);

    // in_app is all that's not an internal Node function or a module within node_modules
    // note that isNative appears to return true even for node core libraries
    // see https://github.com/getsentry/raven-node/issues/176
    const in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');

    return {
      filename,
      module: _optionalChain([getModule, 'optionalCall', _4 => _4(filename)]),
      function: functionName,
      lineno: parseInt(lineMatch[3], 10) || undefined,
      colno: parseInt(lineMatch[4], 10) || undefined,
      in_app,
    };
  };
}

/**
 * Node.js stack line parser
 *
 * This is in @sentry/utils so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.
 * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain
 */
function nodeStackLineParser(getModule) {
  return [90, node(getModule)];
}

// eslint-disable-next-line deprecation/deprecation
const WINDOW$3 = getGlobalObject();

/**
 * Tells whether current environment supports ErrorEvent objects
 * {@link supportsErrorEvent}.
 *
 * @returns Answer to the given question.
 */
function supportsErrorEvent() {
  try {
    new ErrorEvent('');
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Tells whether current environment supports DOMError objects
 * {@link supportsDOMError}.
 *
 * @returns Answer to the given question.
 */
function supportsDOMError() {
  try {
    // Chrome: VM89:1 Uncaught TypeError: Failed to construct 'DOMError':
    // 1 argument required, but only 0 present.
    // @ts-ignore It really needs 1 argument, not 0.
    new DOMError('');
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Tells whether current environment supports DOMException objects
 * {@link supportsDOMException}.
 *
 * @returns Answer to the given question.
 */
function supportsDOMException() {
  try {
    new DOMException('');
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Tells whether current environment supports Fetch API
 * {@link supportsFetch}.
 *
 * @returns Answer to the given question.
 */
function supportsFetch() {
  if (!('fetch' in WINDOW$3)) {
    return false;
  }

  try {
    new Headers();
    new Request('http://www.example.com');
    new Response();
    return true;
  } catch (e) {
    return false;
  }
}
/**
 * isNativeFetch checks if the given function is a native implementation of fetch()
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function isNativeFetch(func) {
  return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
}

/**
 * Tells whether current environment supports Fetch API natively
 * {@link supportsNativeFetch}.
 *
 * @returns true if `window.fetch` is natively implemented, false otherwise
 */
function supportsNativeFetch() {
  if (!supportsFetch()) {
    return false;
  }

  // Fast path to avoid DOM I/O
  // eslint-disable-next-line @typescript-eslint/unbound-method
  if (isNativeFetch(WINDOW$3.fetch)) {
    return true;
  }

  // window.fetch is implemented, but is polyfilled or already wrapped (e.g: by a chrome extension)
  // so create a "pure" iframe to see if that has native fetch
  let result = false;
  const doc = WINDOW$3.document;
  // eslint-disable-next-line deprecation/deprecation
  if (doc && typeof (doc.createElement ) === 'function') {
    try {
      const sandbox = doc.createElement('iframe');
      sandbox.hidden = true;
      doc.head.appendChild(sandbox);
      if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        result = isNativeFetch(sandbox.contentWindow.fetch);
      }
      doc.head.removeChild(sandbox);
    } catch (err) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);
    }
  }

  return result;
}

/**
 * Tells whether current environment supports ReportingObserver API
 * {@link supportsReportingObserver}.
 *
 * @returns Answer to the given question.
 */
function supportsReportingObserver() {
  return 'ReportingObserver' in WINDOW$3;
}

/**
 * Tells whether current environment supports Referrer Policy API
 * {@link supportsReferrerPolicy}.
 *
 * @returns Answer to the given question.
 */
function supportsReferrerPolicy() {
  // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default'
  // (see https://caniuse.com/#feat=referrer-policy),
  // it doesn't. And it throws an exception instead of ignoring this parameter...
  // REF: https://github.com/getsentry/raven-js/issues/1233

  if (!supportsFetch()) {
    return false;
  }

  try {
    new Request('_', {
      referrerPolicy: 'origin' ,
    });
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Tells whether current environment supports History API
 * {@link supportsHistory}.
 *
 * @returns Answer to the given question.
 */
function supportsHistory() {
  // NOTE: in Chrome App environment, touching history.pushState, *even inside
  //       a try/catch block*, will cause Chrome to output an error to console.error
  // borrowed from: https://github.com/angular/angular.js/pull/13945/files
  /* eslint-disable @typescript-eslint/no-unsafe-member-access */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const chrome = (WINDOW$3 ).chrome;
  const isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
  /* eslint-enable @typescript-eslint/no-unsafe-member-access */
  const hasHistoryApi = 'history' in WINDOW$3 && !!WINDOW$3.history.pushState && !!WINDOW$3.history.replaceState;

  return !isChromePackagedApp && hasHistoryApi;
}

// eslint-disable-next-line deprecation/deprecation
const WINDOW$2 = getGlobalObject();

/**
 * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.
 *  - Console API
 *  - Fetch API
 *  - XHR API
 *  - History API
 *  - DOM API (click/typing)
 *  - Error API
 *  - UnhandledRejection API
 */

const handlers = {};
const instrumented = {};

/** Instruments given API */
function instrument(type) {
  if (instrumented[type]) {
    return;
  }

  instrumented[type] = true;

  switch (type) {
    case 'console':
      instrumentConsole();
      break;
    case 'dom':
      instrumentDOM();
      break;
    case 'xhr':
      instrumentXHR();
      break;
    case 'fetch':
      instrumentFetch();
      break;
    case 'history':
      instrumentHistory();
      break;
    case 'error':
      instrumentError();
      break;
    case 'unhandledrejection':
      instrumentUnhandledRejection();
      break;
    default:
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('unknown instrumentation type:', type);
      return;
  }
}

/**
 * Add handler that will be called when given type of instrumentation triggers.
 * Use at your own risk, this might break without changelog notice, only used internally.
 * @hidden
 */
function addInstrumentationHandler(type, callback) {
  handlers[type] = handlers[type] || [];
  (handlers[type] ).push(callback);
  instrument(type);
}

/** JSDoc */
function triggerHandlers(type, data) {
  if (!type || !handlers[type]) {
    return;
  }

  for (const handler of handlers[type] || []) {
    try {
      handler(data);
    } catch (e) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        logger.error(
          `Error while triggering instrumentation handler.\nType: ${type}\nName: ${getFunctionName(handler)}\nError:`,
          e,
        );
    }
  }
}

/** JSDoc */
function instrumentConsole() {
  if (!('console' in WINDOW$2)) {
    return;
  }

  CONSOLE_LEVELS.forEach(function (level) {
    if (!(level in WINDOW$2.console)) {
      return;
    }

    fill(WINDOW$2.console, level, function (originalConsoleMethod) {
      return function (...args) {
        triggerHandlers('console', { args, level });

        // this fails for some browsers. :(
        if (originalConsoleMethod) {
          originalConsoleMethod.apply(WINDOW$2.console, args);
        }
      };
    });
  });
}

/** JSDoc */
function instrumentFetch() {
  if (!supportsNativeFetch()) {
    return;
  }

  fill(WINDOW$2, 'fetch', function (originalFetch) {
    return function (...args) {
      const handlerData = {
        args,
        fetchData: {
          method: getFetchMethod(args),
          url: getFetchUrl(args),
        },
        startTimestamp: Date.now(),
      };

      triggerHandlers('fetch', {
        ...handlerData,
      });

      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      return originalFetch.apply(WINDOW$2, args).then(
        (response) => {
          triggerHandlers('fetch', {
            ...handlerData,
            endTimestamp: Date.now(),
            response,
          });
          return response;
        },
        (error) => {
          triggerHandlers('fetch', {
            ...handlerData,
            endTimestamp: Date.now(),
            error,
          });
          // NOTE: If you are a Sentry user, and you are seeing this stack frame,
          //       it means the sentry.javascript SDK caught an error invoking your application code.
          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.
          throw error;
        },
      );
    };
  });
}

/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/** Extract `method` from fetch call arguments */
function getFetchMethod(fetchArgs = []) {
  if ('Request' in WINDOW$2 && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {
    return String(fetchArgs[0].method).toUpperCase();
  }
  if (fetchArgs[1] && fetchArgs[1].method) {
    return String(fetchArgs[1].method).toUpperCase();
  }
  return 'GET';
}

/** Extract `url` from fetch call arguments */
function getFetchUrl(fetchArgs = []) {
  if (typeof fetchArgs[0] === 'string') {
    return fetchArgs[0];
  }
  if ('Request' in WINDOW$2 && isInstanceOf(fetchArgs[0], Request)) {
    return fetchArgs[0].url;
  }
  return String(fetchArgs[0]);
}
/* eslint-enable @typescript-eslint/no-unsafe-member-access */

/** JSDoc */
function instrumentXHR() {
  if (!('XMLHttpRequest' in WINDOW$2)) {
    return;
  }

  const xhrproto = XMLHttpRequest.prototype;

  fill(xhrproto, 'open', function (originalOpen) {
    return function ( ...args) {
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      const xhr = this;
      const url = args[1];
      const xhrInfo = (xhr.__sentry_xhr__ = {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        method: isString(args[0]) ? args[0].toUpperCase() : args[0],
        url: args[1],
      });

      // if Sentry key appears in URL, don't capture it as a request
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      if (isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {
        xhr.__sentry_own_request__ = true;
      }

      const onreadystatechangeHandler = function () {
        if (xhr.readyState === 4) {
          try {
            // touching statusCode in some platforms throws
            // an exception
            xhrInfo.status_code = xhr.status;
          } catch (e) {
            /* do nothing */
          }

          triggerHandlers('xhr', {
            args,
            endTimestamp: Date.now(),
            startTimestamp: Date.now(),
            xhr,
          });
        }
      };

      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {
        fill(xhr, 'onreadystatechange', function (original) {
          return function (...readyStateArgs) {
            onreadystatechangeHandler();
            return original.apply(xhr, readyStateArgs);
          };
        });
      } else {
        xhr.addEventListener('readystatechange', onreadystatechangeHandler);
      }

      return originalOpen.apply(xhr, args);
    };
  });

  fill(xhrproto, 'send', function (originalSend) {
    return function ( ...args) {
      if (this.__sentry_xhr__ && args[0] !== undefined) {
        this.__sentry_xhr__.body = args[0];
      }

      triggerHandlers('xhr', {
        args,
        startTimestamp: Date.now(),
        xhr: this,
      });

      return originalSend.apply(this, args);
    };
  });
}

let lastHref;

/** JSDoc */
function instrumentHistory() {
  if (!supportsHistory()) {
    return;
  }

  const oldOnPopState = WINDOW$2.onpopstate;
  WINDOW$2.onpopstate = function ( ...args) {
    const to = WINDOW$2.location.href;
    // keep track of the current URL state, as we always receive only the updated state
    const from = lastHref;
    lastHref = to;
    triggerHandlers('history', {
      from,
      to,
    });
    if (oldOnPopState) {
      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.
      // https://github.com/getsentry/sentry-javascript/issues/3344
      // https://github.com/bugsnag/bugsnag-js/issues/469
      try {
        return oldOnPopState.apply(this, args);
      } catch (_oO) {
        // no-empty
      }
    }
  };

  /** @hidden */
  function historyReplacementFunction(originalHistoryFunction) {
    return function ( ...args) {
      const url = args.length > 2 ? args[2] : undefined;
      if (url) {
        // coerce to string (this is what pushState does)
        const from = lastHref;
        const to = String(url);
        // keep track of the current URL state, as we always receive only the updated state
        lastHref = to;
        triggerHandlers('history', {
          from,
          to,
        });
      }
      return originalHistoryFunction.apply(this, args);
    };
  }

  fill(WINDOW$2.history, 'pushState', historyReplacementFunction);
  fill(WINDOW$2.history, 'replaceState', historyReplacementFunction);
}

const debounceDuration = 1000;
let debounceTimerID;
let lastCapturedEvent;

/**
 * Decide whether the current event should finish the debounce of previously captured one.
 * @param previous previously captured event
 * @param current event to be captured
 */
function shouldShortcircuitPreviousDebounce(previous, current) {
  // If there was no previous event, it should always be swapped for the new one.
  if (!previous) {
    return true;
  }

  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.
  if (previous.type !== current.type) {
    return true;
  }

  try {
    // If both events have the same type, it's still possible that actions were performed on different targets.
    // e.g. 2 clicks on different buttons.
    if (previous.target !== current.target) {
      return true;
    }
  } catch (e) {
    // just accessing `target` property can throw an exception in some rare circumstances
    // see: https://github.com/getsentry/sentry-javascript/issues/838
  }

  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_
  // to which an event listener was attached), we treat them as the same action, as we want to capture
  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.
  return false;
}

/**
 * Decide whether an event should be captured.
 * @param event event to be captured
 */
function shouldSkipDOMEvent(event) {
  // We are only interested in filtering `keypress` events for now.
  if (event.type !== 'keypress') {
    return false;
  }

  try {
    const target = event.target ;

    if (!target || !target.tagName) {
      return true;
    }

    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body
    // e.g.tabbing through elements, hotkeys, etc.
    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
      return false;
    }
  } catch (e) {
    // just accessing `target` property can throw an exception in some rare circumstances
    // see: https://github.com/getsentry/sentry-javascript/issues/838
  }

  return true;
}

/**
 * Wraps addEventListener to capture UI breadcrumbs
 * @param handler function that will be triggered
 * @param globalListener indicates whether event was captured by the global event listener
 * @returns wrapped breadcrumb events handler
 * @hidden
 */
function makeDOMEventHandler(handler, globalListener = false) {
  return (event) => {
    // It's possible this handler might trigger multiple times for the same
    // event (e.g. event propagation through node ancestors).
    // Ignore if we've already captured that event.
    if (!event || lastCapturedEvent === event) {
      return;
    }

    // We always want to skip _some_ events.
    if (shouldSkipDOMEvent(event)) {
      return;
    }

    const name = event.type === 'keypress' ? 'input' : event.type;

    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.
    if (debounceTimerID === undefined) {
      handler({
        event: event,
        name,
        global: globalListener,
      });
      lastCapturedEvent = event;
    }
    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.
    // If that's the case, emit the previous event and store locally the newly-captured DOM event.
    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
      handler({
        event: event,
        name,
        global: globalListener,
      });
      lastCapturedEvent = event;
    }

    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.
    clearTimeout(debounceTimerID);
    debounceTimerID = WINDOW$2.setTimeout(() => {
      debounceTimerID = undefined;
    }, debounceDuration);
  };
}

/** JSDoc */
function instrumentDOM() {
  if (!('document' in WINDOW$2)) {
    return;
  }

  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom
  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before
  // we instrument `addEventListener` so that we don't end up attaching this handler twice.
  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');
  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
  WINDOW$2.document.addEventListener('click', globalDOMEventHandler, false);
  WINDOW$2.document.addEventListener('keypress', globalDOMEventHandler, false);

  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled
  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That
  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler
  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still
  // guaranteed to fire at least once.)
  ['EventTarget', 'Node'].forEach((target) => {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    const proto = (WINDOW$2 )[target] && (WINDOW$2 )[target].prototype;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins
    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {
      return;
    }

    fill(proto, 'addEventListener', function (originalAddEventListener) {
      return function (

        type,
        listener,
        options,
      ) {
        if (type === 'click' || type == 'keypress') {
          try {
            const el = this ;
            const handlers = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});
            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });

            if (!handlerForType.handler) {
              const handler = makeDOMEventHandler(triggerDOMHandler);
              handlerForType.handler = handler;
              originalAddEventListener.call(this, type, handler, options);
            }

            handlerForType.refCount += 1;
          } catch (e) {
            // Accessing dom properties is always fragile.
            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
          }
        }

        return originalAddEventListener.call(this, type, listener, options);
      };
    });

    fill(
      proto,
      'removeEventListener',
      function (originalRemoveEventListener) {
        return function (

          type,
          listener,
          options,
        ) {
          if (type === 'click' || type == 'keypress') {
            try {
              const el = this ;
              const handlers = el.__sentry_instrumentation_handlers__ || {};
              const handlerForType = handlers[type];

              if (handlerForType) {
                handlerForType.refCount -= 1;
                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.
                if (handlerForType.refCount <= 0) {
                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                  handlerForType.handler = undefined;
                  delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete
                }

                // If there are no longer any custom handlers of any type on this element, cleanup everything.
                if (Object.keys(handlers).length === 0) {
                  delete el.__sentry_instrumentation_handlers__;
                }
              }
            } catch (e) {
              // Accessing dom properties is always fragile.
              // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
            }
          }

          return originalRemoveEventListener.call(this, type, listener, options);
        };
      },
    );
  });
}

let _oldOnErrorHandler = null;
/** JSDoc */
function instrumentError() {
  _oldOnErrorHandler = WINDOW$2.onerror;

  WINDOW$2.onerror = function (msg, url, line, column, error) {
    triggerHandlers('error', {
      column,
      error,
      line,
      msg,
      url,
    });

    if (_oldOnErrorHandler) {
      // eslint-disable-next-line prefer-rest-params
      return _oldOnErrorHandler.apply(this, arguments);
    }

    return false;
  };
}

let _oldOnUnhandledRejectionHandler = null;
/** JSDoc */
function instrumentUnhandledRejection() {
  _oldOnUnhandledRejectionHandler = WINDOW$2.onunhandledrejection;

  WINDOW$2.onunhandledrejection = function (e) {
    triggerHandlers('unhandledrejection', e);

    if (_oldOnUnhandledRejectionHandler) {
      // eslint-disable-next-line prefer-rest-params
      return _oldOnUnhandledRejectionHandler.apply(this, arguments);
    }

    return true;
  };
}

/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * Helper to decycle json objects
 */
function memoBuilder() {
  const hasWeakSet = typeof WeakSet === 'function';
  const inner = hasWeakSet ? new WeakSet() : [];
  function memoize(obj) {
    if (hasWeakSet) {
      if (inner.has(obj)) {
        return true;
      }
      inner.add(obj);
      return false;
    }
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (let i = 0; i < inner.length; i++) {
      const value = inner[i];
      if (value === obj) {
        return true;
      }
    }
    inner.push(obj);
    return false;
  }

  function unmemoize(obj) {
    if (hasWeakSet) {
      inner.delete(obj);
    } else {
      for (let i = 0; i < inner.length; i++) {
        if (inner[i] === obj) {
          inner.splice(i, 1);
          break;
        }
      }
    }
  }
  return [memoize, unmemoize];
}

/**
 * UUID4 generator
 *
 * @returns string Generated UUID4.
 */
function uuid4() {
  const gbl = GLOBAL_OBJ ;
  const crypto = gbl.crypto || gbl.msCrypto;

  if (crypto && crypto.randomUUID) {
    return crypto.randomUUID().replace(/-/g, '');
  }

  const getRandomByte =
    crypto && crypto.getRandomValues ? () => crypto.getRandomValues(new Uint8Array(1))[0] : () => Math.random() * 16;

  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
  // Concatenating the following numbers as strings results in '10000000100040008000100000000000'
  return (([1e7] ) + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, c =>
    // eslint-disable-next-line no-bitwise
    ((c ) ^ ((getRandomByte() & 15) >> ((c ) / 4))).toString(16),
  );
}

function getFirstException(event) {
  return event.exception && event.exception.values ? event.exception.values[0] : undefined;
}

/**
 * Extracts either message or type+value from an event that can be used for user-facing logs
 * @returns event's description
 */
function getEventDescription(event) {
  const { message, event_id: eventId } = event;
  if (message) {
    return message;
  }

  const firstException = getFirstException(event);
  if (firstException) {
    if (firstException.type && firstException.value) {
      return `${firstException.type}: ${firstException.value}`;
    }
    return firstException.type || firstException.value || eventId || '<unknown>';
  }
  return eventId || '<unknown>';
}

/**
 * Adds exception values, type and value to an synthetic Exception.
 * @param event The event to modify.
 * @param value Value of the exception.
 * @param type Type of the exception.
 * @hidden
 */
function addExceptionTypeValue(event, value, type) {
  const exception = (event.exception = event.exception || {});
  const values = (exception.values = exception.values || []);
  const firstException = (values[0] = values[0] || {});
  if (!firstException.value) {
    firstException.value = value || '';
  }
  if (!firstException.type) {
    firstException.type = type || 'Error';
  }
}

/**
 * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.
 *
 * @param event The event to modify.
 * @param newMechanism Mechanism data to add to the event.
 * @hidden
 */
function addExceptionMechanism(event, newMechanism) {
  const firstException = getFirstException(event);
  if (!firstException) {
    return;
  }

  const defaultMechanism = { type: 'generic', handled: true };
  const currentMechanism = firstException.mechanism;
  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };

  if (newMechanism && 'data' in newMechanism) {
    const mergedData = { ...(currentMechanism && currentMechanism.data), ...newMechanism.data };
    firstException.mechanism.data = mergedData;
  }
}

// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string
const SEMVER_REGEXP =
  /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;

/**
 * Represents Semantic Versioning object
 */

/**
 * Parses input into a SemVer interface
 * @param input string representation of a semver version
 */
function parseSemver(input) {
  const match = input.match(SEMVER_REGEXP) || [];
  const major = parseInt(match[1], 10);
  const minor = parseInt(match[2], 10);
  const patch = parseInt(match[3], 10);
  return {
    buildmetadata: match[5],
    major: isNaN(major) ? undefined : major,
    minor: isNaN(minor) ? undefined : minor,
    patch: isNaN(patch) ? undefined : patch,
    prerelease: match[4],
  };
}

/**
 * This function adds context (pre/post/line) lines to the provided frame
 *
 * @param lines string[] containing all lines
 * @param frame StackFrame that will be mutated
 * @param linesOfContext number of context lines we want to add pre/post
 */
function addContextToFrame(lines, frame, linesOfContext = 5) {
  const lineno = frame.lineno || 0;
  const maxLines = lines.length;
  const sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);

  frame.pre_context = lines
    .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)
    .map((line) => snipLine(line, 0));

  frame.context_line = snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);

  frame.post_context = lines
    .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)
    .map((line) => snipLine(line, 0));
}

/**
 * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object
 * in question), and marks it captured if not.
 *
 * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and
 * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so
 * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because
 * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not
 * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This
 * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we
 * see it.
 *
 * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on
 * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent
 * object wrapper forms so that this check will always work. However, because we need to flag the exact object which
 * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification
 * must be done before the exception captured.
 *
 * @param A thrown exception to check or flag as having been seen
 * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)
 */
function checkOrSetAlreadyCaught(exception) {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
  if (exception && (exception ).__sentry_captured__) {
    return true;
  }

  try {
    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the
    // `ExtraErrorData` integration
    addNonEnumerableProperty(exception , '__sentry_captured__', true);
  } catch (err) {
    // `exception` is a primitive, so we can't mark it seen
  }

  return false;
}

/**
 * Checks whether the given input is already an array, and if it isn't, wraps it in one.
 *
 * @param maybeArray Input to turn into an array, if necessary
 * @returns The input, if already an array, or an array with the input as the only element, if not
 */
function arrayify(maybeArray) {
  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
}

/*
 * This module exists for optimizations in the build process through rollup and terser.  We define some global
 * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these
 * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will
 * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to
 * `logger` and preventing node-related code from appearing in browser bundles.
 *
 * Attention:
 * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by
 * users. These fags should live in their respective packages, as we identified user tooling (specifically webpack)
 * having issues tree-shaking these constants across package boundaries.
 * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want
 * users to be able to shake away expressions that it guards.
 */

/**
 * Figures out if we're building a browser bundle.
 *
 * @returns true if this is a browser bundle build.
 */
function isBrowserBundle() {
  return typeof __SENTRY_BROWSER_BUNDLE__ !== 'undefined' && !!__SENTRY_BROWSER_BUNDLE__;
}

/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */

/**
 * Checks whether we're in the Node.js or Browser environment
 *
 * @returns Answer to given question
 */
function isNodeEnv() {
  // explicitly check for browser bundles as those can be optimized statically
  // by terser/rollup.
  return (
    !isBrowserBundle() &&
    Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'
  );
}

/**
 * Requires a module which is protected against bundler minification.
 *
 * @param request The module path to resolve
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
function dynamicRequire(mod, request) {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
  return mod.require(request);
}

/**
 * Helper for dynamically loading module that should work with linked dependencies.
 * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`
 * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during
 * build time. `require.resolve` is also not available in any other way, so we cannot create,
 * a fake helper like we do with `dynamicRequire`.
 *
 * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.
 * That is to mimic the behavior of `require.resolve` exactly.
 *
 * @param moduleName module name to require
 * @returns possibly required module
 */
function loadModule(moduleName) {
  let mod;

  try {
    mod = dynamicRequire(module, moduleName);
  } catch (e) {
    // no-empty
  }

  try {
    const { cwd } = dynamicRequire(module, 'process');
    mod = dynamicRequire(module, `${cwd()}/node_modules/${moduleName}`) ;
  } catch (e) {
    // no-empty
  }

  return mod;
}

/**
 * Recursively normalizes the given object.
 *
 * - Creates a copy to prevent original input mutation
 * - Skips non-enumerable properties
 * - When stringifying, calls `toJSON` if implemented
 * - Removes circular references
 * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format
 * - Translates known global objects/classes to a string representations
 * - Takes care of `Error` object serialization
 * - Optionally limits depth of final output
 * - Optionally limits number of properties/elements included in any single object/array
 *
 * @param input The object to be normalized.
 * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)
 * @param maxProperties The max number of elements or properties to be included in any single array or
 * object in the normallized output.
 * @returns A normalized version of the object, or `"**non-serializable**"` if any errors are thrown during normalization.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function normalize$1(input, depth = +Infinity, maxProperties = +Infinity) {
  try {
    // since we're at the outermost level, we don't provide a key
    return visit('', input, depth, maxProperties);
  } catch (err) {
    return { ERROR: `**non-serializable** (${err})` };
  }
}

/** JSDoc */
function normalizeToSize(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  object,
  // Default Node.js REPL depth
  depth = 3,
  // 100kB, as 200kB is max payload size, so half sounds reasonable
  maxSize = 100 * 1024,
) {
  const normalized = normalize$1(object, depth);

  if (jsonSize(normalized) > maxSize) {
    return normalizeToSize(object, depth - 1, maxSize);
  }

  return normalized ;
}

/**
 * Visits a node to perform normalization on it
 *
 * @param key The key corresponding to the given node
 * @param value The node to be visited
 * @param depth Optional number indicating the maximum recursion depth
 * @param maxProperties Optional maximum number of properties/elements included in any single object/array
 * @param memo Optional Memo class handling decycling
 */
function visit(
  key,
  value,
  depth = +Infinity,
  maxProperties = +Infinity,
  memo = memoBuilder(),
) {
  const [memoize, unmemoize] = memo;

  // Get the simple cases out of the way first
  if (value === null || (['number', 'boolean', 'string'].includes(typeof value) && !isNaN$1(value))) {
    return value ;
  }

  const stringified = stringifyValue(key, value);

  // Anything we could potentially dig into more (objects or arrays) will have come back as `"[object XXXX]"`.
  // Everything else will have already been serialized, so if we don't see that pattern, we're done.
  if (!stringified.startsWith('[object ')) {
    return stringified;
  }

  // From here on, we can assert that `value` is either an object or an array.

  // Do not normalize objects that we know have already been normalized. As a general rule, the
  // "__sentry_skip_normalization__" property should only be used sparingly and only should only be set on objects that
  // have already been normalized.
  if ((value )['__sentry_skip_normalization__']) {
    return value ;
  }

  // We're also done if we've reached the max depth
  if (depth === 0) {
    // At this point we know `serialized` is a string of the form `"[object XXXX]"`. Clean it up so it's just `"[XXXX]"`.
    return stringified.replace('object ', '');
  }

  // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.
  if (memoize(value)) {
    return '[Circular ~]';
  }

  // If the value has a `toJSON` method, we call it to extract more information
  const valueWithToJSON = value ;
  if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {
    try {
      const jsonValue = valueWithToJSON.toJSON();
      // We need to normalize the return value of `.toJSON()` in case it has circular references
      return visit('', jsonValue, depth - 1, maxProperties, memo);
    } catch (err) {
      // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)
    }
  }

  // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse
  // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each
  // property/entry, and keep track of the number of items we add to it.
  const normalized = (Array.isArray(value) ? [] : {}) ;
  let numAdded = 0;

  // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant
  // properties are non-enumerable and otherwise would get missed.
  const visitable = convertToPlainObject(value );

  for (const visitKey in visitable) {
    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.
    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
      continue;
    }

    if (numAdded >= maxProperties) {
      normalized[visitKey] = '[MaxProperties ~]';
      break;
    }

    // Recursively visit all the child nodes
    const visitValue = visitable[visitKey];
    normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);

    numAdded += 1;
  }

  // Once we've visited all the branches, remove the parent from memo storage
  unmemoize(value);

  // Return accumulated values
  return normalized;
}

/**
 * Stringify the given value. Handles various known special values and types.
 *
 * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn
 * the number 1231 into "[Object Number]", nor on `null`, as it will throw.
 *
 * @param value The value to stringify
 * @returns A stringified representation of the given value
 */
function stringifyValue(
  key,
  // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for
  // our internal use, it'll do
  value,
) {
  try {
    if (key === 'domain' && value && typeof value === 'object' && (value )._events) {
      return '[Domain]';
    }

    if (key === 'domainEmitter') {
      return '[DomainEmitter]';
    }

    // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first
    // which won't throw if they are not present.

    if (typeof global !== 'undefined' && value === global) {
      return '[Global]';
    }

    // eslint-disable-next-line no-restricted-globals
    if (typeof window !== 'undefined' && value === window) {
      return '[Window]';
    }

    // eslint-disable-next-line no-restricted-globals
    if (typeof document !== 'undefined' && value === document) {
      return '[Document]';
    }

    // React's SyntheticEvent thingy
    if (isSyntheticEvent(value)) {
      return '[SyntheticEvent]';
    }

    if (typeof value === 'number' && value !== value) {
      return '[NaN]';
    }

    // this catches `undefined` (but not `null`, which is a primitive and can be serialized on its own)
    if (value === void 0) {
      return '[undefined]';
    }

    if (typeof value === 'function') {
      return `[Function: ${getFunctionName(value)}]`;
    }

    if (typeof value === 'symbol') {
      return `[${String(value)}]`;
    }

    // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion
    if (typeof value === 'bigint') {
      return `[BigInt: ${String(value)}]`;
    }

    // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting
    // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as
    // `"[object Object]"`. If we instead look at the constructor's name (which is the same as the name of the class),
    // we can make sure that only plain objects come out that way.
    return `[object ${(Object.getPrototypeOf(value) ).constructor.name}]`;
  } catch (err) {
    return `**non-serializable** (${err})`;
  }
}

/** Calculates bytes size of input string */
function utf8Length(value) {
  // eslint-disable-next-line no-bitwise
  return ~-encodeURI(value).split(/%..|./).length;
}

/** Calculates bytes size of input object */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function jsonSize(value) {
  return utf8Length(JSON.stringify(value));
}

// Slightly modified (no IE8 support, ES6) and transcribed to TypeScript
// https://raw.githubusercontent.com/calvinmetcalf/rollup-plugin-node-builtins/master/src/es6/path.js

/** JSDoc */
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  let up = 0;
  for (let i = parts.length - 1; i >= 0; i--) {
    const last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      // eslint-disable-next-line no-plusplus
      up++;
    } else if (up) {
      parts.splice(i, 1);
      // eslint-disable-next-line no-plusplus
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    // eslint-disable-next-line no-plusplus
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
const splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^/]+?|)(\.[^./]*|))(?:[/]*)$/;
/** JSDoc */
function splitPath(filename) {
  const parts = splitPathRe.exec(filename);
  return parts ? parts.slice(1) : [];
}

// path.resolve([from ...], to)
// posix version
/** JSDoc */
function resolve$1(...args) {
  let resolvedPath = '';
  let resolvedAbsolute = false;

  for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    const path = i >= 0 ? args[i] : '/';

    // Skip empty entries
    if (!path) {
      continue;
    }

    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(
    resolvedPath.split('/').filter(p => !!p),
    !resolvedAbsolute,
  ).join('/');

  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
}

/** JSDoc */
function trim(arr) {
  let start = 0;
  for (; start < arr.length; start++) {
    if (arr[start] !== '') {
      break;
    }
  }

  let end = arr.length - 1;
  for (; end >= 0; end--) {
    if (arr[end] !== '') {
      break;
    }
  }

  if (start > end) {
    return [];
  }
  return arr.slice(start, end - start + 1);
}

// path.relative(from, to)
// posix version
/** JSDoc */
function relative(from, to) {
  /* eslint-disable no-param-reassign */
  from = resolve$1(from).substr(1);
  to = resolve$1(to).substr(1);
  /* eslint-enable no-param-reassign */

  const fromParts = trim(from.split('/'));
  const toParts = trim(to.split('/'));

  const length = Math.min(fromParts.length, toParts.length);
  let samePartsLength = length;
  for (let i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  let outputParts = [];
  for (let i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
}

// path.normalize(path)
// posix version
/** JSDoc */
function normalizePath(path) {
  const isPathAbsolute = isAbsolute(path);
  const trailingSlash = path.substr(-1) === '/';

  // Normalize the path
  let normalizedPath = normalizeArray(
    path.split('/').filter(p => !!p),
    !isPathAbsolute,
  ).join('/');

  if (!normalizedPath && !isPathAbsolute) {
    normalizedPath = '.';
  }
  if (normalizedPath && trailingSlash) {
    normalizedPath += '/';
  }

  return (isPathAbsolute ? '/' : '') + normalizedPath;
}

// posix version
/** JSDoc */
function isAbsolute(path) {
  return path.charAt(0) === '/';
}

// posix version
/** JSDoc */
function join(...args) {
  return normalizePath(args.join('/'));
}

/** JSDoc */
function dirname(path) {
  const result = splitPath(path);
  const root = result[0];
  let dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
}

/** JSDoc */
function basename(path, ext) {
  let f = splitPath(path)[2];
  if (ext && f.substr(ext.length * -1) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
}

/* eslint-disable @typescript-eslint/explicit-function-return-type */

/** SyncPromise internal states */
var States; (function (States) {
  /** Pending */
  const PENDING = 0; States[States["PENDING"] = PENDING] = "PENDING";
  /** Resolved / OK */
  const RESOLVED = 1; States[States["RESOLVED"] = RESOLVED] = "RESOLVED";
  /** Rejected / Error */
  const REJECTED = 2; States[States["REJECTED"] = REJECTED] = "REJECTED";
})(States || (States = {}));

// Overloads so we can call resolvedSyncPromise without arguments and generic argument

/**
 * Creates a resolved sync promise.
 *
 * @param value the value to resolve the promise with
 * @returns the resolved sync promise
 */
function resolvedSyncPromise(value) {
  return new SyncPromise(resolve => {
    resolve(value);
  });
}

/**
 * Creates a rejected sync promise.
 *
 * @param value the value to reject the promise with
 * @returns the rejected sync promise
 */
function rejectedSyncPromise(reason) {
  return new SyncPromise((_, reject) => {
    reject(reason);
  });
}

/**
 * Thenable class that behaves like a Promise and follows it's interface
 * but is not async internally
 */
class SyncPromise {
   __init() {this._state = States.PENDING;}
   __init2() {this._handlers = [];}

   constructor(
    executor,
  ) {;SyncPromise.prototype.__init.call(this);SyncPromise.prototype.__init2.call(this);SyncPromise.prototype.__init3.call(this);SyncPromise.prototype.__init4.call(this);SyncPromise.prototype.__init5.call(this);SyncPromise.prototype.__init6.call(this);
    try {
      executor(this._resolve, this._reject);
    } catch (e) {
      this._reject(e);
    }
  }

  /** JSDoc */
   then(
    onfulfilled,
    onrejected,
  ) {
    return new SyncPromise((resolve, reject) => {
      this._handlers.push([
        false,
        result => {
          if (!onfulfilled) {
            // TODO: ¯\_(ツ)_/¯
            // TODO: FIXME
            resolve(result );
          } else {
            try {
              resolve(onfulfilled(result));
            } catch (e) {
              reject(e);
            }
          }
        },
        reason => {
          if (!onrejected) {
            reject(reason);
          } else {
            try {
              resolve(onrejected(reason));
            } catch (e) {
              reject(e);
            }
          }
        },
      ]);
      this._executeHandlers();
    });
  }

  /** JSDoc */
   catch(
    onrejected,
  ) {
    return this.then(val => val, onrejected);
  }

  /** JSDoc */
   finally(onfinally) {
    return new SyncPromise((resolve, reject) => {
      let val;
      let isRejected;

      return this.then(
        value => {
          isRejected = false;
          val = value;
          if (onfinally) {
            onfinally();
          }
        },
        reason => {
          isRejected = true;
          val = reason;
          if (onfinally) {
            onfinally();
          }
        },
      ).then(() => {
        if (isRejected) {
          reject(val);
          return;
        }

        resolve(val );
      });
    });
  }

  /** JSDoc */
    __init3() {this._resolve = (value) => {
    this._setResult(States.RESOLVED, value);
  };}

  /** JSDoc */
    __init4() {this._reject = (reason) => {
    this._setResult(States.REJECTED, reason);
  };}

  /** JSDoc */
    __init5() {this._setResult = (state, value) => {
    if (this._state !== States.PENDING) {
      return;
    }

    if (isThenable(value)) {
      void (value ).then(this._resolve, this._reject);
      return;
    }

    this._state = state;
    this._value = value;

    this._executeHandlers();
  };}

  /** JSDoc */
    __init6() {this._executeHandlers = () => {
    if (this._state === States.PENDING) {
      return;
    }

    const cachedHandlers = this._handlers.slice();
    this._handlers = [];

    cachedHandlers.forEach(handler => {
      if (handler[0]) {
        return;
      }

      if (this._state === States.RESOLVED) {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        handler[1](this._value );
      }

      if (this._state === States.REJECTED) {
        handler[2](this._value);
      }

      handler[0] = true;
    });
  };}
}

/**
 * Creates an new PromiseBuffer object with the specified limit
 * @param limit max number of promises that can be stored in the buffer
 */
function makePromiseBuffer(limit) {
  const buffer = [];

  function isReady() {
    return limit === undefined || buffer.length < limit;
  }

  /**
   * Remove a promise from the queue.
   *
   * @param task Can be any PromiseLike<T>
   * @returns Removed promise.
   */
  function remove(task) {
    return buffer.splice(buffer.indexOf(task), 1)[0];
  }

  /**
   * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.
   *
   * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:
   *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor
   *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By
   *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer
   *        limit check.
   * @returns The original promise.
   */
  function add(taskProducer) {
    if (!isReady()) {
      return rejectedSyncPromise(new SentryError('Not adding Promise because buffer limit was reached.'));
    }

    // start the task and add its promise to the queue
    const task = taskProducer();
    if (buffer.indexOf(task) === -1) {
      buffer.push(task);
    }
    void task
      .then(() => remove(task))
      // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`
      // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't
      // have promises, so TS has to polyfill when down-compiling.)
      .then(null, () =>
        remove(task).then(null, () => {
          // We have to add another catch here because `remove()` starts a new promise chain.
        }),
      );
    return task;
  }

  /**
   * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or
   * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and
   * `false` otherwise
   */
  function drain(timeout) {
    return new SyncPromise((resolve, reject) => {
      let counter = buffer.length;

      if (!counter) {
        return resolve(true);
      }

      // wait for `timeout` ms and then resolve to `false` (if not cancelled first)
      const capturedSetTimeout = setTimeout(() => {
        if (timeout && timeout > 0) {
          resolve(false);
        }
      }, timeout);

      // if all promises resolve in time, cancel the timer and resolve to `true`
      buffer.forEach(item => {
        void resolvedSyncPromise(item).then(() => {
          // eslint-disable-next-line no-plusplus
          if (!--counter) {
            clearTimeout(capturedSetTimeout);
            resolve(true);
          }
        }, reject);
      });
    });
  }

  return {
    $: buffer,
    add,
    drain,
  };
}

/**
 * Parses string form of URL into an object
 * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
 * // intentionally using regex and not <a/> href parsing trick because React Native and other
 * // environments where DOM might not be available
 * @returns parsed URL object
 */
function parseUrl(url)

 {
  if (!url) {
    return {};
  }

  const match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);

  if (!match) {
    return {};
  }

  // coerce to undefined values to empty string so we don't get 'undefined'
  const query = match[6] || '';
  const fragment = match[8] || '';
  return {
    host: match[4],
    path: match[5],
    protocol: match[2],
    relative: match[5] + query + fragment, // everything minus origin
  };
}

/**
 * Strip the query string and fragment off of a given URL or path (if present)
 *
 * @param urlPath Full URL or path, including possible query string and/or fragment
 * @returns URL or path without query string or fragment
 */
function stripUrlQueryAndFragment(urlPath) {
  // eslint-disable-next-line no-useless-escape
  return urlPath.split(/[\?#]/, 1)[0];
}

/**
 * Returns number of URL segments of a passed string URL.
 */
function getNumberOfUrlSegments(url) {
  // split at '/' or at '\/' to split regex urls correctly
  return url.split(/\\?\//).filter(s => s.length > 0 && s !== ',').length;
}

const DEFAULT_INCLUDES = {
  ip: false,
  request: true,
  transaction: true,
  user: true,
};
const DEFAULT_REQUEST_INCLUDES = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'];
const DEFAULT_USER_INCLUDES = ['id', 'username', 'email'];

/**
 * Sets parameterized route as transaction name e.g.: `GET /users/:id`
 * Also adds more context data on the transaction from the request
 */
function addRequestDataToTransaction(
  transaction,
  req,
  deps,
) {
  if (!transaction) return;
  if (!transaction.metadata.source || transaction.metadata.source === 'url') {
    // Attempt to grab a parameterized route off of the request
    transaction.setName(...extractPathForTransaction(req, { path: true, method: true }));
  }
  transaction.setData('url', req.originalUrl || req.url);
  if (req.baseUrl) {
    transaction.setData('baseUrl', req.baseUrl);
  }
  transaction.setData('query', extractQueryParams(req, deps));
}

/**
 * Extracts a complete and parameterized path from the request object and uses it to construct transaction name.
 * If the parameterized transaction name cannot be extracted, we fall back to the raw URL.
 *
 * Additionally, this function determines and returns the transaction name source
 *
 * eg. GET /mountpoint/user/:id
 *
 * @param req A request object
 * @param options What to include in the transaction name (method, path, or a custom route name to be
 *                used instead of the request's route)
 *
 * @returns A tuple of the fully constructed transaction name [0] and its source [1] (can be either 'route' or 'url')
 */
function extractPathForTransaction(
  req,
  options = {},
) {
  const method = req.method && req.method.toUpperCase();

  let path = '';
  let source = 'url';

  // Check to see if there's a parameterized route we can use (as there is in Express)
  if (options.customRoute || req.route) {
    path = options.customRoute || `${req.baseUrl || ''}${req.route && req.route.path}`;
    source = 'route';
  }

  // Otherwise, just take the original URL
  else if (req.originalUrl || req.url) {
    path = stripUrlQueryAndFragment(req.originalUrl || req.url || '');
  }

  let name = '';
  if (options.method && method) {
    name += method;
  }
  if (options.method && options.path) {
    name += ' ';
  }
  if (options.path && path) {
    name += path;
  }

  return [name, source];
}

/** JSDoc */
function extractTransaction(req, type) {
  switch (type) {
    case 'path': {
      return extractPathForTransaction(req, { path: true })[0];
    }
    case 'handler': {
      return (req.route && req.route.stack && req.route.stack[0] && req.route.stack[0].name) || '<anonymous>';
    }
    case 'methodPath':
    default: {
      return extractPathForTransaction(req, { path: true, method: true })[0];
    }
  }
}

/** JSDoc */
function extractUserData(
  user

,
  keys,
) {
  const extractedUser = {};
  const attributes = Array.isArray(keys) ? keys : DEFAULT_USER_INCLUDES;

  attributes.forEach(key => {
    if (user && key in user) {
      extractedUser[key] = user[key];
    }
  });

  return extractedUser;
}

/**
 * Normalize data from the request object, accounting for framework differences.
 *
 * @param req The request object from which to extract data
 * @param options.include An optional array of keys to include in the normalized data. Defaults to
 * DEFAULT_REQUEST_INCLUDES if not provided.
 * @param options.deps Injected, platform-specific dependencies
 * @returns An object containing normalized request data
 */
function extractRequestData(
  req,
  options

,
) {
  const { include = DEFAULT_REQUEST_INCLUDES, deps } = options || {};
  const requestData = {};

  // headers:
  //   node, express, koa, nextjs: req.headers
  const headers = (req.headers || {})

;
  // method:
  //   node, express, koa, nextjs: req.method
  const method = req.method;
  // host:
  //   express: req.hostname in > 4 and req.host in < 4
  //   koa: req.host
  //   node, nextjs: req.headers.host
  const host = req.hostname || req.host || headers.host || '<no host>';
  // protocol:
  //   node, nextjs: <n/a>
  //   express, koa: req.protocol
  const protocol = req.protocol === 'https' || (req.socket && req.socket.encrypted) ? 'https' : 'http';
  // url (including path and query string):
  //   node, express: req.originalUrl
  //   koa, nextjs: req.url
  const originalUrl = req.originalUrl || req.url || '';
  // absolute url
  const absoluteUrl = `${protocol}://${host}${originalUrl}`;
  include.forEach(key => {
    switch (key) {
      case 'headers': {
        requestData.headers = headers;
        break;
      }
      case 'method': {
        requestData.method = method;
        break;
      }
      case 'url': {
        requestData.url = absoluteUrl;
        break;
      }
      case 'cookies': {
        // cookies:
        //   node, express, koa: req.headers.cookie
        //   vercel, sails.js, express (w/ cookie middleware), nextjs: req.cookies
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        requestData.cookies =
          // TODO (v8 / #5257): We're only sending the empty object for backwards compatibility, so the last bit can
          // come off in v8
          req.cookies || (headers.cookie && deps && deps.cookie && deps.cookie.parse(headers.cookie)) || {};
        break;
      }
      case 'query_string': {
        // query string:
        //   node: req.url (raw)
        //   express, koa, nextjs: req.query
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        requestData.query_string = extractQueryParams(req, deps);
        break;
      }
      case 'data': {
        if (method === 'GET' || method === 'HEAD') {
          break;
        }
        // body data:
        //   express, koa, nextjs: req.body
        //
        //   when using node by itself, you have to read the incoming stream(see
        //   https://nodejs.dev/learn/get-http-request-body-data-using-nodejs); if a user is doing that, we can't know
        //   where they're going to store the final result, so they'll have to capture this data themselves
        if (req.body !== undefined) {
          requestData.data = isString(req.body) ? req.body : JSON.stringify(normalize$1(req.body));
        }
        break;
      }
      default: {
        if ({}.hasOwnProperty.call(req, key)) {
          requestData[key] = (req )[key];
        }
      }
    }
  });

  return requestData;
}

/**
 * Options deciding what parts of the request to use when enhancing an event
 */

/**
 * Add data from the given request to the given event
 *
 * @param event The event to which the request data will be added
 * @param req Request object
 * @param options.include Flags to control what data is included
 * @param options.deps Injected platform-specific dependencies
 * @hidden
 */
function addRequestDataToEvent(
  event,
  req,
  options,
) {
  const include = {
    ...DEFAULT_INCLUDES,
    ..._optionalChain([options, 'optionalAccess', _ => _.include]),
  };

  if (include.request) {
    const extractedRequestData = Array.isArray(include.request)
      ? extractRequestData(req, { include: include.request, deps: _optionalChain([options, 'optionalAccess', _2 => _2.deps]) })
      : extractRequestData(req, { deps: _optionalChain([options, 'optionalAccess', _3 => _3.deps]) });

    event.request = {
      ...event.request,
      ...extractedRequestData,
    };
  }

  if (include.user) {
    const extractedUser = req.user && isPlainObject$1(req.user) ? extractUserData(req.user, include.user) : {};

    if (Object.keys(extractedUser).length) {
      event.user = {
        ...event.user,
        ...extractedUser,
      };
    }
  }

  // client ip:
  //   node, nextjs: req.socket.remoteAddress
  //   express, koa: req.ip
  if (include.ip) {
    const ip = req.ip || (req.socket && req.socket.remoteAddress);
    if (ip) {
      event.user = {
        ...event.user,
        ip_address: ip,
      };
    }
  }

  if (include.transaction && !event.transaction) {
    // TODO do we even need this anymore?
    // TODO make this work for nextjs
    event.transaction = extractTransaction(req, include.transaction);
  }

  return event;
}

function extractQueryParams(
  req,
  deps,
) {
  // url (including path and query string):
  //   node, express: req.originalUrl
  //   koa, nextjs: req.url
  let originalUrl = req.originalUrl || req.url || '';

  if (!originalUrl) {
    return;
  }

  // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and
  // hostname on the beginning. Since the point here is just to grab the query string, it doesn't matter what we use.
  if (originalUrl.startsWith('/')) {
    originalUrl = `http://dogs.are.great${originalUrl}`;
  }

  return (
    req.query ||
    (typeof URL !== undefined && new URL(originalUrl).search.replace('?', '')) ||
    // In Node 8, `URL` isn't in the global scope, so we have to use the built-in module from Node
    (deps && deps.url && deps.url.parse(originalUrl).query) ||
    undefined
  );
}

// Note: Ideally the `SeverityLevel` type would be derived from `validSeverityLevels`, but that would mean either
//
// a) moving `validSeverityLevels` to `@sentry/types`,
// b) moving the`SeverityLevel` type here, or
// c) importing `validSeverityLevels` from here into `@sentry/types`.
//
// Option A would make `@sentry/types` a runtime dependency of `@sentry/utils` (not good), and options B and C would
// create a circular dependency between `@sentry/types` and `@sentry/utils` (also not good). So a TODO accompanying the
// type, reminding anyone who changes it to change this list also, will have to do.

const validSeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug'];

/**
 * Converts a string-based level into a member of the deprecated {@link Severity} enum.
 *
 * @deprecated `severityFromString` is deprecated. Please use `severityLevelFromString` instead.
 *
 * @param level String representation of Severity
 * @returns Severity
 */
function severityFromString(level) {
  return severityLevelFromString(level) ;
}

/**
 * Converts a string-based level into a `SeverityLevel`, normalizing it along the way.
 *
 * @param level String representation of desired `SeverityLevel`.
 * @returns The `SeverityLevel` corresponding to the given string, or 'log' if the string isn't a valid level.
 */
function severityLevelFromString(level) {
  return (level === 'warn' ? 'warning' : validSeverityLevels.includes(level) ? level : 'log') ;
}

// eslint-disable-next-line deprecation/deprecation
const WINDOW$1 = getGlobalObject();

/**
 * An object that can return the current timestamp in seconds since the UNIX epoch.
 */

/**
 * A TimestampSource implementation for environments that do not support the Performance Web API natively.
 *
 * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier
 * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It
 * is more obvious to explain "why does my span have negative duration" than "why my spans have zero duration".
 */
const dateTimestampSource = {
  nowSeconds: () => Date.now() / 1000,
};

/**
 * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}
 * for accessing a high-resolution monotonic clock.
 */

/**
 * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not
 * support the API.
 *
 * Wrapping the native API works around differences in behavior from different browsers.
 */
function getBrowserPerformance() {
  const { performance } = WINDOW$1;
  if (!performance || !performance.now) {
    return undefined;
  }

  // Replace performance.timeOrigin with our own timeOrigin based on Date.now().
  //
  // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +
  // performance.now() gives a date arbitrarily in the past.
  //
  // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is
  // undefined.
  //
  // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to
  // interact with data coming out of performance entries.
  //
  // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that
  // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes
  // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have
  // observed skews that can be as long as days, weeks or months.
  //
  // See https://github.com/getsentry/sentry-javascript/issues/2590.
  //
  // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload
  // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation
  // transactions of long-lived web pages.
  const timeOrigin = Date.now() - performance.now();

  return {
    now: () => performance.now(),
    timeOrigin,
  };
}

/**
 * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't
 * implement the API.
 */
function getNodePerformance() {
  try {
    const perfHooks = dynamicRequire(module, 'perf_hooks') ;
    return perfHooks.performance;
  } catch (_) {
    return undefined;
  }
}

/**
 * The Performance API implementation for the current platform, if available.
 */
const platformPerformance = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();

const timestampSource =
  platformPerformance === undefined
    ? dateTimestampSource
    : {
        nowSeconds: () => (platformPerformance.timeOrigin + platformPerformance.now()) / 1000,
      };

/**
 * Returns a timestamp in seconds since the UNIX epoch using the Date API.
 */
const dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);

/**
 * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the
 * availability of the Performance API.
 *
 * See `usingPerformanceAPI` to test whether the Performance API is used.
 *
 * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is
 * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The
 * skew can grow to arbitrary amounts like days, weeks or months.
 * See https://github.com/getsentry/sentry-javascript/issues/2590.
 */
const timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);

// Re-exported with an old name for backwards-compatibility.
const timestampWithMs = timestampInSeconds;

/**
 * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.
 */
const usingPerformanceAPI = platformPerformance !== undefined;

/**
 * Internal helper to store what is the source of browserPerformanceTimeOrigin below. For debugging only.
 */
let _browserPerformanceTimeOriginMode;

/**
 * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the
 * performance API is available.
 */
const browserPerformanceTimeOrigin = (() => {
  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or
  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin
  // data as reliable if they are within a reasonable threshold of the current time.

  const { performance } = WINDOW$1;
  if (!performance || !performance.now) {
    _browserPerformanceTimeOriginMode = 'none';
    return undefined;
  }

  const threshold = 3600 * 1000;
  const performanceNow = performance.now();
  const dateNow = Date.now();

  // if timeOrigin isn't available set delta to threshold so it isn't used
  const timeOriginDelta = performance.timeOrigin
    ? Math.abs(performance.timeOrigin + performanceNow - dateNow)
    : threshold;
  const timeOriginIsReliable = timeOriginDelta < threshold;

  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin
  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.
  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always
  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the
  // Date API.
  // eslint-disable-next-line deprecation/deprecation
  const navigationStart = performance.timing && performance.timing.navigationStart;
  const hasNavigationStart = typeof navigationStart === 'number';
  // if navigationStart isn't available set delta to threshold so it isn't used
  const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
  const navigationStartIsReliable = navigationStartDelta < threshold;

  if (timeOriginIsReliable || navigationStartIsReliable) {
    // Use the more reliable time origin
    if (timeOriginDelta <= navigationStartDelta) {
      _browserPerformanceTimeOriginMode = 'timeOrigin';
      return performance.timeOrigin;
    } else {
      _browserPerformanceTimeOriginMode = 'navigationStart';
      return navigationStart;
    }
  }

  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.
  _browserPerformanceTimeOriginMode = 'dateNow';
  return dateNow;
})();

const TRACEPARENT_REGEXP = new RegExp(
  '^[ \\t]*' + // whitespace
    '([0-9a-f]{32})?' + // trace_id
    '-?([0-9a-f]{16})?' + // span_id
    '-?([01])?' + // sampled
    '[ \\t]*$', // whitespace
);

/**
 * Extract transaction context data from a `sentry-trace` header.
 *
 * @param traceparent Traceparent string
 *
 * @returns Object containing data from the header, or undefined if traceparent string is malformed
 */
function extractTraceparentData(traceparent) {
  const matches = traceparent.match(TRACEPARENT_REGEXP);

  if (!traceparent || !matches) {
    // empty string or no matches is invalid traceparent data
    return undefined;
  }

  let parentSampled;
  if (matches[3] === '1') {
    parentSampled = true;
  } else if (matches[3] === '0') {
    parentSampled = false;
  }

  return {
    traceId: matches[1],
    parentSampled,
    parentSpanId: matches[2],
  };
}

/**
 * Creates an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
function createEnvelope(headers, items = []) {
  return [headers, items] ;
}

/**
 * Add an item to an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
function addItemToEnvelope(envelope, newItem) {
  const [headers, items] = envelope;
  return [headers, [...items, newItem]] ;
}

/**
 * Convenience function to loop through the items and item types of an envelope.
 * (This function was mostly created because working with envelope types is painful at the moment)
 */
function forEachEnvelopeItem(
  envelope,
  callback,
) {
  const envelopeItems = envelope[1];
  envelopeItems.forEach((envelopeItem) => {
    const envelopeItemType = envelopeItem[0].type;
    callback(envelopeItem, envelopeItemType);
  });
}

function encodeUTF8(input, textEncoder) {
  const utf8 = textEncoder || new TextEncoder();
  return utf8.encode(input);
}

/**
 * Serializes an envelope.
 */
function serializeEnvelope(envelope, textEncoder) {
  const [envHeaders, items] = envelope;

  // Initially we construct our envelope as a string and only convert to binary chunks if we encounter binary data
  let parts = JSON.stringify(envHeaders);

  function append(next) {
    if (typeof parts === 'string') {
      parts = typeof next === 'string' ? parts + next : [encodeUTF8(parts, textEncoder), next];
    } else {
      parts.push(typeof next === 'string' ? encodeUTF8(next, textEncoder) : next);
    }
  }

  for (const item of items) {
    const [itemHeaders, payload] = item;

    append(`\n${JSON.stringify(itemHeaders)}\n`);

    if (typeof payload === 'string' || payload instanceof Uint8Array) {
      append(payload);
    } else {
      let stringifiedPayload;
      try {
        stringifiedPayload = JSON.stringify(payload);
      } catch (e) {
        // In case, despite all our efforts to keep `payload` circular-dependency-free, `JSON.strinify()` still
        // fails, we try again after normalizing it again with infinite normalization depth. This of course has a
        // performance impact but in this case a performance hit is better than throwing.
        stringifiedPayload = JSON.stringify(normalize$1(payload));
      }
      append(stringifiedPayload);
    }
  }

  return typeof parts === 'string' ? parts : concatBuffers(parts);
}

function concatBuffers(buffers) {
  const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);

  const merged = new Uint8Array(totalLength);
  let offset = 0;
  for (const buffer of buffers) {
    merged.set(buffer, offset);
    offset += buffer.length;
  }

  return merged;
}

/**
 * Creates attachment envelope items
 */
function createAttachmentEnvelopeItem(
  attachment,
  textEncoder,
) {
  const buffer = typeof attachment.data === 'string' ? encodeUTF8(attachment.data, textEncoder) : attachment.data;

  return [
    dropUndefinedKeys({
      type: 'attachment',
      length: buffer.length,
      filename: attachment.filename,
      content_type: attachment.contentType,
      attachment_type: attachment.attachmentType,
    }),
    buffer,
  ];
}

const ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
  session: 'session',
  sessions: 'session',
  attachment: 'attachment',
  transaction: 'transaction',
  event: 'error',
  client_report: 'internal',
  user_report: 'default',
};

/**
 * Maps the type of an envelope item to a data category.
 */
function envelopeItemTypeToDataCategory(type) {
  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
}

/**
 * Creates client report envelope
 * @param discarded_events An array of discard events
 * @param dsn A DSN that can be set on the header. Optional.
 */
function createClientReportEnvelope(
  discarded_events,
  dsn,
  timestamp,
) {
  const clientReportItem = [
    { type: 'client_report' },
    {
      timestamp: timestamp || dateTimestampInSeconds(),
      discarded_events,
    },
  ];
  return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
}

// Intentionally keeping the key broad, as we don't know for sure what rate limit headers get returned from backend

const DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds

/**
 * Extracts Retry-After value from the request header or returns default value
 * @param header string representation of 'Retry-After' header
 * @param now current unix timestamp
 *
 */
function parseRetryAfterHeader(header, now = Date.now()) {
  const headerDelay = parseInt(`${header}`, 10);
  if (!isNaN(headerDelay)) {
    return headerDelay * 1000;
  }

  const headerDate = Date.parse(`${header}`);
  if (!isNaN(headerDate)) {
    return headerDate - now;
  }

  return DEFAULT_RETRY_AFTER;
}

/**
 * Gets the time that given category is disabled until for rate limiting
 */
function disabledUntil(limits, category) {
  return limits[category] || limits.all || 0;
}

/**
 * Checks if a category is rate limited
 */
function isRateLimited(limits, category, now = Date.now()) {
  return disabledUntil(limits, category) > now;
}

/**
 * Update ratelimits from incoming headers.
 * Returns true if headers contains a non-empty rate limiting header.
 */
function updateRateLimits(
  limits,
  { statusCode, headers },
  now = Date.now(),
) {
  const updatedRateLimits = {
    ...limits,
  };

  // "The name is case-insensitive."
  // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get
  const rateLimitHeader = headers && headers['x-sentry-rate-limits'];
  const retryAfterHeader = headers && headers['retry-after'];

  if (rateLimitHeader) {
    /**
     * rate limit headers are of the form
     *     <header>,<header>,..
     * where each <header> is of the form
     *     <retry_after>: <categories>: <scope>: <reason_code>
     * where
     *     <retry_after> is a delay in seconds
     *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form
     *         <category>;<category>;...
     *     <scope> is what's being limited (org, project, or key) - ignored by SDK
     *     <reason_code> is an arbitrary string like "org_quota" - ignored by SDK
     */
    for (const limit of rateLimitHeader.trim().split(',')) {
      const [retryAfter, categories] = limit.split(':', 2);
      const headerDelay = parseInt(retryAfter, 10);
      const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default
      if (!categories) {
        updatedRateLimits.all = now + delay;
      } else {
        for (const category of categories.split(';')) {
          updatedRateLimits[category] = now + delay;
        }
      }
    }
  } else if (retryAfterHeader) {
    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
  } else if (statusCode === 429) {
    updatedRateLimits.all = now + 60 * 1000;
  }

  return updatedRateLimits;
}

const BAGGAGE_HEADER_NAME = 'baggage';

const SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';

const SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;

/**
 * Max length of a serialized baggage string
 *
 * https://www.w3.org/TR/baggage/#limits
 */
const MAX_BAGGAGE_STRING_LENGTH = 8192;

/**
 * Takes a baggage header and turns it into Dynamic Sampling Context, by extracting all the "sentry-" prefixed values
 * from it.
 *
 * @param baggageHeader A very bread definition of a baggage header as it might appear in various frameworks.
 * @returns The Dynamic Sampling Context that was found on `baggageHeader`, if there was any, `undefined` otherwise.
 */
function baggageHeaderToDynamicSamplingContext(
  // Very liberal definition of what any incoming header might look like
  baggageHeader,
) {
  if (!isString(baggageHeader) && !Array.isArray(baggageHeader)) {
    return undefined;
  }

  // Intermediary object to store baggage key value pairs of incoming baggage headers on.
  // It is later used to read Sentry-DSC-values from.
  let baggageObject = {};

  if (Array.isArray(baggageHeader)) {
    // Combine all baggage headers into one object containing the baggage values so we can later read the Sentry-DSC-values from it
    baggageObject = baggageHeader.reduce((acc, curr) => {
      const currBaggageObject = baggageHeaderToObject(curr);
      return {
        ...acc,
        ...currBaggageObject,
      };
    }, {});
  } else {
    // Return undefined if baggage header is an empty string (technically an empty baggage header is not spec conform but
    // this is how we choose to handle it)
    if (!baggageHeader) {
      return undefined;
    }

    baggageObject = baggageHeaderToObject(baggageHeader);
  }

  // Read all "sentry-" prefixed values out of the baggage object and put it onto a dynamic sampling context object.
  const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {
    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {
      const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);
      acc[nonPrefixedKey] = value;
    }
    return acc;
  }, {});

  // Only return a dynamic sampling context object if there are keys in it.
  // A keyless object means there were no sentry values on the header, which means that there is no DSC.
  if (Object.keys(dynamicSamplingContext).length > 0) {
    return dynamicSamplingContext ;
  } else {
    return undefined;
  }
}

/**
 * Turns a Dynamic Sampling Object into a baggage header by prefixing all the keys on the object with "sentry-".
 *
 * @param dynamicSamplingContext The Dynamic Sampling Context to turn into a header. For convenience and compatibility
 * with the `getDynamicSamplingContext` method on the Transaction class ,this argument can also be `undefined`. If it is
 * `undefined` the function will return `undefined`.
 * @returns a baggage header, created from `dynamicSamplingContext`, or `undefined` either if `dynamicSamplingContext`
 * was `undefined`, or if `dynamicSamplingContext` didn't contain any values.
 */
function dynamicSamplingContextToSentryBaggageHeader(
  // this also takes undefined for convenience and bundle size in other places
  dynamicSamplingContext,
) {
  // Prefix all DSC keys with "sentry-" and put them into a new object
  const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce(
    (acc, [dscKey, dscValue]) => {
      if (dscValue) {
        acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;
      }
      return acc;
    },
    {},
  );

  return objectToBaggageHeader(sentryPrefixedDSC);
}

/**
 * Will parse a baggage header, which is a simple key-value map, into a flat object.
 *
 * @param baggageHeader The baggage header to parse.
 * @returns a flat object containing all the key-value pairs from `baggageHeader`.
 */
function baggageHeaderToObject(baggageHeader) {
  return baggageHeader
    .split(',')
    .map(baggageEntry => baggageEntry.split('=').map(keyOrValue => decodeURIComponent(keyOrValue.trim())))
    .reduce((acc, [key, value]) => {
      acc[key] = value;
      return acc;
    }, {});
}

/**
 * Turns a flat object (key-value pairs) into a baggage header, which is also just key-value pairs.
 *
 * @param object The object to turn into a baggage header.
 * @returns a baggage header string, or `undefined` if the object didn't have any values, since an empty baggage header
 * is not spec compliant.
 */
function objectToBaggageHeader(object) {
  if (Object.keys(object).length === 0) {
    // An empty baggage header is not spec compliant: We return undefined.
    return undefined;
  }

  return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {
    const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;
    const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;
    if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        logger.warn(
          `Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`,
        );
      return baggageHeader;
    } else {
      return newBaggageHeader;
    }
  }, '');
}

/**
 * Creates a new `Session` object by setting certain default parameters. If optional @param context
 * is passed, the passed properties are applied to the session object.
 *
 * @param context (optional) additional properties to be applied to the returned session object
 *
 * @returns a new `Session` object
 */
function makeSession(context) {
  // Both timestamp and started are in seconds since the UNIX epoch.
  const startingTime = timestampInSeconds();

  const session = {
    sid: uuid4(),
    init: true,
    timestamp: startingTime,
    started: startingTime,
    duration: 0,
    status: 'ok',
    errors: 0,
    ignoreDuration: false,
    toJSON: () => sessionToJSON(session),
  };

  if (context) {
    updateSession(session, context);
  }

  return session;
}

/**
 * Updates a session object with the properties passed in the context.
 *
 * Note that this function mutates the passed object and returns void.
 * (Had to do this instead of returning a new and updated session because closing and sending a session
 * makes an update to the session after it was passed to the sending logic.
 * @see BaseClient.captureSession )
 *
 * @param session the `Session` to update
 * @param context the `SessionContext` holding the properties that should be updated in @param session
 */
// eslint-disable-next-line complexity
function updateSession(session, context = {}) {
  if (context.user) {
    if (!session.ipAddress && context.user.ip_address) {
      session.ipAddress = context.user.ip_address;
    }

    if (!session.did && !context.did) {
      session.did = context.user.id || context.user.email || context.user.username;
    }
  }

  session.timestamp = context.timestamp || timestampInSeconds();

  if (context.ignoreDuration) {
    session.ignoreDuration = context.ignoreDuration;
  }
  if (context.sid) {
    // Good enough uuid validation. — Kamil
    session.sid = context.sid.length === 32 ? context.sid : uuid4();
  }
  if (context.init !== undefined) {
    session.init = context.init;
  }
  if (!session.did && context.did) {
    session.did = `${context.did}`;
  }
  if (typeof context.started === 'number') {
    session.started = context.started;
  }
  if (session.ignoreDuration) {
    session.duration = undefined;
  } else if (typeof context.duration === 'number') {
    session.duration = context.duration;
  } else {
    const duration = session.timestamp - session.started;
    session.duration = duration >= 0 ? duration : 0;
  }
  if (context.release) {
    session.release = context.release;
  }
  if (context.environment) {
    session.environment = context.environment;
  }
  if (!session.ipAddress && context.ipAddress) {
    session.ipAddress = context.ipAddress;
  }
  if (!session.userAgent && context.userAgent) {
    session.userAgent = context.userAgent;
  }
  if (typeof context.errors === 'number') {
    session.errors = context.errors;
  }
  if (context.status) {
    session.status = context.status;
  }
}

/**
 * Closes a session by setting its status and updating the session object with it.
 * Internally calls `updateSession` to update the passed session object.
 *
 * Note that this function mutates the passed session (@see updateSession for explanation).
 *
 * @param session the `Session` object to be closed
 * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,
 *               this function will keep the previously set status, unless it was `'ok'` in which case
 *               it is changed to `'exited'`.
 */
function closeSession(session, status) {
  let context = {};
  if (status) {
    context = { status };
  } else if (session.status === 'ok') {
    context = { status: 'exited' };
  }

  updateSession(session, context);
}

/**
 * Serializes a passed session object to a JSON object with a slightly different structure.
 * This is necessary because the Sentry backend requires a slightly different schema of a session
 * than the one the JS SDKs use internally.
 *
 * @param session the session to be converted
 *
 * @returns a JSON object of the passed session
 */
function sessionToJSON(session) {
  return dropUndefinedKeys({
    sid: `${session.sid}`,
    init: session.init,
    // Make sure that sec is converted to ms for date constructor
    started: new Date(session.started * 1000).toISOString(),
    timestamp: new Date(session.timestamp * 1000).toISOString(),
    status: session.status,
    errors: session.errors,
    did: typeof session.did === 'number' || typeof session.did === 'string' ? `${session.did}` : undefined,
    duration: session.duration,
    attrs: {
      release: session.release,
      environment: session.environment,
      ip_address: session.ipAddress,
      user_agent: session.userAgent,
    },
  });
}

/**
 * Default value for maximum number of breadcrumbs added to an event.
 */
const DEFAULT_MAX_BREADCRUMBS = 100;

/**
 * Holds additional event information. {@link Scope.applyToEvent} will be
 * called by the client before an event will be sent.
 */
class Scope  {
  /** Flag if notifying is happening. */

  /** Callback for client to receive scope changes. */

  /** Callback list that will be called after {@link applyToEvent}. */

  /** Array of breadcrumbs. */

  /** User */

  /** Tags */

  /** Extra */

  /** Contexts */

  /** Attachments */

  /**
   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
   * sent to Sentry
   */

  /** Fingerprint */

  /** Severity */
  // eslint-disable-next-line deprecation/deprecation

  /** Transaction Name */

  /** Span */

  /** Session */

  /** Request Mode Session Status */

   constructor() {
    this._notifyingListeners = false;
    this._scopeListeners = [];
    this._eventProcessors = [];
    this._breadcrumbs = [];
    this._attachments = [];
    this._user = {};
    this._tags = {};
    this._extra = {};
    this._contexts = {};
    this._sdkProcessingMetadata = {};
  }

  /**
   * Inherit values from the parent scope.
   * @param scope to clone.
   */
   static clone(scope) {
    const newScope = new Scope();
    if (scope) {
      newScope._breadcrumbs = [...scope._breadcrumbs];
      newScope._tags = { ...scope._tags };
      newScope._extra = { ...scope._extra };
      newScope._contexts = { ...scope._contexts };
      newScope._user = scope._user;
      newScope._level = scope._level;
      newScope._span = scope._span;
      newScope._session = scope._session;
      newScope._transactionName = scope._transactionName;
      newScope._fingerprint = scope._fingerprint;
      newScope._eventProcessors = [...scope._eventProcessors];
      newScope._requestSession = scope._requestSession;
      newScope._attachments = [...scope._attachments];
    }
    return newScope;
  }

  /**
   * Add internal on change listener. Used for sub SDKs that need to store the scope.
   * @hidden
   */
   addScopeListener(callback) {
    this._scopeListeners.push(callback);
  }

  /**
   * @inheritDoc
   */
   addEventProcessor(callback) {
    this._eventProcessors.push(callback);
    return this;
  }

  /**
   * @inheritDoc
   */
   setUser(user) {
    this._user = user || {};
    if (this._session) {
      updateSession(this._session, { user });
    }
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   getUser() {
    return this._user;
  }

  /**
   * @inheritDoc
   */
   getRequestSession() {
    return this._requestSession;
  }

  /**
   * @inheritDoc
   */
   setRequestSession(requestSession) {
    this._requestSession = requestSession;
    return this;
  }

  /**
   * @inheritDoc
   */
   setTags(tags) {
    this._tags = {
      ...this._tags,
      ...tags,
    };
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setTag(key, value) {
    this._tags = { ...this._tags, [key]: value };
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setExtras(extras) {
    this._extra = {
      ...this._extra,
      ...extras,
    };
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setExtra(key, extra) {
    this._extra = { ...this._extra, [key]: extra };
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setFingerprint(fingerprint) {
    this._fingerprint = fingerprint;
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setLevel(
    // eslint-disable-next-line deprecation/deprecation
    level,
  ) {
    this._level = level;
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setTransactionName(name) {
    this._transactionName = name;
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setContext(key, context) {
    if (context === null) {
      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
      delete this._contexts[key];
    } else {
      this._contexts[key] = context;
    }

    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   setSpan(span) {
    this._span = span;
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   getSpan() {
    return this._span;
  }

  /**
   * @inheritDoc
   */
   getTransaction() {
    // Often, this span (if it exists at all) will be a transaction, but it's not guaranteed to be. Regardless, it will
    // have a pointer to the currently-active transaction.
    const span = this.getSpan();
    return span && span.transaction;
  }

  /**
   * @inheritDoc
   */
   setSession(session) {
    if (!session) {
      delete this._session;
    } else {
      this._session = session;
    }
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   getSession() {
    return this._session;
  }

  /**
   * @inheritDoc
   */
   update(captureContext) {
    if (!captureContext) {
      return this;
    }

    if (typeof captureContext === 'function') {
      const updatedScope = (captureContext )(this);
      return updatedScope instanceof Scope ? updatedScope : this;
    }

    if (captureContext instanceof Scope) {
      this._tags = { ...this._tags, ...captureContext._tags };
      this._extra = { ...this._extra, ...captureContext._extra };
      this._contexts = { ...this._contexts, ...captureContext._contexts };
      if (captureContext._user && Object.keys(captureContext._user).length) {
        this._user = captureContext._user;
      }
      if (captureContext._level) {
        this._level = captureContext._level;
      }
      if (captureContext._fingerprint) {
        this._fingerprint = captureContext._fingerprint;
      }
      if (captureContext._requestSession) {
        this._requestSession = captureContext._requestSession;
      }
    } else if (isPlainObject$1(captureContext)) {
      // eslint-disable-next-line no-param-reassign
      captureContext = captureContext ;
      this._tags = { ...this._tags, ...captureContext.tags };
      this._extra = { ...this._extra, ...captureContext.extra };
      this._contexts = { ...this._contexts, ...captureContext.contexts };
      if (captureContext.user) {
        this._user = captureContext.user;
      }
      if (captureContext.level) {
        this._level = captureContext.level;
      }
      if (captureContext.fingerprint) {
        this._fingerprint = captureContext.fingerprint;
      }
      if (captureContext.requestSession) {
        this._requestSession = captureContext.requestSession;
      }
    }

    return this;
  }

  /**
   * @inheritDoc
   */
   clear() {
    this._breadcrumbs = [];
    this._tags = {};
    this._extra = {};
    this._user = {};
    this._contexts = {};
    this._level = undefined;
    this._transactionName = undefined;
    this._fingerprint = undefined;
    this._requestSession = undefined;
    this._span = undefined;
    this._session = undefined;
    this._notifyScopeListeners();
    this._attachments = [];
    return this;
  }

  /**
   * @inheritDoc
   */
   addBreadcrumb(breadcrumb, maxBreadcrumbs) {
    const maxCrumbs = typeof maxBreadcrumbs === 'number' ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;

    // No data has been changed, so don't notify scope listeners
    if (maxCrumbs <= 0) {
      return this;
    }

    const mergedBreadcrumb = {
      timestamp: dateTimestampInSeconds(),
      ...breadcrumb,
    };
    this._breadcrumbs = [...this._breadcrumbs, mergedBreadcrumb].slice(-maxCrumbs);
    this._notifyScopeListeners();

    return this;
  }

  /**
   * @inheritDoc
   */
   clearBreadcrumbs() {
    this._breadcrumbs = [];
    this._notifyScopeListeners();
    return this;
  }

  /**
   * @inheritDoc
   */
   addAttachment(attachment) {
    this._attachments.push(attachment);
    return this;
  }

  /**
   * @inheritDoc
   */
   getAttachments() {
    return this._attachments;
  }

  /**
   * @inheritDoc
   */
   clearAttachments() {
    this._attachments = [];
    return this;
  }

  /**
   * Applies data from the scope to the event and runs all event processors on it.
   *
   * @param event Event
   * @param hint Object containing additional information about the original exception, for use by the event processors.
   * @hidden
   */
   applyToEvent(event, hint = {}) {
    if (this._extra && Object.keys(this._extra).length) {
      event.extra = { ...this._extra, ...event.extra };
    }
    if (this._tags && Object.keys(this._tags).length) {
      event.tags = { ...this._tags, ...event.tags };
    }
    if (this._user && Object.keys(this._user).length) {
      event.user = { ...this._user, ...event.user };
    }
    if (this._contexts && Object.keys(this._contexts).length) {
      event.contexts = { ...this._contexts, ...event.contexts };
    }
    if (this._level) {
      event.level = this._level;
    }
    if (this._transactionName) {
      event.transaction = this._transactionName;
    }

    // We want to set the trace context for normal events only if there isn't already
    // a trace context on the event. There is a product feature in place where we link
    // errors with transaction and it relies on that.
    if (this._span) {
      event.contexts = { trace: this._span.getTraceContext(), ...event.contexts };
      const transactionName = this._span.transaction && this._span.transaction.name;
      if (transactionName) {
        event.tags = { transaction: transactionName, ...event.tags };
      }
    }

    this._applyFingerprint(event);

    event.breadcrumbs = [...(event.breadcrumbs || []), ...this._breadcrumbs];
    event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;

    event.sdkProcessingMetadata = { ...event.sdkProcessingMetadata, ...this._sdkProcessingMetadata };

    return this._notifyEventProcessors([...getGlobalEventProcessors(), ...this._eventProcessors], event, hint);
  }

  /**
   * Add data which will be accessible during event processing but won't get sent to Sentry
   */
   setSDKProcessingMetadata(newData) {
    this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };

    return this;
  }

  /**
   * This will be called after {@link applyToEvent} is finished.
   */
   _notifyEventProcessors(
    processors,
    event,
    hint,
    index = 0,
  ) {
    return new SyncPromise((resolve, reject) => {
      const processor = processors[index];
      if (event === null || typeof processor !== 'function') {
        resolve(event);
      } else {
        const result = processor({ ...event }, hint) ;

        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
          processor.id &&
          result === null &&
          logger.log(`Event processor "${processor.id}" dropped event`);

        if (isThenable(result)) {
          void result
            .then(final => this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve))
            .then(null, reject);
        } else {
          void this._notifyEventProcessors(processors, result, hint, index + 1)
            .then(resolve)
            .then(null, reject);
        }
      }
    });
  }

  /**
   * This will be called on every set call.
   */
   _notifyScopeListeners() {
    // We need this check for this._notifyingListeners to be able to work on scope during updates
    // If this check is not here we'll produce endless recursion when something is done with the scope
    // during the callback.
    if (!this._notifyingListeners) {
      this._notifyingListeners = true;
      this._scopeListeners.forEach(callback => {
        callback(this);
      });
      this._notifyingListeners = false;
    }
  }

  /**
   * Applies fingerprint from the scope to the event if there's one,
   * uses message if there's one instead or get rid of empty fingerprint
   */
   _applyFingerprint(event) {
    // Make sure it's an array first and we actually have something in place
    event.fingerprint = event.fingerprint ? arrayify(event.fingerprint) : [];

    // If we have something on the scope, then merge it with event
    if (this._fingerprint) {
      event.fingerprint = event.fingerprint.concat(this._fingerprint);
    }

    // If we have no data at all, remove empty array default
    if (event.fingerprint && !event.fingerprint.length) {
      delete event.fingerprint;
    }
  }
}

/**
 * Returns the global event processors.
 */
function getGlobalEventProcessors() {
  return getGlobalSingleton('globalEventProcessors', () => []);
}

/**
 * Add a EventProcessor to be kept globally.
 * @param callback EventProcessor to add
 */
function addGlobalEventProcessor(callback) {
  getGlobalEventProcessors().push(callback);
}

/**
 * API compatibility version of this hub.
 *
 * WARNING: This number should only be increased when the global interface
 * changes and new methods are introduced.
 *
 * @hidden
 */
const API_VERSION = 4;

/**
 * Default maximum number of breadcrumbs added to an event. Can be overwritten
 * with {@link Options.maxBreadcrumbs}.
 */
const DEFAULT_BREADCRUMBS = 100;

/**
 * A layer in the process stack.
 * @hidden
 */

/**
 * @inheritDoc
 */
class Hub  {
  /** Is a {@link Layer}[] containing the client and scope */
    __init() {this._stack = [{}];}

  /** Contains the last event id of a captured event.  */

  /**
   * Creates a new instance of the hub, will push one {@link Layer} into the
   * internal stack on creation.
   *
   * @param client bound to the hub.
   * @param scope bound to the hub.
   * @param version number, higher number means higher priority.
   */
   constructor(client, scope = new Scope(),   _version = API_VERSION) {;this._version = _version;Hub.prototype.__init.call(this);
    this.getStackTop().scope = scope;
    if (client) {
      this.bindClient(client);
    }
  }

  /**
   * @inheritDoc
   */
   isOlderThan(version) {
    return this._version < version;
  }

  /**
   * @inheritDoc
   */
   bindClient(client) {
    const top = this.getStackTop();
    top.client = client;
    if (client && client.setupIntegrations) {
      client.setupIntegrations();
    }
  }

  /**
   * @inheritDoc
   */
   pushScope() {
    // We want to clone the content of prev scope
    const scope = Scope.clone(this.getScope());
    this.getStack().push({
      client: this.getClient(),
      scope,
    });
    return scope;
  }

  /**
   * @inheritDoc
   */
   popScope() {
    if (this.getStack().length <= 1) return false;
    return !!this.getStack().pop();
  }

  /**
   * @inheritDoc
   */
   withScope(callback) {
    const scope = this.pushScope();
    try {
      callback(scope);
    } finally {
      this.popScope();
    }
  }

  /**
   * @inheritDoc
   */
   getClient() {
    return this.getStackTop().client ;
  }

  /** Returns the scope of the top stack. */
   getScope() {
    return this.getStackTop().scope;
  }

  /** Returns the scope stack for domains or the process. */
   getStack() {
    return this._stack;
  }

  /** Returns the topmost scope layer in the order domain > local > process. */
   getStackTop() {
    return this._stack[this._stack.length - 1];
  }

  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
   captureException(exception, hint) {
    const eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4());
    const syntheticException = new Error('Sentry syntheticException');
    this._withClient((client, scope) => {
      client.captureException(
        exception,
        {
          originalException: exception,
          syntheticException,
          ...hint,
          event_id: eventId,
        },
        scope,
      );
    });
    return eventId;
  }

  /**
   * @inheritDoc
   */
   captureMessage(
    message,
    // eslint-disable-next-line deprecation/deprecation
    level,
    hint,
  ) {
    const eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4());
    const syntheticException = new Error(message);
    this._withClient((client, scope) => {
      client.captureMessage(
        message,
        level,
        {
          originalException: message,
          syntheticException,
          ...hint,
          event_id: eventId,
        },
        scope,
      );
    });
    return eventId;
  }

  /**
   * @inheritDoc
   */
   captureEvent(event, hint) {
    const eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (event.type !== 'transaction') {
      this._lastEventId = eventId;
    }

    this._withClient((client, scope) => {
      client.captureEvent(event, { ...hint, event_id: eventId }, scope);
    });
    return eventId;
  }

  /**
   * @inheritDoc
   */
   lastEventId() {
    return this._lastEventId;
  }

  /**
   * @inheritDoc
   */
   addBreadcrumb(breadcrumb, hint) {
    const { scope, client } = this.getStackTop();

    if (!scope || !client) return;

    // eslint-disable-next-line @typescript-eslint/unbound-method
    const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } =
      (client.getOptions && client.getOptions()) || {};

    if (maxBreadcrumbs <= 0) return;

    const timestamp = dateTimestampInSeconds();
    const mergedBreadcrumb = { timestamp, ...breadcrumb };
    const finalBreadcrumb = beforeBreadcrumb
      ? (consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) )
      : mergedBreadcrumb;

    if (finalBreadcrumb === null) return;

    scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
  }

  /**
   * @inheritDoc
   */
   setUser(user) {
    const scope = this.getScope();
    if (scope) scope.setUser(user);
  }

  /**
   * @inheritDoc
   */
   setTags(tags) {
    const scope = this.getScope();
    if (scope) scope.setTags(tags);
  }

  /**
   * @inheritDoc
   */
   setExtras(extras) {
    const scope = this.getScope();
    if (scope) scope.setExtras(extras);
  }

  /**
   * @inheritDoc
   */
   setTag(key, value) {
    const scope = this.getScope();
    if (scope) scope.setTag(key, value);
  }

  /**
   * @inheritDoc
   */
   setExtra(key, extra) {
    const scope = this.getScope();
    if (scope) scope.setExtra(key, extra);
  }

  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
   setContext(name, context) {
    const scope = this.getScope();
    if (scope) scope.setContext(name, context);
  }

  /**
   * @inheritDoc
   */
   configureScope(callback) {
    const { scope, client } = this.getStackTop();
    if (scope && client) {
      callback(scope);
    }
  }

  /**
   * @inheritDoc
   */
   run(callback) {
    const oldHub = makeMain(this);
    try {
      callback(this);
    } finally {
      makeMain(oldHub);
    }
  }

  /**
   * @inheritDoc
   */
   getIntegration(integration) {
    const client = this.getClient();
    if (!client) return null;
    try {
      return client.getIntegration(integration);
    } catch (_oO) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);
      return null;
    }
  }

  /**
   * @inheritDoc
   */
   startTransaction(context, customSamplingContext) {
    return this._callExtensionMethod('startTransaction', context, customSamplingContext);
  }

  /**
   * @inheritDoc
   */
   traceHeaders() {
    return this._callExtensionMethod('traceHeaders');
  }

  /**
   * @inheritDoc
   */
   captureSession(endSession = false) {
    // both send the update and pull the session from the scope
    if (endSession) {
      return this.endSession();
    }

    // only send the update
    this._sendSessionUpdate();
  }

  /**
   * @inheritDoc
   */
   endSession() {
    const layer = this.getStackTop();
    const scope = layer && layer.scope;
    const session = scope && scope.getSession();
    if (session) {
      closeSession(session);
    }
    this._sendSessionUpdate();

    // the session is over; take it off of the scope
    if (scope) {
      scope.setSession();
    }
  }

  /**
   * @inheritDoc
   */
   startSession(context) {
    const { scope, client } = this.getStackTop();
    const { release, environment } = (client && client.getOptions()) || {};

    // Will fetch userAgent if called from browser sdk
    const { userAgent } = GLOBAL_OBJ.navigator || {};

    const session = makeSession({
      release,
      environment,
      ...(scope && { user: scope.getUser() }),
      ...(userAgent && { userAgent }),
      ...context,
    });

    if (scope) {
      // End existing session if there's one
      const currentSession = scope.getSession && scope.getSession();
      if (currentSession && currentSession.status === 'ok') {
        updateSession(currentSession, { status: 'exited' });
      }
      this.endSession();

      // Afterwards we set the new session on the scope
      scope.setSession(session);
    }

    return session;
  }

  /**
   * Returns if default PII should be sent to Sentry and propagated in ourgoing requests
   * when Tracing is used.
   */
   shouldSendDefaultPii() {
    const client = this.getClient();
    const options = client && client.getOptions();
    return Boolean(options && options.sendDefaultPii);
  }

  /**
   * Sends the current Session on the scope
   */
   _sendSessionUpdate() {
    const { scope, client } = this.getStackTop();
    if (!scope) return;

    const session = scope.getSession();
    if (session) {
      if (client && client.captureSession) {
        client.captureSession(session);
      }
    }
  }

  /**
   * Internal helper function to call a method on the top client if it exists.
   *
   * @param method The method to call on the client.
   * @param args Arguments to pass to the client function.
   */
   _withClient(callback) {
    const { scope, client } = this.getStackTop();
    if (client) {
      callback(client, scope);
    }
  }

  /**
   * Calls global extension method and binding current instance to the function call
   */
  // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
   _callExtensionMethod(method, ...args) {
    const carrier = getMainCarrier();
    const sentry = carrier.__SENTRY__;
    if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {
      return sentry.extensions[method].apply(this, args);
    }
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);
  }
}

/**
 * Returns the global shim registry.
 *
 * FIXME: This function is problematic, because despite always returning a valid Carrier,
 * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check
 * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.
 **/
function getMainCarrier() {
  GLOBAL_OBJ.__SENTRY__ = GLOBAL_OBJ.__SENTRY__ || {
    extensions: {},
    hub: undefined,
  };
  return GLOBAL_OBJ;
}

/**
 * Replaces the current main hub with the passed one on the global object
 *
 * @returns The old replaced hub
 */
function makeMain(hub) {
  const registry = getMainCarrier();
  const oldHub = getHubFromCarrier(registry);
  setHubOnCarrier(registry, hub);
  return oldHub;
}

/**
 * Returns the default hub instance.
 *
 * If a hub is already registered in the global carrier but this module
 * contains a more recent version, it replaces the registered version.
 * Otherwise, the currently registered hub will be returned.
 */
function getCurrentHub() {
  // Get main carrier (global for every environment)
  const registry = getMainCarrier();

  // If there's no hub, or its an old API, assign a new one
  if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
    setHubOnCarrier(registry, new Hub());
  }

  // Prefer domains over global if they are there (applicable only to Node environment)
  if (isNodeEnv()) {
    return getHubFromActiveDomain(registry);
  }
  // Return hub that lives on a global object
  return getHubFromCarrier(registry);
}

/**
 * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist
 * @returns discovered hub
 */
function getHubFromActiveDomain(registry) {
  try {
    const sentry = getMainCarrier().__SENTRY__;
    const activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;

    // If there's no active domain, just return global hub
    if (!activeDomain) {
      return getHubFromCarrier(registry);
    }

    // If there's no hub on current domain, or it's an old API, assign a new one
    if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {
      const registryHubTopStack = getHubFromCarrier(registry).getStackTop();
      setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));
    }

    // Return hub that lives on a domain
    return getHubFromCarrier(activeDomain);
  } catch (_Oo) {
    // Return hub that lives on a global object
    return getHubFromCarrier(registry);
  }
}

/**
 * This will tell whether a carrier has a hub on it or not
 * @param carrier object
 */
function hasHubOnCarrier(carrier) {
  return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
}

/**
 * This will create a new {@link Hub} and add to the passed object on
 * __SENTRY__.hub.
 * @param carrier object
 * @hidden
 */
function getHubFromCarrier(carrier) {
  return getGlobalSingleton('hub', () => new Hub(), carrier);
}

/**
 * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute
 * @param carrier object
 * @param hub Hub
 * @returns A boolean indicating success or failure
 */
function setHubOnCarrier(carrier, hub) {
  if (!carrier) return false;
  const __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});
  __SENTRY__.hub = hub;
  return true;
}

// Note: All functions in this file are typed with a return value of `ReturnType<Hub[HUB_FUNCTION]>`,
// where HUB_FUNCTION is some method on the Hub class.
//
// This is done to make sure the top level SDK methods stay in sync with the hub methods.
// Although every method here has an explicit return type, some of them (that map to void returns) do not
// contain `return` keywords. This is done to save on bundle size, as `return` is not minifiable.

/**
 * Captures an exception event and sends it to Sentry.
 *
 * @param exception An exception-like object.
 * @param captureContext Additional scope data to apply to exception event.
 * @returns The generated eventId.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
function captureException(exception, captureContext) {
  return getCurrentHub().captureException(exception, { captureContext });
}

/**
 * Captures a message event and sends it to Sentry.
 *
 * @param message The message to send to Sentry.
 * @param Severity Define the level of the message.
 * @returns The generated eventId.
 */
function captureMessage(
  message,
  // eslint-disable-next-line deprecation/deprecation
  captureContext,
) {
  // This is necessary to provide explicit scopes upgrade, without changing the original
  // arity of the `captureMessage(message, level)` method.
  const level = typeof captureContext === 'string' ? captureContext : undefined;
  const context = typeof captureContext !== 'string' ? { captureContext } : undefined;
  return getCurrentHub().captureMessage(message, level, context);
}

/**
 * Captures a manually created event and sends it to Sentry.
 *
 * @param event The event to send to Sentry.
 * @returns The generated eventId.
 */
function captureEvent(event, hint) {
  return getCurrentHub().captureEvent(event, hint);
}

/**
 * Callback to set context information onto the scope.
 * @param callback Callback function that receives Scope.
 */
function configureScope(callback) {
  getCurrentHub().configureScope(callback);
}

/**
 * Records a new breadcrumb which will be attached to future events.
 *
 * Breadcrumbs will be added to subsequent events to provide more context on
 * user's actions prior to an error or crash.
 *
 * @param breadcrumb The breadcrumb to record.
 */
function addBreadcrumb(breadcrumb) {
  getCurrentHub().addBreadcrumb(breadcrumb);
}

/**
 * Sets context data with the given name.
 * @param name of the context
 * @param context Any kind of data. This data will be normalized.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setContext(name, context) {
  getCurrentHub().setContext(name, context);
}

/**
 * Set an object that will be merged sent as extra data with the event.
 * @param extras Extras object to merge into current context.
 */
function setExtras(extras) {
  getCurrentHub().setExtras(extras);
}

/**
 * Set key:value that will be sent as extra data with the event.
 * @param key String of extra
 * @param extra Any kind of data. This data will be normalized.
 */
function setExtra(key, extra) {
  getCurrentHub().setExtra(key, extra);
}

/**
 * Set an object that will be merged sent as tags data with the event.
 * @param tags Tags context object to merge into current context.
 */
function setTags(tags) {
  getCurrentHub().setTags(tags);
}

/**
 * Set key:value that will be sent as tags data with the event.
 *
 * Can also be used to unset a tag, by passing `undefined`.
 *
 * @param key String key of tag
 * @param value Value of tag
 */
function setTag(key, value) {
  getCurrentHub().setTag(key, value);
}

/**
 * Updates user context information for future events.
 *
 * @param user User context object to be set in the current context. Pass `null` to unset the user.
 */
function setUser(user) {
  getCurrentHub().setUser(user);
}

/**
 * Creates a new scope with and executes the given operation within.
 * The scope is automatically removed once the operation
 * finishes or throws.
 *
 * This is essentially a convenience function for:
 *
 *     pushScope();
 *     callback();
 *     popScope();
 *
 * @param callback that will be enclosed into push/popScope.
 */
function withScope(callback) {
  getCurrentHub().withScope(callback);
}

/**
 * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
 *
 * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
 * new child span within the transaction or any span, call the respective `.startChild()` method.
 *
 * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
 *
 * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its
 * finished child spans will be sent to Sentry.
 *
 * NOTE: This function should only be used for *manual* instrumentation. Auto-instrumentation should call
 * `startTransaction` directly on the hub.
 *
 * @param context Properties of the new `Transaction`.
 * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
 * default values). See {@link Options.tracesSampler}.
 *
 * @returns The transaction which was just started
 */
function startTransaction(
  context,
  customSamplingContext,
) {
  return getCurrentHub().startTransaction({ ...context }, customSamplingContext);
}

/**
 * @inheritdoc
 */
class SessionFlusher  {
    __init() {this.flushTimeout = 60;}
   __init2() {this._pendingAggregates = {};}

   __init3() {this._isEnabled = true;}

   constructor(client, attrs) {;SessionFlusher.prototype.__init.call(this);SessionFlusher.prototype.__init2.call(this);SessionFlusher.prototype.__init3.call(this);
    this._client = client;
    // Call to setInterval, so that flush is called every 60 seconds
    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);
    this._sessionAttrs = attrs;
  }

  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSession` */
   flush() {
    const sessionAggregates = this.getSessionAggregates();
    if (sessionAggregates.aggregates.length === 0) {
      return;
    }
    this._pendingAggregates = {};
    this._client.sendSession(sessionAggregates);
  }

  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */
   getSessionAggregates() {
    const aggregates = Object.keys(this._pendingAggregates).map((key) => {
      return this._pendingAggregates[parseInt(key)];
    });

    const sessionAggregates = {
      attrs: this._sessionAttrs,
      aggregates,
    };
    return dropUndefinedKeys(sessionAggregates);
  }

  /** JSDoc */
   close() {
    clearInterval(this._intervalId);
    this._isEnabled = false;
    this.flush();
  }

  /**
   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then
   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to
   * `_incrementSessionStatusCount` along with the start date
   */
   incrementSessionStatusCount() {
    if (!this._isEnabled) {
      return;
    }
    const scope = getCurrentHub().getScope();
    const requestSession = scope && scope.getRequestSession();

    if (requestSession && requestSession.status) {
      this._incrementSessionStatusCount(requestSession.status, new Date());
      // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in
      // case captureRequestSession is called more than once to prevent double count
      if (scope) {
        scope.setRequestSession(undefined);
      }
      /* eslint-enable @typescript-eslint/no-unsafe-member-access */
    }
  }

  /**
   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of
   * the session received
   */
   _incrementSessionStatusCount(status, date) {
    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys
    const sessionStartedTrunc = new Date(date).setSeconds(0, 0);
    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};

    // corresponds to aggregated sessions in one specific minute bucket
    // for example, {"started":"2021-03-16T08:00:00.000Z","exited":4, "errored": 1}
    const aggregationCounts = this._pendingAggregates[sessionStartedTrunc];
    if (!aggregationCounts.started) {
      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();
    }

    switch (status) {
      case 'errored':
        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;
        return aggregationCounts.errored;
      case 'ok':
        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;
        return aggregationCounts.exited;
      default:
        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;
        return aggregationCounts.crashed;
    }
  }
}

const SENTRY_API_VERSION = '7';

/** Returns the prefix to construct Sentry ingestion API endpoints. */
function getBaseApiEndpoint(dsn) {
  const protocol = dsn.protocol ? `${dsn.protocol}:` : '';
  const port = dsn.port ? `:${dsn.port}` : '';
  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ''}/api/`;
}

/** Returns the ingest API endpoint for target. */
function _getIngestEndpoint(dsn) {
  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
}

/** Returns a URL-encoded string with auth config suitable for a query string. */
function _encodedAuth(dsn, sdkInfo) {
  return urlEncode({
    // We send only the minimum set of required information. See
    // https://github.com/getsentry/sentry-javascript/issues/2572.
    sentry_key: dsn.publicKey,
    sentry_version: SENTRY_API_VERSION,
    ...(sdkInfo && { sentry_client: `${sdkInfo.name}/${sdkInfo.version}` }),
  });
}

/**
 * Returns the envelope endpoint URL with auth in the query string.
 *
 * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
 */
function getEnvelopeEndpointWithUrlEncodedAuth(
  dsn,
  // TODO (v8): Remove `tunnelOrOptions` in favor of `options`, and use the substitute code below
  // options: ClientOptions = {} as ClientOptions,
  tunnelOrOptions = {} ,
) {
  // TODO (v8): Use this code instead
  // const { tunnel, _metadata = {} } = options;
  // return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, _metadata.sdk)}`;

  const tunnel = typeof tunnelOrOptions === 'string' ? tunnelOrOptions : tunnelOrOptions.tunnel;
  const sdkInfo =
    typeof tunnelOrOptions === 'string' || !tunnelOrOptions._metadata ? undefined : tunnelOrOptions._metadata.sdk;

  return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
}

/** Returns the url to the report dialog endpoint. */
function getReportDialogEndpoint(
  dsnLike,
  dialogOptions

,
) {
  const dsn = makeDsn(dsnLike);
  const endpoint = `${getBaseApiEndpoint(dsn)}embed/error-page/`;

  let encodedOptions = `dsn=${dsnToString(dsn)}`;
  for (const key in dialogOptions) {
    if (key === 'dsn') {
      continue;
    }

    if (key === 'user') {
      const user = dialogOptions.user;
      if (!user) {
        continue;
      }
      if (user.name) {
        encodedOptions += `&name=${encodeURIComponent(user.name)}`;
      }
      if (user.email) {
        encodedOptions += `&email=${encodeURIComponent(user.email)}`;
      }
    } else {
      encodedOptions += `&${encodeURIComponent(key)}=${encodeURIComponent(dialogOptions[key] )}`;
    }
  }

  return `${endpoint}?${encodedOptions}`;
}

/** Extract sdk info from from the API metadata */
function getSdkMetadataForEnvelopeHeader(metadata) {
  if (!metadata || !metadata.sdk) {
    return;
  }
  const { name, version } = metadata.sdk;
  return { name, version };
}

/**
 * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.
 * Merge with existing data if any.
 **/
function enhanceEventWithSdkInfo(event, sdkInfo) {
  if (!sdkInfo) {
    return event;
  }
  event.sdk = event.sdk || {};
  event.sdk.name = event.sdk.name || sdkInfo.name;
  event.sdk.version = event.sdk.version || sdkInfo.version;
  event.sdk.integrations = [...(event.sdk.integrations || []), ...(sdkInfo.integrations || [])];
  event.sdk.packages = [...(event.sdk.packages || []), ...(sdkInfo.packages || [])];
  return event;
}

/** Creates an envelope from a Session */
function createSessionEnvelope(
  session,
  dsn,
  metadata,
  tunnel,
) {
  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  const envelopeHeaders = {
    sent_at: new Date().toISOString(),
    ...(sdkInfo && { sdk: sdkInfo }),
    ...(!!tunnel && { dsn: dsnToString(dsn) }),
  };

  const envelopeItem =
    'aggregates' in session ? [{ type: 'sessions' }, session] : [{ type: 'session' }, session];

  return createEnvelope(envelopeHeaders, [envelopeItem]);
}

/**
 * Create an Envelope from an event.
 */
function createEventEnvelope(
  event,
  dsn,
  metadata,
  tunnel,
) {
  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  const eventType = event.type || 'event';

  enhanceEventWithSdkInfo(event, metadata && metadata.sdk);

  const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);

  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to
  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may
  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid
  // of this `delete`, lest we miss putting it back in the next time the property is in use.)
  delete event.sdkProcessingMetadata;

  const eventItem = [{ type: eventType }, event];
  return createEnvelope(envelopeHeaders, [eventItem]);
}

function createEventEnvelopeHeaders(
  event,
  sdkInfo,
  tunnel,
  dsn,
) {
  const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;

  return {
    event_id: event.event_id ,
    sent_at: new Date().toISOString(),
    ...(sdkInfo && { sdk: sdkInfo }),
    ...(!!tunnel && { dsn: dsnToString(dsn) }),
    ...(event.type === 'transaction' &&
      dynamicSamplingContext && {
        trace: dropUndefinedKeys({ ...dynamicSamplingContext }),
      }),
  };
}

const installedIntegrations = [];

/** Map of integrations assigned to a client */

/**
 * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to
 * preseve the order of integrations in the array.
 *
 * @private
 */
function filterDuplicates(integrations) {
  const integrationsByName = {};

  integrations.forEach(currentInstance => {
    const { name } = currentInstance;

    const existingInstance = integrationsByName[name];

    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a
    // default instance to overwrite an existing user instance
    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {
      return;
    }

    integrationsByName[name] = currentInstance;
  });

  return Object.values(integrationsByName);
}

/** Gets integrations to install */
function getIntegrationsToSetup(options) {
  const defaultIntegrations = options.defaultIntegrations || [];
  const userIntegrations = options.integrations;

  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class
  defaultIntegrations.forEach(integration => {
    integration.isDefaultInstance = true;
  });

  let integrations;

  if (Array.isArray(userIntegrations)) {
    integrations = [...defaultIntegrations, ...userIntegrations];
  } else if (typeof userIntegrations === 'function') {
    integrations = arrayify(userIntegrations(defaultIntegrations));
  } else {
    integrations = defaultIntegrations;
  }

  const finalIntegrations = filterDuplicates(integrations);

  // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend` or
  // `beforeSendTransaction`. It therefore has to run after all other integrations, so that the changes of all event
  // processors will be reflected in the printed values. For lack of a more elegant way to guarantee that, we therefore
  // locate it and, assuming it exists, pop it out of its current spot and shove it onto the end of the array.
  const debugIndex = finalIntegrations.findIndex(integration => integration.name === 'Debug');
  if (debugIndex !== -1) {
    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);
    finalIntegrations.push(debugInstance);
  }

  return finalIntegrations;
}

/**
 * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default
 * integrations are added unless they were already provided before.
 * @param integrations array of integration instances
 * @param withDefault should enable default integrations
 */
function setupIntegrations(integrations) {
  const integrationIndex = {};

  integrations.forEach(integration => {
    integrationIndex[integration.name] = integration;

    if (installedIntegrations.indexOf(integration.name) === -1) {
      integration.setupOnce(addGlobalEventProcessor, getCurrentHub);
      installedIntegrations.push(integration.name);
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Integration installed: ${integration.name}`);
    }
  });

  return integrationIndex;
}

const ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";

/**
 * Base implementation for all JavaScript SDK clients.
 *
 * Call the constructor with the corresponding options
 * specific to the client subclass. To access these options later, use
 * {@link Client.getOptions}.
 *
 * If a Dsn is specified in the options, it will be parsed and stored. Use
 * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is
 * invalid, the constructor will throw a {@link SentryException}. Note that
 * without a valid Dsn, the SDK will not send any events to Sentry.
 *
 * Before sending an event, it is passed through
 * {@link BaseClient._prepareEvent} to add SDK information and scope data
 * (breadcrumbs and context). To add more custom information, override this
 * method and extend the resulting prepared event.
 *
 * To issue automatically created events (e.g. via instrumentation), use
 * {@link Client.captureEvent}. It will prepare the event and pass it through
 * the callback lifecycle. To issue auto-breadcrumbs, use
 * {@link Client.addBreadcrumb}.
 *
 * @example
 * class NodeClient extends BaseClient<NodeOptions> {
 *   public constructor(options: NodeOptions) {
 *     super(options);
 *   }
 *
 *   // ...
 * }
 */
class BaseClient {
  /** Options passed to the SDK. */

  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */

  /** Array of set up integrations. */
   __init() {this._integrations = {};}

  /** Indicates whether this client's integrations have been set up. */
   __init2() {this._integrationsInitialized = false;}

  /** Number of calls being processed */
   __init3() {this._numProcessing = 0;}

  /** Holds flushable  */
   __init4() {this._outcomes = {};}

  /**
   * Initializes this client instance.
   *
   * @param options Options for the client.
   */
   constructor(options) {;BaseClient.prototype.__init.call(this);BaseClient.prototype.__init2.call(this);BaseClient.prototype.__init3.call(this);BaseClient.prototype.__init4.call(this);
    this._options = options;
    if (options.dsn) {
      this._dsn = makeDsn(options.dsn);
      const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);
      this._transport = options.transport({
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...options.transportOptions,
        url,
      });
    } else {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('No DSN provided, client will not do anything.');
    }
  }

  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
   captureException(exception, hint, scope) {
    // ensure we haven't captured this very object before
    if (checkOrSetAlreadyCaught(exception)) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(ALREADY_SEEN_ERROR);
      return;
    }

    let eventId = hint && hint.event_id;

    this._process(
      this.eventFromException(exception, hint)
        .then(event => this._captureEvent(event, hint, scope))
        .then(result => {
          eventId = result;
        }),
    );

    return eventId;
  }

  /**
   * @inheritDoc
   */
   captureMessage(
    message,
    // eslint-disable-next-line deprecation/deprecation
    level,
    hint,
    scope,
  ) {
    let eventId = hint && hint.event_id;

    const promisedEvent = isPrimitive(message)
      ? this.eventFromMessage(String(message), level, hint)
      : this.eventFromException(message, hint);

    this._process(
      promisedEvent
        .then(event => this._captureEvent(event, hint, scope))
        .then(result => {
          eventId = result;
        }),
    );

    return eventId;
  }

  /**
   * @inheritDoc
   */
   captureEvent(event, hint, scope) {
    // ensure we haven't captured this very object before
    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(ALREADY_SEEN_ERROR);
      return;
    }

    let eventId = hint && hint.event_id;

    this._process(
      this._captureEvent(event, hint, scope).then(result => {
        eventId = result;
      }),
    );

    return eventId;
  }

  /**
   * @inheritDoc
   */
   captureSession(session) {
    if (!this._isEnabled()) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('SDK not enabled, will not capture session.');
      return;
    }

    if (!(typeof session.release === 'string')) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Discarded session because of missing or non-string release');
    } else {
      this.sendSession(session);
      // After sending, we set init false to indicate it's not the first occurrence
      updateSession(session, { init: false });
    }
  }

  /**
   * @inheritDoc
   */
   getDsn() {
    return this._dsn;
  }

  /**
   * @inheritDoc
   */
   getOptions() {
    return this._options;
  }

  /**
   * @inheritDoc
   */
   getTransport() {
    return this._transport;
  }

  /**
   * @inheritDoc
   */
   flush(timeout) {
    const transport = this._transport;
    if (transport) {
      return this._isClientDoneProcessing(timeout).then(clientFinished => {
        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);
      });
    } else {
      return resolvedSyncPromise(true);
    }
  }

  /**
   * @inheritDoc
   */
   close(timeout) {
    return this.flush(timeout).then(result => {
      this.getOptions().enabled = false;
      return result;
    });
  }

  /**
   * Sets up the integrations
   */
   setupIntegrations() {
    if (this._isEnabled() && !this._integrationsInitialized) {
      this._integrations = setupIntegrations(this._options.integrations);
      this._integrationsInitialized = true;
    }
  }

  /**
   * Gets an installed integration by its `id`.
   *
   * @returns The installed integration or `undefined` if no integration with that `id` was installed.
   */
   getIntegrationById(integrationId) {
    return this._integrations[integrationId];
  }

  /**
   * @inheritDoc
   */
   getIntegration(integration) {
    try {
      return (this._integrations[integration.id] ) || null;
    } catch (_oO) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);
      return null;
    }
  }

  /**
   * @inheritDoc
   */
   sendEvent(event, hint = {}) {
    if (this._dsn) {
      let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);

      for (const attachment of hint.attachments || []) {
        env = addItemToEnvelope(
          env,
          createAttachmentEnvelopeItem(
            attachment,
            this._options.transportOptions && this._options.transportOptions.textEncoder,
          ),
        );
      }

      this._sendEnvelope(env);
    }
  }

  /**
   * @inheritDoc
   */
   sendSession(session) {
    if (this._dsn) {
      const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);
      this._sendEnvelope(env);
    }
  }

  /**
   * @inheritDoc
   */
   recordDroppedEvent(reason, category) {
    if (this._options.sendClientReports) {
      // We want to track each category (error, transaction, session) separately
      // but still keep the distinction between different type of outcomes.
      // We could use nested maps, but it's much easier to read and type this way.
      // A correct type for map-based implementation if we want to go that route
      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`
      // With typescript 4.1 we could even use template literal types
      const key = `${reason}:${category}`;
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Adding outcome: "${key}"`);

      // The following works because undefined + 1 === NaN and NaN is falsy
      this._outcomes[key] = this._outcomes[key] + 1 || 1;
    }
  }

  /** Updates existing session based on the provided event */
   _updateSessionFromEvent(session, event) {
    let crashed = false;
    let errored = false;
    const exceptions = event.exception && event.exception.values;

    if (exceptions) {
      errored = true;

      for (const ex of exceptions) {
        const mechanism = ex.mechanism;
        if (mechanism && mechanism.handled === false) {
          crashed = true;
          break;
        }
      }
    }

    // A session is updated and that session update is sent in only one of the two following scenarios:
    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update
    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update
    const sessionNonTerminal = session.status === 'ok';
    const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);

    if (shouldUpdateAndSend) {
      updateSession(session, {
        ...(crashed && { status: 'crashed' }),
        errors: session.errors || Number(errored || crashed),
      });
      this.captureSession(session);
    }
  }

  /**
   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
   * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
   * `false` otherwise
   */
   _isClientDoneProcessing(timeout) {
    return new SyncPromise(resolve => {
      let ticked = 0;
      const tick = 1;

      const interval = setInterval(() => {
        if (this._numProcessing == 0) {
          clearInterval(interval);
          resolve(true);
        } else {
          ticked += tick;
          if (timeout && ticked >= timeout) {
            clearInterval(interval);
            resolve(false);
          }
        }
      }, tick);
    });
  }

  /** Determines whether this SDK is enabled and a valid Dsn is present. */
   _isEnabled() {
    return this.getOptions().enabled !== false && this._dsn !== undefined;
  }

  /**
   * Adds common information to events.
   *
   * The information includes release and environment from `options`,
   * breadcrumbs and context (extra, tags and user) from the scope.
   *
   * Information that is already present in the event is never overwritten. For
   * nested objects, such as the context, keys are merged.
   *
   * @param event The original event.
   * @param hint May contain additional information about the original exception.
   * @param scope A scope containing event metadata.
   * @returns A new event with more information.
   */
   _prepareEvent(event, hint, scope) {
    const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = this.getOptions();
    const prepared = {
      ...event,
      event_id: event.event_id || hint.event_id || uuid4(),
      timestamp: event.timestamp || dateTimestampInSeconds(),
    };

    this._applyClientOptions(prepared);
    this._applyIntegrationsMetadata(prepared);

    // If we have scope given to us, use it as the base for further modifications.
    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.
    let finalScope = scope;
    if (hint.captureContext) {
      finalScope = Scope.clone(finalScope).update(hint.captureContext);
    }

    // We prepare the result here with a resolved Event.
    let result = resolvedSyncPromise(prepared);

    // This should be the last thing called, since we want that
    // {@link Hub.addEventProcessor} gets the finished prepared event.
    if (finalScope) {
      // Collect attachments from the hint and scope
      const attachments = [...(hint.attachments || []), ...finalScope.getAttachments()];

      if (attachments.length) {
        hint.attachments = attachments;
      }

      // In case we have a hub we reassign it.
      result = finalScope.applyToEvent(prepared, hint);
    }

    return result.then(evt => {
      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {
        return this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
      }
      return evt;
    });
  }

  /**
   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.
   * Normalized keys:
   * - `breadcrumbs.data`
   * - `user`
   * - `contexts`
   * - `extra`
   * @param event Event
   * @returns Normalized event
   */
   _normalizeEvent(event, depth, maxBreadth) {
    if (!event) {
      return null;
    }

    const normalized = {
      ...event,
      ...(event.breadcrumbs && {
        breadcrumbs: event.breadcrumbs.map(b => ({
          ...b,
          ...(b.data && {
            data: normalize$1(b.data, depth, maxBreadth),
          }),
        })),
      }),
      ...(event.user && {
        user: normalize$1(event.user, depth, maxBreadth),
      }),
      ...(event.contexts && {
        contexts: normalize$1(event.contexts, depth, maxBreadth),
      }),
      ...(event.extra && {
        extra: normalize$1(event.extra, depth, maxBreadth),
      }),
    };

    // event.contexts.trace stores information about a Transaction. Similarly,
    // event.spans[] stores information about child Spans. Given that a
    // Transaction is conceptually a Span, normalization should apply to both
    // Transactions and Spans consistently.
    // For now the decision is to skip normalization of Transactions and Spans,
    // so this block overwrites the normalized event to add back the original
    // Transaction information prior to normalization.
    if (event.contexts && event.contexts.trace && normalized.contexts) {
      normalized.contexts.trace = event.contexts.trace;

      // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it
      if (event.contexts.trace.data) {
        normalized.contexts.trace.data = normalize$1(event.contexts.trace.data, depth, maxBreadth);
      }
    }

    // event.spans[].data may contain circular/dangerous data so we need to normalize it
    if (event.spans) {
      normalized.spans = event.spans.map(span => {
        // We cannot use the spread operator here because `toJSON` on `span` is non-enumerable
        if (span.data) {
          span.data = normalize$1(span.data, depth, maxBreadth);
        }
        return span;
      });
    }

    return normalized;
  }

  /**
   *  Enhances event using the client configuration.
   *  It takes care of all "static" values like environment, release and `dist`,
   *  as well as truncating overly long values.
   * @param event event instance to be enhanced
   */
   _applyClientOptions(event) {
    const options = this.getOptions();
    const { environment, release, dist, maxValueLength = 250 } = options;

    if (!('environment' in event)) {
      event.environment = 'environment' in options ? environment : 'production';
    }

    if (event.release === undefined && release !== undefined) {
      event.release = release;
    }

    if (event.dist === undefined && dist !== undefined) {
      event.dist = dist;
    }

    if (event.message) {
      event.message = truncate(event.message, maxValueLength);
    }

    const exception = event.exception && event.exception.values && event.exception.values[0];
    if (exception && exception.value) {
      exception.value = truncate(exception.value, maxValueLength);
    }

    const request = event.request;
    if (request && request.url) {
      request.url = truncate(request.url, maxValueLength);
    }
  }

  /**
   * This function adds all used integrations to the SDK info in the event.
   * @param event The event that will be filled with all integrations.
   */
   _applyIntegrationsMetadata(event) {
    const integrationsArray = Object.keys(this._integrations);
    if (integrationsArray.length > 0) {
      event.sdk = event.sdk || {};
      event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationsArray];
    }
  }

  /**
   * Processes the event and logs an error in case of rejection
   * @param event
   * @param hint
   * @param scope
   */
   _captureEvent(event, hint = {}, scope) {
    return this._processEvent(event, hint, scope).then(
      finalEvent => {
        return finalEvent.event_id;
      },
      reason => {
        if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {
          // If something's gone wrong, log the error as a warning. If it's just us having used a `SentryError` for
          // control flow, log just the message (no stack) as a log-level log.
          const sentryError = reason ;
          if (sentryError.logLevel === 'log') {
            logger.log(sentryError.message);
          } else {
            logger.warn(sentryError);
          }
        }
        return undefined;
      },
    );
  }

  /**
   * Processes an event (either error or message) and sends it to Sentry.
   *
   * This also adds breadcrumbs and context information to the event. However,
   * platform specific meta data (such as the User's IP address) must be added
   * by the SDK implementor.
   *
   *
   * @param event The event to send to Sentry.
   * @param hint May contain additional information about the original exception.
   * @param scope A scope containing event metadata.
   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
   */
   _processEvent(event, hint, scope) {
    const options = this.getOptions();
    const { sampleRate } = options;

    if (!this._isEnabled()) {
      return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.', 'log'));
    }

    const isTransaction = event.type === 'transaction';
    const beforeSendProcessorName = isTransaction ? 'beforeSendTransaction' : 'beforeSend';
    const beforeSendProcessor = options[beforeSendProcessorName];

    // 1.0 === 100% events are sent
    // 0.0 === 0% events are sent
    // Sampling for transaction happens somewhere else
    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {
      this.recordDroppedEvent('sample_rate', 'error');
      return rejectedSyncPromise(
        new SentryError(
          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,
          'log',
        ),
      );
    }

    return this._prepareEvent(event, hint, scope)
      .then(prepared => {
        if (prepared === null) {
          this.recordDroppedEvent('event_processor', event.type || 'error');
          throw new SentryError('An event processor returned `null`, will not send event.', 'log');
        }

        const isInternalException = hint.data && (hint.data ).__sentry__ === true;
        if (isInternalException || !beforeSendProcessor) {
          return prepared;
        }

        const beforeSendResult = beforeSendProcessor(prepared, hint);
        return _validateBeforeSendResult(beforeSendResult, beforeSendProcessorName);
      })
      .then(processedEvent => {
        if (processedEvent === null) {
          this.recordDroppedEvent('before_send', event.type || 'error');
          throw new SentryError(`\`${beforeSendProcessorName}\` returned \`null\`, will not send event.`, 'log');
        }

        const session = scope && scope.getSession();
        if (!isTransaction && session) {
          this._updateSessionFromEvent(session, processedEvent);
        }

        // None of the Sentry built event processor will update transaction name,
        // so if the transaction name has been changed by an event processor, we know
        // it has to come from custom event processor added by a user
        const transactionInfo = processedEvent.transaction_info;
        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
          const source = 'custom';
          processedEvent.transaction_info = {
            ...transactionInfo,
            source,
            changes: [
              ...transactionInfo.changes,
              {
                source,
                // use the same timestamp as the processed event.
                timestamp: processedEvent.timestamp ,
                propagations: transactionInfo.propagations,
              },
            ],
          };
        }

        this.sendEvent(processedEvent, hint);
        return processedEvent;
      })
      .then(null, reason => {
        if (reason instanceof SentryError) {
          throw reason;
        }

        this.captureException(reason, {
          data: {
            __sentry__: true,
          },
          originalException: reason ,
        });
        throw new SentryError(
          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${reason}`,
        );
      });
  }

  /**
   * Occupies the client with processing and event
   */
   _process(promise) {
    this._numProcessing += 1;
    void promise.then(
      value => {
        this._numProcessing -= 1;
        return value;
      },
      reason => {
        this._numProcessing -= 1;
        return reason;
      },
    );
  }

  /**
   * @inheritdoc
   */
   _sendEnvelope(envelope) {
    if (this._transport && this._dsn) {
      this._transport.send(envelope).then(null, reason => {
        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Error while sending event:', reason);
      });
    } else {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Transport disabled');
    }
  }

  /**
   * Clears outcomes on this client and returns them.
   */
   _clearOutcomes() {
    const outcomes = this._outcomes;
    this._outcomes = {};
    return Object.keys(outcomes).map(key => {
      const [reason, category] = key.split(':') ;
      return {
        reason,
        category,
        quantity: outcomes[key],
      };
    });
  }

  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types

}

/**
 * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.
 */
function _validateBeforeSendResult(
  beforeSendResult,
  beforeSendProcessorName,
) {
  const invalidValueError = `\`${beforeSendProcessorName}\` must return \`null\` or a valid event.`;
  if (isThenable(beforeSendResult)) {
    return beforeSendResult.then(
      event => {
        if (!isPlainObject$1(event) && event !== null) {
          throw new SentryError(invalidValueError);
        }
        return event;
      },
      e => {
        throw new SentryError(`\`${beforeSendProcessorName}\` rejected with ${e}`);
      },
    );
  } else if (!isPlainObject$1(beforeSendResult) && beforeSendResult !== null) {
    throw new SentryError(invalidValueError);
  }
  return beforeSendResult;
}

/** A class object that can instantiate Client objects. */

/**
 * Internal function to create a new SDK client instance. The client is
 * installed and then bound to the current scope.
 *
 * @param clientClass The client class to instantiate.
 * @param options Options to pass to the client.
 */
function initAndBind(
  clientClass,
  options,
) {
  if (options.debug === true) {
    if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {
      logger.enable();
    } else {
      // use `console.warn` rather than `logger.warn` since by non-debug bundles have all `logger.x` statements stripped
      // eslint-disable-next-line no-console
      console.warn('[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.');
    }
  }
  const hub = getCurrentHub();
  const scope = hub.getScope();
  if (scope) {
    scope.update(options.initialScope);
  }

  const client = new clientClass(options);
  hub.bindClient(client);
}

const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;

/**
 * Creates an instance of a Sentry `Transport`
 *
 * @param options
 * @param makeRequest
 */
function createTransport(
  options,
  makeRequest,
  buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE),
) {
  let rateLimits = {};

  const flush = (timeout) => buffer.drain(timeout);

  function send(envelope) {
    const filteredEnvelopeItems = [];

    // Drop rate limited items from envelope
    forEachEnvelopeItem(envelope, (item, type) => {
      const envelopeItemDataCategory = envelopeItemTypeToDataCategory(type);
      if (isRateLimited(rateLimits, envelopeItemDataCategory)) {
        options.recordDroppedEvent('ratelimit_backoff', envelopeItemDataCategory);
      } else {
        filteredEnvelopeItems.push(item);
      }
    });

    // Skip sending if envelope is empty after filtering out rate limited events
    if (filteredEnvelopeItems.length === 0) {
      return resolvedSyncPromise();
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems );

    // Creates client report for each item in an envelope
    const recordEnvelopeLoss = (reason) => {
      forEachEnvelopeItem(filteredEnvelope, (_, type) => {
        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));
      });
    };

    const requestTask = () =>
      makeRequest({ body: serializeEnvelope(filteredEnvelope, options.textEncoder) }).then(
        response => {
          // We don't want to throw on NOK responses, but we want to at least log them
          if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {
            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
          }

          rateLimits = updateRateLimits(rateLimits, response);
        },
        error => {
          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Failed while sending event:', error);
          recordEnvelopeLoss('network_error');
        },
      );

    return buffer.add(requestTask).then(
      result => result,
      error => {
        if (error instanceof SentryError) {
          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Skipped sending event because buffer is full.');
          recordEnvelopeLoss('queue_overflow');
          return resolvedSyncPromise();
        } else {
          throw error;
        }
      },
    );
  }

  return {
    send,
    flush,
  };
}

const SDK_VERSION = '7.20.0';

let originalFunctionToString;

/** Patch toString calls to return proper name for wrapped functions */
class FunctionToString  {constructor() { FunctionToString.prototype.__init.call(this); }
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'FunctionToString';}

  /**
   * @inheritDoc
   */
   __init() {this.name = FunctionToString.id;}

  /**
   * @inheritDoc
   */
   setupOnce() {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    originalFunctionToString = Function.prototype.toString;

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Function.prototype.toString = function ( ...args) {
      const context = getOriginalFunction(this) || this;
      return originalFunctionToString.apply(context, args);
    };
  }
} FunctionToString.__initStatic();

// "Script error." is hard coded into browsers for errors that it can't read.
// this is the result of a script being pulled in from an external domain and CORS.
const DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];

/** Options for the InboundFilters integration */

/** Inbound filters configurable by the user */
class InboundFilters  {
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'InboundFilters';}

  /**
   * @inheritDoc
   */
   __init() {this.name = InboundFilters.id;}

   constructor(  _options = {}) {;this._options = _options;InboundFilters.prototype.__init.call(this);}

  /**
   * @inheritDoc
   */
   setupOnce(addGlobalEventProcessor, getCurrentHub) {
    const eventProcess = (event) => {
      const hub = getCurrentHub();
      if (hub) {
        const self = hub.getIntegration(InboundFilters);
        if (self) {
          const client = hub.getClient();
          const clientOptions = client ? client.getOptions() : {};
          const options = _mergeOptions(self._options, clientOptions);
          return _shouldDropEvent$1(event, options) ? null : event;
        }
      }
      return event;
    };

    eventProcess.id = this.name;
    addGlobalEventProcessor(eventProcess);
  }
} InboundFilters.__initStatic();

/** JSDoc */
function _mergeOptions(
  internalOptions = {},
  clientOptions = {},
) {
  return {
    allowUrls: [...(internalOptions.allowUrls || []), ...(clientOptions.allowUrls || [])],
    denyUrls: [...(internalOptions.denyUrls || []), ...(clientOptions.denyUrls || [])],
    ignoreErrors: [
      ...(internalOptions.ignoreErrors || []),
      ...(clientOptions.ignoreErrors || []),
      ...DEFAULT_IGNORE_ERRORS,
    ],
    ignoreInternal: internalOptions.ignoreInternal !== undefined ? internalOptions.ignoreInternal : true,
  };
}

/** JSDoc */
function _shouldDropEvent$1(event, options) {
  if (options.ignoreInternal && _isSentryError(event)) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${getEventDescription(event)}`);
    return true;
  }
  if (_isIgnoredError(event, options.ignoreErrors)) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger.warn(
        `Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${getEventDescription(event)}`,
      );
    return true;
  }
  if (_isDeniedUrl(event, options.denyUrls)) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger.warn(
        `Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${getEventDescription(
          event,
        )}.\nUrl: ${_getEventFilterUrl(event)}`,
      );
    return true;
  }
  if (!_isAllowedUrl(event, options.allowUrls)) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger.warn(
        `Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${getEventDescription(
          event,
        )}.\nUrl: ${_getEventFilterUrl(event)}`,
      );
    return true;
  }
  return false;
}

function _isIgnoredError(event, ignoreErrors) {
  if (!ignoreErrors || !ignoreErrors.length) {
    return false;
  }

  return _getPossibleEventMessages(event).some(message => stringMatchesSomePattern(message, ignoreErrors));
}

function _isDeniedUrl(event, denyUrls) {
  // TODO: Use Glob instead?
  if (!denyUrls || !denyUrls.length) {
    return false;
  }
  const url = _getEventFilterUrl(event);
  return !url ? false : stringMatchesSomePattern(url, denyUrls);
}

function _isAllowedUrl(event, allowUrls) {
  // TODO: Use Glob instead?
  if (!allowUrls || !allowUrls.length) {
    return true;
  }
  const url = _getEventFilterUrl(event);
  return !url ? true : stringMatchesSomePattern(url, allowUrls);
}

function _getPossibleEventMessages(event) {
  if (event.message) {
    return [event.message];
  }
  if (event.exception) {
    try {
      const { type = '', value = '' } = (event.exception.values && event.exception.values[0]) || {};
      return [`${value}`, `${type}: ${value}`];
    } catch (oO) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error(`Cannot extract message for event ${getEventDescription(event)}`);
      return [];
    }
  }
  return [];
}

function _isSentryError(event) {
  try {
    // @ts-ignore can't be a sentry error if undefined
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    return event.exception.values[0].type === 'SentryError';
  } catch (e) {
    // ignore
  }
  return false;
}

function _getLastValidUrl(frames = []) {
  for (let i = frames.length - 1; i >= 0; i--) {
    const frame = frames[i];

    if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {
      return frame.filename || null;
    }
  }

  return null;
}

function _getEventFilterUrl(event) {
  try {
    let frames;
    try {
      // @ts-ignore we only care about frames if the whole thing here is defined
      frames = event.exception.values[0].stacktrace.frames;
    } catch (e) {
      // ignore
    }
    return frames ? _getLastValidUrl(frames) : null;
  } catch (oO) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);
    return null;
  }
}

var Integrations = /*#__PURE__*/Object.freeze({
  __proto__: null,
  FunctionToString: FunctionToString,
  InboundFilters: InboundFilters
});

;
;

const WINDOW = GLOBAL_OBJ ;

let ignoreOnError = 0;

/**
 * @hidden
 */
function shouldIgnoreOnError() {
  return ignoreOnError > 0;
}

/**
 * @hidden
 */
function ignoreNextOnError() {
  // onerror should trigger before setTimeout
  ignoreOnError += 1;
  setTimeout(() => {
    ignoreOnError -= 1;
  });
}

/**
 * Instruments the given function and sends an event to Sentry every time the
 * function throws an exception.
 *
 * @param fn A function to wrap. It is generally safe to pass an unbound function, because the returned wrapper always
 * has a correct `this` context.
 * @returns The wrapped function.
 * @hidden
 */
function wrap$1(
  fn,
  options

 = {},
  before,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
  // for future readers what this does is wrap a function and then create
  // a bi-directional wrapping between them.
  //
  // example: wrapped = wrap(original);
  //  original.__sentry_wrapped__ -> wrapped
  //  wrapped.__sentry_original__ -> original

  if (typeof fn !== 'function') {
    return fn;
  }

  try {
    // if we're dealing with a function that was previously wrapped, return
    // the original wrapper.
    const wrapper = fn.__sentry_wrapped__;
    if (wrapper) {
      return wrapper;
    }

    // We don't wanna wrap it twice
    if (getOriginalFunction(fn)) {
      return fn;
    }
  } catch (e) {
    // Just accessing custom props in some Selenium environments
    // can cause a "Permission denied" exception (see raven-js#495).
    // Bail on wrapping and return the function as-is (defers to window.onerror).
    return fn;
  }

  /* eslint-disable prefer-rest-params */
  // It is important that `sentryWrapped` is not an arrow function to preserve the context of `this`
  const sentryWrapped = function () {
    const args = Array.prototype.slice.call(arguments);

    try {
      if (before && typeof before === 'function') {
        before.apply(this, arguments);
      }

      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
      const wrappedArguments = args.map((arg) => wrap$1(arg, options));

      // Attempt to invoke user-land function
      // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
      //       means the sentry.javascript SDK caught an error invoking your application code. This
      //       is expected behavior and NOT indicative of a bug with sentry.javascript.
      return fn.apply(this, wrappedArguments);
    } catch (ex) {
      ignoreNextOnError();

      withScope((scope) => {
        scope.addEventProcessor((event) => {
          if (options.mechanism) {
            addExceptionTypeValue(event, undefined, undefined);
            addExceptionMechanism(event, options.mechanism);
          }

          event.extra = {
            ...event.extra,
            arguments: args,
          };

          return event;
        });

        captureException(ex);
      });

      throw ex;
    }
  };
  /* eslint-enable prefer-rest-params */

  // Accessing some objects may throw
  // ref: https://github.com/getsentry/sentry-javascript/issues/1168
  try {
    for (const property in fn) {
      if (Object.prototype.hasOwnProperty.call(fn, property)) {
        sentryWrapped[property] = fn[property];
      }
    }
  } catch (_oO) {} // eslint-disable-line no-empty

  // Signal that this function has been wrapped/filled already
  // for both debugging and to prevent it to being wrapped/filled twice
  markFunctionWrapped(sentryWrapped, fn);

  addNonEnumerableProperty(fn, '__sentry_wrapped__', sentryWrapped);

  // Restore original function name (not all browsers allow that)
  try {
    const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name') ;
    if (descriptor.configurable) {
      Object.defineProperty(sentryWrapped, 'name', {
        get() {
          return fn.name;
        },
      });
    }
    // eslint-disable-next-line no-empty
  } catch (_oO) {}

  return sentryWrapped;
}

/**
 * This function creates an exception from a JavaScript Error
 */
function exceptionFromError(stackParser, ex) {
  // Get the frames first since Opera can lose the stack if we touch anything else first
  const frames = parseStackFrames(stackParser, ex);

  const exception = {
    type: ex && ex.name,
    value: extractMessage(ex),
  };

  if (frames.length) {
    exception.stacktrace = { frames };
  }

  if (exception.type === undefined && exception.value === '') {
    exception.value = 'Unrecoverable error caught';
  }

  return exception;
}

/**
 * @hidden
 */
function eventFromPlainObject(
  stackParser,
  exception,
  syntheticException,
  isUnhandledRejection,
) {
  const hub = getCurrentHub();
  const client = hub.getClient();
  const normalizeDepth = client && client.getOptions().normalizeDepth;

  const event = {
    exception: {
      values: [
        {
          type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',
          value: `Non-Error ${
            isUnhandledRejection ? 'promise rejection' : 'exception'
          } captured with keys: ${extractExceptionKeysForMessage(exception)}`,
        },
      ],
    },
    extra: {
      __serialized__: normalizeToSize(exception, normalizeDepth),
    },
  };

  if (syntheticException) {
    const frames = parseStackFrames(stackParser, syntheticException);
    if (frames.length) {
      // event.exception.values[0] has been set above
      (event.exception ).values[0].stacktrace = { frames };
    }
  }

  return event;
}

/**
 * @hidden
 */
function eventFromError(stackParser, ex) {
  return {
    exception: {
      values: [exceptionFromError(stackParser, ex)],
    },
  };
}

/** Parses stack frames from an error */
function parseStackFrames(
  stackParser,
  ex,
) {
  // Access and store the stacktrace property before doing ANYTHING
  // else to it because Opera is not very good at providing it
  // reliably in other circumstances.
  const stacktrace = ex.stacktrace || ex.stack || '';

  const popSize = getPopSize(ex);

  try {
    return stackParser(stacktrace, popSize);
  } catch (e) {
    // no-empty
  }

  return [];
}

// Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108
const reactMinifiedRegexp = /Minified React error #\d+;/i;

function getPopSize(ex) {
  if (ex) {
    if (typeof ex.framesToPop === 'number') {
      return ex.framesToPop;
    }

    if (reactMinifiedRegexp.test(ex.message)) {
      return 1;
    }
  }

  return 0;
}

/**
 * There are cases where stacktrace.message is an Event object
 * https://github.com/getsentry/sentry-javascript/issues/1949
 * In this specific case we try to extract stacktrace.message.error.message
 */
function extractMessage(ex) {
  const message = ex && ex.message;
  if (!message) {
    return 'No error message';
  }
  if (message.error && typeof message.error.message === 'string') {
    return message.error.message;
  }
  return message;
}

/**
 * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.
 * @hidden
 */
function eventFromException(
  stackParser,
  exception,
  hint,
  attachStacktrace,
) {
  const syntheticException = (hint && hint.syntheticException) || undefined;
  const event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);
  addExceptionMechanism(event); // defaults to { type: 'generic', handled: true }
  event.level = 'error';
  if (hint && hint.event_id) {
    event.event_id = hint.event_id;
  }
  return resolvedSyncPromise(event);
}

/**
 * Builds and Event from a Message
 * @hidden
 */
function eventFromMessage(
  stackParser,
  message,
  // eslint-disable-next-line deprecation/deprecation
  level = 'info',
  hint,
  attachStacktrace,
) {
  const syntheticException = (hint && hint.syntheticException) || undefined;
  const event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
  event.level = level;
  if (hint && hint.event_id) {
    event.event_id = hint.event_id;
  }
  return resolvedSyncPromise(event);
}

/**
 * @hidden
 */
function eventFromUnknownInput(
  stackParser,
  exception,
  syntheticException,
  attachStacktrace,
  isUnhandledRejection,
) {
  let event;

  if (isErrorEvent(exception ) && (exception ).error) {
    // If it is an ErrorEvent with `error` property, extract it to get actual Error
    const errorEvent = exception ;
    return eventFromError(stackParser, errorEvent.error );
  }

  // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name
  // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be
  // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.
  //
  // https://developer.mozilla.org/en-US/docs/Web/API/DOMError
  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException
  // https://webidl.spec.whatwg.org/#es-DOMException-specialness
  if (isDOMError(exception ) || isDOMException(exception )) {
    const domException = exception ;

    if ('stack' in (exception )) {
      event = eventFromError(stackParser, exception );
    } else {
      const name = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');
      const message = domException.message ? `${name}: ${domException.message}` : name;
      event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
      addExceptionTypeValue(event, message);
    }
    if ('code' in domException) {
      event.tags = { ...event.tags, 'DOMException.code': `${domException.code}` };
    }

    return event;
  }
  if (isError$1(exception)) {
    // we have a real Error object, do nothing
    return eventFromError(stackParser, exception);
  }
  if (isPlainObject$1(exception) || isEvent(exception)) {
    // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize
    // it manually. This will allow us to group events based on top-level keys which is much better than creating a new
    // group on any key/value change.
    const objectException = exception ;
    event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);
    addExceptionMechanism(event, {
      synthetic: true,
    });
    return event;
  }

  // If none of previous checks were valid, then it means that it's not:
  // - an instance of DOMError
  // - an instance of DOMException
  // - an instance of Event
  // - an instance of Error
  // - a valid ErrorEvent (one with an error property)
  // - a plain Object
  //
  // So bail out and capture it as a simple message:
  event = eventFromString(stackParser, exception , syntheticException, attachStacktrace);
  addExceptionTypeValue(event, `${exception}`, undefined);
  addExceptionMechanism(event, {
    synthetic: true,
  });

  return event;
}

/**
 * @hidden
 */
function eventFromString(
  stackParser,
  input,
  syntheticException,
  attachStacktrace,
) {
  const event = {
    message: input,
  };

  if (attachStacktrace && syntheticException) {
    const frames = parseStackFrames(stackParser, syntheticException);
    if (frames.length) {
      event.exception = {
        values: [{ value: input, stacktrace: { frames } }],
      };
    }
  }

  return event;
}

/* eslint-disable @typescript-eslint/no-unsafe-member-access */

/** JSDoc */

const BREADCRUMB_INTEGRATION_ID = 'Breadcrumbs';

/**
 * Default Breadcrumbs instrumentations
 * TODO: Deprecated - with v6, this will be renamed to `Instrument`
 */
class Breadcrumbs  {
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = BREADCRUMB_INTEGRATION_ID;}

  /**
   * @inheritDoc
   */
   __init() {this.name = Breadcrumbs.id;}

  /**
   * Options of the breadcrumbs integration.
   */
  // This field is public, because we use it in the browser client to check if the `sentry` option is enabled.

  /**
   * @inheritDoc
   */
   constructor(options) {;Breadcrumbs.prototype.__init.call(this);
    this.options = {
      console: true,
      dom: true,
      fetch: true,
      history: true,
      sentry: true,
      xhr: true,
      ...options,
    };
  }

  /**
   * Instrument browser built-ins w/ breadcrumb capturing
   *  - Console API
   *  - DOM API (click/typing)
   *  - XMLHttpRequest API
   *  - Fetch API
   *  - History API
   */
   setupOnce() {
    if (this.options.console) {
      addInstrumentationHandler('console', _consoleBreadcrumb);
    }
    if (this.options.dom) {
      addInstrumentationHandler('dom', _domBreadcrumb(this.options.dom));
    }
    if (this.options.xhr) {
      addInstrumentationHandler('xhr', _xhrBreadcrumb);
    }
    if (this.options.fetch) {
      addInstrumentationHandler('fetch', _fetchBreadcrumb);
    }
    if (this.options.history) {
      addInstrumentationHandler('history', _historyBreadcrumb);
    }
  }
} Breadcrumbs.__initStatic();

/**
 * A HOC that creaes a function that creates breadcrumbs from DOM API calls.
 * This is a HOC so that we get access to dom options in the closure.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _domBreadcrumb(dom) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function _innerDomBreadcrumb(handlerData) {
    let target;
    let keyAttrs = typeof dom === 'object' ? dom.serializeAttribute : undefined;

    if (typeof keyAttrs === 'string') {
      keyAttrs = [keyAttrs];
    }

    // Accessing event.target can throw (see getsentry/raven-js#838, #768)
    try {
      target = handlerData.event.target
        ? htmlTreeAsString(handlerData.event.target , keyAttrs)
        : htmlTreeAsString(handlerData.event , keyAttrs);
    } catch (e) {
      target = '<unknown>';
    }

    if (target.length === 0) {
      return;
    }

    getCurrentHub().addBreadcrumb(
      {
        category: `ui.${handlerData.name}`,
        message: target,
      },
      {
        event: handlerData.event,
        name: handlerData.name,
        global: handlerData.global,
      },
    );
  }

  return _innerDomBreadcrumb;
}

/**
 * Creates breadcrumbs from console API calls
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _consoleBreadcrumb(handlerData) {
  // This is a hack to fix a Vue3-specific bug that causes an infinite loop of
  // console warnings. This happens when a Vue template is rendered with
  // an undeclared variable, which we try to stringify, ultimately causing
  // Vue to issue another warning which repeats indefinitely.
  // see: https://github.com/getsentry/sentry-javascript/pull/6010
  // see: https://github.com/getsentry/sentry-javascript/issues/5916
  for (let i = 0; i < handlerData.args.length; i++) {
    if (handlerData.args[i] === 'ref=Ref<') {
      handlerData.args[i + 1] = 'viewRef';
      break;
    }
  }
  const breadcrumb = {
    category: 'console',
    data: {
      arguments: handlerData.args,
      logger: 'console',
    },
    level: severityLevelFromString(handlerData.level),
    message: safeJoin(handlerData.args, ' '),
  };

  if (handlerData.level === 'assert') {
    if (handlerData.args[0] === false) {
      breadcrumb.message = `Assertion failed: ${safeJoin(handlerData.args.slice(1), ' ') || 'console.assert'}`;
      breadcrumb.data.arguments = handlerData.args.slice(1);
    } else {
      // Don't capture a breadcrumb for passed assertions
      return;
    }
  }

  getCurrentHub().addBreadcrumb(breadcrumb, {
    input: handlerData.args,
    level: handlerData.level,
  });
}

/**
 * Creates breadcrumbs from XHR API calls
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _xhrBreadcrumb(handlerData) {
  if (handlerData.endTimestamp) {
    // We only capture complete, non-sentry requests
    if (handlerData.xhr.__sentry_own_request__) {
      return;
    }

    const { method, url, status_code, body } = handlerData.xhr.__sentry_xhr__ || {};

    getCurrentHub().addBreadcrumb(
      {
        category: 'xhr',
        data: {
          method,
          url,
          status_code,
        },
        type: 'http',
      },
      {
        xhr: handlerData.xhr,
        input: body,
      },
    );

    return;
  }
}

/**
 * Creates breadcrumbs from fetch API calls
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _fetchBreadcrumb(handlerData) {
  // We only capture complete fetch requests
  if (!handlerData.endTimestamp) {
    return;
  }

  if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === 'POST') {
    // We will not create breadcrumbs for fetch requests that contain `sentry_key` (internal sentry requests)
    return;
  }

  if (handlerData.error) {
    getCurrentHub().addBreadcrumb(
      {
        category: 'fetch',
        data: handlerData.fetchData,
        level: 'error',
        type: 'http',
      },
      {
        data: handlerData.error,
        input: handlerData.args,
      },
    );
  } else {
    getCurrentHub().addBreadcrumb(
      {
        category: 'fetch',
        data: {
          ...handlerData.fetchData,
          status_code: handlerData.response.status,
        },
        type: 'http',
      },
      {
        input: handlerData.args,
        response: handlerData.response,
      },
    );
  }
}

/**
 * Creates breadcrumbs from history API calls
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _historyBreadcrumb(handlerData) {
  let from = handlerData.from;
  let to = handlerData.to;
  const parsedLoc = parseUrl(WINDOW.location.href);
  let parsedFrom = parseUrl(from);
  const parsedTo = parseUrl(to);

  // Initial pushState doesn't provide `from` information
  if (!parsedFrom.path) {
    parsedFrom = parsedLoc;
  }

  // Use only the path component of the URL if the URL matches the current
  // document (almost all the time when using pushState)
  if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
    to = parsedTo.relative;
  }
  if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
    from = parsedFrom.relative;
  }

  getCurrentHub().addBreadcrumb({
    category: 'navigation',
    data: {
      from,
      to,
    },
  });
}

/**
 * The Sentry Browser SDK Client.
 *
 * @see BrowserOptions for documentation on configuration options.
 * @see SentryClient for usage documentation.
 */
class BrowserClient extends BaseClient {
  /**
   * Creates a new Browser SDK instance.
   *
   * @param options Configuration options for this SDK.
   */
   constructor(options) {
    options._metadata = options._metadata || {};
    options._metadata.sdk = options._metadata.sdk || {
      name: 'sentry.javascript.browser',
      packages: [
        {
          name: 'npm:@sentry/browser',
          version: SDK_VERSION,
        },
      ],
      version: SDK_VERSION,
    };

    super(options);

    if (options.sendClientReports && WINDOW.document) {
      WINDOW.document.addEventListener('visibilitychange', () => {
        if (WINDOW.document.visibilityState === 'hidden') {
          this._flushOutcomes();
        }
      });
    }
  }

  /**
   * @inheritDoc
   */
   eventFromException(exception, hint) {
    return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);
  }

  /**
   * @inheritDoc
   */
   eventFromMessage(
    message,
    // eslint-disable-next-line deprecation/deprecation
    level = 'info',
    hint,
  ) {
    return eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace);
  }

  /**
   * @inheritDoc
   */
   sendEvent(event, hint) {
    // We only want to add the sentry event breadcrumb when the user has the breadcrumb integration installed and
    // activated its `sentry` option.
    // We also do not want to use the `Breadcrumbs` class here directly, because we do not want it to be included in
    // bundles, if it is not used by the SDK.
    // This all sadly is a bit ugly, but we currently don't have a "pre-send" hook on the integrations so we do it this
    // way for now.
    const breadcrumbIntegration = this.getIntegrationById(BREADCRUMB_INTEGRATION_ID) ;
    if (
      breadcrumbIntegration &&
      // We check for definedness of `options`, even though it is not strictly necessary, because that access to
      // `.sentry` below does not throw, in case users provided their own integration with id "Breadcrumbs" that does
      // not have an`options` field
      breadcrumbIntegration.options &&
      breadcrumbIntegration.options.sentry
    ) {
      getCurrentHub().addBreadcrumb(
        {
          category: `sentry.${event.type === 'transaction' ? 'transaction' : 'event'}`,
          event_id: event.event_id,
          level: event.level,
          message: getEventDescription(event),
        },
        {
          event,
        },
      );
    }

    super.sendEvent(event, hint);
  }

  /**
   * @inheritDoc
   */
   _prepareEvent(event, hint, scope) {
    event.platform = event.platform || 'javascript';
    return super._prepareEvent(event, hint, scope);
  }

  /**
   * Sends client reports as an envelope.
   */
   _flushOutcomes() {
    const outcomes = this._clearOutcomes();

    if (outcomes.length === 0) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('No outcomes to send');
      return;
    }

    if (!this._dsn) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('No dsn provided, will not send outcomes');
      return;
    }

    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Sending outcomes:', outcomes);

    const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, this._options);
    const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));

    try {
      const isRealNavigator = Object.prototype.toString.call(WINDOW && WINDOW.navigator) === '[object Navigator]';
      const hasSendBeacon = isRealNavigator && typeof WINDOW.navigator.sendBeacon === 'function';
      // Make sure beacon is not used if user configures custom transport options
      if (hasSendBeacon && !this._options.transportOptions) {
        // Prevent illegal invocations - https://xgwang.me/posts/you-may-not-know-beacon/#it-may-throw-error%2C-be-sure-to-catch
        const sendBeacon = WINDOW.navigator.sendBeacon.bind(WINDOW.navigator);
        sendBeacon(url, serializeEnvelope(envelope));
      } else {
        // If beacon is not supported or if they are using the tunnel option
        // use our regular transport to send client reports to Sentry.
        this._sendEnvelope(envelope);
      }
    } catch (e) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error(e);
    }
  }
}

let cachedFetchImpl = undefined;

/**
 * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.
 * Whenever someone wraps the Fetch API and returns the wrong promise chain,
 * this chain becomes orphaned and there is no possible way to capture it's rejections
 * other than allowing it bubble up to this very handler. eg.
 *
 * const f = window.fetch;
 * window.fetch = function () {
 *   const p = f.apply(this, arguments);
 *
 *   p.then(function() {
 *     console.log('hi.');
 *   });
 *
 *   return p;
 * }
 *
 * `p.then(function () { ... })` is producing a completely separate promise chain,
 * however, what's returned is `p` - the result of original `fetch` call.
 *
 * This mean, that whenever we use the Fetch API to send our own requests, _and_
 * some ad-blocker blocks it, this orphaned chain will _always_ reject,
 * effectively causing another event to be captured.
 * This makes a whole process become an infinite loop, which we need to somehow
 * deal with, and break it in one way or another.
 *
 * To deal with this issue, we are making sure that we _always_ use the real
 * browser Fetch API, instead of relying on what `window.fetch` exposes.
 * The only downside to this would be missing our own requests as breadcrumbs,
 * but because we are already not doing this, it should be just fine.
 *
 * Possible failed fetch error messages per-browser:
 *
 * Chrome:  Failed to fetch
 * Edge:    Failed to Fetch
 * Firefox: NetworkError when attempting to fetch resource
 * Safari:  resource blocked by content blocker
 */
function getNativeFetchImplementation() {
  if (cachedFetchImpl) {
    return cachedFetchImpl;
  }

  /* eslint-disable @typescript-eslint/unbound-method */

  // Fast path to avoid DOM I/O
  if (isNativeFetch(WINDOW.fetch)) {
    return (cachedFetchImpl = WINDOW.fetch.bind(WINDOW));
  }

  const document = WINDOW.document;
  let fetchImpl = WINDOW.fetch;
  // eslint-disable-next-line deprecation/deprecation
  if (document && typeof document.createElement === 'function') {
    try {
      const sandbox = document.createElement('iframe');
      sandbox.hidden = true;
      document.head.appendChild(sandbox);
      const contentWindow = sandbox.contentWindow;
      if (contentWindow && contentWindow.fetch) {
        fetchImpl = contentWindow.fetch;
      }
      document.head.removeChild(sandbox);
    } catch (e) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
        logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);
    }
  }

  return (cachedFetchImpl = fetchImpl.bind(WINDOW));
  /* eslint-enable @typescript-eslint/unbound-method */
}

/** Clears cached fetch impl */
function clearCachedFetchImplementation() {
  cachedFetchImpl = undefined;
}

/**
 * Creates a Transport that uses the Fetch API to send events to Sentry.
 */
function makeFetchTransport(
  options,
  nativeFetch = getNativeFetchImplementation(),
) {
  function makeRequest(request) {
    const requestOptions = {
      body: request.body,
      method: 'POST',
      referrerPolicy: 'origin',
      headers: options.headers,
      // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
      // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
      // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).
      // Gotchas:
      // - `keepalive` isn't supported by Firefox
      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch), a request with `keepalive: true`
      //   and a content length of > 64 kibibytes returns a network error. We will therefore only activate the flag when
      //   we're below that limit.
      keepalive: request.body.length <= 65536,
      ...options.fetchOptions,
    };

    try {
      return nativeFetch(options.url, requestOptions).then(response => ({
        statusCode: response.status,
        headers: {
          'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),
          'retry-after': response.headers.get('Retry-After'),
        },
      }));
    } catch (e) {
      clearCachedFetchImplementation();
      return rejectedSyncPromise(e);
    }
  }

  return createTransport(options, makeRequest);
}

/**
 * The DONE ready state for XmlHttpRequest
 *
 * Defining it here as a constant b/c XMLHttpRequest.DONE is not always defined
 * (e.g. during testing, it is `undefined`)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState}
 */
const XHR_READYSTATE_DONE = 4;

/**
 * Creates a Transport that uses the XMLHttpRequest API to send events to Sentry.
 */
function makeXHRTransport(options) {
  function makeRequest(request) {
    return new SyncPromise((resolve, reject) => {
      const xhr = new XMLHttpRequest();

      xhr.onerror = reject;

      xhr.onreadystatechange = () => {
        if (xhr.readyState === XHR_READYSTATE_DONE) {
          resolve({
            statusCode: xhr.status,
            headers: {
              'x-sentry-rate-limits': xhr.getResponseHeader('X-Sentry-Rate-Limits'),
              'retry-after': xhr.getResponseHeader('Retry-After'),
            },
          });
        }
      };

      xhr.open('POST', options.url);

      for (const header in options.headers) {
        if (Object.prototype.hasOwnProperty.call(options.headers, header)) {
          xhr.setRequestHeader(header, options.headers[header]);
        }
      }

      xhr.send(request.body);
    });
  }

  return createTransport(options, makeRequest);
}

// global reference to slice
const UNKNOWN_FUNCTION = '?';

const OPERA10_PRIORITY = 10;
const OPERA11_PRIORITY = 20;
const CHROME_PRIORITY = 30;
const WINJS_PRIORITY = 40;
const GECKO_PRIORITY = 50;

function createFrame(filename, func, lineno, colno) {
  const frame = {
    filename,
    function: func,
    // All browser frames are considered in_app
    in_app: true,
  };

  if (lineno !== undefined) {
    frame.lineno = lineno;
  }

  if (colno !== undefined) {
    frame.colno = colno;
  }

  return frame;
}

// Chromium based browsers: Chrome, Brave, new Opera, new Edge
const chromeRegex =
  /^\s*at (?:(.*\).*?|.*?) ?\((?:address at )?)?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
const chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;

const chrome = line => {
  const parts = chromeRegex.exec(line);

  if (parts) {
    const isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

    if (isEval) {
      const subMatch = chromeEvalRegex.exec(parts[2]);

      if (subMatch) {
        // throw out eval line/column and use top-most line/column number
        parts[2] = subMatch[1]; // url
        parts[3] = subMatch[2]; // line
        parts[4] = subMatch[3]; // column
      }
    }

    // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now
    // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)
    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);

    return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);
  }

  return;
};

const chromeStackLineParser = [CHROME_PRIORITY, chrome];

// gecko regex: `(?:bundle|\d+\.js)`: `bundle` is for react native, `\d+\.js` also but specifically for ram bundles because it
// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js
// We need this specific case for now because we want no other regex to match.
const geckoREgex =
  /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|safari-extension|safari-web-extension|capacitor)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
const geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

const gecko = line => {
  const parts = geckoREgex.exec(line);

  if (parts) {
    const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
    if (isEval) {
      const subMatch = geckoEvalRegex.exec(parts[3]);

      if (subMatch) {
        // throw out eval line/column and use top-most line number
        parts[1] = parts[1] || 'eval';
        parts[3] = subMatch[1];
        parts[4] = subMatch[2];
        parts[5] = ''; // no column when eval
      }
    }

    let filename = parts[3];
    let func = parts[1] || UNKNOWN_FUNCTION;
    [func, filename] = extractSafariExtensionDetails(func, filename);

    return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);
  }

  return;
};

const geckoStackLineParser = [GECKO_PRIORITY, gecko];

const winjsRegex =
  /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;

const winjs = line => {
  const parts = winjsRegex.exec(line);

  return parts
    ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : undefined)
    : undefined;
};

const winjsStackLineParser = [WINJS_PRIORITY, winjs];

const opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i;

const opera10 = line => {
  const parts = opera10Regex.exec(line);
  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : undefined;
};

const opera10StackLineParser = [OPERA10_PRIORITY, opera10];

const opera11Regex =
  / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\(.*\))? in (.*):\s*$/i;

const opera11 = line => {
  const parts = opera11Regex.exec(line);
  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : undefined;
};

const opera11StackLineParser = [OPERA11_PRIORITY, opera11];

const defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser];

const defaultStackParser = createStackParser(...defaultStackLineParsers);

/**
 * Safari web extensions, starting version unknown, can produce "frames-only" stacktraces.
 * What it means, is that instead of format like:
 *
 * Error: wat
 *   at function@url:row:col
 *   at function@url:row:col
 *   at function@url:row:col
 *
 * it produces something like:
 *
 *   function@url:row:col
 *   function@url:row:col
 *   function@url:row:col
 *
 * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.
 * This function is extracted so that we can use it in both places without duplicating the logic.
 * Unfortunately "just" changing RegExp is too complicated now and making it pass all tests
 * and fix this case seems like an impossible, or at least way too time-consuming task.
 */
const extractSafariExtensionDetails = (func, filename) => {
  const isSafariExtension = func.indexOf('safari-extension') !== -1;
  const isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;

  return isSafariExtension || isSafariWebExtension
    ? [
        func.indexOf('@') !== -1 ? func.split('@')[0] : UNKNOWN_FUNCTION,
        isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`,
      ]
    : [func, filename];
};

/* eslint-disable @typescript-eslint/no-unsafe-member-access */

/** Global handlers */
class GlobalHandlers  {
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'GlobalHandlers';}

  /**
   * @inheritDoc
   */
   __init() {this.name = GlobalHandlers.id;}

  /** JSDoc */

  /**
   * Stores references functions to installing handlers. Will set to undefined
   * after they have been run so that they are not used twice.
   */
   __init2() {this._installFunc = {
    onerror: _installGlobalOnErrorHandler,
    onunhandledrejection: _installGlobalOnUnhandledRejectionHandler,
  };}

  /** JSDoc */
   constructor(options) {;GlobalHandlers.prototype.__init.call(this);GlobalHandlers.prototype.__init2.call(this);
    this._options = {
      onerror: true,
      onunhandledrejection: true,
      ...options,
    };
  }
  /**
   * @inheritDoc
   */
   setupOnce() {
    Error.stackTraceLimit = 50;
    const options = this._options;

    // We can disable guard-for-in as we construct the options object above + do checks against
    // `this._installFunc` for the property.
    // eslint-disable-next-line guard-for-in
    for (const key in options) {
      const installFunc = this._installFunc[key ];
      if (installFunc && options[key ]) {
        globalHandlerLog(key);
        installFunc();
        this._installFunc[key ] = undefined;
      }
    }
  }
} GlobalHandlers.__initStatic();

/** JSDoc */
function _installGlobalOnErrorHandler() {
  addInstrumentationHandler(
    'error',
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (data) => {
      const [hub, stackParser, attachStacktrace] = getHubAndOptions();
      if (!hub.getIntegration(GlobalHandlers)) {
        return;
      }
      const { msg, url, line, column, error } = data;
      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {
        return;
      }

      const event =
        error === undefined && isString(msg)
          ? _eventFromIncompleteOnError(msg, url, line, column)
          : _enhanceEventWithInitialFrame(
              eventFromUnknownInput(stackParser, error || msg, undefined, attachStacktrace, false),
              url,
              line,
              column,
            );

      event.level = 'error';

      addMechanismAndCapture(hub, error, event, 'onerror');
    },
  );
}

/** JSDoc */
function _installGlobalOnUnhandledRejectionHandler() {
  addInstrumentationHandler(
    'unhandledrejection',
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (e) => {
      const [hub, stackParser, attachStacktrace] = getHubAndOptions();
      if (!hub.getIntegration(GlobalHandlers)) {
        return;
      }
      let error = e;

      // dig the object of the rejection out of known event types
      try {
        // PromiseRejectionEvents store the object of the rejection under 'reason'
        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent
        if ('reason' in e) {
          error = e.reason;
        }
        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents
        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into
        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec
        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and
        // https://github.com/getsentry/sentry-javascript/issues/2380
        else if ('detail' in e && 'reason' in e.detail) {
          error = e.detail.reason;
        }
      } catch (_oO) {
        // no-empty
      }

      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {
        return true;
      }

      const event = isPrimitive(error)
        ? _eventFromRejectionWithPrimitive(error)
        : eventFromUnknownInput(stackParser, error, undefined, attachStacktrace, true);

      event.level = 'error';

      addMechanismAndCapture(hub, error, event, 'onunhandledrejection');
      return;
    },
  );
}

/**
 * Create an event from a promise rejection where the `reason` is a primitive.
 *
 * @param reason: The `reason` property of the promise rejection
 * @returns An Event object with an appropriate `exception` value
 */
function _eventFromRejectionWithPrimitive(reason) {
  return {
    exception: {
      values: [
        {
          type: 'UnhandledRejection',
          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
          value: `Non-Error promise rejection captured with value: ${String(reason)}`,
        },
      ],
    },
  };
}

/**
 * This function creates a stack from an old, error-less onerror handler.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _eventFromIncompleteOnError(msg, url, line, column) {
  const ERROR_TYPES_RE =
    /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;

  // If 'message' is ErrorEvent, get real message from inside
  let message = isErrorEvent(msg) ? msg.message : msg;
  let name = 'Error';

  const groups = message.match(ERROR_TYPES_RE);
  if (groups) {
    name = groups[1];
    message = groups[2];
  }

  const event = {
    exception: {
      values: [
        {
          type: name,
          value: message,
        },
      ],
    },
  };

  return _enhanceEventWithInitialFrame(event, url, line, column);
}

/** JSDoc */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _enhanceEventWithInitialFrame(event, url, line, column) {
  // event.exception
  const e = (event.exception = event.exception || {});
  // event.exception.values
  const ev = (e.values = e.values || []);
  // event.exception.values[0]
  const ev0 = (ev[0] = ev[0] || {});
  // event.exception.values[0].stacktrace
  const ev0s = (ev0.stacktrace = ev0.stacktrace || {});
  // event.exception.values[0].stacktrace.frames
  const ev0sf = (ev0s.frames = ev0s.frames || []);

  const colno = isNaN(parseInt(column, 10)) ? undefined : column;
  const lineno = isNaN(parseInt(line, 10)) ? undefined : line;
  const filename = isString(url) && url.length > 0 ? url : getLocationHref();

  // event.exception.values[0].stacktrace.frames
  if (ev0sf.length === 0) {
    ev0sf.push({
      colno,
      filename,
      function: '?',
      in_app: true,
      lineno,
    });
  }

  return event;
}

function globalHandlerLog(type) {
  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Global Handler attached: ${type}`);
}

function addMechanismAndCapture(hub, error, event, type) {
  addExceptionMechanism(event, {
    handled: false,
    type,
  });
  hub.captureEvent(event, {
    originalException: error,
  });
}

function getHubAndOptions() {
  const hub = getCurrentHub();
  const client = hub.getClient();
  const options = (client && client.getOptions()) || {
    stackParser: () => [],
    attachStacktrace: false,
  };
  return [hub, options.stackParser, options.attachStacktrace];
}

const DEFAULT_EVENT_TARGET = [
  'EventTarget',
  'Window',
  'Node',
  'ApplicationCache',
  'AudioTrackList',
  'ChannelMergerNode',
  'CryptoOperation',
  'EventSource',
  'FileReader',
  'HTMLUnknownElement',
  'IDBDatabase',
  'IDBRequest',
  'IDBTransaction',
  'KeyOperation',
  'MediaController',
  'MessagePort',
  'ModalWindow',
  'Notification',
  'SVGElementInstance',
  'Screen',
  'TextTrack',
  'TextTrackCue',
  'TextTrackList',
  'WebSocket',
  'WebSocketWorker',
  'Worker',
  'XMLHttpRequest',
  'XMLHttpRequestEventTarget',
  'XMLHttpRequestUpload',
];

/** Wrap timer functions and event targets to catch errors and provide better meta data */
class TryCatch  {
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'TryCatch';}

  /**
   * @inheritDoc
   */
   __init() {this.name = TryCatch.id;}

  /** JSDoc */

  /**
   * @inheritDoc
   */
   constructor(options) {;TryCatch.prototype.__init.call(this);
    this._options = {
      XMLHttpRequest: true,
      eventTarget: true,
      requestAnimationFrame: true,
      setInterval: true,
      setTimeout: true,
      ...options,
    };
  }

  /**
   * Wrap timer functions and event targets to catch errors
   * and provide better metadata.
   */
   setupOnce() {
    if (this._options.setTimeout) {
      fill(WINDOW, 'setTimeout', _wrapTimeFunction);
    }

    if (this._options.setInterval) {
      fill(WINDOW, 'setInterval', _wrapTimeFunction);
    }

    if (this._options.requestAnimationFrame) {
      fill(WINDOW, 'requestAnimationFrame', _wrapRAF);
    }

    if (this._options.XMLHttpRequest && 'XMLHttpRequest' in WINDOW) {
      fill(XMLHttpRequest.prototype, 'send', _wrapXHR);
    }

    const eventTargetOption = this._options.eventTarget;
    if (eventTargetOption) {
      const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
      eventTarget.forEach(_wrapEventTarget);
    }
  }
} TryCatch.__initStatic();

/** JSDoc */
function _wrapTimeFunction(original) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return function ( ...args) {
    const originalCallback = args[0];
    args[0] = wrap$1(originalCallback, {
      mechanism: {
        data: { function: getFunctionName(original) },
        handled: true,
        type: 'instrument',
      },
    });
    return original.apply(this, args);
  };
}

/** JSDoc */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _wrapRAF(original) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return function ( callback) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    return original.apply(this, [
      wrap$1(callback, {
        mechanism: {
          data: {
            function: 'requestAnimationFrame',
            handler: getFunctionName(original),
          },
          handled: true,
          type: 'instrument',
        },
      }),
    ]);
  };
}

/** JSDoc */
function _wrapXHR(originalSend) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return function ( ...args) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const xhr = this;
    const xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];

    xmlHttpRequestProps.forEach(prop => {
      if (prop in xhr && typeof xhr[prop] === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        fill(xhr, prop, function (original) {
          const wrapOptions = {
            mechanism: {
              data: {
                function: prop,
                handler: getFunctionName(original),
              },
              handled: true,
              type: 'instrument',
            },
          };

          // If Instrument integration has been called before TryCatch, get the name of original function
          const originalFunction = getOriginalFunction(original);
          if (originalFunction) {
            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);
          }

          // Otherwise wrap directly
          return wrap$1(original, wrapOptions);
        });
      }
    });

    return originalSend.apply(this, args);
  };
}

/** JSDoc */
function _wrapEventTarget(target) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const globalObject = WINDOW ;
  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
  const proto = globalObject[target] && globalObject[target].prototype;

  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins
  if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {
    return;
  }

  fill(proto, 'addEventListener', function (original)

 {
    return function (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any

      eventName,
      fn,
      options,
    ) {
      try {
        if (typeof fn.handleEvent === 'function') {
          // ESlint disable explanation:
          //  First, it is generally safe to call `wrap` with an unbound function. Furthermore, using `.bind()` would
          //  introduce a bug here, because bind returns a new function that doesn't have our
          //  flags(like __sentry_original__) attached. `wrap` checks for those flags to avoid unnecessary wrapping.
          //  Without those flags, every call to addEventListener wraps the function again, causing a memory leak.
          // eslint-disable-next-line @typescript-eslint/unbound-method
          fn.handleEvent = wrap$1(fn.handleEvent, {
            mechanism: {
              data: {
                function: 'handleEvent',
                handler: getFunctionName(fn),
                target,
              },
              handled: true,
              type: 'instrument',
            },
          });
        }
      } catch (err) {
        // can sometimes get 'Permission denied to access property "handle Event'
      }

      return original.apply(this, [
        eventName,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        wrap$1(fn , {
          mechanism: {
            data: {
              function: 'addEventListener',
              handler: getFunctionName(fn),
              target,
            },
            handled: true,
            type: 'instrument',
          },
        }),
        options,
      ]);
    };
  });

  fill(
    proto,
    'removeEventListener',
    function (
      originalRemoveEventListener,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) {
      return function (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any

        eventName,
        fn,
        options,
      ) {
        /**
         * There are 2 possible scenarios here:
         *
         * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified
         * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function
         * as a pass-through, and call original `removeEventListener` with it.
         *
         * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using
         * our wrapped version of `addEventListener`, which internally calls `wrap` helper.
         * This helper "wraps" whole callback inside a try/catch statement, and attached appropriate metadata to it,
         * in order for us to make a distinction between wrapped/non-wrapped functions possible.
         * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.
         *
         * When someone adds a handler prior to initialization, and then do it again, but after,
         * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible
         * to get rid of the initial handler and it'd stick there forever.
         */
        const wrappedEventHandler = fn ;
        try {
          const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;
          if (originalEventHandler) {
            originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
          }
        } catch (e) {
          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments
        }
        return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
      };
    },
  );
}

const DEFAULT_KEY = 'cause';
const DEFAULT_LIMIT = 5;

/** Adds SDK info to an event. */
class LinkedErrors  {
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'LinkedErrors';}

  /**
   * @inheritDoc
   */
    __init() {this.name = LinkedErrors.id;}

  /**
   * @inheritDoc
   */

  /**
   * @inheritDoc
   */

  /**
   * @inheritDoc
   */
   constructor(options = {}) {;LinkedErrors.prototype.__init.call(this);
    this._key = options.key || DEFAULT_KEY;
    this._limit = options.limit || DEFAULT_LIMIT;
  }

  /**
   * @inheritDoc
   */
   setupOnce() {
    const client = getCurrentHub().getClient();
    if (!client) {
      return;
    }
    addGlobalEventProcessor((event, hint) => {
      const self = getCurrentHub().getIntegration(LinkedErrors);
      return self ? _handler(client.getOptions().stackParser, self._key, self._limit, event, hint) : event;
    });
  }
} LinkedErrors.__initStatic();

/**
 * @inheritDoc
 */
function _handler(
  parser,
  key,
  limit,
  event,
  hint,
) {
  if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
    return event;
  }
  const linkedErrors = _walkErrorTree(parser, limit, hint.originalException , key);
  event.exception.values = [...linkedErrors, ...event.exception.values];
  return event;
}

/**
 * JSDOC
 */
function _walkErrorTree(
  parser,
  limit,
  error,
  key,
  stack = [],
) {
  if (!isInstanceOf(error[key], Error) || stack.length + 1 >= limit) {
    return stack;
  }
  const exception = exceptionFromError(parser, error[key]);
  return _walkErrorTree(parser, limit, error[key], key, [exception, ...stack]);
}

/** HttpContext integration collects information about HTTP request headers */
class HttpContext  {constructor() { HttpContext.prototype.__init.call(this); }
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'HttpContext';}

  /**
   * @inheritDoc
   */
   __init() {this.name = HttpContext.id;}

  /**
   * @inheritDoc
   */
   setupOnce() {
    addGlobalEventProcessor((event) => {
      if (getCurrentHub().getIntegration(HttpContext)) {
        // if none of the information we want exists, don't bother
        if (!WINDOW.navigator && !WINDOW.location && !WINDOW.document) {
          return event;
        }

        // grab as much info as exists and add it to the event
        const url = (event.request && event.request.url) || (WINDOW.location && WINDOW.location.href);
        const { referrer } = WINDOW.document || {};
        const { userAgent } = WINDOW.navigator || {};

        const headers = {
          ...(event.request && event.request.headers),
          ...(referrer && { Referer: referrer }),
          ...(userAgent && { 'User-Agent': userAgent }),
        };
        const request = { ...(url && { url }), headers };

        return { ...event, request };
      }
      return event;
    });
  }
} HttpContext.__initStatic();

/** Deduplication filter */
class Dedupe  {constructor() { Dedupe.prototype.__init.call(this); }
  /**
   * @inheritDoc
   */
   static __initStatic() {this.id = 'Dedupe';}

  /**
   * @inheritDoc
   */
   __init() {this.name = Dedupe.id;}

  /**
   * @inheritDoc
   */

  /**
   * @inheritDoc
   */
   setupOnce(addGlobalEventProcessor, getCurrentHub) {
    const eventProcessor = currentEvent => {
      const self = getCurrentHub().getIntegration(Dedupe);
      if (self) {
        // Juuust in case something goes wrong
        try {
          if (_shouldDropEvent(currentEvent, self._previousEvent)) {
            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Event dropped due to being a duplicate of previously captured event.');
            return null;
          }
        } catch (_oO) {
          return (self._previousEvent = currentEvent);
        }

        return (self._previousEvent = currentEvent);
      }
      return currentEvent;
    };

    eventProcessor.id = this.name;
    addGlobalEventProcessor(eventProcessor);
  }
} Dedupe.__initStatic();

/** JSDoc */
function _shouldDropEvent(currentEvent, previousEvent) {
  if (!previousEvent) {
    return false;
  }

  if (_isSameMessageEvent(currentEvent, previousEvent)) {
    return true;
  }

  if (_isSameExceptionEvent(currentEvent, previousEvent)) {
    return true;
  }

  return false;
}

/** JSDoc */
function _isSameMessageEvent(currentEvent, previousEvent) {
  const currentMessage = currentEvent.message;
  const previousMessage = previousEvent.message;

  // If neither event has a message property, they were both exceptions, so bail out
  if (!currentMessage && !previousMessage) {
    return false;
  }

  // If only one event has a stacktrace, but not the other one, they are not the same
  if ((currentMessage && !previousMessage) || (!currentMessage && previousMessage)) {
    return false;
  }

  if (currentMessage !== previousMessage) {
    return false;
  }

  if (!_isSameFingerprint(currentEvent, previousEvent)) {
    return false;
  }

  if (!_isSameStacktrace(currentEvent, previousEvent)) {
    return false;
  }

  return true;
}

/** JSDoc */
function _isSameExceptionEvent(currentEvent, previousEvent) {
  const previousException = _getExceptionFromEvent(previousEvent);
  const currentException = _getExceptionFromEvent(currentEvent);

  if (!previousException || !currentException) {
    return false;
  }

  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
    return false;
  }

  if (!_isSameFingerprint(currentEvent, previousEvent)) {
    return false;
  }

  if (!_isSameStacktrace(currentEvent, previousEvent)) {
    return false;
  }

  return true;
}

/** JSDoc */
function _isSameStacktrace(currentEvent, previousEvent) {
  let currentFrames = _getFramesFromEvent(currentEvent);
  let previousFrames = _getFramesFromEvent(previousEvent);

  // If neither event has a stacktrace, they are assumed to be the same
  if (!currentFrames && !previousFrames) {
    return true;
  }

  // If only one event has a stacktrace, but not the other one, they are not the same
  if ((currentFrames && !previousFrames) || (!currentFrames && previousFrames)) {
    return false;
  }

  currentFrames = currentFrames ;
  previousFrames = previousFrames ;

  // If number of frames differ, they are not the same
  if (previousFrames.length !== currentFrames.length) {
    return false;
  }

  // Otherwise, compare the two
  for (let i = 0; i < previousFrames.length; i++) {
    const frameA = previousFrames[i];
    const frameB = currentFrames[i];

    if (
      frameA.filename !== frameB.filename ||
      frameA.lineno !== frameB.lineno ||
      frameA.colno !== frameB.colno ||
      frameA.function !== frameB.function
    ) {
      return false;
    }
  }

  return true;
}

/** JSDoc */
function _isSameFingerprint(currentEvent, previousEvent) {
  let currentFingerprint = currentEvent.fingerprint;
  let previousFingerprint = previousEvent.fingerprint;

  // If neither event has a fingerprint, they are assumed to be the same
  if (!currentFingerprint && !previousFingerprint) {
    return true;
  }

  // If only one event has a fingerprint, but not the other one, they are not the same
  if ((currentFingerprint && !previousFingerprint) || (!currentFingerprint && previousFingerprint)) {
    return false;
  }

  currentFingerprint = currentFingerprint ;
  previousFingerprint = previousFingerprint ;

  // Otherwise, compare the two
  try {
    return !!(currentFingerprint.join('') === previousFingerprint.join(''));
  } catch (_oO) {
    return false;
  }
}

/** JSDoc */
function _getExceptionFromEvent(event) {
  return event.exception && event.exception.values && event.exception.values[0];
}

/** JSDoc */
function _getFramesFromEvent(event) {
  const exception = event.exception;

  if (exception) {
    try {
      // @ts-ignore Object could be undefined
      return exception.values[0].stacktrace.frames;
    } catch (_oO) {
      return undefined;
    }
  }
  return undefined;
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  GlobalHandlers: GlobalHandlers,
  TryCatch: TryCatch,
  Breadcrumbs: Breadcrumbs,
  LinkedErrors: LinkedErrors,
  HttpContext: HttpContext,
  Dedupe: Dedupe
});

const defaultIntegrations = [
  new InboundFilters(),
  new FunctionToString(),
  new TryCatch(),
  new Breadcrumbs(),
  new GlobalHandlers(),
  new LinkedErrors(),
  new Dedupe(),
  new HttpContext(),
];

/**
 * The Sentry Browser SDK Client.
 *
 * To use this SDK, call the {@link init} function as early as possible when
 * loading the web page. To set context information or send manual events, use
 * the provided methods.
 *
 * @example
 *
 * ```
 *
 * import { init } from '@sentry/browser';
 *
 * init({
 *   dsn: '__DSN__',
 *   // ...
 * });
 * ```
 *
 * @example
 * ```
 *
 * import { configureScope } from '@sentry/browser';
 * configureScope((scope: Scope) => {
 *   scope.setExtra({ battery: 0.7 });
 *   scope.setTag({ user_mode: 'admin' });
 *   scope.setUser({ id: '4711' });
 * });
 * ```
 *
 * @example
 * ```
 *
 * import { addBreadcrumb } from '@sentry/browser';
 * addBreadcrumb({
 *   message: 'My Breadcrumb',
 *   // ...
 * });
 * ```
 *
 * @example
 *
 * ```
 *
 * import * as Sentry from '@sentry/browser';
 * Sentry.captureMessage('Hello, world!');
 * Sentry.captureException(new Error('Good bye'));
 * Sentry.captureEvent({
 *   message: 'Manual',
 *   stacktrace: [
 *     // ...
 *   ],
 * });
 * ```
 *
 * @see {@link BrowserOptions} for documentation on configuration options.
 */
function init$1(options = {}) {
  if (options.defaultIntegrations === undefined) {
    options.defaultIntegrations = defaultIntegrations;
  }
  if (options.release === undefined) {
    // This supports the variable that sentry-webpack-plugin injects
    if (WINDOW.SENTRY_RELEASE && WINDOW.SENTRY_RELEASE.id) {
      options.release = WINDOW.SENTRY_RELEASE.id;
    }
  }
  if (options.autoSessionTracking === undefined) {
    options.autoSessionTracking = true;
  }
  if (options.sendClientReports === undefined) {
    options.sendClientReports = true;
  }

  const clientOptions = {
    ...options,
    stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
    integrations: getIntegrationsToSetup(options),
    transport: options.transport || (supportsFetch() ? makeFetchTransport : makeXHRTransport),
  };

  initAndBind(BrowserClient, clientOptions);

  if (options.autoSessionTracking) {
    startSessionTracking();
  }
}

/**
 * Present the user with a report dialog.
 *
 * @param options Everything is optional, we try to fetch all info need from the global scope.
 */
function showReportDialog(options = {}, hub = getCurrentHub()) {
  // doesn't work without a document (React Native)
  if (!WINDOW.document) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Global document not defined in showReportDialog call');
    return;
  }

  const { client, scope } = hub.getStackTop();
  const dsn = options.dsn || (client && client.getDsn());
  if (!dsn) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('DSN not configured for showReportDialog call');
    return;
  }

  if (scope) {
    options.user = {
      ...scope.getUser(),
      ...options.user,
    };
  }

  if (!options.eventId) {
    options.eventId = hub.lastEventId();
  }

  const script = WINDOW.document.createElement('script');
  script.async = true;
  script.src = getReportDialogEndpoint(dsn, options);

  if (options.onLoad) {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    script.onload = options.onLoad;
  }

  const injectionPoint = WINDOW.document.head || WINDOW.document.body;
  if (injectionPoint) {
    injectionPoint.appendChild(script);
  } else {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Not injecting report dialog. No injection point found in HTML');
  }
}

/**
 * This is the getter for lastEventId.
 *
 * @returns The last event id of a captured event.
 */
function lastEventId() {
  return getCurrentHub().lastEventId();
}

/**
 * This function is here to be API compatible with the loader.
 * @hidden
 */
function forceLoad() {
  // Noop
}

/**
 * This function is here to be API compatible with the loader.
 * @hidden
 */
function onLoad(callback) {
  callback();
}

/**
 * Call `flush()` on the current client, if there is one. See {@link Client.flush}.
 *
 * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause
 * the client to wait until all events are sent before resolving the promise.
 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
 * doesn't (or if there's no client defined).
 */
function flush(timeout) {
  const client = getCurrentHub().getClient();
  if (client) {
    return client.flush(timeout);
  }
  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Cannot flush events. No client defined.');
  return resolvedSyncPromise(false);
}

/**
 * Call `close()` on the current client, if there is one. See {@link Client.close}.
 *
 * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this
 * parameter will cause the client to wait until all events are sent before disabling itself.
 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
 * doesn't (or if there's no client defined).
 */
function close$1(timeout) {
  const client = getCurrentHub().getClient();
  if (client) {
    return client.close(timeout);
  }
  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Cannot flush events and disable SDK. No client defined.');
  return resolvedSyncPromise(false);
}

/**
 * Wrap code within a try/catch block so the SDK is able to capture errors.
 *
 * @param fn A function to wrap.
 *
 * @returns The result of wrapped function call.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function wrap(fn) {
  return wrap$1(fn)();
}

function startSessionOnHub(hub) {
  hub.startSession({ ignoreDuration: true });
  hub.captureSession();
}

/**
 * Enable automatic Session Tracking for the initial page load.
 */
function startSessionTracking() {
  if (typeof WINDOW.document === 'undefined') {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&
      logger.warn('Session tracking in non-browser environment with @sentry/browser is not supported.');
    return;
  }

  const hub = getCurrentHub();

  // The only way for this to be false is for there to be a version mismatch between @sentry/browser (>= 6.0.0) and
  // @sentry/hub (< 5.27.0). In the simple case, there won't ever be such a mismatch, because the two packages are
  // pinned at the same version in package.json, but there are edge cases where it's possible. See
  // https://github.com/getsentry/sentry-javascript/issues/3207 and
  // https://github.com/getsentry/sentry-javascript/issues/3234 and
  // https://github.com/getsentry/sentry-javascript/issues/3278.
  if (!hub.captureSession) {
    return;
  }

  // The session duration for browser sessions does not track a meaningful
  // concept that can be used as a metric.
  // Automatically captured sessions are akin to page views, and thus we
  // discard their duration.
  startSessionOnHub(hub);

  // We want to create a session for every navigation as well
  addInstrumentationHandler('history', ({ from, to }) => {
    // Don't create an additional session for the initial route or if the location did not change
    if (!(from === undefined || from === to)) {
      startSessionOnHub(getCurrentHub());
    }
  });
}

;

;
;

let windowIntegrations = {};

// This block is needed to add compatibility with the integrations packages when used with a CDN
if (WINDOW.Sentry && WINDOW.Sentry.Integrations) {
  windowIntegrations = WINDOW.Sentry.Integrations;
}

const INTEGRATIONS = {
  ...windowIntegrations,
  ...Integrations,
  ...index,
};

/** @type {Window|null} */
let errorDestination = null;

/**
 * Wrap a callback with an error handler which forwards errors to another frame
 * using {@link sendError}.
 *
 * @template {unknown[]} Args
 * @template Result
 * @param {(...args: Args) => Result} callback
 * @param {string} context - A short message indicating where the error happened.
 * @return {(...args: Args) => Result}
 */
function captureErrors(callback, context) {
  return (...args) => {
    try {
      return callback(...args);
    } catch (err) {
      sendError(err, context);
      throw err;
    }
  };
}

/**
 * @typedef ErrorData
 * @prop {string} message
 * @prop {string} [stack]
 */

/**
 * Return a cloneable representation of an Error.
 *
 * This is needed in browsers that don't support structured-cloning of Error
 * objects, or if the error is not cloneable for some reason.
 *
 * @param {Error|unknown} err
 * @return {ErrorData}
 */
function serializeError(err) {
  if (!(err instanceof Error)) {
    return {
      message: String(err),
      stack: undefined
    };
  }
  return {
    message: err.message,
    stack: err.stack
  };
}

/**
 * Convert error data serialized by {@link serializeError} back into an Error.
 *
 * @param {ErrorData} data
 * @return {Error}
 */
function deserializeError(data) {
  const err = new Error(data.message);
  err.stack = data.stack;
  return err;
}

/**
 * Forward an error to the frame registered with {@link sendErrorsTo}.
 *
 * Errors are delivered on a best-effort basis. If no error handling frame has
 * been registered or the frame is still loading, the error will not be received.
 *
 * Ideally we would use a more robust delivery system which can queue messages
 * until they can be processed (eg. using MessagePort). We use `window.postMessage`
 * for the moment because we are trying to rule out problems with
 * MessageChannel/MessagePort when setting up sidebar <-> host communication.
 *
 * @param {unknown} error
 * @param {string} context - A short message indicating where the error happened.
 */
function sendError(error, context) {
  if (!errorDestination) {
    return;
  }
  const data = {
    type: 'hypothesis-error',
    error: error instanceof Error ? error : serializeError(error),
    context
  };
  try {
    // Try to send the error. If this fails because the browser doesn't support
    // structured cloning of errors, use a fallback.
    try {
      errorDestination.postMessage(data, '*');
    } catch (postErr) {
      if (postErr instanceof DOMException && postErr.name === 'DataCloneError') {
        data.error = serializeError(data.error);
        errorDestination.postMessage(data, '*');
      } else {
        throw postErr;
      }
    }
  } catch (sendErr) {
    console.warn('Unable to report Hypothesis error', sendErr);
  }
}

/**
 * Register a handler for errors sent to the current frame using {@link sendError}
 *
 * @param {(error: unknown, context: string) => void} callback
 * @return {() => void} A function that unregisters the handler
 */
function handleErrorsInFrames(callback) {
  /** @param {MessageEvent} event */
  const handleMessage = event => {
    const {
      data
    } = event;
    if (data && (data === null || data === void 0 ? void 0 : data.type) === 'hypothesis-error') {
      const {
        context,
        error
      } = data;
      callback(error instanceof Error ? error : deserializeError(error), context);
    }
  };
  window.addEventListener('message', handleMessage);
  return () => window.removeEventListener('message', handleMessage);
}

/**
 * Register a destination frame that {@link sendError} should submit errors to.
 *
 * @param {Window|null} destination
 */
function sendErrorsTo(destination) {
  errorDestination = destination;
}

/**
 * @typedef SentryConfig
 * @prop {string} dsn
 * @prop {string} environment
 */

let eventsSent = 0;
const maxEventsToSendPerSession = 5;

/** @type {(() => void)|null} */
let removeFrameErrorHandler = null;
function currentScriptOrigin() {
  // It might be possible to simplify this as `url` appears to be required
  // according to the HTML spec.
  //
  // See https://html.spec.whatwg.org/multipage/webappapis.html#hostgetimportmetaproperties.
  let url = import.meta.url;
  if (!url) {
    return null;
  }
  return new URL(url).origin;
}

/**
 * Initialize the Sentry integration.
 *
 * This will activate Sentry and enable capturing of uncaught errors and
 * unhandled promise rejections.
 *
 * @param {SentryConfig} config
 */
function init(config) {
  const scriptOrigin = currentScriptOrigin();
  const allowUrls = scriptOrigin ? [scriptOrigin] : undefined;
  init$1({
    dsn: config.dsn,
    environment: config.environment,
    // Only report exceptions where the stack trace references a URL that is
    // part of our code. This reduces noise caused by third-party scripts which
    // may be injected by browser extensions.
    //
    // Sentry currently always allows exceptions to bypass this list if no
    // URL can be extracted.
    allowUrls,
    // Ignore various errors due to circumstances outside of our control.
    ignoreErrors: [
    // Ignore network request failures. Some of these ought to be
    // caught and handled better but for now we are suppressing them to
    // improve the signal-to-noise ratio.
    'Network request failed',
    // Standard message prefix for `FetchError` errors

    // Ignore an error that appears to come from CefSharp (embedded Chromium).
    // See https://forum.sentry.io/t/unhandledrejection-non-error-promise-rejection-captured-with-value/14062/20
    'Object Not Found Matching Id'],
    release: '1.0.0-dummy-version',
    // See https://docs.sentry.io/error-reporting/configuration/filtering/?platform=javascript#before-send
    beforeSend: (event, hint) => {
      if (eventsSent >= maxEventsToSendPerSession) {
        // Cap the number of events that any client instance will send, to
        // reduce the impact on our Sentry event quotas.
        //
        // Sentry implements its own server-side rate limiting in addition.
        // See https://docs.sentry.io/accounts/quotas/.
        warnOnce('Client-side Sentry quota reached. No further Sentry events will be sent');
        return null;
      }
      ++eventsSent;

      // Add additional debugging information for non-Error exception types
      // which Sentry can't serialize to a useful format automatically.
      //
      // See https://github.com/getsentry/sentry-javascript/issues/2210
      try {
        const originalErr = hint && hint.originalException;
        if (originalErr instanceof Event) {
          if (!event.extra) {
            event.extra = {};
          }
          Object.assign(event.extra, {
            type: originalErr.type,
            // @ts-ignore - `detail` is a property of certain event types.
            detail: originalErr.detail,
            isTrusted: originalErr.isTrusted
          });
        }
      } catch (e) {
        // If something went wrong serializing the data, just ignore it.
      }
      return event;
    }
  });
  try {
    setExtra('host_config', parseConfigFragment(window.location.href));
  } catch (e) {
    // Ignore errors parsing configuration.
  }

  /** @param {HTMLScriptElement} script */
  const isJavaScript = script => !script.type || script.type.match(/javascript|module/);

  // Include information about the scripts on the page. This may help with
  // debugging of errors caused by scripts injected by browser extensions.
  const loadedScripts = Array.from(document.querySelectorAll('script')).filter(isJavaScript).map(script => script.src || '<inline>');
  setExtra('loaded_scripts', loadedScripts);

  // Catch errors occuring in Hypothesis-related code in the host frame.
  removeFrameErrorHandler = handleErrorsInFrames((err, context) => {
    captureException(err, {
      tags: {
        context
      }
    });
  });
}

/**
 * Record the user ID of the logged-in user.
 *
 * See https://docs.sentry.io/platforms/javascript/#capturing-the-user
 *
 * @param {import('@sentry/browser').User|null} user
 */
function setUserInfo(user) {
  setUser(user);
}

/**
 * Testing aid that resets event counters and removes event handlers installed
 * by {@link init}.
 */
function reset() {
  var _removeFrameErrorHand;
  eventsSent = 0;
  (_removeFrameErrorHand = removeFrameErrorHandler) === null || _removeFrameErrorHand === void 0 ? void 0 : _removeFrameErrorHand();
  removeFrameErrorHandler = null;
}

var focusVisible$1 = {exports: {}};

(function (module, exports) {
	(function (global, factory) {
	  'object' === 'object' && 'object' !== 'undefined' ? factory() :
	  typeof undefined === 'function' && undefined.amd ? undefined(factory) :
	  (factory());
	}(commonjsGlobal, (function () { 'use strict';

	  /**
	   * Applies the :focus-visible polyfill at the given scope.
	   * A scope in this case is either the top-level Document or a Shadow Root.
	   *
	   * @param {(Document|ShadowRoot)} scope
	   * @see https://github.com/WICG/focus-visible
	   */
	  function applyFocusVisiblePolyfill(scope) {
	    var hadKeyboardEvent = true;
	    var hadFocusVisibleRecently = false;
	    var hadFocusVisibleRecentlyTimeout = null;

	    var inputTypesAllowlist = {
	      text: true,
	      search: true,
	      url: true,
	      tel: true,
	      email: true,
	      password: true,
	      number: true,
	      date: true,
	      month: true,
	      week: true,
	      time: true,
	      datetime: true,
	      'datetime-local': true
	    };

	    /**
	     * Helper function for legacy browsers and iframes which sometimes focus
	     * elements like document, body, and non-interactive SVG.
	     * @param {Element} el
	     */
	    function isValidFocusTarget(el) {
	      if (
	        el &&
	        el !== document &&
	        el.nodeName !== 'HTML' &&
	        el.nodeName !== 'BODY' &&
	        'classList' in el &&
	        'contains' in el.classList
	      ) {
	        return true;
	      }
	      return false;
	    }

	    /**
	     * Computes whether the given element should automatically trigger the
	     * `focus-visible` class being added, i.e. whether it should always match
	     * `:focus-visible` when focused.
	     * @param {Element} el
	     * @return {boolean}
	     */
	    function focusTriggersKeyboardModality(el) {
	      var type = el.type;
	      var tagName = el.tagName;

	      if (tagName === 'INPUT' && inputTypesAllowlist[type] && !el.readOnly) {
	        return true;
	      }

	      if (tagName === 'TEXTAREA' && !el.readOnly) {
	        return true;
	      }

	      if (el.isContentEditable) {
	        return true;
	      }

	      return false;
	    }

	    /**
	     * Add the `focus-visible` class to the given element if it was not added by
	     * the author.
	     * @param {Element} el
	     */
	    function addFocusVisibleClass(el) {
	      if (el.classList.contains('focus-visible')) {
	        return;
	      }
	      el.classList.add('focus-visible');
	      el.setAttribute('data-focus-visible-added', '');
	    }

	    /**
	     * Remove the `focus-visible` class from the given element if it was not
	     * originally added by the author.
	     * @param {Element} el
	     */
	    function removeFocusVisibleClass(el) {
	      if (!el.hasAttribute('data-focus-visible-added')) {
	        return;
	      }
	      el.classList.remove('focus-visible');
	      el.removeAttribute('data-focus-visible-added');
	    }

	    /**
	     * If the most recent user interaction was via the keyboard;
	     * and the key press did not include a meta, alt/option, or control key;
	     * then the modality is keyboard. Otherwise, the modality is not keyboard.
	     * Apply `focus-visible` to any current active element and keep track
	     * of our keyboard modality state with `hadKeyboardEvent`.
	     * @param {KeyboardEvent} e
	     */
	    function onKeyDown(e) {
	      if (e.metaKey || e.altKey || e.ctrlKey) {
	        return;
	      }

	      if (isValidFocusTarget(scope.activeElement)) {
	        addFocusVisibleClass(scope.activeElement);
	      }

	      hadKeyboardEvent = true;
	    }

	    /**
	     * If at any point a user clicks with a pointing device, ensure that we change
	     * the modality away from keyboard.
	     * This avoids the situation where a user presses a key on an already focused
	     * element, and then clicks on a different element, focusing it with a
	     * pointing device, while we still think we're in keyboard modality.
	     * @param {Event} e
	     */
	    function onPointerDown(e) {
	      hadKeyboardEvent = false;
	    }

	    /**
	     * On `focus`, add the `focus-visible` class to the target if:
	     * - the target received focus as a result of keyboard navigation, or
	     * - the event target is an element that will likely require interaction
	     *   via the keyboard (e.g. a text box)
	     * @param {Event} e
	     */
	    function onFocus(e) {
	      // Prevent IE from focusing the document or HTML element.
	      if (!isValidFocusTarget(e.target)) {
	        return;
	      }

	      if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {
	        addFocusVisibleClass(e.target);
	      }
	    }

	    /**
	     * On `blur`, remove the `focus-visible` class from the target.
	     * @param {Event} e
	     */
	    function onBlur(e) {
	      if (!isValidFocusTarget(e.target)) {
	        return;
	      }

	      if (
	        e.target.classList.contains('focus-visible') ||
	        e.target.hasAttribute('data-focus-visible-added')
	      ) {
	        // To detect a tab/window switch, we look for a blur event followed
	        // rapidly by a visibility change.
	        // If we don't see a visibility change within 100ms, it's probably a
	        // regular focus change.
	        hadFocusVisibleRecently = true;
	        window.clearTimeout(hadFocusVisibleRecentlyTimeout);
	        hadFocusVisibleRecentlyTimeout = window.setTimeout(function() {
	          hadFocusVisibleRecently = false;
	        }, 100);
	        removeFocusVisibleClass(e.target);
	      }
	    }

	    /**
	     * If the user changes tabs, keep track of whether or not the previously
	     * focused element had .focus-visible.
	     * @param {Event} e
	     */
	    function onVisibilityChange(e) {
	      if (document.visibilityState === 'hidden') {
	        // If the tab becomes active again, the browser will handle calling focus
	        // on the element (Safari actually calls it twice).
	        // If this tab change caused a blur on an element with focus-visible,
	        // re-apply the class when the user switches back to the tab.
	        if (hadFocusVisibleRecently) {
	          hadKeyboardEvent = true;
	        }
	        addInitialPointerMoveListeners();
	      }
	    }

	    /**
	     * Add a group of listeners to detect usage of any pointing devices.
	     * These listeners will be added when the polyfill first loads, and anytime
	     * the window is blurred, so that they are active when the window regains
	     * focus.
	     */
	    function addInitialPointerMoveListeners() {
	      document.addEventListener('mousemove', onInitialPointerMove);
	      document.addEventListener('mousedown', onInitialPointerMove);
	      document.addEventListener('mouseup', onInitialPointerMove);
	      document.addEventListener('pointermove', onInitialPointerMove);
	      document.addEventListener('pointerdown', onInitialPointerMove);
	      document.addEventListener('pointerup', onInitialPointerMove);
	      document.addEventListener('touchmove', onInitialPointerMove);
	      document.addEventListener('touchstart', onInitialPointerMove);
	      document.addEventListener('touchend', onInitialPointerMove);
	    }

	    function removeInitialPointerMoveListeners() {
	      document.removeEventListener('mousemove', onInitialPointerMove);
	      document.removeEventListener('mousedown', onInitialPointerMove);
	      document.removeEventListener('mouseup', onInitialPointerMove);
	      document.removeEventListener('pointermove', onInitialPointerMove);
	      document.removeEventListener('pointerdown', onInitialPointerMove);
	      document.removeEventListener('pointerup', onInitialPointerMove);
	      document.removeEventListener('touchmove', onInitialPointerMove);
	      document.removeEventListener('touchstart', onInitialPointerMove);
	      document.removeEventListener('touchend', onInitialPointerMove);
	    }

	    /**
	     * When the polfyill first loads, assume the user is in keyboard modality.
	     * If any event is received from a pointing device (e.g. mouse, pointer,
	     * touch), turn off keyboard modality.
	     * This accounts for situations where focus enters the page from the URL bar.
	     * @param {Event} e
	     */
	    function onInitialPointerMove(e) {
	      // Work around a Safari quirk that fires a mousemove on <html> whenever the
	      // window blurs, even if you're tabbing out of the page. ¯\_(ツ)_/¯
	      if (e.target.nodeName && e.target.nodeName.toLowerCase() === 'html') {
	        return;
	      }

	      hadKeyboardEvent = false;
	      removeInitialPointerMoveListeners();
	    }

	    // For some kinds of state, we are interested in changes at the global scope
	    // only. For example, global pointer input, global key presses and global
	    // visibility change should affect the state at every scope:
	    document.addEventListener('keydown', onKeyDown, true);
	    document.addEventListener('mousedown', onPointerDown, true);
	    document.addEventListener('pointerdown', onPointerDown, true);
	    document.addEventListener('touchstart', onPointerDown, true);
	    document.addEventListener('visibilitychange', onVisibilityChange, true);

	    addInitialPointerMoveListeners();

	    // For focus and blur, we specifically care about state changes in the local
	    // scope. This is because focus / blur events that originate from within a
	    // shadow root are not re-dispatched from the host element if it was already
	    // the active element in its own scope:
	    scope.addEventListener('focus', onFocus, true);
	    scope.addEventListener('blur', onBlur, true);

	    // We detect that a node is a ShadowRoot by ensuring that it is a
	    // DocumentFragment and also has a host property. This check covers native
	    // implementation and polyfill implementation transparently. If we only cared
	    // about the native implementation, we could just check if the scope was
	    // an instance of a ShadowRoot.
	    if (scope.nodeType === Node.DOCUMENT_FRAGMENT_NODE && scope.host) {
	      // Since a ShadowRoot is a special kind of DocumentFragment, it does not
	      // have a root element to add a class to. So, we add this attribute to the
	      // host element instead:
	      scope.host.setAttribute('data-js-focus-visible', '');
	    } else if (scope.nodeType === Node.DOCUMENT_NODE) {
	      document.documentElement.classList.add('js-focus-visible');
	      document.documentElement.setAttribute('data-js-focus-visible', '');
	    }
	  }

	  // It is important to wrap all references to global window and document in
	  // these checks to support server-side rendering use cases
	  // @see https://github.com/WICG/focus-visible/issues/199
	  if (typeof window !== 'undefined' && typeof document !== 'undefined') {
	    // Make the polyfill helper globally available. This can be used as a signal
	    // to interested libraries that wish to coordinate with the polyfill for e.g.,
	    // applying the polyfill to a shadow root:
	    window.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;

	    // Notify interested libraries of the polyfill's presence, in case the
	    // polyfill was loaded lazily:
	    var event;

	    try {
	      event = new CustomEvent('focus-visible-polyfill-ready');
	    } catch (error) {
	      // IE11 does not support using CustomEvent as a constructor directly:
	      event = document.createEvent('CustomEvent');
	      event.initCustomEvent('focus-visible-polyfill-ready', false, false, {});
	    }

	    window.dispatchEvent(event);
	  }

	  if (typeof document !== 'undefined') {
	    // Apply the polyfill to the global document, so that no JavaScript
	    // coordination is required to use the polyfill in the top-level document:
	    applyFocusVisiblePolyfill(document);
	  }

	})));
} (focusVisible$1, focusVisible$1.exports));

var focusVisible = focusVisible$1.exports;

var n,l$2,u$2,i$3,t$2,o$3,r$2,f$2={},e$1=[],c$2=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s$2(n,l){for(var u in l)n[u]=l[u];return n}function a$2(n){var l=n.parentNode;l&&l.removeChild(n);}function h$2(l,u,i){var t,o,r,f={};for(r in u)"key"==r?t=u[r]:"ref"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),"function"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return v$2(l,f,t,o,null)}function v$2(n,i,t,o,r){var f={type:n,props:i,key:t,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==r?++u$2:r};return null==r&&null!=l$2.vnode&&l$2.vnode(f),f}function y$2(){return {current:null}}function p$2(n){return n.children}function d$2(n,l){this.props=n,this.context=l;}function _$2(n,l){if(null==l)return n.__?_$2(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return "function"==typeof n.type?_$2(n):null}function k$1(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return k$1(n)}}function b$1(n){(!n.__d&&(n.__d=!0)&&t$2.push(n)&&!g$1.__r++||o$3!==l$2.debounceRendering)&&((o$3=l$2.debounceRendering)||setTimeout)(g$1);}function g$1(){for(var n;g$1.__r=t$2.length;)n=t$2.sort(function(n,l){return n.__v.__b-l.__v.__b}),t$2=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=s$2({},t)).__v=t.__v+1,j$1(r,t,i,l.__n,void 0!==r.ownerSVGElement,null!=t.__h?[o]:null,u,null==o?_$2(t):o,t.__h),z$1(u,t),t.__e!=o&&k$1(t)));});}function w$1(n,l,u,i,t,o,r,c,s,a){var h,y,d,k,b,g,w,x=i&&i.__k||e$1,C=x.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(k=u.__k[h]=null==(k=l[h])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k||"bigint"==typeof k?v$2(null,k,null,null,k):Array.isArray(k)?v$2(p$2,{children:k},null,null,null):k.__b>0?v$2(k.type,k.props,k.key,k.ref?k.ref:null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(d=x[h])||d&&k.key==d.key&&k.type===d.type)x[h]=void 0;else for(y=0;y<C;y++){if((d=x[y])&&k.key==d.key&&k.type===d.type){x[y]=void 0;break}d=null;}j$1(n,k,d=d||f$2,t,o,r,c,s,a),b=k.__e,(y=k.ref)&&d.ref!=y&&(w||(w=[]),d.ref&&w.push(d.ref,null,k),w.push(y,k.__c||b,k)),null!=b?(null==g&&(g=b),"function"==typeof k.type&&k.__k===d.__k?k.__d=s=m$1(k,s,n):s=A$1(n,k,d,x,b,s),"function"==typeof u.type&&(u.__d=s)):s&&d.__e==s&&s.parentNode!=n&&(s=_$2(d));}for(u.__e=g,h=C;h--;)null!=x[h]&&N(x[h],x[h]);if(w)for(h=0;h<w.length;h++)M(w[h],w[++h],w[++h]);}function m$1(n,l,u){for(var i,t=n.__k,o=0;t&&o<t.length;o++)(i=t[o])&&(i.__=n,l="function"==typeof i.type?m$1(i,l,u):A$1(u,i,i,t,i.__e,l));return l}function x$1(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){x$1(n,l);}):l.push(n)),l}function A$1(n,l,u,i,t,o){var r,f,e;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(null==u||t!=o||null==t.parentNode)n:if(null==o||o.parentNode!==n)n.appendChild(t),r=null;else {for(f=o,e=0;(f=f.nextSibling)&&e<i.length;e+=1)if(f==t)break n;n.insertBefore(t,o),r=o;}return void 0!==r?r:t.nextSibling}function C(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||H(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||H(n,o,l[o],u[o],i);}function $(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||c$2.test(l)?u:u+"px";}function H(n,l,u,i,t){var o;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else {if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||$(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||$(n.style,l,u[l]);}else if("o"===l[0]&&"n"===l[1])o=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?i||n.addEventListener(l,o?T$2:I,o):n.removeEventListener(l,o?T$2:I,o);else if("dangerouslySetInnerHTML"!==l){if(t)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("href"!==l&&"list"!==l&&"form"!==l&&"tabIndex"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null==u||!1===u&&-1==l.indexOf("-")?n.removeAttribute(l):n.setAttribute(l,u));}}function I(n){this.l[n.type+!1](l$2.event?l$2.event(n):n);}function T$2(n){this.l[n.type+!0](l$2.event?l$2.event(n):n);}function j$1(n,u,i,t,o,r,f,e,c){var a,h,v,y,_,k,b,g,m,x,A,C,$,H,I,T=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(a=l$2.__b)&&a(u);try{n:if("function"==typeof T){if(g=u.props,m=(a=T.contextType)&&t[a.__c],x=a?m?m.props.value:a.__:t,i.__c?b=(h=u.__c=i.__c).__=h.__E:("prototype"in T&&T.prototype.render?u.__c=h=new T(g,x):(u.__c=h=new d$2(g,x),h.constructor=T,h.render=O),m&&m.sub(h),h.props=g,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[],h._sb=[]),null==h.__s&&(h.__s=h.state),null!=T.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=s$2({},h.__s)),s$2(h.__s,T.getDerivedStateFromProps(g,h.__s))),y=h.props,_=h.state,v)null==T.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else {if(null==T.getDerivedStateFromProps&&g!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(g,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(g,h.__s,x)||u.__v===i.__v){for(h.props=g,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u);}),A=0;A<h._sb.length;A++)h.__h.push(h._sb[A]);h._sb=[],h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(g,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,_,k);});}if(h.context=x,h.props=g,h.__v=u,h.__P=n,C=l$2.__r,$=0,"prototype"in T&&T.prototype.render){for(h.state=h.__s,h.__d=!1,C&&C(u),a=h.render(h.props,h.state,h.context),H=0;H<h._sb.length;H++)h.__h.push(h._sb[H]);h._sb=[];}else do{h.__d=!1,C&&C(u),a=h.render(h.props,h.state,h.context),h.state=h.__s;}while(h.__d&&++$<25);h.state=h.__s,null!=h.getChildContext&&(t=s$2(s$2({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(k=h.getSnapshotBeforeUpdate(y,_)),I=null!=a&&a.type===p$2&&null==a.key?a.props.children:a,w$1(n,Array.isArray(I)?I:[I],u,i,t,o,r,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),b&&(h.__E=h.__=null),h.__e=!1;}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=L(i.__e,u,i,t,o,r,f,c);(a=l$2.diffed)&&a(u);}catch(n){u.__v=null,(c||null!=r)&&(u.__e=e,u.__h=!!c,r[r.indexOf(e)]=null),l$2.__e(n,u,i);}}function z$1(n,u){l$2.__c&&l$2.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u);});}catch(n){l$2.__e(n,u.__v);}});}function L(l,u,i,t,o,r,e,c){var s,h,v,y=i.props,p=u.props,d=u.type,k=0;if("svg"===d&&(o=!0),null!=r)for(;k<r.length;k++)if((s=r[k])&&"setAttribute"in s==!!d&&(d?s.localName===d:3===s.nodeType)){l=s,r[k]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=o?document.createElementNS("http://www.w3.org/2000/svg",d):document.createElement(d,p.is&&p),r=null,c=!1;}if(null===d)y===p||c&&l.data===p||(l.data=p);else {if(r=r&&n.call(l.childNodes),h=(y=i.props||f$2).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!c){if(null!=r)for(y={},k=0;k<l.attributes.length;k++)y[l.attributes[k].name]=l.attributes[k].value;(v||h)&&(v&&(h&&v.__html==h.__html||v.__html===l.innerHTML)||(l.innerHTML=v&&v.__html||""));}if(C(l,p,y,o,c),v)u.__k=[];else if(k=u.props.children,w$1(l,Array.isArray(k)?k:[k],u,i,t,o&&"foreignObject"!==d,r,e,r?r[0]:i.__k&&_$2(i,0),c),null!=r)for(k=r.length;k--;)null!=r[k]&&a$2(r[k]);c||("value"in p&&void 0!==(k=p.value)&&(k!==l.value||"progress"===d&&!k||"option"===d&&k!==y.value)&&H(l,"value",k,y.value,!1),"checked"in p&&void 0!==(k=p.checked)&&k!==l.checked&&H(l,"checked",k,y.checked,!1));}return l}function M(n,u,i){try{"function"==typeof n?n(u):n.current=u;}catch(n){l$2.__e(n,i);}}function N(n,u,i){var t,o;if(l$2.unmount&&l$2.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||M(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount();}catch(n){l$2.__e(n,u);}t.base=t.__P=null,n.__c=void 0;}if(t=n.__k)for(o=0;o<t.length;o++)t[o]&&N(t[o],u,i||"function"!=typeof n.type);i||null==n.__e||a$2(n.__e),n.__=n.__e=n.__d=void 0;}function O(n,l,u){return this.constructor(n,u)}function P$1(u,i,t){var o,r,e;l$2.__&&l$2.__(u,i),r=(o="function"==typeof t)?null:t&&t.__k||i.__k,e=[],j$1(i,u=(!o&&t||i).__k=h$2(p$2,null,[u]),r||f$2,f$2,void 0!==i.ownerSVGElement,!o&&t?[t]:r?null:i.firstChild?n.call(i.childNodes):null,e,!o&&t?t:r?r.__e:i.firstChild,o),z$1(e,u);}function S$1(n,l){P$1(n,l,S$1);}function q$1(l,u,i){var t,o,r,f=s$2({},l.props);for(r in u)"key"==r?t=u[r]:"ref"==r?o=u[r]:f[r]=u[r];return arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),v$2(l.type,f,t||l.key,o||l.ref,null)}function B$1(n,l){var u={__c:l="__cC"+r$2++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(b$1);},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n);};}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=e$1.slice,l$2={__e:function(n,l,u,i){for(var t,o,r;l=l.__;)if((t=l.__c)&&!t.__)try{if((o=t.constructor)&&null!=o.getDerivedStateFromError&&(t.setState(o.getDerivedStateFromError(n)),r=t.__d),null!=t.componentDidCatch&&(t.componentDidCatch(n,i||{}),r=t.__d),r)return t.__E=t}catch(l){n=l;}throw n}},u$2=0,i$3=function(n){return null!=n&&void 0===n.constructor},d$2.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s$2({},this.state),"function"==typeof n&&(n=n(s$2({},u),this.props)),n&&s$2(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),b$1(this));},d$2.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),b$1(this));},d$2.prototype.render=p$2,t$2=[],g$1.__r=0,r$2=0;

function t$1(o,e){return l$2.__a&&l$2.__a(e),o}"undefined"!=typeof window&&window.__PREACT_DEVTOOLS__&&window.__PREACT_DEVTOOLS__.attachPreact("10.11.3",l$2,{Fragment:p$2,Component:d$2});

var o$2={};function r$1(){o$2={};}function a$1(e){return e.type===p$2?"Fragment":"function"==typeof e.type?e.type.displayName||e.type.name:"string"==typeof e.type?e.type:"#text"}var i$2=[],c$1=[];function s$1(){return i$2.length>0?i$2[i$2.length-1]:null}var u$1=!1;function l$1(e){return "function"==typeof e.type&&e.type!=p$2}function f$1(n){for(var e=[n],t=n;null!=t.__o;)e.push(t.__o),t=t.__o;return e.reduce(function(n,e){n+="  in "+a$1(e);var t=e.__source;return t?n+=" (at "+t.fileName+":"+t.lineNumber+")":u$1||(u$1=!0,console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")),n+"\n"},"")}var p$1="function"==typeof WeakMap;function d$1(n){return n?"function"==typeof n.type?d$1(n.__):n:{}}var h$1=d$2.prototype.setState;d$2.prototype.setState=function(n,e){return null==this.__v&&null==this.state&&console.warn('Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n'+f$1(s$1())),h$1.call(this,n,e)};var v$1=d$2.prototype.forceUpdate;function y$1(n){var e=n.props,t=a$1(n),o="";for(var r in e)if(e.hasOwnProperty(r)&&"children"!==r){var i=e[r];"function"==typeof i&&(i="function "+(i.displayName||i.name)+"() {}"),i=Object(i)!==i||i.toString?i+"":Object.prototype.toString.call(i),o+=" "+r+"="+JSON.stringify(i);}var c=e.children;return "<"+t+o+(c&&c.length?">..</"+t+">":" />")}d$2.prototype.forceUpdate=function(n){return null==this.__v?console.warn('Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n'+f$1(s$1())):null==this.__P&&console.warn('Can\'t call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n'+f$1(this.__v)),v$1.call(this,n)},function(){!function(){var n=l$2.__b,t=l$2.diffed,o=l$2.__,r=l$2.vnode,a=l$2.__r;l$2.diffed=function(n){l$1(n)&&c$1.pop(),i$2.pop(),t&&t(n);},l$2.__b=function(e){l$1(e)&&i$2.push(e),n&&n(e);},l$2.__=function(n,e){c$1=[],o&&o(n,e);},l$2.vnode=function(n){n.__o=c$1.length>0?c$1[c$1.length-1]:null,r&&r(n);},l$2.__r=function(n){l$1(n)&&c$1.push(n),a&&a(n);};}();var n=!1,t=l$2.__b,r=l$2.diffed,s=l$2.vnode,u=l$2.__e,h=l$2.__,v=l$2.__h,m=p$1?{useEffect:new WeakMap,useLayoutEffect:new WeakMap,lazyPropTypes:new WeakMap}:null,b=[];l$2.__e=function(n,e,t,o){if(e&&e.__c&&"function"==typeof n.then){var r=n;n=new Error("Missing Suspense. The throwing component was: "+a$1(e));for(var i=e;i;i=i.__)if(i.__c&&i.__c.__c){n=r;break}if(n instanceof Error)throw n}try{(o=o||{}).componentStack=f$1(e),u(n,e,t,o),"function"!=typeof n.then&&setTimeout(function(){throw n});}catch(n){throw n}},l$2.__=function(n,e){if(!e)throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");var t;switch(e.nodeType){case 1:case 11:case 9:t=!0;break;default:t=!1;}if(!t){var o=a$1(n);throw new Error("Expected a valid HTML node as a second argument to render.\tReceived "+e+" instead: render(<"+o+" />, "+e+");")}h&&h(n,e);},l$2.__b=function(e){var r=e.type,i=d$1(e.__);if(n=!0,void 0===r)throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports"+y$1(e)+"\n\n"+f$1(e));if(null!=r&&"object"==typeof r){if(void 0!==r.__k&&void 0!==r.__e)throw new Error("Invalid type passed to createElement(): "+r+"\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My"+a$1(e)+" = "+y$1(r)+";\n  let vnode = <My"+a$1(e)+" />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n"+f$1(e));throw new Error("Invalid type passed to createElement(): "+(Array.isArray(r)?"array":r))}if("thead"!==r&&"tfoot"!==r&&"tbody"!==r||"table"===i.type?"tr"===r&&"thead"!==i.type&&"tfoot"!==i.type&&"tbody"!==i.type&&"table"!==i.type?console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent."+y$1(e)+"\n\n"+f$1(e)):"td"===r&&"tr"!==i.type?console.error("Improper nesting of table. Your <td> should have a <tr> parent."+y$1(e)+"\n\n"+f$1(e)):"th"===r&&"tr"!==i.type&&console.error("Improper nesting of table. Your <th> should have a <tr>."+y$1(e)+"\n\n"+f$1(e)):console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent."+y$1(e)+"\n\n"+f$1(e)),void 0!==e.ref&&"function"!=typeof e.ref&&"object"!=typeof e.ref&&!("$$typeof"in e))throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got ['+typeof e.ref+"] instead\n"+y$1(e)+"\n\n"+f$1(e));if("string"==typeof e.type)for(var c in e.props)if("o"===c[0]&&"n"===c[1]&&"function"!=typeof e.props[c]&&null!=e.props[c])throw new Error("Component's \""+c+'" property should be a function, but got ['+typeof e.props[c]+"] instead\n"+y$1(e)+"\n\n"+f$1(e));if("function"==typeof e.type&&e.type.propTypes){if("Lazy"===e.type.displayName&&m&&!m.lazyPropTypes.has(e.type)){var s="PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";try{var u=e.type();m.lazyPropTypes.set(e.type,!0),console.warn(s+"Component wrapped in lazy() is "+a$1(u));}catch(n){console.warn(s+"We will log the wrapped component's name once it is loaded.");}}var l=e.props;e.type.__f&&delete(l=function(n,e){for(var t in e)n[t]=e[t];return n}({},l)).ref,function(n,e,t,r,a){Object.keys(n).forEach(function(t){var i;try{i=n[t](e,t,r,"prop",null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");}catch(n){i=n;}i&&!(i.message in o$2)&&(o$2[i.message]=!0,console.error("Failed prop type: "+i.message+(a&&"\n"+a()||"")));});}(e.type.propTypes,l,0,a$1(e),function(){return f$1(e)});}t&&t(e);},l$2.__h=function(e,t,o){if(!e||!n)throw new Error("Hook can only be invoked from render methods.");v&&v(e,t,o);};var w=function(n,e){return {get:function(){var t="get"+n+e;b&&b.indexOf(t)<0&&(b.push(t),console.warn("getting vnode."+n+" is deprecated, "+e));},set:function(){var t="set"+n+e;b&&b.indexOf(t)<0&&(b.push(t),console.warn("setting vnode."+n+" is not allowed, "+e));}}},g={nodeName:w("nodeName","use vnode.type"),attributes:w("attributes","use vnode.props"),children:w("children","use vnode.props.children")},E=Object.create({},g);l$2.vnode=function(n){var e=n.props;if(null!==n.type&&null!=e&&("__source"in e||"__self"in e)){var t=n.props={};for(var o in e){var r=e[o];"__source"===o?n.__source=r:"__self"===o?n.__self=r:t[o]=r;}}n.__proto__=E,s&&s(n);},l$2.diffed=function(e){if(e.__k&&e.__k.forEach(function(n){if(n&&void 0===n.type){delete n.__,delete n.__b;var t=Object.keys(n).join(",");throw new Error("Objects are not valid as a child. Encountered an object with the keys {"+t+"}.\n\n"+f$1(e))}}),n=!1,r&&r(e),null!=e.__k)for(var t=[],o=0;o<e.__k.length;o++){var a=e.__k[o];if(a&&null!=a.key){var i=a.key;if(-1!==t.indexOf(i)){console.error('Following component has two or more children with the same key attribute: "'+i+'". This may cause glitches and misbehavior in rendering process. Component: \n\n'+y$1(e)+"\n\n"+f$1(e));break}t.push(i);}}};}();

var classnames$1 = {exports: {}};

/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/

(function (module) {
	/* global define */

	(function () {
		'use strict';

		var hasOwn = {}.hasOwnProperty;
		var nativeCodeString = '[native code]';

		function classNames() {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					if (arg.length) {
						var inner = classNames.apply(null, arg);
						if (inner) {
							classes.push(inner);
						}
					}
				} else if (argType === 'object') {
					if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
						classes.push(arg.toString());
						continue;
					}

					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if ('object' !== 'undefined' && module.exports) {
			classNames.default = classNames;
			module.exports = classNames;
		} else if (typeof undefined === 'function' && typeof undefined.amd === 'object' && undefined.amd) {
			// register as 'classnames', consistent with npm package name
			undefined('classnames', [], function () {
				return classNames;
			});
		} else {
			window.classNames = classNames;
		}
	}());
} (classnames$1));

var classnames = classnames$1.exports;

var t,r,u,i$1,o$1=0,f=[],c=[],e=l$2.__b,a=l$2.__r,v=l$2.diffed,l=l$2.__c,m=l$2.unmount;function d(t,u){l$2.__h&&l$2.__h(r,t,o$1||u),o$1=0;var i=r.__H||(r.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({__V:c}),i.__[t]}function p(n){return o$1=1,y(B,n)}function y(n,u,i){var o=d(t++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):B(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}));}],o.__c=r,!r.u)){r.u=!0;var f=r.shouldComponentUpdate;r.shouldComponentUpdate=function(n,t,r){if(!o.__c.__H)return !0;var u=o.__c.__H.__.filter(function(n){return n.__c});if(u.every(function(n){return !n.__N}))return !f||f.call(this,n,t,r);var i=!1;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0);}}),!(!i&&o.__c.props===n)&&(!f||f.call(this,n,t,r))};}return o.__N||o.__}function h(u,i){var o=d(t++,3);!l$2.__s&&z(o.__H,i)&&(o.__=u,o.i=i,r.__H.__h.push(o));}function s(u,i){var o=d(t++,4);!l$2.__s&&z(o.__H,i)&&(o.__=u,o.i=i,r.__h.push(o));}function _$1(n){return o$1=5,F(function(){return {current:n}},[])}function A(n,t,r){o$1=6,s(function(){return "function"==typeof n?(n(t()),function(){return n(null)}):n?(n.current=t(),function(){return n.current=null}):void 0},null==r?r:r.concat(n));}function F(n,r){var u=d(t++,7);return z(u.__H,r)?(u.__V=n(),u.i=r,u.__h=n,u.__V):u.__}function T$1(n,t){return o$1=8,F(function(){return n},t)}function q(n){var u=r.context[n.__c],i=d(t++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r)),u.props.value):n.__}function x(t,r){l$2.useDebugValue&&l$2.useDebugValue(r?r(t):t);}function P(n){var u=d(t++,10),i=p();return u.__=n,r.componentDidCatch||(r.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n);}),[i[0],function(){i[1](void 0);}]}function V(){var n=d(t++,11);if(!n.__){for(var u=r.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__="P"+i[0]+"-"+i[1]++;}return n.__}function b(){for(var t;t=f.shift();)if(t.__P&&t.__H)try{t.__H.__h.forEach(k),t.__H.__h.forEach(w),t.__H.__h=[];}catch(r){t.__H.__h=[],l$2.__e(r,t.__v);}}l$2.__b=function(n){r=null,e&&e(n);},l$2.__r=function(n){a&&a(n),t=0;var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.__V=c,n.__N=n.i=void 0;})):(i.__h.forEach(k),i.__h.forEach(w),i.__h=[])),u=r;},l$2.diffed=function(t){v&&v(t);var o=t.__c;o&&o.__H&&(o.__H.__h.length&&(1!==f.push(o)&&i$1===l$2.requestAnimationFrame||((i$1=l$2.requestAnimationFrame)||j)(b)),o.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.__V!==c&&(n.__=n.__V),n.i=void 0,n.__V=c;})),u=r=null;},l$2.__c=function(t,r){r.some(function(t){try{t.__h.forEach(k),t.__h=t.__h.filter(function(n){return !n.__||w(n)});}catch(u){r.some(function(n){n.__h&&(n.__h=[]);}),r=[],l$2.__e(u,t.__v);}}),l&&l(t,r);},l$2.unmount=function(t){m&&m(t);var r,u=t.__c;u&&u.__H&&(u.__H.__.forEach(function(n){try{k(n);}catch(n){r=n;}}),u.__H=void 0,r&&l$2.__e(r,u.__v));};var g="function"==typeof requestAnimationFrame;function j(n){var t,r=function(){clearTimeout(u),g&&cancelAnimationFrame(t),setTimeout(n);},u=setTimeout(r,100);g&&(t=requestAnimationFrame(r));}function k(n){var t=r,u=n.__c;"function"==typeof u&&(n.__c=void 0,u()),r=t;}function w(n){var t=r;n.__c=n.__(),r=t;}function z(n,t){return !n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function B(n,t){return "function"==typeof t?t(n):t}

var _=0;function o(o,e,n,t,f){var l,s,u={};for(s in e)"ref"==s?l=e[s]:u[s]=e[s];var a={type:o,props:u,key:n,ref:l,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:--_,__source:f,__self:t};if("function"==typeof o&&(l=o.defaultProps))for(s in l)void 0===u[s]&&(u[s]=l[s]);return l$2.vnode&&l$2.vnode(a),a}

var _jsxFileName$3m = "/home/runner/work/frontend-shared/frontend-shared/src/components/SvgIcon.js";
const iconRegistry = new Map();
/**
 * @typedef SvgIconProps
 * @prop {string|symbol} name - The name of the icon to display.
 *   The name must match a name that has already been registered using the
 *   `registerIcon` or `registerIcons` functions.
 * @prop {string} [className] - A CSS class to apply to the `<svg>` element.
 * @prop {boolean} [inline] - Apply a style allowing for inline display of icon wrapper.
 * @prop {string} [title] - Optional title attribute to apply to the SVG's containing `span`.
 */

/**
 * Component that renders icons using inline `<svg>` elements.
 * This enables their appearance to be customized via CSS.
 *
 * This matches the way we do icons on the website, see
 * https://github.com/hypothesis/h/pull/3675
 *
 * @param {SvgIconProps} props
 */

function SvgIcon({
  name,
  className = '',
  inline = false,
  title = ''
}) {
  const markup = iconRegistry.get(name);

  if (!markup) {
    throw new Error(`Icon "${name.toString()}" is not registered`);
  }

  const element =
  /** @type {{ current: HTMLElement }} */
  _$1();
  s(() => {
    const svg = element.current.querySelector('svg'); // The icon should always contain an `<svg>` element, but check here as we
    // don't validate the markup when it is registered.

    if (svg) {
      svg.setAttribute('class', className);
    }
  }, [className, // `markup` is a dependency of this effect because the SVG is replaced if
  // it changes.
  markup]);
  const spanProps = {};

  if (title) {
    spanProps.title = title;
  }

  return o("span", {
    className: classnames('Hyp-SvgIcon', {
      'Hyp-SvgIcon--inline': inline
    }),
    dangerouslySetInnerHTML: {
      __html: markup
    },
    ref: element,
    ...spanProps
  }, void 0, false, {
    fileName: _jsxFileName$3m,
    lineNumber: 69,
    columnNumber: 5
  }, this);
}
/**
 * Register an icon for use with the `SvgIcon` component.
 *
 * Returns a symbol that can be passed as the `name` prop to `SvgIcon` in order
 * to render this icon.
 *
 * @param {string|symbol} name - A name for this icon
 * @param {string} markup - SVG markup for the icon
 * @return {symbol}
 */

function registerIcon(name, markup) {
  const key = typeof name === 'string' ? Symbol(name) : name;
  iconRegistry.set(key, markup);
  return key;
}
/**
 * Register icons for use with the `SvgIcon` component.
 *
 * @deprecated Prefer the `registerIcon` function instead which will return a
 * key that does not conflict with existing icons.
 *
 * @param {Record<string, string>} icons
 * @param {Object} options
 *  @param {boolean} [options.reset] - If `true`, remove existing registered icons.
 */

function registerIcons(icons, {
  reset = false
} = {}) {
  if (reset) {
    iconRegistry.clear();
  }

  for (let [key, value] of Object.entries(icons)) {
    iconRegistry.set(key, value);
  }
}
/**
 * Return the currently available icons.
 *
 * To register icons, don't mutate this directly but call `registerIcons`
 * instead.
 *
 * @return {IconMap}
 */

function availableIcons() {
  return iconRegistry;
}

var _jsxFileName$3l = "/home/runner/work/frontend-shared/frontend-shared/src/components/buttons.js";

function ButtonBase({
  // Custom props.
  buttonRef,
  classes,
  className,
  icon,
  iconPosition = 'left',
  size = 'medium',
  variant = 'normal',
  expanded,
  pressed,
  // Standard <button> props.
  type = 'button',
  ...restProps
}) {
  var _restProps$role;

  const role = (_restProps$role = restProps === null || restProps === void 0 ? void 0 : restProps.role) !== null && _restProps$role !== void 0 ? _restProps$role : 'button';
  /** @type {Record<string, unknown>} */

  const ariaProps = {
    'aria-label': restProps.title
  }; // aria-pressed and aria-expanded are not allowed for buttons with
  // an aria role of `tab`. Instead, the aria-selected attribute is expected.

  if (role === 'tab') {
    ariaProps['aria-selected'] = pressed;
  } else {
    ariaProps['aria-pressed'] = pressed;
    ariaProps['aria-expanded'] = expanded;
  }

  return o("button", {
    ref: buttonRef,
    className: classnames(className, `${className}--${size}`, `${className}--${variant}`, {
      [`${className}--icon-${iconPosition}`]: icon
    }, classes),
    type: type,
    ...ariaProps,
    ...restProps
  }, void 0, false, {
    fileName: _jsxFileName$3l,
    lineNumber: 84,
    columnNumber: 5
  }, this);
}
/**
 * An icon-only button
 *
 * @deprecated - Use re-implemented component in the input group
 * @param {IconButtonProps} props
 */


function IconButton({
  className = 'Hyp-IconButton',
  ...restProps
}) {
  const {
    icon
  } = restProps;
  return o(ButtonBase, {
    className: className,
    ...restProps,
    children: o(SvgIcon, {
      name: icon
    }, void 0, false, {
      fileName: _jsxFileName$3l,
      lineNumber: 112,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$3l,
    lineNumber: 111,
    columnNumber: 5
  }, this);
}
/**
 * A labeled button, with or without an icon
 *
 * @deprecated - Use re-implemented component in the input group
 * @param {ButtonBaseProps} props
 */

function LabeledButton({
  children,
  className = 'Hyp-LabeledButton',
  ...restProps
}) {
  const {
    icon,
    iconPosition = 'left'
  } = restProps;
  return o(ButtonBase, {
    className: className,
    ...restProps,
    children: [icon && iconPosition === 'left' && o(SvgIcon, {
      name: icon
    }, void 0, false, {
      fileName: _jsxFileName$3l,
      lineNumber: 131,
      columnNumber: 43
    }, this), children, icon && iconPosition === 'right' && o(SvgIcon, {
      name: icon
    }, void 0, false, {
      fileName: _jsxFileName$3l,
      lineNumber: 133,
      columnNumber: 44
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$3l,
    lineNumber: 130,
    columnNumber: 5
  }, this);
}
/**
 * A button styled to appear as an HTML link (<a>)
 *
 * @deprecated - Use re-implemented component in the navigation group
 * @param {ButtonBaseProps} props
 */

function LinkButton(props) {
  return o(ButtonBase, {
    className: "Hyp-LinkButton",
    ...props
  }, void 0, false, {
    fileName: _jsxFileName$3l,
    lineNumber: 145,
    columnNumber: 10
  }, this);
}

var checkboxSVG = "  <svg\n    width=\"16\"\n    height=\"16\"\n    viewBox=\"-4 -4 39 39\"\n    aria-hidden=\"true\"\n    focusable=\"false\"\n  >\n    <rect\n      class=\"hyp-svg-checkbox--background\"\n      width=\"35\"\n      height=\"35\"\n      x=\"-2\"\n      y=\"-2\"\n      stroke=\"currentColor\"\n      fill=\"none\"\n      stroke-width=\"3\"\n      rx=\"5\"\n      ry=\"5\"\n    />\n    <polyline\n      class=\"hyp-svg-checkbox--checkmark\"\n      points=\"4,14 12,23 28,5\"\n      stroke=\"transparent\"\n      stroke-width=\"5\"\n      fill=\"none\"\n    />\n</svg>";

var _jsxFileName$3k = "/home/runner/work/frontend-shared/frontend-shared/src/components/Checkbox.js";
const checkboxIcon = registerIcon('checkbox', checkboxSVG);
/**
 * @typedef CheckboxBaseProps
 * @prop {string} [classes] - Additional CSS classes to apply to the <input>
 * @prop {string} name - The `name` of the checkbox.
 * @prop {import('preact').Ref<HTMLInputElement>} [inputRef] - Access to the input
 *    element in case a parent element wants for example to focus on it.
 * @prop {(checked: boolean) => void} [onToggle] - Callback when checkbox is
 *   checked/unchecked
 * @prop {never} [type] - Type is always 'checkbox'
 * @prop {never} [children] - Children are not allowed
 *
 * The props for Checkbox component extends and narrows the attributes of the native input element.
 * `onToggle` event should only be associated to HTMLDetailsElement, but Preact is not very strict with types.
 * We omit the `onToggle` because it clashes with our definition.
 * @typedef {Omit<import('preact').JSX.HTMLAttributes<HTMLInputElement>, 'onToggle'> & CheckboxBaseProps} CheckboxProps
 */

/**
 * @typedef LabeledCheckboxBaseProps
 * @prop {import('preact').ComponentChildren} children - Label text or elements
 * @prop {string} [containerClasses] - Optional additional classes for the container
 *   <label> element
 *
 * @typedef {Omit<CheckboxProps, 'children'> & LabeledCheckboxBaseProps} LabeledCheckboxProps
 */

/**
 * A checkbox input.
 *
 * A checkbox component is a combination of an <input> element and a sibling
 * <svg> element that is used for the visual appearance of the checkbox.
 *
 * @deprecated - Use re-implemented Checkbox component in the input group
 * @param {CheckboxProps} props
 */

function Checkbox({
  classes = '',
  inputRef,
  onToggle,
  onClick,
  ...restProps
}) {
  /**
   * @param {import('preact').JSX.TargetedMouseEvent<HTMLInputElement>} event
   * @this HTMLInputElement
   */
  function onPressed(event) {
    onToggle === null || onToggle === void 0 ? void 0 : onToggle(event.currentTarget.checked); // preact event handlers expects `this` context to be of type `never`
    // https://github.com/preactjs/preact/issues/3137

    onClick === null || onClick === void 0 ? void 0 : onClick.call(
    /** @type {never} */
    this, event);
  }

  return o(p$2, {
    children: [o("input", {
      className: classnames('Hyp-Checkbox', classes),
      ref: inputRef,
      type: "checkbox",
      onClick: onPressed,
      ...restProps
    }, void 0, false, {
      fileName: _jsxFileName$3k,
      lineNumber: 65,
      columnNumber: 7
    }, this), o(SvgIcon, {
      className: "hyp-svg-checkbox",
      name: checkboxIcon
    }, void 0, false, {
      fileName: _jsxFileName$3k,
      lineNumber: 72,
      columnNumber: 7
    }, this)]
  }, void 0, true);
}
/**
 * @deprecated - Use re-implemented Checkbox component in the input group
 * A labeled checkbox input
 *
 * @param {LabeledCheckboxProps} props
 */

function LabeledCheckbox({
  children,
  id,
  containerClasses = '',
  ...restProps
}) {
  var _id;

  (_id = id) !== null && _id !== void 0 ? _id : id = restProps.name;
  return o("label", {
    htmlFor: id,
    className: classnames('Hyp-LabeledCheckbox', containerClasses),
    children: [o(Checkbox, {
      id: id,
      ...restProps
    }, void 0, false, {
      fileName: _jsxFileName$3k,
      lineNumber: 95,
      columnNumber: 7
    }, this), o("span", {
      "data-testid": "label-text",
      children: children
    }, void 0, false, {
      fileName: _jsxFileName$3k,
      lineNumber: 96,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$3k,
    lineNumber: 91,
    columnNumber: 5
  }, this);
}

/**
 * @template T
 * @typedef {import('preact').Ref<T>} Ref
 */

/**
 * Helper for downcasting a ref to a more specific type, where that is safe
 * to do.
 *
 * This is mainly useful to cast a generic `Ref<HTMLElement>` to a more specific
 * element type (eg. `Ref<HTMLDivElement>`) for use with the `ref` prop of a JSX element.
 * Since Preact only writes to the `ref` prop, such a cast is safe.
 *
 * @template T
 * @template {T} U
 * @param {Ref<T>|undefined} ref
 * @return {Ref<U>|undefined}
 */
function downcastRef(ref) {
  return (
    /** @type {Ref<U>|undefined} */
    ref
  );
}

var _jsxFileName$3j = "/home/runner/work/frontend-shared/frontend-shared/src/components/containers.js";
function Frame({
  children,
  classes,
  containerRef,
  elementRef,
  ...restProps
}) {
  return o("div", {
    className: classnames('Hyp-Frame', classes),
    ...restProps,
    ref: downcastRef(elementRef !== null && elementRef !== void 0 ? elementRef : containerRef),
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$3j,
    lineNumber: 41,
    columnNumber: 5
  }, this);
}
/**
 * Render content inside of a "card"
 *
 * @deprecated - Use re-implemented Card component in the layout group
 * @param {PresentationalProps} props
 */

function Card({
  children,
  classes,
  containerRef,
  elementRef,
  ...restProps
}) {
  return o("div", {
    className: classnames('Hyp-Card', classes),
    ...restProps,
    ref: downcastRef(elementRef !== null && elementRef !== void 0 ? elementRef : containerRef),
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$3j,
    lineNumber: 65,
    columnNumber: 5
  }, this);
}
/**
 * Render a set of actions (typically buttons) laid out either horizontally
 * by default or vertically.
 *
 * @deprecated - Use CardActions component in the layout group
 * @param {{ direction?: 'row'|'column'} & PresentationalProps} props
 */

function Actions({
  children,
  direction = 'row',
  classes,
  containerRef,
  elementRef,
  ...restProps
}) {
  const baseClass = `Hyp-Actions--${direction}`;
  return o("div", {
    className: classnames(baseClass, classes),
    ...restProps,
    ref: downcastRef(elementRef !== null && elementRef !== void 0 ? elementRef : containerRef),
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$3j,
    lineNumber: 92,
    columnNumber: 5
  }, this);
}
/**
 * Render a scrollable container to contain content that might overflow.
 * Optionally provide styling affordances for a sticky header (`withHeader`).
 *
 * @deprecated - Use re-implemented ScrollBox component in the data-display group
 * @param {{withHeader?: boolean} & PresentationalProps} props
 */

function Scrollbox({
  children,
  classes,
  containerRef,
  elementRef,
  withHeader = false,
  ...restProps
}) {
  const baseClass = withHeader ? 'Hyp-Scrollbox--with-header' : 'Hyp-Scrollbox';
  return o("div", {
    className: classnames(baseClass, classes),
    ...restProps,
    ref: downcastRef(elementRef !== null && elementRef !== void 0 ? elementRef : containerRef),
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$3j,
    lineNumber: 119,
    columnNumber: 5
  }, this);
}

var cancel = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M8 8l3.536-3.536L8 8 4.464 4.464 8 8zm0 0l-3.536 3.536L8 8l3.536 3.536L8 8z\"></path></g></svg>\n";

var _jsxFileName$3i = "/home/runner/work/frontend-shared/frontend-shared/src/components/Dialog.js";
const cancelIcon$1 = registerIcon('cancel', cancel);
let idCounter = 0;
/**
 * Return an element ID beginning with `prefix` that is unique per component instance.
 *
 * This avoids different instances of a component re-using the same ID.
 *
 * @param {string} prefix
 */

function useUniqueId(prefix) {
  const [id] = p(() => {
    ++idCounter;
    return `${prefix}-${idCounter}`;
  });
  return id;
}
/**
 * @typedef {import('preact').ComponentChildren} Children
 *
 * @typedef DialogProps
 * @prop {Children} [buttons] -
 *   Additional `Button` elements to display at the bottom of the dialog.
 *   A "Cancel" button is added automatically if the `onCancel` prop is set.
 * @prop {string} [cancelLabel] - Label for the cancel button
 * @prop {Children} children
 * @prop {string} [contentClass] - CSS class to apply to the dialog's content
 * @prop {string|symbol} [icon] - Name of optional icon to render in header
 * @prop {import("preact/hooks").Ref<HTMLElement>|null} [initialFocus] -
 *   Child element to focus when the dialog is rendered. If not provided,
 *   the Dialog's container will be automatically focused on opening. Set to
 *   `null` to opt out of automatic focus control.
 * @prop {() => void} [onCancel] -
 *   A callback to invoke when the user cancels the dialog. If provided, a
 *   "Cancel" button will be displayed.
 * @prop {'dialog'|'alertdialog'} [role] - The aria role for the dialog (defaults to" dialog")
 * @prop {string} title
 * @prop {boolean} [withCancelButton=true] - If `onCancel` is provided, render
 *   a Cancel button as one of the Dialog's buttons (along with any other
 *   `buttons`)
 * @prop {boolean} [withCloseButton=true] - If `onCancel` is provided, render
 *   a close button (X icon) in the Dialog's header
 */

/**
 * HTML control that can be disabled.
 *
 * @typedef {HTMLElement & { disabled: boolean }} InputElement
 */

/**
 * Render a "panel"-like interface with a title and optional icon and/or
 * close button. Grabs focus on initial render, defaulting to the entire
 * Dialog container element, or `initialFocus` HTMLElement if provided.
 *
 * @param {DialogProps} props
 */


function Dialog({
  buttons,
  cancelLabel = 'Cancel',
  children,
  contentClass,
  icon,
  initialFocus,
  onCancel,
  role = 'dialog',
  title,
  withCancelButton = true,
  withCloseButton = true
}) {
  const dialogDescriptionId = useUniqueId('dialog-description');
  const dialogTitleId = useUniqueId('dialog-title');
  const rootEl =
  /** @type {{ current: HTMLDivElement }} */
  _$1();
  h(() => {
    // Setting `initialFocus` to `null` opts out of focus handling
    if (initialFocus !== null) {
      const focusEl =
      /** @type {InputElement|null} */
      initialFocus === null || initialFocus === void 0 ? void 0 : initialFocus.current;

      if (focusEl && !focusEl.disabled) {
        focusEl.focus();
      } else {
        // The `initialFocus` prop has not been set, so use automatic focus handling.
        // Modern accessibility guidance is to focus the dialog itself rather than
        // trying to be smart about focusing a particular control within the
        // dialog.
        rootEl.current.focus();
      }
    } // We only want to run this effect once when the dialog is mounted.
    //
    // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []); // Try to assign the dialog an accessible description, using the content of
  // the first paragraph of text in it.
  //
  // A limitation of this approach is that it doesn't update if the dialog's
  // content changes after the initial render.

  s(() => {
    const description = rootEl.current.querySelector('p');

    if (description) {
      description.id = dialogDescriptionId;
      rootEl.current.setAttribute('aria-describedby', dialogDescriptionId);
    }
  }, [dialogDescriptionId]);
  const hasCancelButton = onCancel && withCancelButton;
  const hasCloseButton = onCancel && withCloseButton;
  const hasButtons = buttons || hasCancelButton;
  return o("div", {
    "aria-labelledby": dialogTitleId,
    className: classnames('Hyp-Dialog', {
      'Hyp-Dialog--closeable': hasCloseButton
    }, contentClass),
    ref: rootEl,
    role: role,
    tabIndex: -1,
    children: [o("header", {
      className: "Hyp-Dialog__header",
      children: [icon && o("div", {
        className: "Hyp-Dialog__header-icon",
        children: o(SvgIcon, {
          name: icon,
          title: title,
          "data-testid": "header-icon"
        }, void 0, false, {
          fileName: _jsxFileName$3i,
          lineNumber: 139,
          columnNumber: 13
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$3i,
        lineNumber: 138,
        columnNumber: 11
      }, this), o("h2", {
        className: "Hyp-Dialog__title",
        id: dialogTitleId,
        children: title
      }, void 0, false, {
        fileName: _jsxFileName$3i,
        lineNumber: 142,
        columnNumber: 9
      }, this), onCancel && withCloseButton && o("div", {
        className: "Hyp-Dialog__close",
        children: o(IconButton, {
          "data-testid": "close-button",
          icon: cancelIcon$1,
          title: "Close",
          onClick: onCancel
        }, void 0, false, {
          fileName: _jsxFileName$3i,
          lineNumber: 147,
          columnNumber: 13
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$3i,
        lineNumber: 146,
        columnNumber: 11
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$3i,
      lineNumber: 136,
      columnNumber: 7
    }, this), children, hasButtons && o("div", {
      className: "Hyp-Dialog__actions",
      children: [hasCancelButton && o(LabeledButton, {
        "data-testid": "cancel-button",
        onClick: onCancel,
        children: cancelLabel
      }, void 0, false, {
        fileName: _jsxFileName$3i,
        lineNumber: 160,
        columnNumber: 13
      }, this), buttons]
    }, void 0, true, {
      fileName: _jsxFileName$3i,
      lineNumber: 158,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$3i,
    lineNumber: 125,
    columnNumber: 5
  }, this);
}

var _jsxFileName$3h = "/home/runner/work/frontend-shared/frontend-shared/src/components/Icon.js";
function Icon({
  name,
  classes = '',
  containerClasses = '',
  title = ''
}) {
  const registeredIcons = availableIcons();
  const markup = registeredIcons.get(name);

  if (!markup) {
    throw new Error(`Icon "${name.toString()}" is not registered`);
  }

  const element =
  /** @type {{ current: HTMLElement }} */
  _$1();
  s(() => {
    const svg = element.current.querySelector('svg'); // The icon should always contain an `<svg>` element, but check here as we
    // don't validate the markup when it is registered.

    if (svg) {
      svg.setAttribute('class', classnames('Hyp-Icon', classes));
    }
  }, [classes, // `markup` is a dependency of this effect because the SVG is replaced if
  // it changes.
  markup]);
  const spanProps = {};

  if (title) {
    spanProps.title = title;
  }

  return o("span", {
    className: containerClasses,
    dangerouslySetInnerHTML: {
      __html: markup
    },
    ref: element,
    ...spanProps
  }, void 0, false, {
    fileName: _jsxFileName$3h,
    lineNumber: 62,
    columnNumber: 5
  }, this);
}

var _jsxFileName$3g = "/home/runner/work/frontend-shared/frontend-shared/src/components/Link.js";
function Link({
  children,
  classes = '',
  linkRef,
  ...restProps
}) {
  return o("a", {
    className: classnames('Hyp-Link', classes),
    ref: linkRef,
    rel: "noopener noreferrer",
    ...restProps,
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$3g,
    lineNumber: 26,
    columnNumber: 5
  }, this);
}

/**
 * Attach listeners for one or multiple events to an element and return a
 * function that removes the listeners.
 *
 * @param {HTMLElement} element
 * @param {string[]} events
 * @param {EventListener} listener
 * @param {object} options
 *   @param {boolean} [options.useCapture]
 * @return {() => void} Function which removes the event listeners.
 */

function listen(element, events, listener, {
  useCapture = false
} = {}) {
  events.forEach(event => element.addEventListener(event, listener, useCapture));
  return () => {
    events.forEach(event => element.removeEventListener(event, listener, useCapture));
  };
}
/**
 * @template T
 * @typedef {import("preact/hooks").Ref<T>} Ref
 */

/**
 * This hook provides a way to close or hide an element when a user interacts
 * with elements outside of it or presses the Esc key. It can be used to
 * create non-modal popups (eg. for menus, autocomplete lists and non-modal dialogs)
 * that automatically close when appropriate.
 *
 * When the element is visible/open, this hook monitors for document interactions
 * that should close it - such as clicks outside the element or Esc key presses.
 * When such an interaction happens, the `handleClose` callback is invoked.
 *
 * @param {Ref<HTMLElement>} closeableEl - Outer DOM element for the popup
 * @param {boolean} isOpen - Whether the popup is currently visible/open
 * @param {() => void} handleClose - Callback invoked to close the popup
 */


function useElementShouldClose(closeableEl, isOpen, handleClose) {
  h(() => {
    if (!isOpen) {
      return () => {};
    } // Close element when user presses Escape key, regardless of focus.


    const removeKeyDownListener = listen(document.body, ['keydown'], event => {
      const keyEvent =
      /** @type {KeyboardEvent} */
      event;

      if (keyEvent.key === 'Escape') {
        handleClose();
      }
    }); // Close element if user focuses an element outside of it via any means
    // (key press, programmatic focus change).

    const removeFocusListener = listen(document.body, ['focus'], event => {
      if (closeableEl.current && !closeableEl.current.contains(
      /** @type {Node} */
      event.target)) {
        handleClose();
      }
    }, {
      useCapture: true
    }); // Close element if user clicks outside of it, even if on an element which
    // does not accept focus.

    const removeClickListener = listen(document.body, ['mousedown', 'click'], event => {
      if (closeableEl.current && !closeableEl.current.contains(
      /** @type {Node} */
      event.target)) {
        handleClose();
      }
    }, {
      useCapture: true
    });
    return () => {
      removeKeyDownListener();
      removeClickListener();
      removeFocusListener();
    };
  }, [closeableEl, isOpen, handleClose]);
}

var _jsxFileName$3f = "/home/runner/work/frontend-shared/frontend-shared/src/components/Modal.js";
function Modal({
  children,
  onCancel,
  ...restProps
}) {
  const modalContainerRef =
  /** @type {{ current: HTMLDivElement }} */
  _$1();
  useElementShouldClose(modalContainerRef, true
  /* isOpen */
  , () => {
    if (onCancel) {
      onCancel();
    }
  });
  return o(p$2, {
    children: [o("div", {
      className: "Hyp-Modal__overlay"
    }, void 0, false, {
      fileName: _jsxFileName$3f,
      lineNumber: 39,
      columnNumber: 7
    }, this), o("div", {
      className: "Hyp-Modal",
      ref: modalContainerRef,
      children: o(Dialog, {
        onCancel: onCancel,
        ...restProps,
        children: children
      }, void 0, false, {
        fileName: _jsxFileName$3f,
        lineNumber: 41,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$3f,
      lineNumber: 40,
      columnNumber: 7
    }, this)]
  }, void 0, true);
}
/**
 * @typedef ConfirmModalBaseProps
 * @prop {string} message - Main text of the modal message
 * @prop {string} confirmAction - Label for the "Confirm" button
 * @prop {() => void} onConfirm - Callback invoked if the user clicks the "Confirm" button
 * @prop {() => void} onCancel - Callback invoked if the user cancels
 *
 * @typedef {Omit<ModalProps, 'buttons' | 'children'> & ConfirmModalBaseProps} ConfirmModalProps
 */

/**
 * A modal that emulates a `window.confirm` interface:
 * request a boolean yes/no confirmation from the user.
 *
 * @param {ConfirmModalProps} props
 */

function ConfirmModal({
  message,
  confirmAction,
  onConfirm,
  onCancel,
  ...restProps
}) {
  return o(Modal, {
    onCancel: onCancel,
    buttons: [o(LabeledButton, {
      onClick: onConfirm,
      variant: "primary",
      "data-testid": "confirm-button",
      children: confirmAction
    }, "ok", false, {
      fileName: _jsxFileName$3f,
      lineNumber: 76,
      columnNumber: 9
    }, this)],
    ...restProps,
    children: o("p", {
      children: message
    }, void 0, false, {
      fileName: _jsxFileName$3f,
      lineNumber: 87,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$3f,
    lineNumber: 73,
    columnNumber: 5
  }, this);
}

var _jsxFileName$3e = "/home/runner/work/frontend-shared/frontend-shared/src/components/Panel.js";
const cancelIcon = registerIcon('cancel', cancel);
/**
 * @typedef PanelProps
 * @prop {import("preact").ComponentChildren} children
 * @prop {string} [icon] - Name of optional icon to render in header
 * @prop {() => void} [onClose] - handler for closing the panel; if provided,
 *   will render a close button that invokes this onClick
 * @prop {string} title
 */

/**
 * Render a "panel"-like interface with a title and optional icon and/or
 * close button.
 *
 * @deprecated - Use re-implemented Panel component in the layout group
 * @param {PanelProps} props
 */

function Panel({
  children,
  icon,
  onClose,
  title
}) {
  const withCloseButton = !!onClose;
  return o("div", {
    className: classnames('Hyp-Panel', {
      'Hyp-Panel--closeable': withCloseButton
    }),
    children: [o("header", {
      className: "Hyp-Panel__header",
      children: [icon && o("div", {
        className: "Hyp-Panel__header-icon",
        children: o(SvgIcon, {
          name: icon,
          title: title
        }, void 0, false, {
          fileName: _jsxFileName$3e,
          lineNumber: 38,
          columnNumber: 13
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$3e,
        lineNumber: 37,
        columnNumber: 11
      }, this), o("h2", {
        className: "Hyp-Panel__title",
        children: title
      }, void 0, false, {
        fileName: _jsxFileName$3e,
        lineNumber: 41,
        columnNumber: 9
      }, this), withCloseButton && o("div", {
        className: "Hyp-Panel__close",
        children: o(IconButton, {
          icon: cancelIcon,
          title: "Close",
          onClick: onClose
        }, void 0, false, {
          fileName: _jsxFileName$3e,
          lineNumber: 44,
          columnNumber: 13
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$3e,
        lineNumber: 43,
        columnNumber: 11
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$3e,
      lineNumber: 35,
      columnNumber: 7
    }, this), o("div", {
      className: "Hyp-Panel__content",
      children: children
    }, void 0, false, {
      fileName: _jsxFileName$3e,
      lineNumber: 48,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$3e,
    lineNumber: 30,
    columnNumber: 5
  }, this);
}

var spinnerSVG = "<svg viewBox=\"0 0 64 64\" width=\"16\" height=\"16\">\n  <g stroke-width=\"6\" stroke=\"currentColor\" stroke-linecap=\"round\">\n    <line y1=\"16\" y2=\"28\" transform=\"translate(32,32) rotate(180)\">\n      <animate attributeName=\"stroke-opacity\" dur=\"750ms\" values=\"0;1;.8;.65;.45;.3;.15;0\" repeatCount=\"indefinite\"></animate>\n    </line>\n    <line y1=\"16\" y2=\"28\" transform=\"translate(32,32) rotate(225)\">\n      <animate attributeName=\"stroke-opacity\" dur=\"750ms\" values=\".15;0;1;.8;.65;.45;.3;.15\" repeatCount=\"indefinite\"></animate>\n    </line>\n    <line y1=\"16\" y2=\"28\" transform=\"translate(32,32) rotate(270)\">\n      <animate attributeName=\"stroke-opacity\" dur=\"750ms\" values=\".3;.15;0;1;.8;.65;.45;.3\" repeatCount=\"indefinite\"></animate>\n    </line>\n    <line y1=\"16\" y2=\"28\" transform=\"translate(32,32) rotate(315)\">\n      <animate attributeName=\"stroke-opacity\" dur=\"750ms\" values=\".45;.3;.15;0;1;.85;.65;.45\" repeatCount=\"indefinite\"></animate>\n    </line>\n    <line y1=\"16\" y2=\"28\" transform=\"translate(32,32) rotate(0)\">\n      <animate attributeName=\"stroke-opacity\" dur=\"750ms\" values=\".65;.45;.3;.15;0;1;.8;.65;\" repeatCount=\"indefinite\"></animate>\n    </line>\n    <line y1=\"16\" y2=\"28\" transform=\"translate(32,32) rotate(45)\">\n      <animate attributeName=\"stroke-opacity\" dur=\"750ms\" values=\".8;.65;.45;.3;.15;0;1;.8\" repeatCount=\"indefinite\"></animate>\n    </line>\n    <line y1=\"16\" y2=\"28\" transform=\"translate(32,32) rotate(90)\">\n      <animate attributeName=\"stroke-opacity\" dur=\"750ms\" values=\"1;.85;.6;.45;.3;.15;0;1;\" repeatCount=\"indefinite\"></animate>\n    </line>\n    <line y1=\"16\" y2=\"28\" transform=\"translate(32,32) rotate(135)\">\n      <animate attributeName=\"stroke-opacity\" dur=\"750ms\" values=\"0;1;.8;.65;.45;.3;.15;0\" repeatCount=\"indefinite\"></animate>\n    </line>\n  </g>\n</svg>";

var _jsxFileName$3d = "/home/runner/work/frontend-shared/frontend-shared/src/components/Spinner.js";
const spinnerIcon = registerIcon('spinner', spinnerSVG);
/**
 * @typedef SpinnerProps
 * @prop {string} [classes] - Additional CSS classes to apply
 * @prop {'small'|'medium'|'large'} [size='medium'] - Relative size of spinner
 *   to surrounding content
 */

/**
 * @typedef FullScreenSpinnerProps
 * @prop {string} [classes] - Additional CSS classes to apply
 * @prop {string} [containerClasses] - CSS classes to apply to wrapping element.
 */

/**
 * Loading indicator.
 *
 * @deprecated - Use re-implemented component in the feedback group
 * @param {SpinnerProps} props
 */

function Spinner({
  classes = '',
  size = 'medium'
}) {
  const baseClass = `Hyp-Spinner--${size}`;
  return o(Icon, {
    name: spinnerIcon,
    containerClasses: classnames(baseClass, classes)
  }, void 0, false, {
    fileName: _jsxFileName$3d,
    lineNumber: 33,
    columnNumber: 5
  }, this);
}
/**
 * Full-screen loading indicator.
 *
 * @param {FullScreenSpinnerProps} props
 */

function FullScreenSpinner({
  classes = '',
  containerClasses = ''
}) {
  return o("div", {
    className: classnames('Hyp-FullScreenSpinner', containerClasses),
    children: o(Spinner, {
      classes: classnames('Hyp-FullScreenSpinner__spinner', classes),
      size: "large"
    }, void 0, false, {
      fileName: _jsxFileName$3d,
      lineNumber: 48,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$3d,
    lineNumber: 47,
    columnNumber: 5
  }, this);
}

var _jsxFileName$3c = "/home/runner/work/frontend-shared/frontend-shared/src/components/Table.js";

function nextItem(items, currentItem, step) {
  const index = currentItem ? items.indexOf(currentItem) : -1;
  const delta = index + step;

  if (index < 0) {
    return items[0];
  }

  if (delta < 0) {
    return items[0];
  }

  if (delta >= items.length) {
    return items[items.length - 1];
  }

  return items[delta];
}
/**
 * An interactive table of items with a sticky header.
 *
 * @template Item
 * @param {TableProps<Item>} props
 * @deprecated - Use re-implemented DataTable component in the data group
 */


function Table({
  accessibleLabel,
  classes,
  containerClasses,
  emptyItemsMessage,
  isLoading = false,
  items,
  onSelectItem,
  onUseItem,
  renderItem,
  selectedItem,
  tableHeaders
}) {
  const rowRefs = _$1(
  /** @type {(HTMLElement|null)[]} */
  []);
  const scrollboxRef =
  /** @type {{ current: HTMLElement }} */
  _$1();
  const headerRef =
  /** @type {{ current: HTMLTableSectionElement }} */
  _$1();
  /** @param {Item} item */

  const onKeyboardSelect = item => {
    const rowEl = rowRefs.current[items.indexOf(item)];

    if (rowEl) {
      rowEl.focus();
    }

    onSelectItem(item);
  };
  /** @param {KeyboardEvent} event */


  const onKeyDown = event => {
    let handled = false;

    switch (event.key) {
      case 'Enter':
        handled = true;

        if (selectedItem) {
          onUseItem(selectedItem);
        }

        break;

      case 'ArrowUp':
        handled = true;
        onKeyboardSelect(nextItem(items, selectedItem, -1));
        break;

      case 'ArrowDown':
        handled = true;
        onKeyboardSelect(nextItem(items, selectedItem, 1));
        break;

      default:
        handled = false;
        break;
    }

    if (handled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }; // When the selectedItem changes, assure that the table row associated with it
  // is fully visible and not obscured by the sticky table header. This could
  // happen if the table is partially scrolled. Scroll the Scrollbox as needed
  // to make the item row fully visible below the header.


  h(() => {
    if (!selectedItem) {
      return;
    }

    const rowEl = rowRefs.current[items.indexOf(selectedItem)];
    const headingEl = headerRef.current;
    const scrollboxEl = scrollboxRef.current;

    if (rowEl) {
      const headingHeight = headingEl.offsetHeight; // The top of the selected row, relative to the top of the Scrollbox frame

      const rowOffsetFromScrollbox = rowEl.offsetTop - scrollboxEl.scrollTop;

      if (rowOffsetFromScrollbox >= scrollboxEl.clientHeight) {
        // The `selectedItem` is in a table row that is not visible because it
        // is below the visible content in the `scrollbox`. This is most likely
        // to occur if a `Table` is rendered with an initial `selectedItem` that
        // is towards the bottom of the table (later in the `items` array).
        // Scroll it into view.
        rowEl.scrollIntoView();
      } // If the offset position is smaller than the height of the header,
      // the row is partially or fully obscured by the header. Scroll just
      // enough to make the full row visible beneath the header.


      if (rowOffsetFromScrollbox <= headingHeight) {
        scrollboxEl.scrollBy(0, rowOffsetFromScrollbox - headingHeight);
      }
    }
  }, [items, selectedItem]);
  return o(Scrollbox, {
    withHeader: true,
    classes: classnames('Hyp-Table-Scrollbox', containerClasses),
    elementRef: scrollboxRef,
    children: [o("table", {
      "aria-label": accessibleLabel,
      className: classnames('Hyp-Table', classes),
      tabIndex: 0,
      role: "grid",
      onKeyDown: onKeyDown,
      children: [o("thead", {
        ref: headerRef,
        children: o("tr", {
          children: tableHeaders.map(({
            classes,
            label
          }, index) => o("th", {
            className: classnames('Hyp-Table__header', classes),
            scope: "col",
            children: label
          }, `${label}-${index}`, false, {
            fileName: _jsxFileName$3c,
            lineNumber: 181,
            columnNumber: 15
          }, this))
        }, void 0, false, {
          fileName: _jsxFileName$3c,
          lineNumber: 179,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$3c,
        lineNumber: 178,
        columnNumber: 9
      }, this), o("tbody", {
        children: !isLoading && items.map((item, index) => o("tr", {
          "aria-selected": selectedItem === item,
          className: classnames({
            'is-selected': selectedItem === item
          }),
          onMouseDown: () => onSelectItem(item),
          onClick: () => onSelectItem(item)
          /* preact-React incompatibility `onDblClick` */

          /* eslint-disable-next-line react/no-unknown-property */
          ,
          onDblClick: () => onUseItem(item),
          ref: node => rowRefs.current[index] = node,
          tabIndex: -1,
          children: renderItem(item, selectedItem === item)
        }, index, false, {
          fileName: _jsxFileName$3c,
          lineNumber: 194,
          columnNumber: 15
        }, this))
      }, void 0, false, {
        fileName: _jsxFileName$3c,
        lineNumber: 191,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$3c,
      lineNumber: 171,
      columnNumber: 7
    }, this), isLoading && o("div", {
      className: "Hyp-Table-Scrollbox__loading",
      children: o(Spinner, {
        size: "large"
      }, void 0, false, {
        fileName: _jsxFileName$3c,
        lineNumber: 215,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$3c,
      lineNumber: 214,
      columnNumber: 9
    }, this), !isLoading && items.length === 0 && emptyItemsMessage && o("div", {
      className: "Hyp-Table-Scrollbox__message",
      "data-testid": "empty-items-message",
      children: emptyItemsMessage
    }, void 0, false, {
      fileName: _jsxFileName$3c,
      lineNumber: 219,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$3c,
    lineNumber: 166,
    columnNumber: 5
  }, this);
}

var _jsxFileName$3b = "/home/runner/work/frontend-shared/frontend-shared/src/components/TextInput.js";
function TextInput({
  classes = '',
  inputRef,
  hasError = false,
  type = 'text',
  ...restProps
}) {
  return o("input", {
    className: classnames('Hyp-TextInput', {
      'has-error': hasError
    }, classes),
    ...restProps,
    ref: inputRef,
    type: type
  }, void 0, false, {
    fileName: _jsxFileName$3b,
    lineNumber: 40,
    columnNumber: 5
  }, this);
}
/**
 * A wrapping component for pairing a `TextInput` with an `IconButton` component.
 * Applies appropriate design pattern. Expected usage:
 *
 * <TextInputWithButton>
 *   <TextInput />
 *   <IconButton />
 * </TextInputWithButton>
 *
 * Current implementation assumes the input is on the left and button on right.
 *
 * @deprecated - Use InputGroup component in the input group
 * @param {TextInputWithButtonProps} props
 */

function TextInputWithButton({
  children,
  classes = ''
}) {
  return o("div", {
    className: classnames('Hyp-TextInputWithButton', classes),
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$3b,
    lineNumber: 69,
    columnNumber: 5
  }, this);
}

var _jsxFileName$3a = "/home/runner/work/frontend-shared/frontend-shared/src/components/Thumbnail.js";
function Thumbnail({
  children,
  classes = '',
  isLoading = false,
  placeholder = '...',
  size = 'medium'
}) {
  // If there are no `children`, render a placeholder (unless loading)
  const content = x$1(children).length ? children : placeholder;
  return o("div", {
    className: classnames('Hyp-Thumbnail', classes),
    children: o("div", {
      className: "Hyp-Thumbnail__content",
      children: [isLoading && o(Spinner, {
        size: size
      }, void 0, false, {
        fileName: _jsxFileName$3a,
        lineNumber: 59,
        columnNumber: 23
      }, this), !isLoading && content]
    }, void 0, true, {
      fileName: _jsxFileName$3a,
      lineNumber: 58,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$3a,
    lineNumber: 57,
    columnNumber: 5
  }, this);
}

// Components

var annotate = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\n  <path fill=\"currentColor\" fill-rule=\"nonzero\" d=\"M15 0c.27 0 .505.099.703.297A.961.961 0 0116 1v15l-4-3H1a.974.974 0 01-.703-.29A.953.953 0 010 12V1C0 .719.096.482.29.29A.966.966 0 011 0h14zM7 3l-.469.063c-.312.041-.656.187-1.031.437-.375.25-.719.646-1.031 1.188C4.156 5.229 4 6 4 7l.002.063.006.062a.896.896 0 01.008.11l-.002.074-.006.066a1.447 1.447 0 00.43 1.188C4.729 8.854 5.082 9 5.5 9c.417 0 .77-.146 1.063-.438C6.854 8.271 7 7.918 7 7.5c0-.417-.146-.77-.438-1.063A1.447 1.447 0 005.5 6c-.073 0-.146.005-.219.016-.073.01-.14.026-.203.046.177-1.03.542-1.632 1.094-1.804L7 4V3zm5 0l-.469.063c-.312.041-.656.187-1.031.437-.375.25-.719.646-1.031 1.188C9.156 5.229 9 6 9 7l.002.063.006.062a.896.896 0 01.008.11l-.002.074-.006.066a1.447 1.447 0 00.43 1.188c.291.291.645.437 1.062.437.417 0 .77-.146 1.063-.438.291-.291.437-.645.437-1.062 0-.417-.146-.77-.438-1.063A1.447 1.447 0 0010.5 6c-.073 0-.146.005-.219.016-.073.01-.14.026-.203.046.177-1.03.542-1.632 1.094-1.804L12 4V3z\"/>\n</svg>\n";

var annotateAlt = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"currentColor\" stroke=\"none\" d=\"M14 0a2 2 0 012 2v13a1 1 0 01-1.555.832l-4.262-1.757A1 1 0 009.802 14H2a2 2 0 01-2-2V2a2 2 0 012-2h12zm-2.109 3.5h-.484l-.14.006-.122.018a.684.684 0 00-.2.071l-.076.054-.108.1-.097.1-1.632 1.999-.091.12-.084.129a2.56 2.56 0 00-.291.722l-.03.142-.027.218-.009.223v2.646l.01.086.027.08a.537.537 0 00.236.236l.067.028.07.016.074.006h2.907l.074-.006.094-.024a.516.516 0 00.169-.108.525.525 0 00.082-.096l.029-.051.027-.081.01-.086V7.336l-.006-.073-.018-.068a.436.436 0 00-.124-.178.549.549 0 00-.103-.074l-.055-.026-.087-.024-.092-.009h-.579l-.057-.006-.054-.017a.307.307 0 01-.096-.07.175.175 0 01-.045-.078l-.004-.04.01-.043.022-.043 1.311-2.227.047-.09.037-.106a.492.492 0 00-.06-.394.531.531 0 00-.255-.22l-.084-.028-.092-.016-.1-.006zm-5.924 0h-.424l-.121.006-.108.018a.552.552 0 00-.174.071l-.067.054-.095.1-.084.1-1.429 1.999-.08.12-.096.174a2.798 2.798 0 00-.232.677l-.025.142-.024.218L3 7.402v2.646l.008.086.024.08a.486.486 0 00.097.148c.035.037.071.066.11.088l.058.028.062.016.065.006h2.543l.065-.006.082-.024a.513.513 0 00.22-.204l.025-.051.024-.081.008-.086V7.336l-.005-.073-.023-.09a.487.487 0 00-.191-.23l-.048-.026-.076-.024-.08-.009H5.46l-.05-.006-.047-.017a.273.273 0 01-.084-.07.182.182 0 01-.04-.078l-.003-.04.008-.043.02-.043L6.411 4.36l.04-.09.033-.106a.553.553 0 00-.053-.394.49.49 0 00-.222-.22l-.074-.028-.08-.016-.089-.006z\"></path></g></svg>";

var arrowDown = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 9l-4 4-4-4m4 3V3v9z\"></path></g></svg>";

var arrowLeft = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M7 12L3 8l4-4M4 8h9-9z\"></path></g></svg>\n";

var arrowRight = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 4l4 4-4 4m3-4H3h9z\"></path></g></svg>\n";

var arrowUp = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 7l4-4 4 4M8 4v9-9z\"></path></g></svg>";

var bookmark = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 1v14l-5-4-5 4V1z\"></path></g></svg>";

var bookmarkFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"currentColor\" stroke=\"none\" d=\"M13 0a1 1 0 01.993.883L14 1v14a1 1 0 01-1.534.846l-.09-.065L8 12.28l-4.375 3.5a1.001 1.001 0 01-1.6-.556l-.02-.112L2 15V1a1 1 0 01.883-.993L3 0h10z\"></path></g></svg>";

var caretDown = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 6l-4 4-4-4\"></path></g></svg>";

var caretLeft = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M10 12L6 8l4-4\"></path></g></svg>";

var caretRight = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M6 4l4 4-4 4\"></path></g></svg>";

var caretUp = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 10l4-4 4 4\"></path></g></svg>";

var caution = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z\"></path><line x1=\"12\" y1=\"9\" x2=\"12\" y2=\"13\"></line><line x1=\"12\" y1=\"17\" x2=\"12.01\" y2=\"17\"></line></svg>";

var ccStd = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"currentColor\" stroke=\"none\" d=\"M7.985 0c2.238 0 4.143.781 5.715 2.343a7.694 7.694 0 011.714 2.579C15.804 5.888 16 6.914 16 8a8.164 8.164 0 01-.579 3.078 7.344 7.344 0 01-1.707 2.536 8.222 8.222 0 01-2.657 1.772c-.99.41-2.014.614-3.071.614a7.775 7.775 0 01-3.036-.607 8.047 8.047 0 01-2.6-1.757A7.846 7.846 0 010 8c0-1.057.202-2.074.607-3.05A8.033 8.033 0 012.371 2.33C3.895.777 5.766 0 7.985 0zm.03 1.443c-1.83 0-3.367.638-4.615 1.914a6.878 6.878 0 00-1.45 2.15A6.301 6.301 0 001.443 8c0 .858.168 1.684.507 2.479a6.627 6.627 0 001.45 2.129 6.593 6.593 0 002.129 1.428c.79.329 1.619.493 2.485.493.857 0 1.688-.166 2.494-.5a6.91 6.91 0 002.178-1.442c1.247-1.22 1.871-2.748 1.871-4.586a6.57 6.57 0 00-.486-2.515 6.397 6.397 0 00-1.413-2.114C11.37 2.086 9.824 1.443 8.014 1.443zm-.1 5.229l-1.073.557c-.114-.238-.254-.405-.42-.5a.95.95 0 00-.465-.143c-.714 0-1.072.472-1.072 1.415 0 .428.09.77.271 1.028.181.257.448.386.8.386.467 0 .796-.229.987-.686l.985.5a2.35 2.35 0 01-2.1 1.257c-.714 0-1.29-.218-1.729-.657-.438-.438-.657-1.047-.657-1.828 0-.762.222-1.367.665-1.814.442-.448 1.002-.672 1.678-.672.991 0 1.7.385 2.13 1.157zm4.613 0l-1.057.557c-.114-.238-.255-.405-.421-.5a.972.972 0 00-.479-.143c-.714 0-1.072.472-1.072 1.415 0 .428.091.77.272 1.028.18.257.447.386.8.386.466 0 .795-.229.985-.686l1 .5c-.218.39-.514.698-.885.922a2.308 2.308 0 01-1.214.335c-.724 0-1.302-.218-1.735-.657-.434-.438-.65-1.047-.65-1.828 0-.762.22-1.367.664-1.814.442-.448 1.002-.672 1.678-.672.99 0 1.696.385 2.114 1.157z\"></path></g></svg>";

var ccStdFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M7.98537477,0 C10.2231597,0 12.1284395,0.781262207 13.6997141,2.34303661 C14.4517258,3.09529836 15.0234847,3.9550618 15.4139908,4.9215769 C15.8042469,5.88834201 16,6.91435804 16,8.000125 C16,9.09539212 15.806747,10.1216582 15.421491,11.0784231 C15.0357349,12.0354381 14.466476,12.8809513 13.7144643,13.6142127 C12.9337021,14.3854748 12.0479382,14.976234 11.0571728,15.3857404 C10.0669073,15.7952468 9.0428913,16 7.98587478,16 C6.92885826,16 5.91684245,15.7979968 4.95007734,15.3927405 C3.98356224,14.9882342 3.1167987,14.402475 2.35003672,13.6359631 C1.58327474,12.8694511 1.00001563,12.0049376 0.600009375,11.0429225 C0.200003125,10.0809075 0,9.06689167 0,8.000125 C0,6.94285848 0.20225316,5.9263426 0.607009485,4.95007734 C1.01176581,3.97381209 1.600025,3.10004844 2.37128705,2.32853638 C3.89506086,0.776512133 5.7663401,0 7.98537477,0 Z M5.7853404,5.5150852 C5.10882983,5.5150852 4.54932108,5.73908967 4.10656417,6.18659667 C3.66380725,6.63435366 3.44230379,7.23886311 3.44230379,8.00087501 C3.44230379,8.78163721 3.66130721,9.39114674 4.09931405,9.82915358 C4.5373209,10.2676604 5.1138299,10.4864139 5.82809106,10.4864139 C6.27584806,10.4864139 6.68560446,10.3746621 7.05661026,10.1506586 C7.37504381,9.95886989 7.63396622,9.70591696 7.8333775,9.39148493 L7.92812388,9.22914421 L6.94260848,8.72913639 C6.7518555,9.18614353 6.42335036,9.41489711 5.95659307,9.41489711 C5.60408756,9.41489711 5.3373334,9.2861451 5.15633057,9.02889108 C4.97557774,8.77163706 4.88507633,8.42913171 4.88507633,8.00062501 C4.88507633,7.05761028 5.24258192,6.58635291 5.95659307,6.58635291 C6.09959531,6.58635291 6.25434772,6.63410366 6.42110033,6.72910514 C6.55430241,6.80530633 6.67070423,6.92742824 6.77056179,7.09495886 L6.84235691,7.22911295 L7.91412366,6.67185425 C7.48536696,5.90034219 6.77610588,5.51458617 5.7853404,5.5150852 Z M10.4139127,5.5150852 C9.73765215,5.5150852 9.17814341,5.73908967 8.73563649,6.18659667 C8.29237957,6.63435366 8.07112611,7.23886311 8.07112611,8.00087501 C8.07112611,8.78163721 8.28762949,9.39114674 8.72163628,9.82915358 C9.15464304,10.2676604 9.73290208,10.4864139 10.4569134,10.4864139 C10.8949202,10.4864139 11.2996766,10.3746621 11.6711824,10.1506586 C11.9803539,9.96419736 12.237094,9.71992271 12.4406793,9.4175453 L12.5564462,9.22914421 L11.5564306,8.72913639 C11.3661776,9.18614353 11.0374225,9.41489711 10.5711652,9.41489711 C10.2181597,9.41489711 9.95165549,9.2861451 9.77090267,9.02889108 C9.59014985,8.77163706 9.49939843,8.42913171 9.49939843,8.00062501 C9.49939843,7.05761028 9.85690401,6.58635291 10.5711652,6.58635291 C10.7229175,6.58635291 10.88267,6.63410366 11.0496727,6.72910514 C11.1828747,6.80530633 11.2995966,6.92742824 11.3994541,7.09495886 L11.4711792,7.22911295 L12.5284458,6.67185425 C12.1096892,5.90034219 11.4044282,5.51458617 10.4139127,5.5150852 Z\"></path></svg>";

var ccZero = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"currentColor\" stroke=\"none\" d=\"M7.983 0c2.238 0 4.148.78 5.72 2.342a7.662 7.662 0 011.715 2.582c.39.962.582 1.99.582 3.076a8.13 8.13 0 01-.583 3.087 7.262 7.262 0 01-1.703 2.526 8.213 8.213 0 01-2.655 1.77c-.99.41-2.018.617-3.076.617a7.902 7.902 0 01-3.042-.6 8.301 8.301 0 01-2.6-1.759A8.087 8.087 0 01.6 11.042 7.84 7.84 0 010 8c0-1.057.2-2.07.6-3.042a8.12 8.12 0 011.77-2.633C3.893.772 5.764 0 7.983 0zm.034 1.44c-1.829 0-3.369.64-4.616 1.915a6.962 6.962 0 00-1.457 2.157 6.388 6.388 0 000 4.969 6.83 6.83 0 003.585 3.558c.79.324 1.62.487 2.488.487.857 0 1.681-.165 2.482-.498a6.88 6.88 0 002.184-1.446C13.931 11.364 14.56 9.838 14.56 8a6.57 6.57 0 00-.487-2.515 6.418 6.418 0 00-1.418-2.118C11.37 2.081 9.826 1.44 8.017 1.44zM8 3.395c2.641 0 3.305 2.492 3.305 4.605 0 2.113-.664 4.605-3.305 4.605S4.694 10.113 4.694 8l.007-.355c.073-2.027.804-4.25 3.299-4.25zm1.316 3.227L7.35 10.017c-.274.412-.083.645.219.774l.135.044c.091.022.19.034.297.034 1.357 0 1.422-1.938 1.422-2.869l-.007-.409a7.282 7.282 0 00-.06-.72l-.04-.25zM8 5.132c-1.258 0-1.406 1.66-1.421 2.646L6.577 8c0 .24.005.544.035.865l.027.244 1.759-3.232c.182-.316.09-.542-.101-.706A1.222 1.222 0 008 5.13z\"></path></g></svg>";

var ccZeroFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M7.98325,0 C10.22125,0 12.13125,0.77975 13.70325,2.34175 C14.4555,3.09425 15.027,3.953 15.4175,4.92425 C15.8075,5.8865 16,6.91425 16,8 C16,9.09575 15.8075,10.125 15.41725,11.08675 C15.0365,12.039 14.467,12.88 13.71425,13.61325 C12.933,14.385 12.0495,14.97375 11.059,15.3835 C10.06825,15.79325 9.0405,15.99975 7.98325,15.99975 C6.92575,15.99975 5.9125,15.80075 4.941,15.40025 C3.97875,14.99075 3.11275,14.40325 2.3415,13.641 C1.5795,12.87 0.99925,12.0045 0.59925,11.042 C0.19925,10.08 0,9.067 0,8 C0,6.94275 0.19925,5.92975 0.59925,4.958 C1.009,3.97675 1.598,3.09675 2.36975,2.325 C3.8935,0.7725 5.764,0 7.98325,0 Z M8,3.395 C5.58107744,3.395 4.82033452,5.48533799 4.70940247,7.46012326 L4.70087556,7.64485352 L4.6945,8 L4.70087337,8.35518364 L4.70087337,8.35518364 L4.72089438,8.7144321 C4.86646914,10.6360123 5.652,12.605 8,12.605 C10.641,12.605 11.30525,10.113 11.30525,8 C11.30525,5.88725 10.641,3.395 8,3.395 Z M9.3165,6.62175 L9.35676736,6.87076968 C9.37957986,7.03692014 9.39473958,7.20226042 9.40471875,7.36028125 L9.41611111,7.59100926 L9.42267213,8.10741209 L9.42267213,8.10741209 L9.41475695,8.47041107 L9.41475695,8.47041107 L9.39995748,8.73740123 L9.39995748,8.73740123 L9.37404324,9.01600457 L9.37404324,9.01600457 L9.33401712,9.29903864 C9.19778738,10.1004619 8.85553704,10.86875 8.0005,10.86875 C7.92916667,10.86875 7.86161111,10.86375 7.79738889,10.8536759 L7.7035,10.83475 L7.569,10.7905 C7.28976923,10.6716538 7.10597041,10.4641923 7.29524761,10.1091259 L7.3505,10.01725 L9.3165,6.62175 Z M8,5.1315 C8.10725,5.1315 8.205,5.148 8.297,5.17075 C8.46611111,5.31652778 8.55838272,5.51149074 8.44862414,5.77460185 L8.39775,5.8765 L6.63875,9.109 L6.611592,8.86531 C6.589368,8.62408 6.581022,8.39248 6.578238,8.19076 L6.57856145,7.77758895 L6.58524468,7.52944923 L6.58524468,7.52944923 L6.60004801,7.26251269 L6.60004801,7.26251269 L6.62596977,6.98396115 L6.62596977,6.98396115 L6.66600828,6.70097644 C6.80228121,5.89968896 7.14464815,5.1315 8,5.1315 Z\"></path></svg>";

var check = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 3L6 13 3 8\"></path></g></svg>\n";

var collapse = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 11l-4 4 4-4zm-3-1h4v4m9-13l-4 4 4-4zm-1 5h-4V2\"></path></g></svg>";

var contrast = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M8 1C4.5 1 1 4.5 1 8s3.5 7 7 7 7-3.5 7-7-3.5-7-7-7zM7 2v12M6 2v12M4 3v10M2 5v6\"></path></g></svg>";

var copy = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 15H1V5h3m11-4v10H7V1h8z\"></path></g></svg>";

var copyFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M1,16 C0.487164161,16 0.0644928393,15.6139598 0.00672773133,15.1166211 L0,15 L0,5 C0,4.48716416 0.38604019,4.06449284 0.883378875,4.00672773 L1,4 L4,4 C4.55228475,4 5,4.44771525 5,5 L5,13 L9,13 C9.55228475,13 10,13.4477153 10,14 L10,15 C10,15.5128358 9.61395981,15.9355072 9.11662113,15.9932723 L9,16 L1,16 Z M15,0 C15.5128358,0 15.9355072,0.38604019 15.9932723,0.883378875 L16,1 L16,11 C16,11.5128358 15.6139598,11.9355072 15.1166211,11.9932723 L15,12 L7,12 C6.48716416,12 6.06449284,11.6139598 6.00672773,11.1166211 L6,11 L6,1 C6,0.487164161 6.38604019,0.0644928393 6.88337887,0.00672773133 L7,0 L15,0 Z\"></path></svg>";

var edit = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M11 4l1 1-9 9-2 1 1-2 9-9zm3-3l1 1-1 1-1-1 1-1z\"></path></g></svg>\n";

var editorLatex = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"currentColor\" stroke=\"none\" d=\"M13.392 16c.158 0 .299-.036.423-.108.123-.073.185-.155.185-.248v-1.778c0-.099-.062-.183-.185-.252a.848.848 0 00-.423-.104H6.85c-.138 0-.227-.028-.267-.083-.04-.055-.04-.105 0-.152l5.533-5.101c.158-.14.223-.265.193-.378a.755.755 0 00-.193-.325L6.88 2.707c-.04-.046-.042-.094-.007-.143.034-.05.13-.074.289-.074h6.17a.782.782 0 00.416-.108c.119-.073.178-.155.178-.248V.356c0-.093-.06-.175-.178-.248A.782.782 0 0013.333 0H2.905c-.158 0-.3.036-.423.108-.124.073-.185.155-.185.248v1.943c0 .128.037.236.11.326l.171.204 5.31 4.815c.04.047.065.106.075.178a.221.221 0 01-.074.195l-5.622 5.154c-.04.047-.094.113-.163.2A.512.512 0 002 13.7v1.943c0 .093.062.175.185.248a.822.822 0 00.423.108h10.784z\"></path></g></svg>";

var editorQuote = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"currentColor\" stroke=\"none\" d=\"M2.701 14c.38 0 .659-.085.837-.255.177-.17.328-.343.45-.52l2.408-3.25c.246-.328.445-.725.598-1.19a4.69 4.69 0 00.23-1.475V2.775a.752.752 0 00-.23-.539A.713.713 0 006.47 2H1.947a.713.713 0 00-.524.236.752.752 0 00-.23.539v4.649c0 .214.077.396.23.548a.726.726 0 00.524.226h.901c.123 0 .23.054.322.161.092.107.101.224.028.35l-2.041 3.817c-.196.365-.208.702-.037 1.011.172.309.447.463.827.463h.754zm7.795 0c.367 0 .64-.085.818-.255.178-.17.328-.343.45-.52l2.409-3.25c.257-.328.46-.725.606-1.19A4.87 4.87 0 0015 7.31V2.775a.752.752 0 00-.23-.539.713.713 0 00-.524-.236H9.742a.703.703 0 00-.533.236.767.767 0 00-.22.539v4.649c0 .214.076.396.23.548a.726.726 0 00.523.226h.9c.123 0 .228.054.313.161.086.107.092.224.019.35L8.95 12.526c-.208.365-.223.702-.045 1.011.177.309.456.463.836.463h.754z\"></path></g></svg>";

var editorTextBold = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"currentColor\" stroke=\"none\" d=\"M8.661 16c.805 0 1.536-.117 2.193-.351a4.953 4.953 0 001.69-.993c.47-.428.831-.947 1.081-1.557s.375-1.287.375-2.03c0-.29-.038-.588-.114-.893a4.123 4.123 0 00-.325-.87 3.937 3.937 0 00-.495-.754 4.412 4.412 0 00-.604-.597c-.17-.126-.17-.264 0-.412.381-.335.699-.772.953-1.311.254-.54.382-1.062.382-1.568 0-.64-.132-1.244-.394-1.813a4.628 4.628 0 00-1.081-1.484c-.458-.42-1-.753-1.627-.999A5.531 5.531 0 008.66 0h-6.14a.534.534 0 00-.362.14A.415.415 0 002 .456v15.086c0 .119.053.225.159.318.106.093.227.139.362.139h6.14zm-.127-9.852H5.826c-.17 0-.254-.075-.254-.223V3.437c0-.157.085-.235.254-.235h2.708c.45 0 .847.145 1.195.435.347.29.521.633.521 1.027 0 .394-.174.74-.521 1.038a1.784 1.784 0 01-1.195.446zm0 6.65H5.826c-.17 0-.254-.075-.254-.223v-2.99c0-.157.085-.235.254-.235h2.708c.56 0 1.004.177 1.335.53.33.353.495.75.495 1.188 0 .454-.165.856-.495 1.205-.33.35-.776.525-1.335.525z\"></path></g></svg>";

var editorTextItalic = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"currentColor\" stroke=\"none\" d=\"M10.61 16c.12 0 .23-.046.329-.14a.633.633 0 00.191-.317l.457-2.176a.348.348 0 00-.064-.313.336.336 0 00-.276-.133H8.845c-.142-.008-.198-.086-.17-.235l1.892-9.372c.035-.149.124-.223.266-.223H13a.49.49 0 00.335-.14.62.62 0 00.196-.318L13.99.457a.542.542 0 00.011-.1.337.337 0 00-.085-.223.336.336 0 00-.276-.134H5.805a.49.49 0 00-.335.14.62.62 0 00-.196.317l-.457 2.176a.353.353 0 00.069.318c.074.093.168.14.281.14h2.18c.141 0 .198.074.17.223l-1.893 9.372c-.028.156-.113.235-.255.235H2.967a.489.489 0 00-.324.133.59.59 0 00-.197.313l-.435 2.176a.542.542 0 00-.011.1c0 .082.025.156.074.223.071.09.16.134.266.134h8.27z\"></path></g></svg>";

var ellipsis = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M2 9a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm6 0a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm6 0a1 1 0 1 1 0-2 1 1 0 0 1 0 2z\"></path></g></svg>";

var email = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M1 3v10h14V3H1zm0 0l7 6 7-6H1z\"></path></g></svg>";

var emailFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M0.0310424035,3.64706271 L7.7,9.4 L7.77988338,9.44897959 C7.91852932,9.5170068 8.08147068,9.5170068 8.22011662,9.44897959 L8.3,9.4 L15.9691358,3.64806483 L15.9921737,3.82184812 L15.9921737,3.82184812 L16,4 L16,12 C16,13.0543618 15.1841222,13.9181651 14.1492623,13.9945143 L14,14 L2,14 C0.945638205,14 0.0818348781,13.1841222 0.00548573643,12.1492623 L-8.8817842e-16,12 L-8.8817842e-16,4 C-8.8817842e-16,3.87957173 0.0106439466,3.76162949 0.0310424035,3.64706271 Z M14,2 C14.6181536,2 15.1708071,2.2804391 15.5376736,2.7210303 L8,8.375 L0.462326444,2.7210303 C0.792506267,2.32449822 1.27317359,2.05768934 1.81663922,2.00829289 L2,2 L14,2 Z\"></path></svg>";

var expand = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M2 14l4-4-4 4zm3 1H1v-4m13-9l-4 4 4-4zm-3-1h4v4\"></path></g></svg>";

var external = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M7 3h6v6m-1-5l-9 9 9-9z\"></path></g></svg>";

var fileCode = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M12.3333333,0 C12.4649846,0 12.5913236,0.0519229236 12.684928,0.144498701 L14.8515947,2.28735584 C14.9465603,2.38127786 15,2.5092914 15,2.64285714 L15,15.5 C15,15.7761424 14.7761424,16 14.5,16 L1.5,16 C1.22385763,16 1,15.7761424 1,15.5 L1,0.5 C1,0.223857625 1.22385763,0 1.5,0 L12.3333333,0 Z M11,1 L2,1 L2,15 L14,15 L14,4 L11.5,4 C11.2238576,4 11,3.77614237 11,3.5 L11,1 Z M6.53033009,5.46966991 C6.79659665,5.73593648 6.8208027,6.15260016 6.60294824,6.44621165 L6.53033009,6.53033009 L5.061,8 L6.53033009,9.46966991 C6.79659665,9.73593648 6.8208027,10.1526002 6.60294824,10.4462117 L6.53033009,10.5303301 C6.26406352,10.7965966 5.84739984,10.8208027 5.55378835,10.6029482 L5.46966991,10.5303301 L3.46966991,8.53033009 C3.20340335,8.26406352 3.1791973,7.84739984 3.39705176,7.55378835 L3.46966991,7.46966991 L5.46966991,5.46966991 C5.76256313,5.1767767 6.23743687,5.1767767 6.53033009,5.46966991 Z M10.4462117,5.39705176 L10.5303301,5.46966991 L12.5303301,7.46966991 L12.6029482,7.55378835 C12.7965966,7.81477634 12.7989874,8.17299076 12.6101204,8.4363794 L12.5303301,8.53033009 L10.5303301,10.5303301 L10.4462117,10.6029482 C10.1852237,10.7965966 9.82700924,10.7989874 9.5636206,10.6101204 L9.46966991,10.5303301 L9.39705176,10.4462117 C9.20340335,10.1852237 9.20101263,9.82700924 9.3898796,9.5636206 L9.46966991,9.46966991 L10.939,8 L9.46966991,6.53033009 L9.39705176,6.44621165 C9.1791973,6.15260016 9.20340335,5.73593648 9.46966991,5.46966991 C9.73593648,5.20340335 10.1526002,5.1791973 10.4462117,5.39705176 Z\"></path></svg>";

var fileCodeFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M11,0 L11,3.5 C11,3.74545989 11.1768752,3.94960837 11.4101244,3.99194433 L11.5,4 L15,4 L15,15.5 C15,15.7761424 14.7761424,16 14.5,16 L1.5,16 C1.22385763,16 1,15.7761424 1,15.5 L1,0.5 C1,0.223857625 1.22385763,0 1.5,0 L11,0 Z M6.53033009,5.46966991 C6.23743687,5.1767767 5.76256313,5.1767767 5.46966991,5.46966991 L5.46966991,5.46966991 L3.46966991,7.46966991 L3.39705176,7.55378835 C3.1791973,7.84739984 3.20340335,8.26406352 3.46966991,8.53033009 L3.46966991,8.53033009 L5.46966991,10.5303301 L5.55378835,10.6029482 C5.84739984,10.8208027 6.26406352,10.7965966 6.53033009,10.5303301 L6.53033009,10.5303301 L6.60294824,10.4462117 C6.8208027,10.1526002 6.79659665,9.73593648 6.53033009,9.46966991 L6.53033009,9.46966991 L5.061,8 L6.53033009,6.53033009 L6.60294824,6.44621165 C6.8208027,6.15260016 6.79659665,5.73593648 6.53033009,5.46966991 Z M10.4462117,5.39705176 C10.1526002,5.1791973 9.73593648,5.20340335 9.46966991,5.46966991 C9.20340335,5.73593648 9.1791973,6.15260016 9.39705176,6.44621165 L9.39705176,6.44621165 L9.46966991,6.53033009 L10.939,8 L9.46966991,9.46966991 L9.3898796,9.5636206 C9.20101263,9.82700924 9.20340335,10.1852237 9.39705176,10.4462117 L9.39705176,10.4462117 L9.46966991,10.5303301 L9.5636206,10.6101204 C9.82700924,10.7989874 10.1852237,10.7965966 10.4462117,10.6029482 L10.4462117,10.6029482 L10.5303301,10.5303301 L12.5303301,8.53033009 L12.6101204,8.4363794 C12.7989874,8.17299076 12.7965966,7.81477634 12.6029482,7.55378835 L12.6029482,7.55378835 L12.5303301,7.46966991 L10.5303301,5.46966991 Z M12.3333333,0 C12.4649846,0 12.5913236,0.0519229236 12.684928,0.144498701 L14.8515947,2.28735584 C14.9465603,2.38127786 15,2.5092914 15,2.64285714 L15,3 L12.25,3 C12.1119288,3 12,2.88807119 12,2.75 L12,0 L12.3333333,0 Z\"></path></svg>";

var fileGeneric = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M12.3333333,0 C12.4649846,0 12.5913236,0.0519229236 12.684928,0.144498701 L14.8515947,2.28735584 C14.9465603,2.38127786 15,2.5092914 15,2.64285714 L15,15.5 C15,15.7761424 14.7761424,16 14.5,16 L1.5,16 C1.22385763,16 1,15.7761424 1,15.5 L1,0.5 C1,0.223857625 1.22385763,0 1.5,0 L12.3333333,0 Z M11,1 L2,1 L2,15 L14,15 L14,4 L11.5,4 C11.2238576,4 11,3.77614237 11,3.5 L11,1 Z M7.25,10.5 C7.66421356,10.5 8,10.8357864 8,11.25 C8,11.6642136 7.66421356,12 7.25,12 L4.75,12 C4.33578644,12 4,11.6642136 4,11.25 C4,10.8357864 4.33578644,10.5 4.75,10.5 L7.25,10.5 Z M11.25,7.75 C11.6642136,7.75 12,8.08578644 12,8.5 C12,8.91421356 11.6642136,9.25 11.25,9.25 L4.75,9.25 C4.33578644,9.25 4,8.91421356 4,8.5 C4,8.08578644 4.33578644,7.75 4.75,7.75 L11.25,7.75 Z M11.25,5 C11.6642136,5 12,5.33578644 12,5.75 C12,6.16421356 11.6642136,6.5 11.25,6.5 L4.75,6.5 C4.33578644,6.5 4,6.16421356 4,5.75 C4,5.33578644 4.33578644,5 4.75,5 L11.25,5 Z\"></path></svg>";

var fileGenericFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M11,0 L11,3.5 C11,3.74545989 11.1768752,3.94960837 11.4101244,3.99194433 L11.5,4 L15,4 L15,15.5 C15,15.7761424 14.7761424,16 14.5,16 L1.5,16 C1.22385763,16 1,15.7761424 1,15.5 L1,0.5 C1,0.223857625 1.22385763,0 1.5,0 L11,0 Z M7.25,10.5 L4.75,10.5 C4.33578644,10.5 4,10.8357864 4,11.25 C4,11.6642136 4.33578644,12 4.75,12 L4.75,12 L7.25,12 C7.66421356,12 8,11.6642136 8,11.25 C8,10.8357864 7.66421356,10.5 7.25,10.5 L7.25,10.5 Z M11.25,7.75 L4.75,7.75 C4.33578644,7.75 4,8.08578644 4,8.5 C4,8.91421356 4.33578644,9.25 4.75,9.25 L4.75,9.25 L11.25,9.25 C11.6642136,9.25 12,8.91421356 12,8.5 C12,8.08578644 11.6642136,7.75 11.25,7.75 L11.25,7.75 Z M11.25,5 L4.75,5 C4.33578644,5 4,5.33578644 4,5.75 C4,6.16421356 4.33578644,6.5 4.75,6.5 L4.75,6.5 L11.25,6.5 C11.6642136,6.5 12,6.16421356 12,5.75 C12,5.33578644 11.6642136,5 11.25,5 L11.25,5 Z M12.3333333,0 C12.4649846,0 12.5913236,0.0519229236 12.684928,0.144498701 L14.8515947,2.28735584 C14.9465603,2.38127786 15,2.5092914 15,2.64285714 L15,3 L12.25,3 C12.1119288,3 12,2.88807119 12,2.75 L12,0 L12.3333333,0 Z\"></path></svg>";

var fileImage = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M12.3333333,0 C12.4649846,0 12.5913236,0.0519229236 12.684928,0.144498701 L14.8515947,2.28735584 C14.9465603,2.38127786 15,2.5092914 15,2.64285714 L15,15.5 C15,15.7761424 14.7761424,16 14.5,16 L1.5,16 C1.22385763,16 1,15.7761424 1,15.5 L1,0.5 C1,0.223857625 1.22385763,0 1.5,0 L12.3333333,0 Z M11,1 L2,1 L2,15 L14,15 L14,4 L11.5,4 C11.2238576,4 11,3.77614237 11,3.5 L11,1 Z M9.54145248,5.12213937 L9.59648295,5.19084277 L12.9293307,10.3336999 C13.0985213,10.594775 12.9458527,10.9370896 12.6629375,10.992329 L12.5826935,11 L9.22956549,11.000554 C9.38101295,10.7046385 9.37898764,10.3284054 9.15394288,10.0197277 L7.36454649,7.564 L8.90320872,5.19084277 C9.05162037,4.96183145 9.3608727,4.93893031 9.54145248,5.12213937 Z M6.18902068,6.81798942 L6.2502829,6.88571429 L8.74991868,10.3142857 C8.94005528,10.5750825 8.78770602,10.9386856 8.49312613,10.9930813 L8.41663391,11 L3.41736235,11 C3.10046801,11 2.90911637,10.6564582 3.04356266,10.3813883 L3.08407757,10.3142857 L5.58371336,6.88571429 C5.73183992,6.68253968 6.01163454,6.65996473 6.18902068,6.81798942 Z\"></path></svg>";

var fileImageFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M11,0 L11,3.5 C11,3.74545989 11.1768752,3.94960837 11.4101244,3.99194433 L11.5,4 L15,4 L15,15.5 C15,15.7761424 14.7761424,16 14.5,16 L1.5,16 C1.22385763,16 1,15.7761424 1,15.5 L1,0.5 C1,0.223857625 1.22385763,0 1.5,0 L11,0 Z M9.54145248,5.12213937 C9.38093712,4.95928688 9.11875456,4.95928688 8.9582392,5.12213937 L8.90320872,5.19084277 L7.36454649,7.564 L9.15394288,10.0197277 C9.35398266,10.2941079 9.37780955,10.6218651 9.2742684,10.8991436 L9.22956549,11.000554 L12.5826935,11 L12.6629375,10.992329 C12.9201332,10.9421113 13.069687,10.6546415 12.9676376,10.4066397 L12.9293307,10.3336999 L9.59648295,5.19084277 L9.54145248,5.12213937 Z M6.18902068,6.81798942 C6.03380781,6.67971781 5.80018845,6.67971781 5.64497558,6.81798942 L5.58371336,6.88571429 L3.08407757,10.3142857 L3.04356266,10.3813883 C2.92032023,10.6335357 3.07083856,10.9432185 3.34087012,10.9930813 L3.41736235,11 L8.41663391,11 L8.49312613,10.9930813 C8.7631577,10.9432185 8.91367603,10.6335357 8.7904336,10.3813883 L8.74991868,10.3142857 L6.2502829,6.88571429 L6.18902068,6.81798942 Z M12.3333333,0 C12.4649846,0 12.5913236,0.0519229236 12.684928,0.144498701 L14.8515947,2.28735584 C14.9465603,2.38127786 15,2.5092914 15,2.64285714 L15,3 L12.25,3 C12.1119288,3 12,2.88807119 12,2.75 L12,0 L12.3333333,0 Z\"></path></svg>";

var filePdf = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M12.3333333,0 C12.4649846,0 12.5913236,0.0519229236 12.684928,0.144498701 L14.8515947,2.28735584 C14.9465603,2.38127786 15,2.5092914 15,2.64285714 L15,15.5 C15,15.7761424 14.7761424,16 14.5,16 L1.5,16 C1.22385763,16 1,15.7761424 1,15.5 L1,0.5 C1,0.223857625 1.22385763,0 1.5,0 L12.3333333,0 Z M11,1 L2,1 L2,15 L14,15 L14,4 L11.5,4 C11.2238576,4 11,3.77614237 11,3.5 L11,1 Z M7.44899868,3 C7.72116887,3 8.49231776,3.2739726 8.53767946,4.50684932 L8.53439997,4.7114967 L8.53439997,4.7114967 L8.52112076,4.92880771 C8.48445506,5.34358194 8.37135323,5.86149163 8.03870077,6.69863014 C8.2371582,6.98401826 8.45333505,7.26940639 8.72045521,7.58823844 L9.06757852,7.98903039 C9.13021665,8.05921804 9.19542409,8.13127854 9.26346664,8.20547945 L9.3917552,8.34175228 L9.3917552,8.34175228 L9.61431103,8.59717466 C9.64904108,8.63641553 9.68306236,8.67351598 9.71708363,8.70776256 L10.0799772,8.70776256 C11.1232963,8.70776256 11.9398069,8.89041096 12.4387856,9.16438356 C13.1192111,9.57534247 13.0284877,10.260274 12.9377643,10.5342466 C12.8470409,10.7625571 12.529509,11.173516 11.8490835,11.173516 C11.7129984,11.173516 11.5315516,11.173516 11.3501048,11.0821918 C10.9018245,10.9693795 10.5458372,10.7636631 9.85144216,10.0824957 L9.53186977,9.76034228 C9.47473601,9.70142674 9.41556175,9.63980661 9.35419004,9.57534247 C8.85521135,9.62100457 8.31087096,9.71232877 7.76653057,9.80365297 C7.31291358,9.89497717 6.90465829,9.98630137 6.5417647,10.1232877 C6.46011364,10.2846271 6.38128509,10.4364282 6.3051984,10.5792728 L6.08508327,10.9815187 C6.04974147,11.0442753 6.01506497,11.1049383 5.9810437,11.1635802 L5.7846981,11.4917622 C5.7532574,11.5426112 5.72245177,11.5915846 5.69227112,11.6387553 L5.51860638,11.9007272 C5.49088534,11.9409775 5.46376912,11.9795704 5.43724765,12.0165787 L5.28517507,12.2201945 L5.28517507,12.2201945 L5.14689245,12.3892694 L5.14689245,12.3892694 L5.02191593,12.5272941 C5.00216847,12.5479046 4.98295527,12.5673668 4.96426625,12.5857534 L4.85834165,12.6837477 L4.85834165,12.6837477 L4.76451349,12.7594182 L4.76451349,12.7594182 L4.68229793,12.8162557 L4.68229793,12.8162557 L4.61121111,12.8577507 L4.61121111,12.8577507 L4.50048824,12.9086758 L4.50048824,12.9086758 L4.25666911,12.9714612 C4.18295635,12.9885845 4.1149138,13 4.04687125,13 C3.6476883,13 3.39366279,12.76621 3.23834433,12.5791781 L3.13963727,12.4520548 L3.13963727,12.4520548 L3.09240884,12.3626097 C2.96547075,12.0890129 2.86242689,11.5388128 3.54789256,10.8082192 L3.74466613,10.6154123 C3.77007533,10.5915914 3.79678638,10.5670456 3.82491931,10.5418492 L4.01173971,10.3834585 C4.38904601,10.0809436 4.96744691,9.71770078 5.90670091,9.39269406 C6.08814771,8.98173516 6.3149562,8.57077626 6.496403,8.11415525 C6.57200583,7.94672755 6.64256847,7.78437341 6.70809093,7.62878404 L6.88953772,7.18400135 L6.88953772,7.18400135 L7.04074339,6.78995434 L7.04074339,6.78995434 C6.4510413,5.83105023 6.3603179,5.10045662 6.3603179,4.27853881 C6.3603179,3.3196347 7.04074339,3 7.44899868,3 Z M5.22627543,10.6712329 C4.81348397,10.8949772 4.55628313,11.096347 4.37687761,11.2596804 L4.18295635,11.4474886 L4.18295635,11.4474886 C3.97126842,11.6605784 3.92422666,11.8184227 3.91377293,11.9210215 L3.91078615,11.9954338 L3.91078615,11.9954338 L4.00150955,12.0410959 L3.95614785,12.0410959 L3.98449892,12.0639269 C4.00150955,12.0753425 4.0241904,12.086758 4.04687125,12.086758 C4.04687125,12.1324201 4.09223295,12.1324201 4.13759465,12.086758 L4.15950435,12.080411 L4.15950435,12.080411 L4.19856077,12.0578995 L4.19856077,12.0578995 L4.25558043,12.0140183 L4.25558043,12.0140183 L4.33137983,11.9435616 L4.33137983,11.9435616 L4.42677548,11.8413242 L4.42677548,11.8413242 L4.5425839,11.7021005 L4.5425839,11.7021005 L4.67962159,11.5206849 C4.70427567,11.4866438 4.72984833,11.4506279 4.75635658,11.4125285 L4.92676914,11.1580651 L4.92676914,11.1580651 L5.12045225,10.8483961 C5.15471735,10.791895 5.18998607,10.7328767 5.22627543,10.6712329 Z M10.6243176,9.62100457 L10.8681367,9.83959073 C11.2304003,10.1524607 11.3879062,10.2222222 11.5769133,10.260274 L11.6442471,10.2674087 L11.6442471,10.2674087 L11.761904,10.2988014 C11.7782058,10.3030822 11.7923814,10.3059361 11.8037218,10.3059361 C11.9851686,10.3059361 12.075892,10.260274 12.075892,10.2146119 C12.1061331,10.1232877 12.0557312,10.0522577 12.0053293,10.0015221 L11.9398069,9.94063927 L11.9398069,9.94063927 L11.8251535,9.88433584 L11.8251535,9.88433584 L11.6890477,9.82767909 C11.6622478,9.81751579 11.6333625,9.80710309 11.6023505,9.79660725 L11.3904286,9.73396475 C11.1920099,9.68314825 10.9383601,9.63856691 10.6243176,9.62100457 Z M7.67580717,7.70319635 L7.67580717,7.74885845 L7.4334056,8.32034817 C7.40647209,8.38812785 7.38095613,8.456621 7.35827528,8.52511416 L7.2278604,8.793379 C7.18816891,8.87899543 7.15414764,8.95890411 7.13146679,9.02739726 L7.17682848,9.02739726 L7.08610509,9.07305936 L7.33559443,9.01027397 C7.4149774,8.99315068 7.49436038,8.98173516 7.58508378,8.98173516 L7.84945743,8.94035388 L7.84945743,8.94035388 L8.34418346,8.84046804 L8.34418346,8.84046804 L8.58304116,8.79908676 C8.43788372,8.6347032 8.30724202,8.47762557 8.18530978,8.32785388 L7.83983508,7.90045662 C7.78467525,7.83287671 7.73024121,7.76712329 7.67580717,7.70319635 Z M7.44899868,3.91324201 C7.35827528,3.95890411 7.31291358,4.09589041 7.31291358,4.32420091 C7.26755188,4.73515982 7.31291358,5.10045662 7.49436038,5.64840183 C7.61532491,5.28310502 7.65564642,5.01927955 7.66908692,4.81633688 L7.67555828,4.6321852 C7.67580717,4.60437454 7.67580717,4.57787925 7.67580717,4.55251142 C7.67580717,4.14155251 7.53972208,3.95890411 7.44899868,3.91324201 Z\"></path></svg>";

var filePdfFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M11,0 L11,3.5 C11,3.74545989 11.1768752,3.94960837 11.4101244,3.99194433 L11.5,4 L15,4 L15,15.5 C15,15.7761424 14.7761424,16 14.5,16 L1.5,16 C1.22385763,16 1,15.7761424 1,15.5 L1,0.5 C1,0.223857625 1.22385763,0 1.5,0 L11,0 Z M7.44899868,3 C7.04074339,3 6.3603179,3.3196347 6.3603179,4.27853881 C6.3603179,5.10045662 6.4510413,5.83105023 7.04074339,6.78995434 L6.88953772,7.18400135 L6.88953772,7.18400135 L6.70809093,7.62878404 C6.64256847,7.78437341 6.57200583,7.94672755 6.496403,8.11415525 C6.3149562,8.57077626 6.08814771,8.98173516 5.90670091,9.39269406 C4.96744691,9.71770078 4.38904601,10.0809436 4.01173971,10.3834585 L3.82491931,10.5418492 L3.82491931,10.5418492 L3.67222406,10.6846257 L3.67222406,10.6846257 L3.54789256,10.8082192 L3.54789256,10.8082192 C2.86242689,11.5388128 2.96547075,12.0890129 3.09240884,12.3626097 L3.13963727,12.4520548 L3.13963727,12.4520548 L3.23834433,12.5791781 C3.39366279,12.76621 3.6476883,13 4.04687125,13 C4.1149138,13 4.18295635,12.9885845 4.25666911,12.9714612 L4.50048824,12.9086758 L4.50048824,12.9086758 L4.61121111,12.8577507 L4.61121111,12.8577507 L4.68229793,12.8162557 L4.68229793,12.8162557 L4.76451349,12.7594182 L4.76451349,12.7594182 L4.85834165,12.6837477 L4.85834165,12.6837477 L4.96426625,12.5857534 L4.96426625,12.5857534 L5.08277117,12.4619449 C5.10359723,12.438965 5.12496763,12.4147641 5.14689245,12.3892694 L5.28517507,12.2201945 L5.28517507,12.2201945 L5.43724765,12.0165787 L5.43724765,12.0165787 L5.60359404,11.7749315 C5.6325348,11.7312938 5.66209047,11.6859259 5.69227112,11.6387553 L5.88093547,11.333516 C5.94637728,11.2241705 6.01439967,11.107032 6.08508327,10.9815187 L6.3051984,10.5792728 C6.38128509,10.4364282 6.46011364,10.2846271 6.5417647,10.1232877 C6.90465829,9.98630137 7.31291358,9.89497717 7.76653057,9.80365297 C8.31087096,9.71232877 8.85521135,9.62100457 9.35419004,9.57534247 L9.53186977,9.76034228 L9.53186977,9.76034228 L9.85144216,10.0824957 C10.5458372,10.7636631 10.9018245,10.9693795 11.3501048,11.0821918 C11.5315516,11.173516 11.7129984,11.173516 11.8490835,11.173516 C12.529509,11.173516 12.8470409,10.7625571 12.9377643,10.5342466 C13.0284877,10.260274 13.1192111,9.57534247 12.4387856,9.16438356 C11.9813884,8.91324201 11.2571763,8.73883815 10.3360293,8.71151488 L10.0799772,8.70776256 L9.71708363,8.70776256 L9.61431103,8.59717466 L9.61431103,8.59717466 L9.3917552,8.34175228 C9.35135493,8.29680365 9.30882834,8.25114155 9.26346664,8.20547945 L9.06757852,7.98903039 L9.06757852,7.98903039 L8.72045521,7.58823844 C8.45333505,7.26940639 8.2371582,6.98401826 8.03870077,6.69863014 C8.37135323,5.86149163 8.48445506,5.34358194 8.52112076,4.92880771 L8.53439997,4.7114967 L8.53439997,4.7114967 L8.53767946,4.50684932 L8.53767946,4.50684932 C8.49231776,3.2739726 7.72116887,3 7.44899868,3 Z M5.22627543,10.6712329 L5.02065084,11.0104566 C4.988376,11.062032 4.95708776,11.1111986 4.92676914,11.1580651 L4.75635658,11.4125285 L4.75635658,11.4125285 L4.60839805,11.616992 L4.60839805,11.616992 L4.48207706,11.776661 L4.48207706,11.776661 L4.37657709,11.8967409 L4.37657709,11.8967409 L4.29108163,11.9824372 C4.27845407,11.9941438 4.266626,12.0046347 4.25558043,12.0140183 L4.19856077,12.0578995 L4.19856077,12.0578995 L4.15950435,12.080411 L4.15950435,12.080411 L4.13759465,12.086758 L4.13759465,12.086758 C4.09223295,12.1324201 4.04687125,12.1324201 4.04687125,12.086758 C4.0241904,12.086758 4.00150955,12.0753425 3.98449892,12.0639269 L3.95614785,12.0410959 L4.00150955,12.0410959 L3.91078615,11.9954338 L3.91377293,11.9210215 C3.92422666,11.8184227 3.97126842,11.6605784 4.18295635,11.4474886 L4.37687761,11.2596804 C4.55628313,11.096347 4.81348397,10.8949772 5.22627543,10.6712329 Z M10.6243176,9.62100457 C10.9383601,9.63856691 11.1920099,9.68314825 11.3904286,9.73396475 L11.6023505,9.79660725 C11.6333625,9.80710309 11.6622478,9.81751579 11.6890477,9.82767909 L11.8750575,9.9079255 L11.8750575,9.9079255 L11.9398069,9.94063927 L11.9398069,9.94063927 L12.0053293,10.0015221 C12.0557312,10.0522577 12.1061331,10.1232877 12.075892,10.2146119 C12.075892,10.260274 11.9851686,10.3059361 11.8037218,10.3059361 L11.761904,10.2988014 L11.761904,10.2988014 L11.6442471,10.2674087 C11.622275,10.2631279 11.5995941,10.260274 11.5769133,10.260274 C11.4068069,10.2260274 11.2622165,10.1660959 10.9709093,9.92636986 L10.7530787,9.7382251 C10.7125209,9.70186454 10.6696793,9.66286149 10.6243176,9.62100457 Z M7.67580717,7.70319635 L7.83983508,7.90045662 L7.83983508,7.90045662 L8.18530978,8.32785388 C8.2462759,8.40273973 8.30941939,8.47945205 8.37546602,8.55799087 L8.58304116,8.79908676 L8.34418346,8.84046804 L7.84945743,8.94035388 C7.76369547,8.95605023 7.67580717,8.97031963 7.58508378,8.98173516 C7.49436038,8.98173516 7.4149774,8.99315068 7.33559443,9.01027397 L7.08610509,9.07305936 L7.17682848,9.02739726 L7.13146679,9.02739726 C7.15414764,8.95890411 7.18816891,8.87899543 7.2278604,8.793379 L7.35827528,8.52511416 L7.35827528,8.52511416 L7.4334056,8.32034817 L7.4334056,8.32034817 L7.67580717,7.74885845 L7.67580717,7.70319635 Z M7.44899868,3.91324201 C7.53972208,3.95890411 7.67580717,4.14155251 7.67580717,4.55251142 L7.67381599,4.71975121 C7.66684684,4.93415638 7.63548566,5.22222222 7.49436038,5.64840183 C7.31291358,5.10045662 7.26755188,4.73515982 7.31291358,4.32420091 C7.31291358,4.09589041 7.35827528,3.95890411 7.44899868,3.91324201 Z M12.3333333,0 C12.4649846,0 12.5913236,0.0519229236 12.684928,0.144498701 L14.8515947,2.28735584 C14.9465603,2.38127786 15,2.5092914 15,2.64285714 L15,3 L12.25,3 C12.1119288,3 12,2.88807119 12,2.75 L12,0 L12.3333333,0 Z\"></path></svg>";

var filter = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M1 3h14H1zm4 10h6-6zM3 8h10H3z\"></path></g></svg>";

var flag = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M3 9v6V1h12l-4 4 4 4H3z\"></path></g></svg>";

var flagFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"currentColor\" stroke=\"none\" d=\"M2 1a1 1 0 01.883-.993L3 0h12c.852 0 1.297.986.783 1.623l-.076.084L12.415 5l3.292 3.293c.575.575.253 1.523-.485 1.684l-.108.017L15 10H4v5a1 1 0 01-1.993.117L2 15V1z\"></path></g></svg>";

var folder = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M4.5,1 C5.08477209,1 5.59138843,1.33462455 5.83881221,1.82283684 L5.89516355,1.9479849 L5.913,2 L14.5,2 C15.2309651,2 15.8398119,2.52285085 15.9729528,3.21496507 L15.9931334,3.35553999 L16,3.5 L16,13.5 C16,14.2796961 15.4051119,14.9204487 14.64446,14.9931334 L14.5,15 L1.5,15 C0.720303883,15 0.0795513218,14.4051119 0.00686657806,13.64446 L0,13.5 L0,2.5 C0,1.72030388 0.594888083,1.07955132 1.35553999,1.00686658 L1.5,1 L4.5,1 Z M15,5 L1,5 L1,13.5 C1,13.7454599 1.17687516,13.9496084 1.41012437,13.9919443 L1.5,14 L14.5,14 C14.7454599,14 14.9496084,13.8231248 14.9919443,13.5898756 L15,13.5 L15,5 Z M4.5,2 L1.5,2 C1.25454011,2 1.05039163,2.17687516 1.00805567,2.41012437 L1,2.5 L1,4 L15,4 L15,3.5 C15,3.25454011 14.8231248,3.05039163 14.5898756,3.00805567 L14.5,3 L5.5,3 C5.25454011,3 5.05039163,2.82312484 5.00805567,2.58987563 L4.99194433,2.41012437 C4.95490037,2.20603131 4.79396869,2.04509963 4.58987563,2.00805567 L4.5,2 Z\"></path></svg>";

var folderFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M16,5 L16,13.5 C16,14.2796961 15.4051119,14.9204487 14.64446,14.9931334 L14.5,15 L1.5,15 C0.720303883,15 0.0795513218,14.4051119 0.00686657806,13.64446 L0,13.5 L0,5 L16,5 Z M0,2.5 C0,1.72030388 0.594888083,1.07955132 1.35553999,1.00686658 L1.5,1 L4.5,1 C5.15321869,1 5.70891488,1.41754351 5.91475048,2.00029246 L14.5,2 C15.2796961,2 15.9204487,2.59488808 15.9931334,3.35553999 L16,3.5 L16,4 L0,4 L0,2.5 Z\"></path></svg>";

var folderOpen = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M5.5,1 C6.08477209,1 6.59138843,1.33462455 6.83881221,1.82283684 L6.89516355,1.9479849 L6.913,2 L13.5,2 C14.2309651,2 14.8398119,2.52285085 14.9729528,3.21496507 L14.9931334,3.35553999 L15,3.5 L15.0010598,4.13322895 C15.4776831,4.34981658 15.8213063,4.81001691 15.8751588,5.36132835 L15.8825437,5.51383039 L15.8781572,5.61042101 L15,13.5 C15,14.2796961 14.4051119,14.9204487 13.64446,14.9931334 L13.5,15 L2.5,15 C1.72030388,15 1.07955132,14.4051119 1.00941616,13.6904938 L1.00305813,13.5552158 L0.126439413,5.66564729 C0.0530908166,5.00550992 0.41993647,4.39791149 0.999710191,4.1351147 L1,2.5 C1,1.72030388 1.59488808,1.07955132 2.35553999,1.00686658 L2.5,1 L5.5,1 Z M1.593,5 L1.56204925,5.00305813 C1.31809066,5.03016464 1.1347234,5.22850242 1.11840444,5.46500023 L1.12032315,5.55521576 L2,13.5 C2,13.7454599 2.17687516,13.9496084 2.41012437,13.9919443 L2.5,14 L13.5,14 C13.7454599,14 13.9496084,13.8231248 13.9940847,13.5511627 L14.0030476,13.4448794 L14.8813961,5.54147 L14.882735,5.5 C14.882735,5.25454011 14.7058598,5.05039163 14.4726106,5.00805567 L14.382735,5 L1.593,5 Z M5.5,2 L2.5,2 C2.25454011,2 2.05039163,2.17687516 2.00805567,2.41012437 L2,2.5 L2,4 L14,4 L14,3.5 C14,3.2852226 13.86458,3.10207424 13.6744662,3.03128126 L13.5898756,3.00805567 L13.5,3 L6.5,3 C6.25454011,3 6.05039163,2.82312484 6.00805567,2.58987563 L6,2.5 C6,2.25454011 5.82312484,2.05039163 5.58987563,2.00805567 L5.5,2 Z\"></path></svg>";

var folderOpenFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M5.5,1 C6.1335031,1 6.67528173,1.39271909 6.89516355,1.9479849 L6.913,2 L13.5,2 C14.2796961,2 14.9204487,2.59488808 14.9931334,3.35553999 L15,3.5 L15.000587,4.13275264 C15.5208051,4.36820732 15.882735,4.89183703 15.882735,5.5 L15.8804396,5.58295058 L15.8804396,5.58295058 L15.8735606,5.66564729 L15,13.5 C15,14.2796961 14.4051119,14.9204487 13.64446,14.9931334 L13.5,15 L2.5,15 C1.72030388,15 1.07955132,14.4051119 1.00941616,13.6904938 L1.00305813,13.5552158 L0.126439413,5.66564729 C0.0528213209,5.00308446 0.422638124,4.39344735 0.998935589,4.13292877 L1,2.5 C1,1.72030388 1.59488808,1.07955132 2.35553999,1.00686658 L2.5,1 L5.5,1 Z M5.5,2 L2.5,2 C2.25454011,2 2.05039163,2.17687516 2.00805567,2.41012437 L2,2.5 L1.99913273,4 L13.9991327,4 L14,3.5 C14,3.25454011 13.8231248,3.05039163 13.5898756,3.00805567 L13.5,3 L6.5,3 C6.25454011,3 6.05039163,2.82312484 6.00805567,2.58987563 L6,2.5 C6,2.25454011 5.82312484,2.05039163 5.58987563,2.00805567 L5.5,2 Z\"></path></svg>";

var globe = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\n  <path fill=\"currentColor\" fill-rule=\"nonzero\" d=\"M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0zm2.655 11.535c.244-.242.442-.719.442-1.063a1.13 1.13 0 0 0-.288-.696l-.442-.442a1.033 1.033 0 0 0-.73-.302H7.484C7.181 8.88 6.791 8 6.452 8c-.34 0-.674-.08-.978-.231l-.357-.179a.386.386 0 0 1-.213-.345c0-.153.118-.317.263-.366l1.006-.335a.618.618 0 0 1 .163-.026c.106 0 .258.056.338.126l.3.26c.046.04.106.063.169.063h.182a.258.258 0 0 0 .23-.373l-.503-1.006a.306.306 0 0 1-.027-.116c0-.06.035-.143.078-.185l.32-.31a.258.258 0 0 1 .18-.074h.29c.06 0 .141-.034.183-.076l.258-.258c.1-.1.1-.264 0-.364l-.151-.152c-.101-.1-.101-.264 0-.365l.333-.333.151-.151a.516.516 0 0 0 0-.73l-.912-.913a6.45 6.45 0 0 0-.787.078v.365a.516.516 0 0 1-.747.461l-.775-.387a6.487 6.487 0 0 0-3.329 3.287c.32.474.813 1.205 1.116 1.65.138.203.4.503.582.668l.026.023c.308.278.65.516 1.021.702.452.227 1.111.586 1.575.842.328.182.53.527.53.903v1.032c0 .274.11.537.303.73.484.484.785 1.246.73 1.653v.884c.473 0 .932-.055 1.376-.152l.56-1.511c.067-.177.106-.362.155-.544a.771.771 0 0 1 .199-.346l.365-.364zm2.797-2.946l.94.235c.036-.27.06-.544.06-.824a6.4 6.4 0 0 0-.688-2.882l-.419.21a.773.773 0 0 0-.298.263l-.632.947a.908.908 0 0 0-.13.43c0 .13.058.321.13.43l.58.87c.107.16.27.274.457.32z\"/>\n</svg>";

var globeAlt = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 0c1.105 0 2-3.134 2-7s-.895-7-2-7-2 3.134-2 7 .895 7 2 7zm6.272-9.61C13.127 6.049 10.748 6.501 8 6.501S2.873 6.05 1.728 5.39m12.544 5.221C13.127 9.953 10.748 9.5 8 9.5s-5.127.453-6.272 1.111\"></path></g></svg>";

var groups = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M1 15a3 3 0 0 1 6 0m2-4a3 3 0 0 1 6 0M4 9a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm8-4a2 2 0 1 1 0-4 2 2 0 0 1 0 4z\"></path></g></svg>";

var groupsFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M4,11 C6.209139,11 8,12.790861 8,15 C8,15.5128358 7.61395981,15.9355072 7.11662113,15.9932723 L7,16 L1,16 C0.44771525,16 0,15.5522847 0,15 C0,12.790861 1.790861,11 4,11 Z M12,7 C14.209139,7 16,8.790861 16,11 C16,11.5128358 15.6139598,11.9355072 15.1166211,11.9932723 L15,12 L9,12 C8.44771525,12 8,11.5522847 8,11 C8,8.790861 9.790861,7 12,7 Z M4,4 C5.65685425,4 7,5.34314575 7,7 C7,8.65685425 5.65685425,10 4,10 C2.34314575,10 1,8.65685425 1,7 C1,5.34314575 2.34314575,4 4,4 Z M12,0 C13.6568542,0 15,1.34314575 15,3 C15,4.65685425 13.6568542,6 12,6 C10.3431458,6 9,4.65685425 9,3 C9,1.34314575 10.3431458,0 12,0 Z\"></path></svg>";

var help = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M8 15a1 1 0 1 1 0-2 1 1 0 0 1 0 2zM4 4.5C4 2.567 5.79 1 8 1s4 1.567 4 3.5S10.21 8 8 8m0 0v1.5V8z\"></path></g></svg>";

var hide = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M1.61289944,0.209704612 L1.70710678,0.292893219 L15.7071068,14.2928932 C16.0976311,14.6834175 16.0976311,15.3165825 15.7071068,15.7071068 C15.3466228,16.0675907 14.7793918,16.0953203 14.3871006,15.7902954 L14.2928932,15.7071068 L0.292893219,1.70710678 C-0.0976310729,1.31658249 -0.0976310729,0.683417511 0.292893219,0.292893219 C0.65337718,-0.0675907428 1.22060824,-0.0953202783 1.61289944,0.209704612 Z M2.19604887,5.05494269 C2.65878442,5.35642943 2.78950241,5.97595401 2.48801567,6.43868956 C2.16488794,6.93464068 2,7.46139686 2,8 C2,10.1228856 4.62796016,12 8,12 C8.22060643,12 8.4396701,11.9919023 8.65660209,11.9758355 C9.20737829,11.9350431 9.68693944,12.3484666 9.72773191,12.8992428 C9.76852437,13.450019 9.35510087,13.9295801 8.80432467,13.9703726 C8.53822524,13.9900809 8.26988704,14 8,14 C3.64005335,14 0,11.3999619 0,8 C0,7.06308249 0.28281658,6.15958778 0.812302005,5.34690949 C1.11378875,4.88417394 1.73331332,4.75345595 2.19604887,5.05494269 Z M8,2 C12.3599467,2 16,4.6000381 16,8 C16,8.93691751 15.7171834,9.84041222 15.187698,10.6530905 C14.8862113,11.1158261 14.2666867,11.246544 13.8039511,10.9450573 C13.3412156,10.6435706 13.2104976,10.024046 13.5119843,9.56131044 C13.8351121,9.06535932 14,8.53860314 14,8 C14,5.8771144 11.3720398,4 8,4 C7.77939357,4 7.5603299,4.00809769 7.34339791,4.02416445 C6.79262171,4.06495692 6.31306056,3.65153342 6.27226809,3.10075722 C6.23147563,2.54998102 6.64489913,2.07041987 7.19567533,2.02962741 C7.46177476,2.00991913 7.73011296,2 8,2 Z\"></path></svg>";

var hideFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M1.61289944,0.209704612 L1.70710678,0.292893219 L15.7071068,14.2928932 C16.0976311,14.6834175 16.0976311,15.3165825 15.7071068,15.7071068 C15.3466228,16.0675907 14.7793918,16.0953203 14.3871006,15.7902954 L14.2928932,15.7071068 L0.292893219,1.70710678 C-0.0976310729,1.31658249 -0.0976310729,0.683417511 0.292893219,0.292893219 C0.65337718,-0.0675907428 1.22060824,-0.0953202783 1.61289944,0.209704612 Z M1.57493899,4.40449804 L5.00453586,7.83361728 L5,8 L5,8 C5,9.65685425 6.34314575,11 8,11 L8.166,10.994 L10.7974423,13.6264349 C9.92342583,13.8686663 8.97989462,14 8,14 C3.64005335,14 0,11.3999619 0,8 C0,6.63325914 0.58820946,5.39578088 1.57493899,4.40449804 Z M8,2 C12.3599467,2 16,4.6000381 16,8 C16,9.36674086 15.4117905,10.6042191 14.425061,11.595502 L10.9954672,8.1663265 L11,8 L11,8 C11,6.34314575 9.65685425,5 8,5 L7.833,5.005 L5.20154887,2.37384475 C6.0758481,2.13143476 7.01972836,2 8,2 Z\"></path></svg>";

var highlight = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 15H1h11zm-.5-6v2l-1 1v-2l1-1zm.5-7v6h-2V2h2zm0-1h-2 2zm0 8h-2 2z\"></path></g></svg>";

var image = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15 1v14H1V1h14zM1 15l3-8 4 6 3-4 4 6m-4-9a1 1 0 110-2 1 1 0 010 2z\"></path></g></svg>";

var imageFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M14,0 C15.1045695,0 16,0.8954305 16,2 L16,2 L16,14 C16,15.1045695 15.1045695,16 14,16 L14,16 L2,16 C0.8954305,16 0,15.1045695 0,14 L0,14 L0,2 C0,0.8954305 0.8954305,0 2,0 L2,0 Z M9.54145248,5.12213937 C9.3608727,4.93893031 9.05162037,4.96183145 8.90320872,5.19084277 L8.90320872,5.19084277 L7.36454649,7.564 L9.15394288,10.0197277 C9.37898764,10.3284054 9.38101295,10.7046385 9.22956549,11.000554 L9.22956549,11.000554 L12.5826935,11 L12.6629375,10.992329 C12.9458527,10.9370896 13.0985213,10.594775 12.9293307,10.3336999 L12.9293307,10.3336999 L9.59648295,5.19084277 Z M6.18902068,6.81798942 C6.01163454,6.65996473 5.73183992,6.68253968 5.58371336,6.88571429 L5.58371336,6.88571429 L3.08407757,10.3142857 L3.04356266,10.3813883 C2.90911637,10.6564582 3.10046801,11 3.41736235,11 L3.41736235,11 L8.41663391,11 L8.49312613,10.9930813 C8.78770602,10.9386856 8.94005528,10.5750825 8.74991868,10.3142857 L8.74991868,10.3142857 L6.2502829,6.88571429 Z\"></path></svg>";

var leave = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M8,0 C12.0522847,0 16,3.94771525 16,8 C16,12.0522847 12.0522847,16 8,16 C3.94771525,16 0,12.0522847 0,8 C0,3.94771525 3.94771525,0 8,0 Z M8,2 C5.05228475,2 2,5.05228475 2,8 C2,10.9477153 5.05228475,14 8,14 C10.9477153,14 14,10.9477153 14,8 C14,5.05228475 10.9477153,2 8,2 Z M10.7864022,6.62017694 L10.7071068,6.70710678 L9.415,8 L10.7071068,9.29289322 C11.0976311,9.68341751 11.0976311,10.3165825 10.7071068,10.7071068 C10.3466228,11.0675907 9.77939176,11.0953203 9.38710056,10.7902954 L9.29289322,10.7071068 L8,9.415 L6.70710678,10.7071068 C5.79286771,11.6213459 4.43536121,10.3192478 5.21359778,9.37982306 L5.29289322,9.29289322 L6.585,8 L5.29289322,6.70710678 C4.90236893,6.31658249 4.90236893,5.68341751 5.29289322,5.29289322 C5.65337718,4.93240926 6.22060824,4.90467972 6.61289944,5.20970461 L6.70710678,5.29289322 L8,6.585 L9.29289322,5.29289322 C10.2071323,4.37865415 11.5646388,5.68075222 10.7864022,6.62017694 Z\"></path></svg>";

var leaveFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M8,0 C12.0522847,0 16,3.94771525 16,8 C16,12.0522847 12.0522847,16 8,16 C3.94771525,16 0,12.0522847 0,8 C0,3.94771525 3.94771525,0 8,0 Z M6.61289944,5.20970461 C6.25329917,4.93009846 5.74670083,4.93009846 5.38710056,5.20970461 L5.38710056,5.20970461 L5.29289322,5.29289322 L5.20970461,5.38710056 C4.93009846,5.74670083 4.93009846,6.25329917 5.20970461,6.61289944 L5.20970461,6.61289944 L5.29289322,6.70710678 L6.585,8 L5.29289322,9.29289322 L5.20970461,9.38710056 C4.90467972,9.77939176 4.93240926,10.3466228 5.29289322,10.7071068 L5.29289322,10.7071068 L5.38710056,10.7902954 C5.77939176,11.0953203 6.34662282,11.0675907 6.70710678,10.7071068 L6.70710678,10.7071068 L8,9.415 L9.29289322,10.7071068 L9.38710056,10.7902954 C9.77939176,11.0953203 10.3466228,11.0675907 10.7071068,10.7071068 C11.0976311,10.3165825 11.0976311,9.68341751 10.7071068,9.29289322 L10.7071068,9.29289322 L9.415,8 L10.7071068,6.70710678 L10.7902954,6.61289944 C11.0953203,6.22060824 11.0675907,5.65337718 10.7071068,5.29289322 C10.3466228,4.93240926 9.77939176,4.90467972 9.38710056,5.20970461 L9.38710056,5.20970461 L9.29289322,5.29289322 L8,6.585 L6.70710678,5.29289322 Z\"></path></svg>";

var link = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M9.68027557,6.09714063 C10.0850762,6.47284645 10.1086623,7.10557198 9.73295644,7.51037264 C9.35725062,7.9151733 8.72452509,7.93875933 8.31972443,7.56305351 C7.52101725,6.821753 6.4700536,6.81243414 5.66500421,7.53509692 L2.58706553,11.1273971 L2.50815798,11.2094765 C1.81384474,11.8538863 1.84803625,12.885989 2.50815798,13.4986648 C3.17004601,14.1129799 4.31769172,14.1788096 5.06581128,13.6063341 L5.156,13.529 L6.16163376,12.3189006 C6.48720494,11.9265987 7.04943452,11.8464869 7.46827399,12.1138931 L7.56977663,12.1880051 C7.96207853,12.5135762 8.04219031,13.0758058 7.77478412,13.4946453 L7.70067217,13.5961479 L6.64329964,14.8702449 L6.554056,14.9645777 C5.02884562,16.3801643 2.59807851,16.3107974 1.14760683,14.9645777 C-0.293859995,13.6267155 -0.415580233,11.3582822 0.996093014,9.89228498 L1.095,9.794 L4.19491885,6.17921998 L4.2738264,6.09714063 C5.8499647,4.63428646 8.10413728,4.63428646 9.68027557,6.09714063 Z M14.8523932,1.03542234 C16.29386,2.37328448 16.4155802,4.64171776 15.003907,6.10771502 L14.904,6.205 L11.7857496,9.84275726 L11.7261736,9.90285937 C10.1500353,11.3657135 7.89586272,11.3657135 6.31972443,9.90285937 C5.91492376,9.52715355 5.89133773,8.89442802 6.26704356,8.48962736 C6.64274938,8.0848267 7.27547491,8.06124067 7.68027557,8.43694649 C8.47898275,9.178247 9.5299464,9.18756586 10.3349958,8.46490308 L13.4129345,4.87260289 L13.491842,4.79052353 C14.1861553,4.1461137 14.1519637,3.11401104 13.491842,2.50133522 C12.829954,1.88702005 11.6823083,1.82119037 10.9341887,2.39366585 L10.843,2.47 L9.83836624,3.6810994 C9.51279506,4.0734013 8.95056548,4.15351308 8.53172601,3.88610689 L8.43022337,3.81199494 C8.03792147,3.48642376 7.95780969,2.92419418 8.22521588,2.5053547 L8.29932783,2.40385206 L9.35670036,1.12975511 L9.445944,1.03542234 C10.9711544,-0.380164327 13.4019215,-0.310797434 14.8523932,1.03542234 Z\"></path></svg>";

var listOrdered = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M2.74823068,11.5 C2.97524895,11.5 3.1905939,11.5343408 3.39366257,11.603155 C3.59684892,11.6720091 3.77524112,11.7672163 3.92811884,11.8888526 C4.08261947,12.0117802 4.20418892,12.156176 4.29187398,12.3213933 C4.38099535,12.489317 4.42568877,12.6706965 4.42568877,12.8637096 C4.42568877,13.0343925 4.38425005,13.1965655 4.30193102,13.3483633 C4.2490321,13.4459099 4.1864049,13.5350392 4.1129322,13.6165937 L4.04984615,13.678 L4.09689729,13.7134462 C4.1440201,13.7542692 4.18757668,13.798784 4.2275306,13.8469317 L4.28475493,13.9218707 L4.36039919,14.0444001 C4.45317113,14.2160007 4.5,14.3957363 4.5,14.5818816 C4.5,14.7829974 4.45212751,14.9723959 4.35676927,15.1481679 C4.26309551,15.320835 4.13497752,15.4708273 3.973323,15.5974593 C3.8136645,15.7225277 3.62857226,15.8208403 3.41870764,15.8924562 C3.20845593,15.9642041 2.98476013,16 2.74823068,16 C2.51170124,16 2.28800544,15.9642041 2.07775373,15.8924562 C1.86788911,15.8208403 1.68279687,15.7225277 1.52313837,15.5974593 C1.36129205,15.4706771 1.23362688,15.3204523 1.14109689,15.1474913 C1.07063396,15.015779 1.02649843,14.8764526 1.00883459,14.7302917 L1,14.5818816 L1.00164157,14.5040028 L1.01140889,14.4539704 C1.02582527,14.4107075 1.05279311,14.3734256 1.08945882,14.3425177 C1.12493487,14.3126126 1.16582677,14.2925055 1.21036894,14.2824235 L1.27969922,14.2748479 L1.98756339,14.275596 L2.03880852,14.2818104 C2.08219582,14.2912785 2.12219058,14.3102242 2.15757967,14.3377172 C2.20307663,14.3730626 2.23398517,14.4185737 2.24659587,14.4705773 L2.25296992,14.5246092 L2.25258047,14.5718213 L2.25807808,14.6486267 C2.27079066,14.7268552 2.30703478,14.7869418 2.3704462,14.83505 C2.45795803,14.9014424 2.58255226,14.9363441 2.74823068,14.9363441 C2.90942468,14.9363441 3.03317339,14.9014105 3.12354059,14.834251 C3.20476584,14.7738856 3.24349145,14.6939404 3.24349145,14.5818816 C3.24349145,14.4698229 3.20476584,14.3898777 3.12354059,14.3295123 C3.05576519,14.2791427 2.96921269,14.2469001 2.86216869,14.2339269 L2.74823068,14.2274192 L2.64842249,14.226608 L2.59661089,14.2200403 C2.55268483,14.2100552 2.5123734,14.1901638 2.47690455,14.1614608 C2.43271565,14.1257011 2.40232873,14.081078 2.38989708,14.0303367 L2.38360435,13.9776578 L2.38524592,13.4072363 L2.39501324,13.3572039 C2.40942962,13.313941 2.43639745,13.2766591 2.47306317,13.2457512 C2.50853922,13.2158461 2.54943112,13.195739 2.59397329,13.1856571 L2.66330356,13.1780814 L2.73975563,13.1783439 L2.85168659,13.171719 C2.9437197,13.159688 3.01749149,13.1309337 3.07554665,13.0860883 C3.14630362,13.0314312 3.17979611,12.9612082 3.17979611,12.8637096 C3.17979611,12.7707791 3.14699089,12.703807 3.07678781,12.650869 C2.99833824,12.5917126 2.89023521,12.5607923 2.74823068,12.5607923 C2.61090557,12.5607923 2.5044056,12.5916531 2.4243983,12.6513063 C2.37106807,12.6910692 2.33912383,12.7385788 2.32648485,12.7989128 L2.32020389,12.8637096 L2.31842543,12.9739248 L2.3080742,13.0246617 C2.2929189,13.0683229 2.26484596,13.1055802 2.22690369,13.1362848 C2.19123111,13.1651527 2.15096982,13.1848449 2.10763134,13.1947655 L2.04050468,13.2022432 L1.32851348,13.201432 L1.27670188,13.1948643 C1.23277582,13.1848792 1.19246439,13.1649878 1.15699554,13.1362848 C1.11280664,13.1005251 1.08241973,13.055902 1.06998808,13.0051607 L1.06369534,12.9524818 L1.06393749,12.8557746 L1.07242996,12.7209412 C1.08997955,12.5797335 1.13393935,12.4455677 1.2039704,12.3192694 C1.29496951,12.155156 1.41713001,12.0116018 1.56968036,11.8891974 C1.72150283,11.7673769 1.89945766,11.6720615 2.1027988,11.603155 C2.30586747,11.5343408 2.52121242,11.5 2.74823068,11.5 Z M15,13 C15.5522847,13 16,13.4477153 16,14 C16,14.5128358 15.6139598,14.9355072 15.1166211,14.9932723 L15,15 L7,15 C6.44771525,15 6,14.5522847 6,14 C6,13.4871642 6.38604019,13.0644928 6.88337887,13.0067277 L7,13 L15,13 Z M2.7773794,5.5 C3.01061163,5.5 3.23063146,5.5337146 3.43690633,5.60133257 C3.64413053,5.66926173 3.82577219,5.7650503 3.98104183,5.88877206 C4.13710704,6.01312774 4.26121525,6.15905988 4.35251855,6.32596194 C4.4458521,6.49657529 4.49269883,6.68102126 4.49269883,6.87734324 C4.49269883,7.06676157 4.44420922,7.24780552 4.34808196,7.41850518 C4.27840068,7.54224292 4.19235414,7.65579573 4.08998064,7.75916145 L3.98216624,7.8591314 L2.70907692,8.93164706 L4.22978618,8.93317541 L4.2819717,8.93938021 C4.32589213,8.9488175 4.3664409,8.96773068 4.4024143,8.99524839 C4.44854332,9.0305346 4.48037077,9.07558051 4.49340143,9.12731154 L4.5,9.18115708 L4.49816677,9.77015236 L4.48750644,9.82162448 C4.47195889,9.86572783 4.44325396,9.90323894 4.40450989,9.93411094 C4.36826988,9.96298765 4.327482,9.98264611 4.28362146,9.99254322 L4.21571056,10 L1.26963414,9.99921332 L1.21688863,9.99265811 C1.17242832,9.98270676 1.1315541,9.9628474 1.09549011,9.93411094 C1.0503175,9.89811655 1.01919062,9.8530851 1.00645046,9.80173694 L1,9.74838397 L1.00023177,9.03667757 L1.00355503,8.98666953 C1.00929123,8.94324778 1.02217372,8.90475398 1.04484149,8.87164013 L1.07818082,8.82870401 L1.07818082,8.82870401 L1.11259372,8.79570542 L3.0410264,7.16741642 L3.07654241,7.13085815 C3.10025944,7.10314083 3.12742004,7.06517228 3.15746767,7.01728725 C3.19525076,6.95707469 3.21225554,6.90816349 3.21225554,6.87152553 C3.21225554,6.79090998 3.18100574,6.72355114 3.1131028,6.66181443 C3.04506831,6.5999581 2.94635937,6.5675501 2.81023468,6.5675501 C2.64713406,6.5675501 2.52518911,6.59993944 2.44117557,6.66093246 C2.38470254,6.70193134 2.35127551,6.74944837 2.33809157,6.80847605 L2.3315515,6.87152553 L2.32971827,6.99510388 L2.31905794,7.046576 C2.30351039,7.09067935 2.27480546,7.12819046 2.23606139,7.15906246 C2.19982138,7.18793917 2.1590335,7.20759763 2.11517296,7.21749474 L2.04726206,7.22495152 L1.32074236,7.22416484 L1.26799684,7.21760963 C1.22353654,7.20765828 1.18266232,7.18779892 1.14659833,7.15906246 C1.10142571,7.12306807 1.07029883,7.07803662 1.05755868,7.02668846 L1.05110821,6.97333549 L1.05135795,6.86928498 L1.06011863,6.73232654 C1.07821769,6.58893392 1.12354325,6.45272403 1.19572508,6.32454589 C1.28957677,6.15788712 1.41614427,6.01221295 1.57458539,5.88808592 C1.73194983,5.7648024 1.91380696,5.66924767 2.11943393,5.60141275 C2.3245881,5.53373381 2.54408196,5.5 2.7773794,5.5 Z M15,7 C15.5522847,7 16,7.44771525 16,8 C16,8.51283584 15.6139598,8.93550716 15.1166211,8.99327227 L15,9 L7,9 C6.44771525,9 6,8.55228475 6,8 C6,7.48716416 6.38604019,7.06449284 6.88337887,7.00672773 L7,7 L15,7 Z M3.23683366,0.000892565676 L3.28871073,0.00783402044 C3.33286644,0.0183677239 3.37314954,0.0392281526 3.40833624,0.0691110527 C3.45125131,0.105557407 3.4804697,0.15047096 3.49239669,0.201063483 L3.49842676,0.25344573 L3.49415385,3.42 L4.23779051,3.42095615 L4.28908093,3.4275216 C4.33270312,3.43751177 4.37269953,3.45739525 4.40784121,3.48604614 C4.45172591,3.52182516 4.48162288,3.56677356 4.49382857,3.61775241 L4.5,3.67062515 L4.498507,4.26621158 L4.48924681,4.31635115 C4.4754812,4.35970406 4.44942679,4.39750461 4.41369292,4.42911668 C4.37842528,4.46031631 4.3374287,4.48142013 4.29262358,4.49202272 L4.22279954,4.5 L1.28941458,4.49910743 L1.23753751,4.49216598 C1.1933818,4.48163228 1.1530987,4.46077185 1.117912,4.43088895 C1.07499693,4.39444259 1.04577855,4.34952904 1.03385155,4.29893652 L1.02782148,4.24655427 L1.02933048,3.65086338 L1.03870489,3.60058458 C1.05277955,3.55675636 1.07953979,3.51887873 1.11617316,3.48776722 C1.15134466,3.45789723 1.19194091,3.4377942 1.23617227,3.42771107 L1.30502194,3.42013291 L2.23738462,3.42211765 L2.23953846,1.46329412 L1.44368956,2.09185679 L1.37612125,2.12885556 C1.31383831,2.15121761 1.2470982,2.14957471 1.18010744,2.12726371 C1.08916935,2.09697716 1.02846344,2.03286164 1.0078186,1.94807494 L1,1.88081467 L1.00024153,1.29400722 L1.00681164,1.20546936 L1.0220171,1.13018676 C1.03500364,1.08276189 1.06008142,1.03856361 1.09493964,0.997770613 L1.15427346,0.939157422 L1.98428355,0.180994532 L2.02561691,0.145157104 C2.05782836,0.119624731 2.0953492,0.0943348848 2.13827642,0.0690384205 C2.19137322,0.0377491519 2.25228164,0.0174951656 2.32051982,0.00746909355 L2.42831415,0 L3.23683366,0.000892565676 Z M15,1 C15.5522847,1 16,1.44771525 16,2 C16,2.51283584 15.6139598,2.93550716 15.1166211,2.99327227 L15,3 L7,3 C6.44771525,3 6,2.55228475 6,2 C6,1.48716416 6.38604019,1.06449284 6.88337887,1.00672773 L7,1 L15,1 Z\"></path></svg>";

var listUnordered = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M2,12 C3.1045695,12 4,12.8954305 4,14 C4,15.1045695 3.1045695,16 2,16 C0.8954305,16 0,15.1045695 0,14 C0,12.8954305 0.8954305,12 2,12 Z M15,13 C15.5522847,13 16,13.4477153 16,14 C16,14.5128358 15.6139598,14.9355072 15.1166211,14.9932723 L15,15 L7,15 C6.44771525,15 6,14.5522847 6,14 C6,13.4871642 6.38604019,13.0644928 6.88337887,13.0067277 L7,13 L15,13 Z M2,6 C3.1045695,6 4,6.8954305 4,8 C4,9.1045695 3.1045695,10 2,10 C0.8954305,10 0,9.1045695 0,8 C0,6.8954305 0.8954305,6 2,6 Z M15,7 C15.5522847,7 16,7.44771525 16,8 C16,8.51283584 15.6139598,8.93550716 15.1166211,8.99327227 L15,9 L7,9 C6.44771525,9 6,8.55228475 6,8 C6,7.48716416 6.38604019,7.06449284 6.88337887,7.00672773 L7,7 L15,7 Z M2,0 C3.1045695,0 4,0.8954305 4,2 C4,3.1045695 3.1045695,4 2,4 C0.8954305,4 0,3.1045695 0,2 C0,0.8954305 0.8954305,0 2,0 Z M15,1 C15.5522847,1 16,1.44771525 16,2 C16,2.51283584 15.6139598,2.93550716 15.1166211,2.99327227 L15,3 L7,3 C6.44771525,3 6,2.55228475 6,2 C6,1.48716416 6.38604019,1.06449284 6.88337887,1.00672773 L7,1 L15,1 Z\"></path></svg>";

var list = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M15,12 C15.5522847,12 16,12.4477153 16,13 C16,13.5128358 15.6139598,13.9355072 15.1166211,13.9932723 L15,14 L1,14 C0.44771525,14 0,13.5522847 0,13 C0,12.4871642 0.38604019,12.0644928 0.883378875,12.0067277 L1,12 L15,12 Z M15,7 C15.5522847,7 16,7.44771525 16,8 C16,8.51283584 15.6139598,8.93550716 15.1166211,8.99327227 L15,9 L1,9 C0.44771525,9 0,8.55228475 0,8 C0,7.48716416 0.38604019,7.06449284 0.883378875,7.00672773 L1,7 L15,7 Z M15,2 C15.5522847,2 16,2.44771525 16,3 C16,3.51283584 15.6139598,3.93550716 15.1166211,3.99327227 L15,4 L1,4 C0.44771525,4 0,3.55228475 0,3 C0,2.48716416 0.38604019,2.06449284 0.883378875,2.00672773 L1,2 L15,2 Z\"></path></svg>";

var lock = "<svg width=\"14\" height=\"16\" viewBox=\"0 0 48 56\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n    <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <g fill=\"currentColor\">\n            <rect x=\"0\" y=\"24\" width=\"48\" height=\"32\"></rect>\n            <path d=\"M24,0 C24,0 8,0 8,16 L8,32 L16,32 L16,16.0000004 C16,8 24,8 24,8 C24,8 32,8 32,16 L32,32 L40,32 L40,16 C40,0 24,0 24,0 Z\"></path>\n        </g>\n    </g>\n</svg>";

var lockAltFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M15,7 C15.5128358,7 15.9355072,7.38604019 15.9932723,7.88337887 L16,8 L16,15 C16,15.5128358 15.6139598,15.9355072 15.1166211,15.9932723 L15,16 L1,16 C0.487164161,16 0.0644928393,15.6139598 0.00672773133,15.1166211 L0,15 L0,8 C0,7.48716416 0.38604019,7.06449284 0.883378875,7.00672773 L1,7 L15,7 Z M8,0 C10.6887547,0 12.8818181,2.12230671 12.9953805,4.78311038 L13,5 L13,5.5 C13,5.77614237 12.7761424,6 12.5,6 L11.5,6 C11.2238576,6 11,5.77614237 11,5.5 L11,5 C11,3.34314575 9.65685425,2 8,2 C6.40231912,2 5.09633912,3.24891996 5.00509269,4.82372721 L5,5 L5,5.5 C5,5.77614237 4.77614237,6 4.5,6 L3.5,6 C3.22385763,6 3,5.77614237 3,5.5 L3,5 C3,2.23857625 5.23857625,0 8,0 Z\"></path></svg>";

var logout = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M9,0 C9.55228475,0 10,0.44771525 10,1 C10,1.51283584 9.61395981,1.93550716 9.11662113,1.99327227 L9,2 L1.999,2 L1.999,14 L9,14 C9.51283584,14 9.93550716,14.3860402 9.99327227,14.8833789 L10,15 C10,15.5128358 9.61395981,15.9355072 9.11662113,15.9932723 L9,16 L1,16 C0.487164161,16 0.0644928393,15.6139598 0.00672773133,15.1166211 L-8.8817842e-16,15 L-8.8817842e-16,1 C-8.8817842e-16,0.487164161 0.38604019,0.0644928393 0.883378875,0.00672773133 L1,0 L9,0 Z M11.6128994,3.20970461 L11.7071068,3.29289322 L15.7071068,7.29289322 C16.0675907,7.65337718 16.0953203,8.22060824 15.7902954,8.61289944 L15.7071068,8.70710678 L11.7071068,12.7071068 C11.3165825,13.0976311 10.6834175,13.0976311 10.2928932,12.7071068 C9.93240926,12.3466228 9.90467972,11.7793918 10.2097046,11.3871006 L10.2928932,11.2928932 L12.585,9 L5,9 C4.44771525,9 4,8.55228475 4,8 C4,7.48716416 4.38604019,7.06449284 4.88337887,7.00672773 L5,7 L12.585,7 L10.2928932,4.70710678 C9.93240926,4.34662282 9.90467972,3.77939176 10.2097046,3.38710056 L10.2928932,3.29289322 C10.6533772,2.93240926 11.2206082,2.90467972 11.6128994,3.20970461 Z\"></path></svg>";

var logo = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg width=\"24px\" height=\"28px\" viewBox=\"0 0 24 28\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <rect fill=\"#ffffff\" stroke=\"none\" width=\"17.14407\" height=\"16.046612\" x=\"3.8855932\" y=\"3.9449153\" />\n    <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <path d=\"M0,2.00494659 C0,0.897645164 0.897026226,0 2.00494659,0 L21.9950534,0 C23.1023548,0 24,0.897026226 24,2.00494659 L24,21.9950534 C24,23.1023548 23.1029738,24 21.9950534,24 L2.00494659,24 C0.897645164,24 0,23.1029738 0,21.9950534 L0,2.00494659 Z M9,24 L12,28 L15,24 L9,24 Z M7.00811294,4 L4,4 L4,20 L7.00811294,20 L7.00811294,15.0028975 C7.00811294,12.004636 8.16824717,12.0097227 9,12 C10,12.0072451 11.0189302,12.0606714 11.0189302,14.003477 L11.0189302,20 L14.0270431,20 L14.0270431,13.1087862 C14.0270433,10 12,9.00309038 10,9.00309064 C8.01081726,9.00309091 8,9.00309086 7.00811294,11.0019317 L7.00811294,4 Z M19,19.9869002 C20.1045695,19.9869002 21,19.0944022 21,17.9934501 C21,16.892498 20.1045695,16 19,16 C17.8954305,16 17,16.892498 17,17.9934501 C17,19.0944022 17.8954305,19.9869002 19,19.9869002 Z\" fill=\"currentColor\"></path>\n    </g>\n</svg>\n";

var note = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M14,0 C15.0543618,0 15.9181651,0.815877791 15.9945143,1.85073766 L16,2 L16,9 C16,9.27541264 15.8865388,9.53676152 15.6894833,9.7243131 L15.6,9.8 L7.6,15.8 C7.46152306,15.9038577 7.29908616,15.9695431 7.12886893,15.9916629 L7,16 L2,16 C0.945638205,16 0.0818348781,15.1841222 0.00548573643,14.1492623 L0,14 L0,2 C0,0.945638205 0.815877791,0.0818348781 1.85073766,0.00548573643 L2,0 L14,0 Z M14,2 L2,2 L2,14 L6,14 L6,9 C6,8.48716416 6.38604019,8.06449284 6.88337887,8.00672773 L7,8 L14,8 L14,2 Z M12,10 L8,10 L8,13 L12,10 Z\"></path></svg>";

var noteFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M14,0 C15.0543618,0 15.9181651,0.815877791 15.9945143,1.85073766 L16,2 L16,7 C16,7.55228475 15.5522847,8 15,8 L7,8 C6.44771525,8 6,8.44771525 6,9 L6,15 C6,15.5522847 5.55228475,16 5,16 L2,16 C0.945638205,16 0.0818348781,15.1841222 0.00548573643,14.1492623 L0,14 L0,2 C0,0.945638205 0.815877791,0.0818348781 1.85073766,0.00548573643 L2,0 L14,0 Z M15.75,9 C15.8880712,9 16,9.11192881 16,9.25 L7.25,16 C7.11192881,16 7,15.8880712 7,15.75 L7,10 C7,9.44771525 7.44771525,9 8,9 L15.75,9 Z\"></path></svg>";

var plus = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M8.99302964,2.86682521 L9,3 L9,6.999 L13,7 C13.5522847,7 14,7.44771525 14,8 C14,8.51283584 13.6139598,8.93550716 13.1166211,8.99327227 L13,9 L9,9 L9,13 C9,14.2873563 7.13555291,14.3317479 7.00697036,13.1331748 L7,13 L7,9 L3,9 C2.44771525,9 2,8.55228475 2,8 C2,7.48716416 2.38604019,7.06449284 2.88337887,7.00672773 L3,7 L7,7 L7,3 C7,1.71264368 8.86444709,1.66825208 8.99302964,2.86682521 Z\"></path></svg>";

var preview = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M8,0 C12.418278,0 16,3.581722 16,8 C16,12.418278 12.418278,16 8,16 C3.581722,16 0,12.418278 0,8 C0,3.581722 3.581722,0 8,0 Z M8,2 C4.6862915,2 2,4.6862915 2,8 C2,11.3137085 4.6862915,14 8,14 C11.3137085,14 14,11.3137085 14,8 C14,4.6862915 11.3137085,2 8,2 Z M6,5 C6,4.21341129 6.8571835,3.74906551 7.50847393,4.13850094 L7.6,4.2 L11.6,7.2 C12.0977778,7.57333333 12.130963,8.29511111 11.6995556,8.7149037 L11.6,8.8 L7.6,11.8 C6.97072903,12.2719532 6.08494231,11.8648139 6.00571639,11.1101203 L6,11 L6,5 Z\"></path></svg>";

var previewFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M8,0 C12.418278,0 16,3.581722 16,8 C16,12.418278 12.418278,16 8,16 C3.581722,16 0,12.418278 0,8 C0,3.581722 3.581722,0 8,0 Z M7.6,4.2 C6.97072903,3.72804677 6.08494231,4.1351861 6.00571639,4.88987971 L6,5 L6,11 C6,11.7865887 6.8571835,12.2509345 7.50847393,11.8614991 L7.6,11.8 L11.6,8.8 C12.0977778,8.42666667 12.130963,7.70488889 11.6995556,7.2850963 L11.6,7.2 L7.6,4.2 Z\"></path></svg>";

var profile$1 = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M1 15c0-2.761 3.134-5 7-5s7 2.239 7 5M8 7a3 3 0 1 1 0-6 3 3 0 0 1 0 6z\"></path></g></svg>\n";

var profileFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M8,9 C12.3599467,9 16,11.6000381 16,15 C16,15.5128358 15.6139598,15.9355072 15.1166211,15.9932723 L15,16 L1,16 C0.44771525,16 0,15.5522847 0,15 C0,11.6000381 3.64005335,9 8,9 Z M8,0 C10.209139,0 12,1.790861 12,4 C12,6.209139 10.209139,8 8,8 C5.790861,8 4,6.209139 4,4 C4,1.790861 5.790861,0 8,0 Z\"></path></svg>";

var refresh = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg width=\"16px\" height=\"16px\" viewBox=\"0 0 16 16\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <!-- Generator: Sketch 39.1 (31720) - http://www.bohemiancoding.com/sketch -->\n    <defs/>\n    <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <g fill=\"currentColor\">\n            <g>\n                <path d=\"M0,8 C0,12.418278 3.581722,16 8,16 C12.418278,16 16,12.418278 16,8 C16,4.89580324 14.2154684,2.11256098 11.4682644,0.789110134 L10.6002482,2.59092808 C12.661769,3.58405472 14,5.6712248 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,5.65296151 3.35941993,3.55225774 5.44569583,2.56903563 L4.59307587,0.759881355 C1.81273067,2.07020511 0,4.87140735 0,8 Z\" />\n                <polygon points=\"7 8.58578644 7 0 9 0 9 8.58578644 10.2928932 7.29289322 11 6.58578644 12.4142136 8 11.7071068 8.70710678 8.70710678 11.7071068 8 12.4142136 7.64644661 12.0606602 7.29289322 11.7071068 4.29289322 8.70710678 3.58578644 8 5 6.58578644 5.70710678 7.29289322\"/>\n            </g>\n        </g>\n    </g>\n</svg>";

var reply = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\n  <path fill=\"currentColor\" fill-rule=\"nonzero\" d=\"M6.422 5.422c2 0 3.542.417 4.625 1.25 1.083.833 1.875 1.75 2.375 2.75s.792 1.917.875 2.75l.125 1.25h-2l-.094-.938c-.062-.625-.281-1.312-.656-2.062-.375-.75-.969-1.438-1.781-2.063-.813-.625-1.97-.937-3.47-.937H4.829l2 2-1.406 1.422L1 6.422 5.422 2l1.406 1.422-2 2h1.594z\"/>\n</svg>\n";

var restricted = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M8,0 C9.68208046,0 11.3461433,0.680204408 12.7173184,1.76574326 L12.7968302,1.82941136 L13.0821869,2.07021798 L13.0821869,2.07021798 L13.3921258,2.35532672 L13.3921258,2.35532672 L13.5196418,2.4804269 L13.5196418,2.4804269 L13.6802379,2.64503003 L13.6802379,2.64503003 L13.9230383,2.91014998 L13.9230383,2.91014998 L14.2342567,3.28268159 C15.3197956,4.65385675 16,6.31791954 16,8 C16,12.0522847 12.0522847,16 8,16 C6.31791954,16 4.65385675,15.3197956 3.28268159,14.2342567 L3.22655228,14.1894621 C3.11728724,14.1015615 3.00992829,14.0110805 2.90461703,13.9181609 L2.77356586,13.8003012 L2.77356586,13.8003012 L2.60704997,13.6438799 L2.60704997,13.6438799 L2.47549501,13.5147055 L2.47549501,13.5147055 L2.3227975,13.3581572 L2.3227975,13.3581572 L2.07024759,13.082218 L2.07024759,13.082218 L1.76574326,12.7173184 C0.680204408,11.3461433 0,9.68208046 0,8 C0,3.94771525 3.94771525,0 8,0 Z M12.7649054,4.65130747 L4.65130747,12.7649054 C5.65399996,13.523368 6.83516455,14 8,14 C10.9477153,14 14,10.9477153 14,8 C14,6.83516455 13.523368,5.65399996 12.7649054,4.65130747 Z M8,2 C5.05228475,2 2,5.05228475 2,8 C2,9.1652227 2.47694891,10.3467854 3.23585116,11.3496925 L11.3496925,3.23585116 C10.3467854,2.47694891 9.1652227,2 8,2 Z\"></path></svg>";

var search = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M6,7.74491582e-13 C9.3137085,7.74491582e-13 12,2.6862915 12,6 C12,7.29898246 11.5846266,8.5351264 10.8252219,9.56391425 L10.8900586,9.47439923 L15.7071068,14.2928932 C16.0976311,14.6834175 16.0976311,15.3165825 15.7071068,15.7071068 C15.3466228,16.0675907 14.7793918,16.0953203 14.3871006,15.7902954 L14.2928932,15.7071068 L9.47512648,10.8918743 L9.53331766,10.8499347 C8.52109315,11.5886903 7.29230116,12 6,12 C2.6862915,12 0,9.3137085 0,6 C0,2.6862915 2.6862915,7.74491582e-13 6,7.74491582e-13 Z M6,2 C3.790861,2 2,3.790861 2,6 C2,8.209139 3.790861,10 6,10 C6.99932461,10 7.93836334,9.63301144 8.65132683,8.99699272 L8.81176823,8.84548807 L8.96107603,8.68929627 C9.62604013,7.95767293 10,7.00931223 10,6 C10,3.790861 8.209139,2 6,2 Z\"></path></svg>";

var settings = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M13,10 C14.6568542,10 16,11.3431458 16,13 C16,14.6568542 14.6568542,16 13,16 C11.6882004,16 10.5730503,15.1580438 10.1654654,13.9850473 L10.1166211,13.9932723 L10,14 L1,14 C0.44771525,14 0,13.5522847 0,13 C0,12.4871642 0.38604019,12.0644928 0.883378875,12.0067277 L1,12 L10,12 C10.0565551,12 10.1120136,12.0046948 10.1660072,12.013716 C10.5730503,10.8419562 11.6882004,10 13,10 Z M13,12 C12.4477153,12 12,12.4477153 12,13 C12,13.5522847 12.4477153,14 13,14 C13.5522847,14 14,13.5522847 14,13 C14,12.4477153 13.5522847,12 13,12 Z M3,0 C4.31179956,0 5.42694971,0.841956184 5.83453458,2.01495267 L5.88337887,2.00672773 L6,2 L15,2 C15.5522847,2 16,2.44771525 16,3 C16,3.51283584 15.6139598,3.93550716 15.1166211,3.99327227 L15,4 L6,4 C5.94344492,4 5.88798638,3.99530518 5.83399285,3.98628401 C5.42694971,5.15804382 4.31179956,6 3,6 C1.34314575,6 0,4.65685425 0,3 C0,1.34314575 1.34314575,0 3,0 Z M3,2 C2.44771525,2 2,2.44771525 2,3 C2,3.55228475 2.44771525,4 3,4 C3.55228475,4 4,3.55228475 4,3 C4,2.44771525 3.55228475,2 3,2 Z\"></path></svg>";

var share = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M15,9 C15.5128358,9 15.9355072,9.38604019 15.9932723,9.88337887 L16,10 L16,15 C16,15.5128358 15.6139598,15.9355072 15.1166211,15.9932723 L15,16 L1,16 C0.487164161,16 0.0644928393,15.6139598 0.00672773133,15.1166211 L0,15 L0,10 C0,9.44771525 0.44771525,9 1,9 C1.51283584,9 1.93550716,9.38604019 1.99327227,9.88337887 L2,10 L2,14 L14,14 L14,10 C14,9.48716416 14.3860402,9.06449284 14.8833789,9.00672773 L15,9 Z M8.61289944,0.209704612 L8.70710678,0.292893219 L12.7071068,4.29289322 C13.0976311,4.68341751 13.0976311,5.31658249 12.7071068,5.70710678 C12.3466228,6.06759074 11.7793918,6.09532028 11.3871006,5.79029539 L11.2928932,5.70710678 L9,3.415 L9,11 C9,11.5522847 8.55228475,12 8,12 C7.48716416,12 7.06449284,11.6139598 7.00672773,11.1166211 L7,11 L7,3.415 L4.70710678,5.70710678 C4.34662282,6.06759074 3.77939176,6.09532028 3.38710056,5.79029539 L3.29289322,5.70710678 C2.93240926,5.34662282 2.90467972,4.77939176 3.20970461,4.38710056 L3.29289322,4.29289322 L7.29289322,0.292893219 C7.62333685,-0.0375504127 8.12750547,-0.0883878944 8.51140295,0.140380774 L8.61289944,0.209704612 Z\"></path></svg>";

var show = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M8,2 C12.3599467,2 16,4.6000381 16,8 C16,11.3999619 12.3599467,14 8,14 C3.64005335,14 0,11.3999619 0,8 C0,4.6000381 3.64005335,2 8,2 Z M8,4 C4.62796016,4 2,5.8771144 2,8 C2,10.1228856 4.62796016,12 8,12 C11.3720398,12 14,10.1228856 14,8 C14,5.8771144 11.3720398,4 8,4 Z M8,6 C9.1045695,6 10,6.8954305 10,8 C10,9.1045695 9.1045695,10 8,10 C6.8954305,10 6,9.1045695 6,8 C6,6.8954305 6.8954305,6 8,6 Z\"></path></svg>";

var showFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M8,2 C12.3599467,2 16,4.6000381 16,8 C16,11.3999619 12.3599467,14 8,14 C3.64005335,14 0,11.3999619 0,8 C0,4.6000381 3.64005335,2 8,2 Z M8,5 C6.34314575,5 5,6.34314575 5,8 C5,9.65685425 6.34314575,11 8,11 C9.65685425,11 11,9.65685425 11,8 C11,6.34314575 9.65685425,5 8,5 Z\"></path></svg>";

var socialFacebook = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"currentColor\" stroke=\"none\" d=\"M15.999 8.049c0-4.445-3.582-8.049-8-8.049S0 3.604 0 8.049C0 12.066 2.925 15.396 6.75 16v-5.624H4.717V8.049H6.75V6.276c0-2.018 1.195-3.132 3.022-3.132.875 0 1.79.157 1.79.157v1.981h-1.008c-.994 0-1.304.62-1.304 1.257v1.51h2.219l-.355 2.327H9.25V16c3.825-.604 6.75-3.934 6.75-7.951z\"></path></g></svg>";

var socialTwitter = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"currentColor\" stroke=\"none\" d=\"M15.969 3.049c-.59.259-1.22.436-1.884.516a3.305 3.305 0 0 0 1.442-1.815c-.634.37-1.336.64-2.084.79a3.28 3.28 0 0 0-5.59 2.988 9.29 9.29 0 0 1-6.76-3.418A3.214 3.214 0 0 0 .65 3.76c0 1.14.58 2.142 1.459 2.73a3.27 3.27 0 0 1-1.485-.41v.04a3.282 3.282 0 0 0 2.63 3.218 3.33 3.33 0 0 1-1.474.057 3.291 3.291 0 0 0 3.069 2.278A6.578 6.578 0 0 1 .78 13.076c-.26 0-.52-.015-.78-.044a9.33 9.33 0 0 0 5.038 1.472c6.036 0 9.332-4.997 9.332-9.323 0-.14 0-.28-.01-.42.64-.46 1.2-1.04 1.64-1.7l-.031-.012z\"></path></g></svg>";

var sort = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 9V2v7zM1 5l4-4 4 4m2 2v7-7zm-4 4l4 4 4-4\"></path></g></svg>\n";

var tag = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M7,3.95905531e-13 C7.20185262,3.95905531e-13 7.39798776,0.0610543386 7.56325188,0.173711952 L7.65850461,0.247423305 L15.6585046,7.24742331 C16.0132096,7.55779017 16.0991779,8.06835747 15.880849,8.47356796 L15.8137335,8.58123819 L10.8137335,15.5812382 C10.4929736,16.030302 9.8764296,16.1291156 9.43434479,15.824813 L9.33563616,15.7474093 L0.335636161,7.74740932 C0.152646135,7.58475152 0.0367634639,7.36167496 0.00738861958,7.12138148 L0,7 L0,1 C0,0.487164161 0.38604019,0.0644928393 0.883378875,0.00672773133 L1,3.95905531e-13 L7,3.95905531e-13 Z M6.624,2 L2,2 L2,6.551 L9.833,13.513 L13.659,8.155 L6.624,2 Z M5,3 C6.1045695,3 7,3.8954305 7,5 C7,6.1045695 6.1045695,7 5,7 C3.8954305,7 3,6.1045695 3,5 C3,3.8954305 3.8954305,3 5,3 Z\"></path></svg>";

var tagFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M7,-2.4158453e-13 C7.20185262,-2.4158453e-13 7.39798776,0.0610543386 7.56325188,0.173711952 L7.65850461,0.247423305 L15.6585046,7.24742331 C16.0132096,7.55779017 16.0991779,8.06835747 15.880849,8.47356796 L15.8137335,8.58123819 L10.8137335,15.5812382 C10.4929736,16.030302 9.8764296,16.1291156 9.43434479,15.824813 L9.33563616,15.7474093 L0.335636161,7.74740932 C0.152646135,7.58475152 0.0367634639,7.36167496 0.00738861958,7.12138148 L0,7 L0,1 C0,0.487164161 0.38604019,0.0644928393 0.883378875,0.00672773133 L1,-2.4158453e-13 L7,-2.4158453e-13 Z M5,3 C3.8954305,3 3,3.8954305 3,5 C3,6.1045695 3.8954305,7 5,7 C6.1045695,7 7,6.1045695 7,5 C7,3.8954305 6.1045695,3 5,3 Z\"></path></svg>";

var tagAltFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M5,3 C7.76142375,3 10,5.23857625 10,8 C10,10.7614237 7.76142375,13 5,13 C2.23857625,13 0,10.7614237 0,8 C0,5.23857625 2.23857625,3 5,3 Z M11,3 C13.7614237,3 16,5.23857625 16,8 C16,10.7614237 13.7614237,13 11,13 C10.4477153,13 10,12.5522847 10,12 C10,11.4871642 10.3860402,11.0644928 10.8833789,11.0067277 L11,11 C12.6568542,11 14,9.65685425 14,8 C14,6.34314575 12.6568542,5 11,5 C10.4477153,5 10,4.55228475 10,4 C10,3.44771525 10.4477153,3 11,3 Z\"></path></svg>";

var theme = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M8,12 C8.51283584,12 8.93550716,12.3860402 8.99327227,12.8833789 L9,13 L9,15 C9,15.5522847 8.55228475,16 8,16 C7.48716416,16 7.06449284,15.6139598 7.00672773,15.1166211 L7,15 L7,13 C7,12.4477153 7.44771525,12 8,12 Z M5.17157288,10.8284271 C5.53420257,11.1910568 5.5601047,11.7629022 5.24927924,12.1554199 L5.17157288,12.2426407 L3.75735931,13.6568542 C3.36683502,14.0473785 2.73367004,14.0473785 2.34314575,13.6568542 C1.98051605,13.2942246 1.95461393,12.7223792 2.26543939,12.3298615 L2.34314575,12.2426407 L3.75735931,10.8284271 C4.1478836,10.4379028 4.78104858,10.4379028 5.17157288,10.8284271 Z M12.1554199,10.7507208 L12.2426407,10.8284271 L13.6568542,12.2426407 C14.0473785,12.633165 14.0473785,13.26633 13.6568542,13.6568542 C13.2942246,14.0194839 12.7223792,14.0453861 12.3298615,13.7345606 L12.2426407,13.6568542 L10.8284271,12.2426407 C10.4379028,11.8521164 10.4379028,11.2189514 10.8284271,10.8284271 C11.1910568,10.4657974 11.7629022,10.4398953 12.1554199,10.7507208 Z M8,5 C9.55228475,5 11,6.44771525 11,8 C11,9.55228475 9.55228475,11 8,11 C6.44771525,11 5,9.55228475 5,8 C5,6.44771525 6.44771525,5 8,5 Z M15,7 C15.5522847,7 16,7.44771525 16,8 C16,8.51283584 15.6139598,8.93550716 15.1166211,8.99327227 L15,9 L13,9 C12.4477153,9 12,8.55228475 12,8 C12,7.48716416 12.3860402,7.06449284 12.8833789,7.00672773 L13,7 L15,7 Z M3,7 C3.55228475,7 4,7.44771525 4,8 C4,8.51283584 3.61395981,8.93550716 3.11662113,8.99327227 L3,9 L1,9 C0.44771525,9 0,8.55228475 0,8 C0,7.48716416 0.38604019,7.06449284 0.883378875,7.00672773 L1,7 L3,7 Z M13.6568542,2.34314575 C14.0194839,2.70577545 14.0453861,3.27762084 13.7345606,3.6701385 L13.6568542,3.75735931 L12.2426407,5.17157288 C11.8521164,5.56209717 11.2189514,5.56209717 10.8284271,5.17157288 C10.4657974,4.80894318 10.4398953,4.23709778 10.7507208,3.84458013 L10.8284271,3.75735931 L12.2426407,2.34314575 C12.633165,1.95262146 13.26633,1.95262146 13.6568542,2.34314575 Z M3.6701385,2.26543939 L3.75735931,2.34314575 L5.17157288,3.75735931 C5.56209717,4.1478836 5.56209717,4.78104858 5.17157288,5.17157288 C4.80894318,5.53420257 4.23709778,5.5601047 3.84458013,5.24927924 L3.75735931,5.17157288 L2.34314575,3.75735931 C1.95262146,3.36683502 1.95262146,2.73367004 2.34314575,2.34314575 C2.70577545,1.98051605 3.27762084,1.95461393 3.6701385,2.26543939 Z M8,0 C8.51283584,0 8.93550716,0.38604019 8.99327227,0.883378875 L9,1 L9,3 C9,3.55228475 8.55228475,4 8,4 C7.48716416,4 7.06449284,3.61395981 7.00672773,3.11662113 L7,3 L7,1 C7,0.44771525 7.44771525,0 8,0 Z\"></path></svg>";

var trash = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M2 4h12l-2 11H4L2 4zM1 1h14H1z\"></path></g></svg>\n";

var trashFilled = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\"><path fill=\"currentColor\" d=\"M14,4 C14.591606,4 15.0445613,4.50741385 14.9968959,5.08070942 L14.9805807,5.19611614 L12.9805807,15.1961161 C12.8948862,15.6245883 12.5428826,15.9430139 12.1176446,15.9931093 L12,16 L4,16 C3.5630424,16 3.18176682,15.7172804 3.04924818,15.3101248 L3.01941932,15.1961161 L1.01941932,5.19611614 C0.903395838,4.6159987 1.31212423,4.07232751 1.88363472,4.00663469 L2,4 L14,4 Z M15,0 C15.5522847,0 16,0.44771525 16,1 C16,1.55228475 15.5522847,2 15,2 L1,2 C0.44771525,2 0,1.55228475 0,1 C0,0.44771525 0.44771525,0 1,0 L15,0 Z\"></path></svg>";

// @ts-nocheck

var annotateIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\n  <path fill=\"currentColor\" fill-rule=\"nonzero\" d=\"M15 0c.27 0 .505.099.703.297A.961.961 0 0116 1v15l-4-3H1a.974.974 0 01-.703-.29A.953.953 0 010 12V1C0 .719.096.482.29.29A.966.966 0 011 0h14zM7 3l-.469.063c-.312.041-.656.187-1.031.437-.375.25-.719.646-1.031 1.188C4.156 5.229 4 6 4 7l.002.063.006.062a.896.896 0 01.008.11l-.002.074-.006.066a1.447 1.447 0 00.43 1.188C4.729 8.854 5.082 9 5.5 9c.417 0 .77-.146 1.063-.438C6.854 8.271 7 7.918 7 7.5c0-.417-.146-.77-.438-1.063A1.447 1.447 0 005.5 6c-.073 0-.146.005-.219.016-.073.01-.14.026-.203.046.177-1.03.542-1.632 1.094-1.804L7 4V3zm5 0l-.469.063c-.312.041-.656.187-1.031.437-.375.25-.719.646-1.031 1.188C9.156 5.229 9 6 9 7l.002.063.006.062a.896.896 0 01.008.11l-.002.074-.006.066a1.447 1.447 0 00.43 1.188c.291.291.645.437 1.062.437.417 0 .77-.146 1.063-.438.291-.291.437-.645.437-1.062 0-.417-.146-.77-.438-1.063A1.447 1.447 0 0010.5 6c-.073 0-.146.005-.219.016-.073.01-.14.026-.203.046.177-1.03.542-1.632 1.094-1.804L12 4V3z\"/>\n</svg>\n";

var lockIcon = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg width=\"48px\" height=\"56px\" viewBox=\"0 0 48 56\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <g fill=\"currentColor\">\n            <rect x=\"0\" y=\"24\" width=\"48\" height=\"32\"></rect>\n            <path d=\"M24,0 C24,0 8,0 8,16 L8,32 L16,32 L16,16.0000004 C16,8 24,8 24,8 C24,8 32,8 32,16 L32,32 L40,32 L40,16 C40,0 24,0 24,0 Z\"></path>\n        </g>\n    </g>\n</svg>";

var replyIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\n  <path fill=\"currentColor\" fill-rule=\"nonzero\" d=\"M6.422 5.422c2 0 3.542.417 4.625 1.25 1.083.833 1.875 1.75 2.375 2.75s.792 1.917.875 2.75l.125 1.25h-2l-.094-.938c-.062-.625-.281-1.312-.656-2.062-.375-.75-.969-1.438-1.781-2.063-.813-.625-1.97-.937-3.47-.937H4.829l2 2-1.406 1.422L1 6.422 5.422 2l1.406 1.422-2 2h1.594z\"/>\n</svg>\n";

var sortIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" aria-hidden=\"true\" focusable=\"false\" class=\"Icon Icon--sort\"><g fill-rule=\"evenodd\"><rect fill=\"none\" stroke=\"none\" x=\"0\" y=\"0\" width=\"16\" height=\"16\"></rect><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 9V2v7zM1 5l4-4 4 4m2 2v7-7zm-4 4l4 4 4-4\"></path></g></svg>\n";

var expandMenuIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\n  <path fill=\"currentColor\" fill-rule=\"nonzero\" d=\"M7.456 11.788L1.226 5.92a.695.695 0 0 1 0-1.025l.726-.684a.804.804 0 0 1 1.087-.001L8 8.861l4.961-4.65a.804.804 0 0 1 1.087.001l.727.684c.3.283.3.742 0 1.025l-6.23 5.867a.804.804 0 0 1-1.09 0z\"/>\n</svg>";

var pointerIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"8\" viewBox=\"0 0 15 8\" aria-hidden=\"true\" focusable=\"false\"><path d=\"M0 8 L7 0 L15 8\" stroke=\"currentColor\" strokeWidth=\"2\" /></svg>\n";

// @ts-nocheck - TS doesn't understand SVG imports.

/**
 * Set of icons used by the sidebar application
 */
const sidebarIcons = {
  add: plus,
  annotate: annotateIcon,
  'arrow-left': arrowLeft,
  'arrow-right': arrowRight,
  cancel,
  'caret-right': caretRight,
  'cc-std': ccStd,
  'cc-zero': ccZero,
  'collapse-menu': caretUp,
  collapse,
  collapsed: caretRight,
  copy,
  edit,
  email,
  'expand-menu': expandMenuIcon,
  error: cancel,
  expand,
  external,
  facebook: socialFacebook,
  flag,
  'flag--active': flagFilled,
  'format-bold': editorTextBold,
  'format-functions': editorLatex,
  'format-italic': editorTextItalic,
  'format-list-numbered': listOrdered,
  'format-list-unordered': listUnordered,
  'format-quote': editorQuote,
  groups,
  help,
  hide,
  highlight,
  image,
  leave,
  link,
  lock: lockIcon,
  logo,
  pointer: pointerIcon,
  profile: profile$1,
  public: globe,
  refresh,
  restricted,
  reply: replyIcon,
  search,
  share,
  success: check,
  sort: sortIcon,
  trash,
  twitter: socialTwitter
};

var _jsxFileName$39 = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/shared/prompts.js";
async function confirm({
  title = 'Confirm',
  message,
  confirmAction = 'Yes'
}) {
  const container = document.createElement('div');
  container.setAttribute('data-testid', 'confirm-container');

  // Ensure dialog appears above any existing content. The Z-index value here
  // is Good Enough™ for current usage.
  container.style.position = 'relative';
  container.style.zIndex = '10';
  document.body.appendChild(container);
  return new Promise(resolve => {
    /** @param {boolean} result */
    const close = result => {
      P$1(null, container);
      container.remove();
      resolve(result);
    };
    P$1(o(ConfirmModal, {
      title: title,
      message: message,
      confirmAction: confirmAction,
      onConfirm: () => close(true),
      onCancel: () => close(false)
    }, void 0, false, {
      fileName: _jsxFileName$39,
      lineNumber: 45,
      columnNumber: 7
    }, this), container);
  });
}

/**
 * @typedef {import('../../types/config').SidebarSettings} SidebarSettings
 * @typedef {import('../../types/api').Profile} Profile
 */

/**
 * The following things must all be true for the tutorial component to auto-display
 * on app launch:
 * - The app must be operating within the "sidebar" (i.e. not single-annotation
 *   or stream mode); AND
 * - No configuration is present in `settings.services` indicating
 *   that the host wants to handle its own help requests (i.e. no event handler
 *   is provided to intercept the default help panel), AND
 * - A user profile is loaded in the current state that indicates a `true` value
 *   for the `show_sidebar_tutorial` preference (i.e. the tutorial has not been
 *   dismissed by this user yet). This implies the presence of a profile, which
 *   in turn implies that there is an authenticated user.
 *
 * @param {boolean} isSidebar - is the app currently displayed in a sidebar?
 * @param {Profile} profile - User profile returned from the API
 * @param {SidebarSettings} settings
 * @return {boolean} - Tutorial panel should be displayed automatically
 */
function shouldAutoDisplayTutorial(isSidebar, profile, settings) {
  const shouldShowBasedOnProfile = typeof profile.preferences === 'object' && !!profile.preferences.show_sidebar_tutorial;
  const service = serviceConfig(settings) || {
    onHelpRequestProvided: false
  };
  return isSidebar && !service.onHelpRequestProvided && shouldShowBasedOnProfile;
}

/**
 * @typedef {import('../../types/config').ThemeProperty} ThemeProperty
 */

/** @type {Record<ThemeProperty, string>} */
const supportedThemeProperties = {
  accentColor: 'color',
  appBackgroundColor: 'backgroundColor',
  ctaBackgroundColor: 'backgroundColor',
  ctaTextColor: 'color',
  selectionFontFamily: 'fontFamily',
  annotationFontFamily: 'fontFamily'
};

/**
 * Subset of the config from the host page which includes theme configuration.
 *
 * @typedef Settings
 * @prop {Record<ThemeProperty,string>} [branding]
 */

/**
 * Return a React `style` object suitable for use as the value of the `style`
 * attr in a React element, with styling rules for the requested set of
 * `themeProperties`.
 *
 * `supportedThemeProperties` defines a whitelist of properties that may be
 * set by a partner's configuration for theme customization. For a given theme
 * property's styling to be present in the returned style object, all of the
 * following must be true:
 *
 * - The theme property is present in the `supportedThemeProperties` whitelist
 * - `settings.branding` (derived from client configuration) has an entry
 *    for this theme property
 *
 * See https://reactjs.org/docs/dom-elements.html#style
 *
 * @param {ThemeProperty[]} themeProperties -
 *   Which of the supported theme properties should have applied rules in the `style`
 *   object
 * @param {Settings} settings
 * @return {Record<string,string>} - Object that can be passed as the `style` prop
 *
 * @example
 * let themeProperties = ['accentColor', 'ctaTextColor', 'foo'];
 * let settings = { branding: {
 *     accentColor: '#ffc',
 *     selectionFontFamily: 'Times New Roman'
 *   }
 * };
 * // Only two of the `themeProperties` are whitelisted and
 * // only one of those has a value in the `settings` object, so:
 * applyTheme(themeProperties, settings); // -> { color: '#ffc '}
 */
function applyTheme(themeProperties, settings) {
  /** @type {Record<string,string>} */
  const style = {};
  if (!settings.branding) {
    return style;
  }
  const {
    branding
  } = settings;
  themeProperties.forEach(themeProp => {
    const propertyName = supportedThemeProperties[themeProp];
    const propertyValue = branding[themeProp];
    if (propertyName && propertyValue) {
      style[propertyName] = propertyValue;
    }
  });
  return style;
}

var _jsxFileName$38 = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/service-context.js";
const fallbackInjector = {
  get(service) {
    throw new Error(`Missing ServiceContext provider to provide "${service}" prop`);
  }
};

/**
 * Context type for a service dependency injector.
 *
 * The value should be an object with a `get(serviceName)` method which returns
 * the instance of the named value or service.
 *
 * Consumers will either use this directly via `useContext` or use the
 * `withServices` wrapper.
 */
const ServiceContext = B$1(fallbackInjector);

/**
 * @template Props
 * @typedef {import("preact").ComponentType<Props>} ComponentType
 */

/**
 * Wrap a Preact component to inject specified props using a dependency injector.
 *
 * The returned component accepts the same props as the input component, except
 * for those listed in the `serviceNames` argument. When the component is rendered
 * the dependency injector is looked up using `useContext(ServiceContext)` and
 * values for these props are obtained from the injector.
 *
 * As a convenience for testing, the props specified by `serviceNames` can still
 * be passed to the returned component. In this case they will override the
 * injected values.
 *
 * @example
 *   function MyComponent({ settings }) {
 *     return ...
 *   }
 *
 *   // Wrap `MyComponent` to inject "settings" service from context.
 *   export default withServices(MyComponent, ['settings']);
 *
 * @template {Record<string, unknown>} Props
 * @template {string} ServiceName
 * @param {ComponentType<Props>} Component
 * @param {ServiceName[]} serviceNames - List of prop names that should be injected
 * @return {ComponentType<Omit<Props,ServiceName>>}
 */
function withServices(Component, serviceNames) {
  /** @param {Omit<Props,ServiceName>} props */
  function Wrapper(props) {
    // Get the current dependency injector instance that is provided by a
    // `ServiceContext.Provider` somewhere higher up the component tree.
    const injector = q(ServiceContext);

    // Inject services, unless they have been overridden by props passed from
    // the parent component.

    /** @type {Record<string,unknown>} */
    const services = {};
    for (let service of serviceNames) {
      // Debugging check to make sure the store is used correctly.
      if (undefined !== 'production') {
        if (service === 'store') {
          throw new Error('Do not use `withServices` to inject the `store` service. Use the `useStore` hook instead');
        }
      }
      if (!(service in props)) {
        services[service] = injector.get(service);
      }
    }
    const propsWithServices = /** @type {Props} */{
      ...services,
      ...props
    };
    return o(Component, {
      ...propsWithServices
    }, void 0, false, {
      fileName: _jsxFileName$38,
      lineNumber: 102,
      columnNumber: 12
    }, this);
  }

  // Set the name of the wrapper for use in debug tools and queries in Enzyme
  // tests.
  const wrappedName = Component.displayName || Component.name;
  Wrapper.displayName = `withServices(${wrappedName})`;
  return Wrapper;
}

/**
 * Hook for looking up a service within a component or a custom hook.
 *
 * This is an alternative to `withServices` that is mainly useful in the
 * context of custom hooks.
 *
 * @param {string} service - Name of the service to look up
 */
function useService(service) {
  const injector = q(ServiceContext);
  return injector.get(service);
}

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

/**
 * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js
 *
 * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes
 * during build.
 * @param {number} code
 */
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or " + 'use the non-minified dev environment for full errors. ';
}

// Inlined version of the `symbol-observable` polyfill
var $$observable = (function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
})();

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of
function miniKindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';
  var type = typeof val;

  switch (type) {
    case 'boolean':
    case 'string':
    case 'number':
    case 'symbol':
    case 'function':
      {
        return type;
      }
  }

  if (Array.isArray(val)) return 'array';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  var constructorName = ctorName(val);

  switch (constructorName) {
    case 'Symbol':
    case 'Promise':
    case 'WeakMap':
    case 'WeakSet':
    case 'Map':
    case 'Set':
      return constructorName;
  } // other


  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
}

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isError(val) {
  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
}

function kindOf(val) {
  var typeOfVal = typeof val;

  if (undefined !== 'production') {
    typeOfVal = miniKindOf(val);
  }

  return typeOfVal;
}

/**
 * @deprecated
 *
 * **We recommend using the `configureStore` method
 * of the `@reduxjs/toolkit` package**, which replaces `createStore`.
 *
 * Redux Toolkit is our recommended approach for writing Redux logic today,
 * including store setup, reducers, data fetching, and more.
 *
 * **For more details, please read this Redux docs page:**
 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
 *
 * `configureStore` from Redux Toolkit is an improved version of `createStore` that
 * simplifies setup and helps avoid common bugs.
 *
 * You should not be using the `redux` core package by itself today, except for learning purposes.
 * The `createStore` method from the core `redux` package will not be removed, but we encourage
 * all users to migrate to using Redux Toolkit for all Redux code.
 *
 * If you want to use `createStore` without this visual deprecation warning, use
 * the `legacy_createStore` import instead:
 *
 * `import { legacy_createStore as createStore} from 'redux'`
 *
 */

function createStore$1(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error(undefined === "production" ? formatProdErrorMessage(0) : 'It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.');
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error(undefined === "production" ? formatProdErrorMessage(1) : "Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
    }

    return enhancer(createStore$1)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error(undefined === "production" ? formatProdErrorMessage(2) : "Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer) + "'");
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error(undefined === "production" ? formatProdErrorMessage(3) : 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error(undefined === "production" ? formatProdErrorMessage(4) : "Expected the listener to be a function. Instead, received: '" + kindOf(listener) + "'");
    }

    if (isDispatching) {
      throw new Error(undefined === "production" ? formatProdErrorMessage(5) : 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error(undefined === "production" ? formatProdErrorMessage(6) : 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(undefined === "production" ? formatProdErrorMessage(7) : "Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    }

    if (typeof action.type === 'undefined') {
      throw new Error(undefined === "production" ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }

    if (isDispatching) {
      throw new Error(undefined === "production" ? formatProdErrorMessage(9) : 'Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error(undefined === "production" ? formatProdErrorMessage(10) : "Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new Error(undefined === "production" ? formatProdErrorMessage(11) : "Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[$$observable] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
/**
 * Creates a Redux store that holds the state tree.
 *
 * **We recommend using `configureStore` from the
 * `@reduxjs/toolkit` package**, which replaces `createStore`:
 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
 *
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

var legacy_createStore = createStore$1;

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + kindOf(inputState) + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error(undefined === "production" ? formatProdErrorMessage(12) : "The slice reducer for key \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error(undefined === "production" ? formatProdErrorMessage(13) : "The slice reducer for key \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle '" + ActionTypes.INIT + "' or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (undefined !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        warning("No reducer provided for key \"" + key + "\"");
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
  // keys multiple times.

  var unexpectedKeyCache;

  if (undefined !== 'production') {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (undefined !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);

      if (warningMessage) {
        warning(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var actionType = action && action.type;
        throw new Error(undefined === "production" ? formatProdErrorMessage(14) : "When called with an action of type " + (actionType ? "\"" + String(actionType) + "\"" : '(unknown type)') + ", the slice reducer for key \"" + _key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.");
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass an action creator as the first argument,
 * and get a dispatch wrapped function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */


function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error(undefined === "production" ? formatProdErrorMessage(16) : "bindActionCreators expected an object or a function, but instead received: '" + kindOf(actionCreators) + "'. " + "Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?");
  }

  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error(undefined === "production" ? formatProdErrorMessage(15) : 'Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2$1(_objectSpread2$1({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

function isCrushed() {}

if (undefined !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
}

/** A function that accepts a potential "extra argument" value to be injected later,
 * and returns an instance of the thunk middleware that uses that value
 */
function createThunkMiddleware(extraArgument) {
  // Standard Redux middleware definition pattern:
  // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware
  var middleware = function middleware(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        // The thunk middleware looks for any functions that were passed to `store.dispatch`.
        // If this "action" is really a function, call it and return the result.
        if (typeof action === 'function') {
          // Inject the store's `dispatch` and `getState` methods, as well as any "extra arg"
          return action(dispatch, getState, extraArgument);
        } // Otherwise, pass the action down the middleware chain as usual


        return next(action);
      };
    };
  };

  return middleware;
}

var thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version
// with whatever "extra arg" they want to inject into their thunks

thunk.withExtraArgument = createThunkMiddleware;

/* global process */

/**
 * Freeze an object recursively.
 *
 * This only works for plain objects, arrays and objects where data is stored
 * in enumerable fields.
 *
 * @template {object} T
 * @param {T} object
 */
function deepFreeze(object) {
  if (Object.isFrozen(object)) {
    return object;
  }
  Object.freeze(object);
  Object.values(object).forEach(val => {
    if (typeof val === 'object' && val !== null) {
      deepFreeze(val);
    }
  });
  return object;
}

/**
 * Prevent accidental mutations to `object` or any of its fields in debug builds.
 *
 * @template {object} T
 * @param {T} object
 * @return {T} Returns the input object
 */
function immutable(object) {
  if (undefined === 'production') {
    return object;
  } else {
    return deepFreeze(object);
  }
}

/* global process */
/** Create a Redux reducer from a store module's reducer map. */
function createReducer(reducers) {
  return (state = {}, action) => {
    const reducer = reducers[action.type];
    if (!reducer) {
      return state;
    }
    const stateChanges = reducer(state, action);
    return {
      ...state,
      ...stateChanges
    };
  };
}

/**
 * Convert a map of selector functions, which take a state value as their
 * first argument, to a map of selector methods, which pre-fill the first
 * argument by calling `getState()`.
 */
function bindSelectors(selectors, getState) {
  const boundSelectors = {};
  for (const [name, selector] of Object.entries(selectors)) {
    boundSelectors[name] = (...args) => selector(getState(), ...args);
  }
  return boundSelectors;
}

/**
 * `Object.assign` wrapper that checks for overwriting properties in debug builds.
 */
function assignOnce(target, source) {
  if (undefined !== 'production') {
    for (const key of Object.keys(source)) {
      if (key in target) {
        throw new Error(`Cannot add duplicate '${key}' property to object`);
      }
    }
  }
  return Object.assign(target, source);
}

/**
 * Create a Redux store from a set of modules.
 *
 * Each module defines the logic related to a subset of the application state.
 * This includes:
 *
 *  - The initial value of the state. This should always be an object.
 *  - Actions that can change the state
 *  - Selectors for extracting information from the state
 *
 * In addition to the standard Redux store interface, the returned store also exposes
 * each action creator and selector from the input modules as a method. For example, if
 * a store is created from a module that has a `getWidget(<id>)` selector and
 * an `addWidget(<object>)` action, a consumer would use `store.getWidget(<id>)`
 * to fetch an item and `store.addWidget(<object>)` to dispatch an action that
 * adds an item. External consumers of the store should in most cases use these
 * selector and action methods rather than `getState` or `dispatch`. This
 * makes it easier to refactor the internal state structure.
 *
 * Preact UI components access stores via the `useStore` hook. This returns a
 * proxy which enables UI components to observe what store state a component
 * depends upon and re-render when it changes.
 */
function createStore(modules, initArgs = [], middleware = []) {
  const initialState = {};
  for (const module of modules) {
    initialState[module.namespace] = module.initialState(...initArgs);
  }
  const allReducers = {};
  for (const module of modules) {
    allReducers[module.namespace] = createReducer(module.reducers);
  }
  const defaultMiddleware = [
  // The `thunk` middleware handles actions which are functions.
  // This is used to implement actions which have side effects or are
  // asynchronous (see https://github.com/gaearon/redux-thunk#motivation)
  thunk];
  const enhancer = applyMiddleware(...defaultMiddleware, ...middleware);

  // Combine the reducers for all modules
  let reducer = combineReducers(allReducers);

  // In debug builds, freeze the new state after each action to catch any attempts
  // to mutate it, which indicates a bug since it is supposed to be immutable.
  if (undefined !== 'production') {
    const originalReducer = reducer;
    reducer = (state, action) => immutable(originalReducer(state, action));
  }
  const store = createStore$1(reducer, initialState, enhancer);

  // Add action creators as methods to the store.
  const actionCreators = {};
  for (const module of modules) {
    assignOnce(actionCreators, module.actionCreators);
  }
  const actionMethods = bindActionCreators(actionCreators, store.dispatch);
  Object.assign(store, actionMethods);

  // Add selectors as methods to the store.
  const selectorMethods = {};
  for (const module of modules) {
    const {
      namespace,
      selectors,
      rootSelectors
    } = module;
    const boundSelectors = bindSelectors(selectors, () => store.getState()[namespace]);
    assignOnce(selectorMethods, boundSelectors);
    if (rootSelectors) {
      const boundRootSelectors = bindSelectors(rootSelectors, store.getState);
      assignOnce(selectorMethods, boundRootSelectors);
    }
  }
  Object.assign(store, selectorMethods);
  return store;
}

/**
 * Helper for creating an action which checks that the type of the action's
 * payload is compatible with what the reducer expects.
 *
 * @param reducers - The map of reducer functions from a store module
 * @param type - The name of a specific reducer in `reducers`
 * @param payload - The fields of the action
 *   except for `type`. Pass `undefined` if the reducer doesn't need an action payload.
 */
function makeAction(reducers, type, payload) {
  // nb. `reducers` is not used here. It exists purely for type inference.
  return {
    type,
    ...payload
  };
}

/**
 * Configuration for a store module.
 *
 * This specifies everything about the contents of a store module, except the
 * initial state. The initial state is passed separately to {@link createStoreModule}
 * to aid type inference.
 */

/**
 * Create a store module that can be passed to {@link createStore}.
 *
 * @param initialState - Initial state for the module, specified either as a
 *   value or a function which computes it. If a function is passed, it is
 *   provided the arguments from the {@link createStore} call
 * @param config - Namespace and contents (actions, selectors, reducers etc.)
 *   of the module
 */
function createStoreModule(initialState, config) {
  if (!(initialState instanceof Function)) {
    const state = initialState;
    initialState = () => state;
  }
  return {
    initialState,
    ...config
  };
}

/**
 * @typedef {import('redux').Action} Action
 * @typedef {import('redux').Store} Store
 */

/**
 * A debug utility that prints information about internal application state
 * changes to the console.
 *
 * Debugging is enabled by setting `window.debug` to a truthy value.
 *
 * When enabled, every action that changes application state will be printed
 * to the console, along with the application state before and after the action
 * was handled.
 *
 * @param {Store} store
 */
function debugMiddleware(store) {
  /* eslint-disable no-console */
  let serial = 0;

  /** @param {(a: Action) => void} next */
  return next => {
    /** @param {Action} action */
    return action => {
      // @ts-ignore The window interface needs to be expanded to include this property
      if (!window.debug) {
        next(action);
        return;
      }
      ++serial;
      const groupTitle = action.type + ' (' + serial.toString() + ')';
      console.group(groupTitle);
      console.log('Prev State:', store.getState());
      console.log('Action:', action);
      next(action);
      console.log('Next State:', store.getState());
      console.groupEnd();
    };
  };
  /* eslint-enable no-console */
}

/**
 * Store module which tracks activity happening in the application that may
 * need to be reflected in the UI.
 */

/** @typedef {import('../../../types/api').Annotation} Annotation */

const initialState$f = {
  /**
   * Annotation `$tag`s that correspond to annotations with active API requests
   *
   * @type {string[]}
   */
  activeAnnotationSaveRequests: [],
  /**
   * The number of API requests that have started and not yet completed.
   */
  activeApiRequests: 0,
  /**
   * The number of annotation fetches that have started and not yet completed.
   */
  activeAnnotationFetches: 0,
  /**
   * Have annotations ever been fetched?
   */
  hasFetchedAnnotations: false,
  /**
   * The number of total annotation results the service reported as
   * matching the most recent load/search request
   *
   * @type {number|null}
   */
  annotationResultCount: null
};

/** @typedef {typeof initialState} State */

const reducers$f = {
  /** @param {State} state */
  API_REQUEST_STARTED(state) {
    return {
      ...state,
      activeApiRequests: state.activeApiRequests + 1
    };
  },
  /** @param {State} state */
  API_REQUEST_FINISHED(state) {
    if (state.activeApiRequests === 0) {
      throw new Error('API_REQUEST_FINISHED action when no requests were active');
    }
    return {
      ...state,
      activeApiRequests: state.activeApiRequests - 1
    };
  },
  /**
   * @param {State} state
   * @param {{ annotation: Annotation }} action
   */
  ANNOTATION_SAVE_STARTED(state, action) {
    let addToStarted = [];
    if (action.annotation.$tag && !state.activeAnnotationSaveRequests.includes(action.annotation.$tag)) {
      addToStarted.push(action.annotation.$tag);
    }
    const updatedSaves = state.activeAnnotationSaveRequests.concat(addToStarted);
    return {
      ...state,
      activeAnnotationSaveRequests: updatedSaves
    };
  },
  /**
   * @param {State} state
   * @param {{ annotation: Annotation }} action
   */
  ANNOTATION_SAVE_FINISHED(state, action) {
    const updatedSaves = state.activeAnnotationSaveRequests.filter($tag => $tag !== action.annotation.$tag);
    return {
      ...state,
      activeAnnotationSaveRequests: updatedSaves
    };
  },
  /** @param {State} state */
  ANNOTATION_FETCH_STARTED(state) {
    return {
      ...state,
      activeAnnotationFetches: state.activeAnnotationFetches + 1
    };
  },
  /** @param {State} state */
  ANNOTATION_FETCH_FINISHED(state) {
    if (state.activeAnnotationFetches === 0) {
      throw new Error('ANNOTATION_FETCH_FINISHED action when no annotation fetches were active');
    }
    return {
      ...state,
      hasFetchedAnnotations: true,
      activeAnnotationFetches: state.activeAnnotationFetches - 1
    };
  },
  /**
   * @param {State} state
   * @param {{ resultCount: number }} action
   */
  SET_ANNOTATION_RESULT_COUNT(state, action) {
    return {
      annotationResultCount: action.resultCount
    };
  }
};
function annotationFetchStarted() {
  return makeAction(reducers$f, 'ANNOTATION_FETCH_STARTED', undefined);
}
function annotationFetchFinished() {
  return makeAction(reducers$f, 'ANNOTATION_FETCH_FINISHED', undefined);
}

/**
 * @param {Annotation} annotation — annotation object with a `$tag` property
 */
function annotationSaveStarted(annotation) {
  return makeAction(reducers$f, 'ANNOTATION_SAVE_STARTED', {
    annotation
  });
}

/**
 * @param {Annotation} annotation — annotation object with a `$tag` property
 */
function annotationSaveFinished(annotation) {
  return makeAction(reducers$f, 'ANNOTATION_SAVE_FINISHED', {
    annotation
  });
}
function apiRequestStarted() {
  return makeAction(reducers$f, 'API_REQUEST_STARTED', undefined);
}
function apiRequestFinished() {
  return makeAction(reducers$f, 'API_REQUEST_FINISHED', undefined);
}

/** @param {number} resultCount */
function setAnnotationResultCount(resultCount) {
  return makeAction(reducers$f, 'SET_ANNOTATION_RESULT_COUNT', {
    resultCount
  });
}

/** Selectors */

/** @param {State} state */
function annotationResultCount(state) {
  return state.annotationResultCount;
}

/** @param {State} state */
function hasFetchedAnnotations(state) {
  return state.hasFetchedAnnotations;
}

/**
 * Return true when annotations are actively being fetched.
 *
 * @param {State} state
 */
function isFetchingAnnotations(state) {
  return state.activeAnnotationFetches > 0;
}

/**
 * Return true when any activity is happening in the app that needs to complete
 * before the UI is ready for interactivity with annotations.
 *
 * @param {State} state
 */
function isLoading(state) {
  return state.activeApiRequests > 0 || !state.hasFetchedAnnotations;
}

/**
 * Return `true` if `$tag` exists in the array of annotation `$tag`s that
 * have in-flight save requests, i.e. the annotation in question is actively
 * being saved to a remote service.
 *
 * @param {State} state
 * @param {Annotation} annotation
 */
function isSavingAnnotation(state, annotation) {
  if (!annotation.$tag) {
    return false;
  }
  return state.activeAnnotationSaveRequests.includes(annotation.$tag);
}
const activityModule = createStoreModule(initialState$f, {
  reducers: reducers$f,
  namespace: 'activity',
  actionCreators: {
    annotationFetchStarted,
    annotationFetchFinished,
    annotationSaveStarted,
    annotationSaveFinished,
    apiRequestStarted,
    apiRequestFinished,
    setAnnotationResultCount
  },
  selectors: {
    hasFetchedAnnotations,
    isLoading,
    isFetchingAnnotations,
    isSavingAnnotation,
    annotationResultCount
  }
});

// Cache implementation based on Erik Rasmussen's `lru-memoize`:
// https://github.com/erikras/lru-memoize
var NOT_FOUND = 'NOT_FOUND';

function createSingletonCache(equals) {
  var entry;
  return {
    get: function get(key) {
      if (entry && equals(entry.key, key)) {
        return entry.value;
      }

      return NOT_FOUND;
    },
    put: function put(key, value) {
      entry = {
        key: key,
        value: value
      };
    },
    getEntries: function getEntries() {
      return entry ? [entry] : [];
    },
    clear: function clear() {
      entry = undefined;
    }
  };
}

function createLruCache(maxSize, equals) {
  var entries = [];

  function get(key) {
    var cacheIndex = entries.findIndex(function (entry) {
      return equals(key, entry.key);
    }); // We found a cached entry

    if (cacheIndex > -1) {
      var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top

      if (cacheIndex > 0) {
        entries.splice(cacheIndex, 1);
        entries.unshift(entry);
      }

      return entry.value;
    } // No entry found in cache, return sentinel


    return NOT_FOUND;
  }

  function put(key, value) {
    if (get(key) === NOT_FOUND) {
      // TODO Is unshift slow?
      entries.unshift({
        key: key,
        value: value
      });

      if (entries.length > maxSize) {
        entries.pop();
      }
    }
  }

  function getEntries() {
    return entries;
  }

  function clear() {
    entries = [];
  }

  return {
    get: get,
    put: put,
    getEntries: getEntries,
    clear: clear
  };
}

var defaultEqualityCheck = function defaultEqualityCheck(a, b) {
  return a === b;
};
function createCacheKeyComparator(equalityCheck) {
  return function areArgumentsShallowlyEqual(prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
      return false;
    } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.


    var length = prev.length;

    for (var i = 0; i < length; i++) {
      if (!equalityCheck(prev[i], next[i])) {
        return false;
      }
    }

    return true;
  };
}
// defaultMemoize now supports a configurable cache size with LRU behavior,
// and optional comparison of the result value with existing values
function defaultMemoize(func, equalityCheckOrOptions) {
  var providedOptions = typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : {
    equalityCheck: equalityCheckOrOptions
  };
  var _providedOptions$equa = providedOptions.equalityCheck,
      equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa,
      _providedOptions$maxS = providedOptions.maxSize,
      maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,
      resultEqualityCheck = providedOptions.resultEqualityCheck;
  var comparator = createCacheKeyComparator(equalityCheck);
  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons

  function memoized() {
    var value = cache.get(arguments);

    if (value === NOT_FOUND) {
      // @ts-ignore
      value = func.apply(null, arguments);

      if (resultEqualityCheck) {
        var entries = cache.getEntries();
        var matchingEntry = entries.find(function (entry) {
          return resultEqualityCheck(entry.value, value);
        });

        if (matchingEntry) {
          value = matchingEntry.value;
        }
      }

      cache.put(arguments, value);
    }

    return value;
  }

  memoized.clearCache = function () {
    return cache.clear();
  };

  return memoized;
}

function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

  if (!dependencies.every(function (dep) {
    return typeof dep === 'function';
  })) {
    var dependencyTypes = dependencies.map(function (dep) {
      return typeof dep === 'function' ? "function " + (dep.name || 'unnamed') + "()" : typeof dep;
    }).join(', ');
    throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + dependencyTypes + "]");
  }

  return dependencies;
}

function createSelectorCreator(memoize) {
  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    memoizeOptionsFromArgs[_key - 1] = arguments[_key];
  }

  var createSelector = function createSelector() {
    for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }

    var _recomputations = 0;

    var _lastResult; // Due to the intricacies of rest params, we can't do an optional arg after `...funcs`.
    // So, start by declaring the default value here.
    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)


    var directlyPassedOptions = {
      memoizeOptions: undefined
    }; // Normally, the result func or "output selector" is the last arg

    var resultFunc = funcs.pop(); // If the result func is actually an _object_, assume it's our options object

    if (typeof resultFunc === 'object') {
      directlyPassedOptions = resultFunc; // and pop the real result func off

      resultFunc = funcs.pop();
    }

    if (typeof resultFunc !== 'function') {
      throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof resultFunc + "]");
    } // Determine which set of options we're using. Prefer options passed directly,
    // but fall back to options given to createSelectorCreator.


    var _directlyPassedOption = directlyPassedOptions,
        _directlyPassedOption2 = _directlyPassedOption.memoizeOptions,
        memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2; // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer
    // is an array. In most libs I've looked at, it's an equality function or options object.
    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full
    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so
    // we wrap it in an array so we can apply it.

    var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];
    var dependencies = getDependencies(funcs);
    var memoizedResultFunc = memoize.apply(void 0, [function recomputationWrapper() {
      _recomputations++; // apply arguments instead of spreading for performance.

      return resultFunc.apply(null, arguments);
    }].concat(finalMemoizeOptions)); // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.

    var selector = memoize(function dependenciesChecker() {
      var params = [];
      var length = dependencies.length;

      for (var i = 0; i < length; i++) {
        // apply arguments instead of spreading and mutate a local list of params for performance.
        // @ts-ignore
        params.push(dependencies[i].apply(null, arguments));
      } // apply arguments instead of spreading for performance.


      _lastResult = memoizedResultFunc.apply(null, params);
      return _lastResult;
    });
    Object.assign(selector, {
      resultFunc: resultFunc,
      memoizedResultFunc: memoizedResultFunc,
      dependencies: dependencies,
      lastResult: function lastResult() {
        return _lastResult;
      },
      recomputations: function recomputations() {
        return _recomputations;
      },
      resetRecomputations: function resetRecomputations() {
        return _recomputations = 0;
      }
    });
    return selector;
  }; // @ts-ignore


  return createSelector;
}
var createSelector = /* #__PURE__ */createSelectorCreator(defaultMemoize);
// Manual definition of state and output arguments
var createStructuredSelector = function createStructuredSelector(selectors, selectorCreator) {
  if (selectorCreator === void 0) {
    selectorCreator = createSelector;
  }

  if (typeof selectors !== 'object') {
    throw new Error('createStructuredSelector expects first argument to be an object ' + ("where each property is a selector, instead received a " + typeof selectors));
  }

  var objectKeys = Object.keys(selectors);
  var resultSelector = selectorCreator( // @ts-ignore
  objectKeys.map(function (key) {
    return selectors[key];
  }), function () {
    for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      values[_key3] = arguments[_key3];
    }

    return values.reduce(function (composition, value, index) {
      composition[objectKeys[index]] = value;
      return composition;
    }, {});
  });
  return resultSelector;
};

/**
 * Polyfill for `Object.hasOwn`.
 *
 * `hasOwn(someObject, property)` should be used instead of
 * `someObject.hasOwnProperty(name)`.
 *
 * @param {object} object
 * @param {string} property
 */
function hasOwn(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
}

/**
 * Utility functions for querying annotation metadata.
 */

/**
 * @typedef {import('../../types/api').Annotation} Annotation
 * @typedef {import('../../types/api').SavedAnnotation} SavedAnnotation
 * @typedef {import('../../types/api').TextPositionSelector} TextPositionSelector
 * @typedef {import('../../types/api').TextQuoteSelector} TextQuoteSelector
 */

/**
 * Extract document metadata from an annotation.
 *
 * @param {Annotation} annotation
 */
function documentMetadata(annotation) {
  const uri = annotation.uri;
  let domain;
  try {
    domain = new URL(uri).hostname;
  } catch {
    // Annotation URI parsing on the backend is very liberal compared to the URL
    // constructor. There is also some historic invalid data in h (eg [1]).
    // Hence we must handle URL parsing failures in the client.
    //
    // [1] https://github.com/hypothesis/client/issues/3666
    domain = '';
  }
  if (domain === 'localhost') {
    domain = '';
  }
  let title = domain;
  if (annotation.document && annotation.document.title) {
    title = annotation.document.title[0];
  }
  return {
    uri,
    domain,
    title
  };
}

/**
 * Return the domain and title of an annotation for display on an annotation
 * card.
 *
 * @param {Annotation} annotation
 */
function domainAndTitle(annotation) {
  return {
    domain: domainTextFromAnnotation(annotation),
    titleText: titleTextFromAnnotation(annotation),
    titleLink: titleLinkFromAnnotation(annotation)
  };
}

/**
 * @param {Annotation} annotation
 */
function titleLinkFromAnnotation(annotation) {
  let titleLink = /** @type {string|null} */annotation.uri;
  if (titleLink && !(titleLink.indexOf('http://') === 0 || titleLink.indexOf('https://') === 0)) {
    // We only link to http(s) URLs.
    titleLink = null;
  }
  if (annotation.links && annotation.links.incontext) {
    titleLink = annotation.links.incontext;
  }
  return titleLink;
}
/**
 * Returns the domain text from an annotation.
 *
 * @param {Annotation} annotation
 */
function domainTextFromAnnotation(annotation) {
  const document = documentMetadata(annotation);
  let domainText = '';
  if (document.uri && document.uri.indexOf('file://') === 0 && document.title) {
    const parts = document.uri.split('/');
    const filename = parts[parts.length - 1];
    if (filename) {
      domainText = filename;
    }
  } else if (document.domain && document.domain !== document.title) {
    domainText = document.domain;
  }
  return domainText;
}

/**
 * Returns the title text from an annotation and crops it to 30 chars
 * if needed.
 *
 * @param {Annotation} annotation
 */
function titleTextFromAnnotation(annotation) {
  const document = documentMetadata(annotation);
  let titleText = document.title;
  if (titleText.length > 30) {
    titleText = titleText.slice(0, 30) + '…';
  }
  return titleText;
}

/**
 * Return `true` if the given annotation is a reply, `false` otherwise.
 *
 * @param {Annotation} annotation
 */
function isReply(annotation) {
  return (annotation.references || []).length > 0;
}

/**
 * Return true if the given annotation has been saved to the backend and assigned
 * an ID.
 *
 * @param {Annotation} annotation
 * @return {annotation is SavedAnnotation}
 */
function isSaved(annotation) {
  return !!annotation.id;
}

/**
 * Return true if an annotation has not been saved to the backend.
 *
 * @deprecated - Use {@link isSaved} instead
 * @param {Annotation} annotation
 */
function isNew(annotation) {
  return !annotation.id;
}

/**
 * Return `true` if the given annotation is public, `false` otherwise.
 *
 * @param {Annotation} annotation
 */
function isPublic(annotation) {
  let isPublic = false;
  if (!annotation.permissions) {
    return isPublic;
  }
  annotation.permissions.read.forEach(perm => {
    const readPermArr = perm.split(':');
    if (readPermArr.length === 2 && readPermArr[0] === 'group') {
      isPublic = true;
    }
  });
  return isPublic;
}

/**
 * Return `true` if `annotation` has a selector.
 *
 * An annotation which has a selector refers to a specific part of a document,
 * as opposed to a Page Note which refers to the whole document or a reply,
 * which refers to another annotation.
 *
 * @param {Annotation} annotation
 */
function hasSelector(annotation) {
  return !!(annotation.target && annotation.target.length > 0 && annotation.target[0].selector);
}

/**
 * Return `true` if the given annotation is not yet anchored.
 *
 * Returns false if anchoring is still in process but the flag indicating that
 * the initial timeout allowed for anchoring has expired.
 *
 * @param {Annotation} annotation
 */
function isWaitingToAnchor(annotation) {
  return hasSelector(annotation) && typeof annotation.$orphan === 'undefined' && !annotation.$anchorTimeout;
}

/**
 * Has this annotation hidden by moderators?
 *
 * @param {Annotation} annotation
 * @return {boolean}
 */
function isHidden(annotation) {
  return !!annotation.hidden;
}

/**
 * Is this annotation a highlight?
 *
 * Highlights are generally identifiable by having no text content AND no tags,
 * but there is some nuance.
 *
 * @param {Annotation} annotation
 * @return {boolean}
 */
function isHighlight(annotation) {
  // `$highlight` is an ephemeral attribute set by the `annotator` on new
  // annotation objects (created by clicking the "highlight" button).
  // It is not persisted and cannot be relied upon, but if it IS present,
  // this is definitely a highlight (one which is not yet saved).
  if (annotation.$highlight) {
    return true;
  }
  if (isNew(annotation)) {
    // For new (unsaved-to-service) annotations, unless they have a truthy
    // `$highlight` attribute, we don't know yet if they are a highlight.
    return false;
  }

  // Note that it is possible to end up with an empty (no `text`) annotation
  // that is not a highlight by adding at least one tag—thus, it is necessary
  // to check for the existence of tags as well as text content.

  return !isPageNote(annotation) && !isReply(annotation) && !annotation.hidden &&
  // A hidden annotation has some form of objectionable content
  !annotation.text && !(annotation.tags && annotation.tags.length);
}

/**
 * Return `true` if the given annotation is an orphan.
 *
 * @param {Annotation} annotation
 */
function isOrphan(annotation) {
  return hasSelector(annotation) && annotation.$orphan === true;
}

/**
 * Return `true` if the given annotation is a page note.
 *
 * @param {Annotation} annotation
 */
function isPageNote(annotation) {
  return !hasSelector(annotation) && !isReply(annotation);
}

/**
 * Return `true` if the given annotation is a top level annotation, `false` otherwise.
 *
 * @param {Annotation} annotation
 */
function isAnnotation(annotation) {
  return !!(hasSelector(annotation) && !isOrphan(annotation));
}

/**
 * Return a human-readable string describing the annotation's role.
 *
 * @param {Annotation} annotation
 */
function annotationRole(annotation) {
  if (isReply(annotation)) {
    return 'Reply';
  } else if (isHighlight(annotation)) {
    return 'Highlight';
  } else if (isPageNote(annotation)) {
    return 'Page note';
  }
  return 'Annotation';
}

/**
 * Key containing information needed to sort annotations based on their
 * associated position within the document.
 *
 * @typedef LocationKey
 * @prop {string} [cfi] - EPUB Canonical Fragment Identifier. For annotations
 *   on EPUBs, this identifies the location of the chapter within the book's
 *   table of contents.
 * @prop {number} [position] - Text offset within the document segment, in UTF-16
 *   code units. For web pages and PDFs this refers to the offset from the start
 *   of the document. In EPUBs this refers to the offset from the start of the
 *   Content Document (ie. chapter).
 */

/**
 * Return a key that can be used to sort annotations by document position.
 *
 * Note that the key may not have any fields set if the annotation is a page
 * note or was created via the Hypothesis API without providing the selectors
 * that this function uses.
 *
 * @param {Annotation} annotation
 * @return {LocationKey}
 */
function location(annotation) {
  const targets = annotation.target;
  let cfi;
  let position;

  // nb. We ignore the possibility of an annotation having multiple targets here.
  // h and the client only support one.
  for (const selector of (_targets$0$selector = (_targets$ = targets[0]) === null || _targets$ === void 0 ? void 0 : _targets$.selector) !== null && _targets$0$selector !== void 0 ? _targets$0$selector : []) {
    var _targets$0$selector, _targets$;
    if (selector.type === 'TextPositionSelector') {
      position = selector.start;
    } else if (selector.type === 'EPUBContentSelector' && selector.cfi) {
      cfi = selector.cfi;
    }
  }
  return {
    cfi,
    position
  };
}

/**
 * Return the number of times the annotation has been flagged
 * by other users. If moderation metadata is not present, returns `null`.
 *
 * @param {Annotation} annotation
 * @return {number|null}
 */
function flagCount(annotation) {
  if (!annotation.moderation) {
    return null;
  }
  return annotation.moderation.flagCount;
}

/**
 * Return the text quote that an annotation refers to.
 *
 * @param {Annotation} annotation
 * @return {string|null}
 */
function quote(annotation) {
  if (annotation.target.length === 0) {
    return null;
  }
  const target = annotation.target[0];
  if (!target.selector) {
    return null;
  }
  const quoteSel = target.selector.find(s => s.type === 'TextQuoteSelector');
  return quoteSel ? /** @type {TextQuoteSelector}*/quoteSel.exact : null;
}

/**
 * Has this annotation been edited subsequent to its creation?
 *
 * @param {Annotation} annotation
 * @return {boolean}
 */
function hasBeenEdited(annotation) {
  // New annotations created with the current `h` API service will have
  // equivalent (string) values for `created` and `updated` datetimes.
  // However, in the past, these values could have sub-second differences,
  // which can make them appear as having been edited when they have not
  // been. Only consider an annotation as "edited" if its creation time is
  // more than 2 seconds before its updated time.
  const UPDATED_THRESHOLD = 2000;

  // If either time string is non-extant or they are equivalent...
  if (!annotation.updated || !annotation.created || annotation.updated === annotation.created) {
    return false;
  }

  // Both updated and created SHOULD be ISO-8601-formatted strings
  // with microsecond resolution; (NB: Date.prototype.getTime() returns
  // milliseconds since epoch, so we're dealing in ms after this)
  const created = new Date(annotation.created).getTime();
  const updated = new Date(annotation.updated).getTime();
  if (isNaN(created) || isNaN(updated)) {
    // If either is not a valid date...
    return false;
  }
  return updated - created > UPDATED_THRESHOLD;
}

/**
 * Utility functions for collections: Sets, Maps, Arrays and Map-like objects
 */

/**
 * Return the number of elements in `ary` for which `predicate` returns true.
 *
 * @template T
 * @param {T[]} ary
 * @param {(item: T) => boolean} predicate
 * @return {number}
 */
function countIf(ary, predicate) {
  return ary.reduce((count, item) => {
    return predicate(item) ? count + 1 : count;
  }, 0);
}

/**
 * Convert an array of strings into an object mapping each array entry
 * to `true`.
 *
 * @param {string[]} arr
 * @return {Record<string,true>}
 */
function toTrueMap(arr) {
  const obj = /** @type {Record<string,true>} */{};
  arr.forEach(key => obj[key] = true);
  return obj;
}

/**
 * Utility function that returns all of the properties of an object whose
 * value is `true`.
 *
 * @param {Record<string, boolean>} obj
 * @return {string[]}
 */
function trueKeys(obj) {
  return Object.keys(obj).filter(key => obj[key] === true);
}

/**
 * Typed version of `Object.entries` for use with objects typed as
 * `Record<Key, Value>`.
 *
 * Unlike `Object.entries`, this preserves the type of the key.
 *
 * @template {string|number|symbol} Key
 * @template Value
 * @param {Record<Key, Value>} object
 */
function entries(object) {
  return (/** @type {[Key, Value][]} */Object.entries(object)
  );
}

/**
 * @typedef {'annotation'|'notebook'|'sidebar'|'stream'} RouteName
 */

const initialState$e = {
  /**
   * The current route.
   *
   * @type {RouteName|null}
   */
  name: null,
  /**
   * Parameters of the current route.
   *
   * - The "annotation" route has an "id" (annotation ID) parameter.
   * - The "stream" route has a "q" (query) parameter.
   * - The "sidebar" route has no parameters.
   *
   * @type {Record<string, string>}
   */
  params: {}
};

/** @typedef {typeof initialState} State */

const reducers$e = {
  /**
   * @param {State} state
   * @param {{ name: RouteName, params: Record<string, string> }} action
   */
  CHANGE_ROUTE(state, {
    name,
    params
  }) {
    return {
      name,
      params
    };
  }
};

/**
 * Change the active route.
 *
 * @param {RouteName} name - Name of the route to activate. See `initialState` for possible values
 * @param {Record<string,string>} params - Parameters associated with the route
 */
function changeRoute(name, params = {}) {
  return makeAction(reducers$e, 'CHANGE_ROUTE', {
    name,
    params
  });
}

/**
 * Return the name of the current route.
 *
 * @param {State} state
 */
function route(state) {
  return state.name;
}

/**
 * Return any parameters for the current route, extracted from the path and
 * query string.
 *
 * @param {State} state
 */
function routeParams(state) {
  return state.params;
}
const routeModule = createStoreModule(initialState$e, {
  namespace: 'route',
  reducers: reducers$e,
  actionCreators: {
    changeRoute
  },
  selectors: {
    route,
    routeParams
  }
});

/**
 * @typedef {import('../../../types/api').Profile} Profile
 * @typedef {import('../../../types/config').SidebarSettings} SidebarSettings
 */

/**
 * A dummy profile returned by the `profile` selector before the real profile
 * is fetched.
 *
 * @type Profile
 */
const initialProfile = {
  /** A map of features that are enabled for the current user. */
  features: {},
  /** A map of preference names and values. */
  preferences: {},
  /**
   * The authenticated user ID or null if the user is not logged in.
   */
  userid: null
};

/**
 * @typedef State
 * @prop {string} defaultAuthority
 * @prop {Profile} profile
 */

/** @param {SidebarSettings} settings */
function initialState$d(settings) {
  var _settings$authDomain;
  return {
    /**
     * The app's default authority (user identity provider), from settings,
     * e.g. `hypothes.is` or `localhost`
     * FIXME: This returns an empty string when `authDomain` is missing
     * because other app logic has long assumed its string-y presence:
     * behavior when it's missing is undefined. This setting should be
     * enforced similarly to how `apiUrl` is enforced.
     */
    defaultAuthority: (_settings$authDomain = settings === null || settings === void 0 ? void 0 : settings.authDomain) !== null && _settings$authDomain !== void 0 ? _settings$authDomain : '',
    /**
     * Profile object fetched from the `/api/profile` endpoint.
     */
    profile: initialProfile
  };
}
const reducers$d = {
  /**
   * @param {State} state
   * @param {{ profile: Profile }} action
   */
  UPDATE_PROFILE(state, action) {
    return {
      profile: {
        ...action.profile
      }
    };
  }
};

/**
 * Update the profile information for the current user.
 *
 * @param {Profile} profile
 */
function updateProfile(profile) {
  return makeAction(reducers$d, 'UPDATE_PROFILE', {
    profile
  });
}

/**
 * @param {State} state
 */
function defaultAuthority(state) {
  return state.defaultAuthority;
}

/**
 * Return true if a user is logged in and false otherwise.
 *
 * @param {State} state
 */
function isLoggedIn(state) {
  return state.profile.userid !== null;
}

/**
 * Return true if a given feature flag is enabled for the current user.
 *
 * @param {State} state
 * @param {string} feature - The name of the feature flag. This matches the
 *        name of the feature flag as declared in the Hypothesis service.
 */
function isFeatureEnabled(state, feature) {
  return !!state.profile.features[feature];
}

/**
 * Return true if the user's profile has been fetched. This can be used to
 * distinguish the dummy profile returned by `profile()` on startup from a
 * logged-out user profile returned by the server.
 *
 * @param {State} state
 */
function hasFetchedProfile(state) {
  return state.profile !== initialProfile;
}

/**
 * Return the user's profile.
 *
 * Returns the current user's profile fetched from the `/api/profile` endpoint.
 *
 * If the profile has not yet been fetched yet, a dummy logged-out profile is
 * returned. This allows code to skip a null check.
 *
 * @param {State} state
 */
function profile(state) {
  return state.profile;
}
const sessionModule = createStoreModule(initialState$d, {
  namespace: 'session',
  reducers: reducers$d,
  actionCreators: {
    updateProfile
  },
  selectors: {
    defaultAuthority,
    hasFetchedProfile,
    isFeatureEnabled,
    isLoggedIn,
    profile
  }
});

/**
 * State management for the set of annotations currently loaded into the
 * sidebar.
 */

/**
 * @typedef {'anchored'|'orphan'|'timeout'} AnchorStatus
 * @typedef {import('../../../types/api').Annotation} Annotation
 * @typedef {import('../../../types/shared').HighlightCluster} HighlightCluster
 * @typedef {import('../../../types/shared').ClientAnnotationData} ClientAnnotationData
 * @typedef {import('../../../types/api').SavedAnnotation} SavedAnnotation
 */

/**
 * @typedef AnnotationStub
 * @prop {string} [id] - service-provided identifier if annotation has been
 *       persisted to the service
 * @prop {string} [$tag] - local-generated identifier
 */

/**
 * Return a copy of `current` with all matching annotations in `annotations`
 * removed (matched on identifier—`id` or `$tag`)
 *
 * Annotations in `annotations` may be complete annotations or "stubs" with only
 * the `id` field set.
 *
 * @param {Annotation[]} current
 * @param {AnnotationStub[]} annotations
 */
function excludeAnnotations(current, annotations) {
  const ids = new Set();
  const tags = new Set();
  for (let annot of annotations) {
    if (annot.id) {
      ids.add(annot.id);
    }
    if (annot.$tag) {
      tags.add(annot.$tag);
    }
  }
  return current.filter(annot => {
    const shouldRemove = annot.id && ids.has(annot.id) || annot.$tag && tags.has(annot.$tag);
    return !shouldRemove;
  });
}

/**
 * @param {Annotation[]} annotations
 * @param {string} id
 */
function findByID(annotations, id) {
  return annotations.find(a => a.id === id);
}

/**
 * @param {Annotation[]} annotations
 * @param {string} tag
 */
function findByTag(annotations, tag) {
  return annotations.find(a => a.$tag === tag);
}

/**
 * Merge client annotation data into the annotation object about to be added to
 * the store's collection of `annotations`.
 *
 * `annotation` may either be new (unsaved) or a persisted annotation retrieved
 * from the service.
 *
 * @param {Omit<Annotation, '$anchorTimeout'>} annotation
 * @param {string} tag - The `$tag` value that should be used for this if it
 *                       doesn't have a `$tag` already
 * @param {string|null} currentUserId - The account id of the currently-auth'd
 *                       user, if any
 * @return {Annotation} - API annotation data with client annotation data merged
 */
function initializeAnnotation(annotation, tag, currentUserId) {
  let orphan = annotation.$orphan;
  if (!annotation.id) {
    // New annotations must be anchored
    orphan = false;
  }
  let $cluster = /** @type {HighlightCluster} */'other-content';
  if (annotation.user === currentUserId) {
    $cluster = isHighlight(annotation) ? 'user-highlights' : 'user-annotations';
  }
  return Object.assign({}, annotation, /** @type {ClientAnnotationData} */{
    $anchorTimeout: false,
    $cluster,
    $tag: annotation.$tag || tag,
    $orphan: orphan
  });
}
const initialState$c = {
  /**
   * Set of all currently loaded annotations.
   *
   * @type {Annotation[]}
   */
  annotations: [],
  /**
   * Annotations whose cards or highlights are currently hovered.
   *
   * The styling of the highlights/cards of these annotations are adjusted to
   * show the correspondence between the two.
   *
   * @type {Record<string, boolean>}
   */
  hovered: {},
  /**
   * A map of annotations that should appear as "highlighted", e.g. the
   * target of a single-annotation view
   *
   * @type {Record<string, boolean>}
   */
  highlighted: {},
  /** The local tag to assign to the next annotation that is loaded into the app. */
  nextTag: 1
};

/** @typedef {typeof initialState} State */

const reducers$c = {
  /**
   * @param {State} state
   * @param {{ annotations: Annotation[], currentAnnotationCount: number, currentUserId: string|null }} action
   */
  ADD_ANNOTATIONS(state, action) {
    const updatedIDs = new Set();
    const updatedTags = new Set();
    const added = [];
    const unchanged = [];
    const updated = [];
    let nextTag = state.nextTag;
    for (let annot of action.annotations) {
      let existing;
      if (annot.id) {
        existing = findByID(state.annotations, annot.id);
      }
      if (!existing && annot.$tag) {
        existing = findByTag(state.annotations, annot.$tag);
      }
      if (existing) {
        // Merge the updated annotation with the private fields from the local
        // annotation
        updated.push(Object.assign({}, existing, annot));
        if (annot.id) {
          updatedIDs.add(annot.id);
        }
        if (existing.$tag) {
          updatedTags.add(existing.$tag);
        }
      } else {
        added.push(initializeAnnotation(annot, 't' + nextTag, action.currentUserId));
        ++nextTag;
      }
    }
    for (let annot of state.annotations) {
      if (!updatedIDs.has(annot.id) && !updatedTags.has(annot.$tag)) {
        unchanged.push(annot);
      }
    }
    return {
      annotations: added.concat(updated).concat(unchanged),
      nextTag
    };
  },
  CLEAR_ANNOTATIONS() {
    return {
      annotations: [],
      highlighted: {},
      hovered: {}
    };
  },
  /**
   * @param {State} state
   * @param {{ tags: string[] }} action
   */
  HOVER_ANNOTATIONS(state, action) {
    return {
      hovered: toTrueMap(action.tags)
    };
  },
  /**
   * @param {State} state
   * @param {{ id: string }} action
   */
  HIDE_ANNOTATION(state, action) {
    const anns = state.annotations.map(ann => {
      if (ann.id !== action.id) {
        return ann;
      }
      return {
        ...ann,
        hidden: true
      };
    });
    return {
      annotations: anns
    };
  },
  /**
   * @param {State} state
   * @param {{ highlighted: Record<string, boolean> }} action
   */
  HIGHLIGHT_ANNOTATIONS(state, action) {
    return {
      highlighted: action.highlighted
    };
  },
  /**
   * @param {State} state
   * @param {{ annotationsToRemove: AnnotationStub[], remainingAnnotations: Annotation[] }} action
   */
  REMOVE_ANNOTATIONS(state, action) {
    return {
      annotations: [...action.remainingAnnotations]
    };
  },
  /**
   * @param {State} state
   * @param {{ id: string }} action
   */
  UNHIDE_ANNOTATION(state, action) {
    const anns = state.annotations.map(ann => {
      if (ann.id !== action.id) {
        return ann;
      }
      return Object.assign({}, ann, {
        hidden: false
      });
    });
    return {
      annotations: anns
    };
  },
  /**
   * @param {State} state
   * @param {{ statusUpdates: Record<string, AnchorStatus> }} action
   */
  UPDATE_ANCHOR_STATUS(state, action) {
    const annotations = state.annotations.map(annot => {
      if (!hasOwn(action.statusUpdates, annot.$tag)) {
        return annot;
      }
      const state = action.statusUpdates[annot.$tag];
      if (state === 'timeout') {
        return Object.assign({}, annot, {
          $anchorTimeout: true
        });
      } else {
        return Object.assign({}, annot, {
          $orphan: state === 'orphan'
        });
      }
    });
    return {
      annotations
    };
  },
  /**
   * @param {State} state
   * @param {{ id: string, isFlagged: boolean }} action
   */
  UPDATE_FLAG_STATUS(state, action) {
    const annotations = state.annotations.map(annot => {
      const match = annot.id && annot.id === action.id;
      if (match) {
        if (annot.flagged === action.isFlagged) {
          return annot;
        }
        const newAnn = Object.assign({}, annot, {
          flagged: action.isFlagged
        });
        if (newAnn.moderation) {
          const countDelta = action.isFlagged ? 1 : -1;
          newAnn.moderation = {
            ...newAnn.moderation,
            flagCount: newAnn.moderation.flagCount + countDelta
          };
        }
        return newAnn;
      } else {
        return annot;
      }
    });
    return {
      annotations
    };
  }
};

/* Action creators */

/**
 * Add these `annotations` to the current collection of annotations in the store.
 *
 * @param {Annotation[]} annotations - Array of annotation objects to add.
 */
function addAnnotations(annotations) {
  /**
   * @param {import('redux').Dispatch} dispatch
   * @param {() => { annotations: State, route: import('./route').State, session: import('./session').State }} getState
   */
  return function (dispatch, getState) {
    const added = annotations.filter(annot => {
      return !annot.id || !findByID(getState().annotations.annotations, annot.id);
    });
    const profile = sessionModule.selectors.profile(getState().session);
    dispatch(makeAction(reducers$c, 'ADD_ANNOTATIONS', {
      annotations,
      currentAnnotationCount: getState().annotations.annotations.length,
      currentUserId: profile.userid
    }));

    // If we're not in the sidebar, we're done here.
    // FIXME Split the annotation-adding from the anchoring code; possibly
    // move into service
    if (routeModule.selectors.route(getState().route) !== 'sidebar') {
      return;
    }

    // If anchoring fails to complete in a reasonable amount of time, then
    // we assume that the annotation failed to anchor. If it does later
    // successfully anchor then the status will be updated.
    const ANCHORING_TIMEOUT = 500;
    const anchoringIDs = added.filter(isWaitingToAnchor).map(ann => ann.id);
    if (anchoringIDs.length > 0) {
      setTimeout(() => {
        // Find annotations which haven't yet been anchored in the document.
        const anns = getState().annotations.annotations;
        const annsStillAnchoring = anchoringIDs.map(id => id ? findByID(anns, id) : null).filter(ann => ann && isWaitingToAnchor(ann));

        // Mark anchoring as timed-out for these annotations.
        const anchorStatusUpdates = annsStillAnchoring.reduce((updates, ann) => {
          updates[/** @type {Annotation} */ann.$tag] = 'timeout';
          return updates;
        }, /** @type {Record<string, 'timeout'>} */{});
        dispatch(updateAnchorStatus(anchorStatusUpdates));
      }, ANCHORING_TIMEOUT);
    }
  };
}

/** Set the currently displayed annotations to the empty set. */
function clearAnnotations() {
  return makeAction(reducers$c, 'CLEAR_ANNOTATIONS', undefined);
}

/**
 * Replace the current set of hovered annotations with the annotations
 * identified by `tags`.
 *
 * @param {string[]} tags
 */
function hoverAnnotations(tags) {
  return makeAction(reducers$c, 'HOVER_ANNOTATIONS', {
    tags
  });
}

/**
 * Update the local hidden state of an annotation.
 *
 * This updates an annotation to reflect the fact that it has been hidden from
 * non-moderators.
 *
 * @param {string} id
 */
function hideAnnotation(id) {
  return makeAction(reducers$c, 'HIDE_ANNOTATION', {
    id
  });
}

/**
 * Highlight annotations with the given `ids`.
 *
 * This is used to indicate the specific annotation in a thread that was
 * linked to for example. Replaces the current map of highlighted annotations.
 * All provided annotations (`ids`) will be set to `true` in the `highlighted`
 * map.
 *
 * @param {string[]} ids - annotations to highlight
 */
function highlightAnnotations(ids) {
  return makeAction(reducers$c, 'HIGHLIGHT_ANNOTATIONS', {
    highlighted: toTrueMap(ids)
  });
}

/**
 * Remove annotations from the currently displayed set.
 *
 * @param {AnnotationStub[]} annotations -
 *   Annotations to remove. These may be complete annotations or stubs which
 *   only contain an `id` property.
 */
function removeAnnotations(annotations) {
  /**
   * @param {import('redux').Dispatch} dispatch
   * @param {() => { annotations: State }} getState
   */
  return (dispatch, getState) => {
    const remainingAnnotations = excludeAnnotations(getState().annotations.annotations, annotations);
    dispatch(makeAction(reducers$c, 'REMOVE_ANNOTATIONS', {
      annotationsToRemove: annotations,
      remainingAnnotations
    }));
  };
}

/**
 * Update the local hidden state of an annotation.
 *
 * This updates an annotation to reflect the fact that it has been made visible
 * to non-moderators.
 *
 * @param {string} id
 */
function unhideAnnotation(id) {
  return makeAction(reducers$c, 'UNHIDE_ANNOTATION', {
    id
  });
}

/**
 * Update the anchoring status of an annotation
 *
 * @param {Record<string, AnchorStatus>} statusUpdates - Map of annotation tag to orphan status
 */
function updateAnchorStatus(statusUpdates) {
  return makeAction(reducers$c, 'UPDATE_ANCHOR_STATUS', {
    statusUpdates
  });
}

/**
 * Updating the flagged status of an annotation.
 *
 * @param {string} id - Annotation ID
 * @param {boolean} isFlagged - The flagged status of the annotation. True if
 *        the user has flagged the annotation.
 *
 */
function updateFlagStatus(id, isFlagged) {
  return makeAction(reducers$c, 'UPDATE_FLAG_STATUS', {
    id,
    isFlagged
  });
}

/* Selectors */

/**
 * Count the number of annotations (as opposed to notes or orphans)
 */
const annotationCount = createSelector( /** @param {State} state */
state => state.annotations, annotations => countIf(annotations, isAnnotation));

/**
 * Retrieve all annotations currently in the store
 *
 * @param {State} state
 */
function allAnnotations(state) {
  return state.annotations;
}

/**
 * Does the annotation indicated by `id` exist in the collection?
 *
 * @param {State} state
 * @param {string} id
 */
function annotationExists(state, id) {
  return state.annotations.some(annot => annot.id === id);
}

/**
 * Return the annotation with the given ID
 *
 * @param {State} state
 * @param {string} id
 */
function findAnnotationByID(state, id) {
  return findByID(state.annotations, id);
}

/**
 * Return the IDs of annotations that correspond to `tags`.
 *
 * If an annotation does not have an ID because it has not been created on
 * the server, there will be no entry for it in the returned array.
 *
 * @param {State} state
 * @param {string[]} tags - Local tags of annotations to look up
 */
function findIDsForTags(state, tags) {
  const ids = [];
  for (let tag of tags) {
    const annot = findByTag(state.annotations, tag);
    if (annot && annot.id) {
      ids.push(annot.id);
    }
  }
  return ids;
}

/**
 * Retrieve currently-hovered annotation identifiers
 */
const hoveredAnnotations = createSelector( /** @param {State} state */
state => state.hovered, hovered => trueKeys(hovered));

/**
 * Retrieve currently-highlighted annotation identifiers
 */
const highlightedAnnotations = createSelector( /** @param {State} state */
state => state.highlighted, highlighted => trueKeys(highlighted));

/**
 * Is the annotation identified by `$tag` currently hovered?
 *
 * @param {State} state
 * @param {string} $tag
 */
function isAnnotationHovered(state, $tag) {
  return state.hovered[$tag] === true;
}

/**
 * Are there any annotations still waiting to anchor?
 */
const isWaitingToAnchorAnnotations = createSelector( /** @param {State} state */
state => state.annotations, annotations => annotations.some(isWaitingToAnchor));

/**
 * Return all loaded annotations that are not highlights and have not been saved
 * to the server
 */
const newAnnotations = createSelector( /** @param {State} state */
state => state.annotations, annotations => annotations.filter(ann => isNew(ann) && !isHighlight(ann)));

/**
 * Return all loaded annotations that are highlights and have not been saved
 * to the server
 */
const newHighlights = createSelector( /** @param {State} state */
state => state.annotations, annotations => annotations.filter(ann => isNew(ann) && isHighlight(ann)));

/**
 * Count the number of page notes currently in the collection
 */
const noteCount = createSelector( /** @param {State} state */
state => state.annotations, annotations => countIf(annotations, isPageNote));

/**
 * Count the number of orphans currently in the collection
 */
const orphanCount = createSelector( /** @param {State} state */
state => state.annotations, annotations => countIf(annotations, isOrphan));

/**
 * Return all loaded annotations which have been saved to the server
 *
 * @param {State} state
 * @return {SavedAnnotation[]}
 */
function savedAnnotations(state) {
  return (/** @type {SavedAnnotation[]} */
    state.annotations.filter(ann => isSaved(ann))
  );
}
const annotationsModule = createStoreModule(initialState$c, {
  namespace: 'annotations',
  reducers: reducers$c,
  actionCreators: {
    addAnnotations,
    clearAnnotations,
    hoverAnnotations,
    hideAnnotation,
    highlightAnnotations,
    removeAnnotations,
    unhideAnnotation,
    updateAnchorStatus,
    updateFlagStatus
  },
  selectors: {
    allAnnotations,
    annotationCount,
    annotationExists,
    findAnnotationByID,
    findIDsForTags,
    hoveredAnnotations,
    highlightedAnnotations,
    isAnnotationHovered,
    isWaitingToAnchorAnnotations,
    newAnnotations,
    newHighlights,
    noteCount,
    orphanCount,
    savedAnnotations
  }
});

/**
 * A store module for managing client-side user-convenience defaults.
 *
 * Example: the default privacy level for newly-created annotations
 * (`private` or `shared`). This default is updated when a user selects a
 * different publishing destination (e.g. `Post to [group name]` versus
 * `Post to Only Me`) from the menu rendered by the `AnnotationPublishControl`
 * component.
 *
 * At present, these defaults are persisted between app sessions in `localStorage`,
 * and their retrieval and re-persistence on change is handled in the
 * `persistedDefaults` service.
 */

const initialState$b = {
  annotationPrivacy: /** @type {'private'|'shared'|null} */null,
  focusedGroup: /** @type {string|null} */null
};

/**
 * @typedef {keyof initialState} Key
 * @typedef {typeof initialState} State
 */

const reducers$b = {
  /**
   * @param {State} state
   * @param {{ defaultKey: Key, value: string|null }} action
   */
  SET_DEFAULT(state, action) {
    return {
      [action.defaultKey]: action.value
    };
  }
};

/**
 * @param {Key} defaultKey
 * @param {string|null} value
 */
function setDefault(defaultKey, value) {
  return makeAction(reducers$b, 'SET_DEFAULT', {
    defaultKey,
    value
  });
}

/** Selectors */

/**
 * Retrieve the state's current value for `defaultKey`.
 *
 * @param {State} state
 * @param {Key} defaultKey
 */
function getDefault(state, defaultKey) {
  return state[defaultKey];
}

/** @param {State} state */
function getDefaults(state) {
  return state;
}
const defaultsModule = createStoreModule(initialState$b, {
  namespace: 'defaults',
  reducers: reducers$b,
  actionCreators: {
    setDefault
  },
  selectors: {
    getDefault,
    getDefaults
  }
});

/** @param {import('../../../types/config').SidebarSettings} settings */
function initialState$a(settings) {
  return {
    /**
     * The ID of the direct-linked group.
     *
     * This ID is initialized from the client's configuration to indicate that
     * the client should focus on a particular group initially. The user may
     * need to login for this step to complete. When the user navigates away
     * from the group or clears the selection, the direct link is "consumed"
     * and no longer used.
     *
     * @type {string|null}
     */
    directLinkedGroupId: settings.group || null,
    /**
     * The ID of the direct-linked annotation.
     *
     * This ID is initialized from the client's configuration to indicate that
     * the client should focus on a particular annotation. The user may need to
     * login to see the annotation. When the user clears the selection or
     * switches to a different group manually, the direct link is "consumed"
     * and no longer used.
     *
     * @type {string|null}
     */
    directLinkedAnnotationId: settings.annotations || null,
    /**
     * Indicates that an error occurred in retrieving/showing the direct linked group.
     * This could be because:
     * - the group does not exist
     * - the user does not have permission
     * - the group is out of scope for the given page
     * @type {boolean}
     */
    directLinkedGroupFetchFailed: false
  };
}

/** @typedef {ReturnType<initialState>} State */

const reducers$a = {
  /**
   * @param {State} state
   * @param {{ directLinkedGroupFetchFailed: boolean }} action
   */
  UPDATE_DIRECT_LINKED_GROUP_FETCH_FAILED(state, action) {
    return {
      directLinkedGroupFetchFailed: action.directLinkedGroupFetchFailed
    };
  },
  /**
   * @param {State} state
   * @param {{ directLinkedGroupId: string }} action
   */
  UPDATE_DIRECT_LINKED_GROUP_ID(state, action) {
    return {
      directLinkedGroupId: action.directLinkedGroupId
    };
  },
  /**
   * @param {State} state
   * @param {{ directLinkedAnnotationId: string }} action
   */
  UPDATE_DIRECT_LINKED_ANNOTATION_ID(state, action) {
    return {
      directLinkedAnnotationId: action.directLinkedAnnotationId
    };
  },
  CLEAR_DIRECT_LINKED_IDS() {
    return {
      directLinkedAnnotationId: null,
      directLinkedGroupId: null
    };
  },
  CLEAR_SELECTION() {
    return {
      directLinkedAnnotationId: null,
      directLinkedGroupId: null,
      directLinkedGroupFetchFailed: false
    };
  }
};

/**
 * Set the direct linked group id.
 *
 * @param {string} groupId
 */
function setDirectLinkedGroupId(groupId) {
  return makeAction(reducers$a, 'UPDATE_DIRECT_LINKED_GROUP_ID', {
    directLinkedGroupId: groupId
  });
}

/**
 * Set the direct linked annotation's id.
 *
 * @param {string} annId
 */
function setDirectLinkedAnnotationId(annId) {
  return makeAction(reducers$a, 'UPDATE_DIRECT_LINKED_ANNOTATION_ID', {
    directLinkedAnnotationId: annId
  });
}

/**
 * Set the direct linked group fetch failure to true.
 */
function setDirectLinkedGroupFetchFailed() {
  return makeAction(reducers$a, 'UPDATE_DIRECT_LINKED_GROUP_FETCH_FAILED', {
    directLinkedGroupFetchFailed: true
  });
}

/**
 * Clear the direct linked group fetch failure.
 */
function clearDirectLinkedGroupFetchFailed() {
  return makeAction(reducers$a, 'UPDATE_DIRECT_LINKED_GROUP_FETCH_FAILED', {
    directLinkedGroupFetchFailed: false
  });
}

/**
 * Clear the direct linked annotations and group IDs.
 *
 * This action indicates that the direct link has been "consumed" and should
 * not affect future group/annotation etc. fetches.
 */
function clearDirectLinkedIds() {
  return makeAction(reducers$a, 'CLEAR_DIRECT_LINKED_IDS', undefined);
}

/** @param {State} state */
function directLinkedAnnotationId(state) {
  return state.directLinkedAnnotationId;
}

/** @param {State} state */
function directLinkedGroupId(state) {
  return state.directLinkedGroupId;
}

/** @param {State} state */
function directLinkedGroupFetchFailed(state) {
  return state.directLinkedGroupFetchFailed;
}
const directLinkedModule = createStoreModule(initialState$a, {
  namespace: 'directLinked',
  reducers: reducers$a,
  actionCreators: {
    setDirectLinkedGroupFetchFailed,
    setDirectLinkedGroupId,
    setDirectLinkedAnnotationId,
    clearDirectLinkedGroupFetchFailed,
    clearDirectLinkedIds
  },
  selectors: {
    directLinkedAnnotationId,
    directLinkedGroupFetchFailed,
    directLinkedGroupId
  }
});

/**
 * @typedef {import('redux-thunk/extend-redux')} Dummy
 * @typedef {import('../../../types/api').Annotation} Annotation
 */

/**
 * The drafts store provides temporary storage for unsaved edits to new or
 * existing annotations.
 */

const initialState$9 = {
  /** @type {Draft[]} */
  drafts: []
};

/** @typedef {typeof initialState} State */

/**
 * @typedef {Pick<Annotation, 'id'|'$tag'>} AnnotationID
 */

/**
 * Edits made to a new or existing annotation by a user.
 *
 * @typedef DraftChanges
 * @prop {boolean} isPrivate
 * @prop {string[]} tags
 * @prop {string} text
 */

/**
 * An unsaved set of changes to an annotation.
 *
 * This consists of an annotation ID ({@link AnnotationID}) and the edits
 * ({@link DraftChanges}) made by the user.
 */
class Draft {
  /**
   * @param {AnnotationID} annotation
   * @param {DraftChanges} changes
   */
  constructor(annotation, changes) {
    this.annotation = {
      id: annotation.id,
      $tag: annotation.$tag
    };
    this.isPrivate = changes.isPrivate;
    this.tags = changes.tags;
    this.text = changes.text;
  }
  /**
   * Returns true if this draft matches a given annotation.
   *
   * Annotations are matched by ID or local tag.
   *
   * @param {AnnotationID} annotation
   */
  match(annotation) {
    return this.annotation.$tag && annotation.$tag === this.annotation.$tag || this.annotation.id && annotation.id === this.annotation.id;
  }
  /**
   * Return true if this draft is empty and can be discarded without losing
   * any user input.
   */
  isEmpty() {
    return !this.text && this.tags.length === 0;
  }
}
const reducers$9 = {
  DISCARD_ALL_DRAFTS() {
    return {
      drafts: []
    };
  },
  /**
   * @param {State} state
   * @param {{ annotation: AnnotationID }} action
   */
  REMOVE_DRAFT(state, action) {
    const drafts = state.drafts.filter(draft => {
      return !draft.match(action.annotation);
    });
    return {
      drafts
    };
  },
  /**
   * @param {State} state
   * @param {{ draft: Draft }} action
   */
  UPDATE_DRAFT(state, action) {
    // removes a matching existing draft, then adds
    const drafts = state.drafts.filter(draft => {
      return !draft.match(action.draft.annotation);
    });
    drafts.push(action.draft); // push ok since its a copy
    return {
      drafts
    };
  }
};

/**
 * Create or update the draft version for a given annotation by
 * replacing any existing draft or simply creating a new one.
 *
 * @param {AnnotationID} annotation
 * @param {DraftChanges} changes
 */
function createDraft(annotation, changes) {
  return makeAction(reducers$9, 'UPDATE_DRAFT', {
    draft: new Draft(annotation, changes)
  });
}

/**
 * Remove any drafts that are empty.
 *
 * An empty draft has no text and no reference tags.
 */
function deleteNewAndEmptyDrafts() {
  /**
   * @param {import('redux').Dispatch} dispatch
   * @param {() => { drafts: State }} getState
   */
  return (dispatch, getState) => {
    const newDrafts = getState().drafts.drafts.filter(draft => {
      return !draft.annotation.id && !getDraftIfNotEmpty(getState().drafts, draft.annotation);
    });
    const removedAnnotations = newDrafts.map(draft => {
      dispatch(removeDraft(draft.annotation));
      return draft.annotation;
    });
    dispatch(removeAnnotations(removedAnnotations));
  };
}

/**
 * Remove all drafts.
 */
function discardAllDrafts() {
  return makeAction(reducers$9, 'DISCARD_ALL_DRAFTS', undefined);
}

/**
 * Remove the draft version of an annotation.
 *
 * @param {AnnotationID} annotation
 */
function removeDraft(annotation) {
  return makeAction(reducers$9, 'REMOVE_DRAFT', {
    annotation
  });
}

/**
 * Returns the number of drafts - both unsaved new annotations, and unsaved
 * edits to saved annotations - currently stored.
 *
 * @param {State} state
 */
function countDrafts(state) {
  return state.drafts.length;
}

/**
 * Retrieve the draft changes for an annotation.
 *
 * @param {State} state
 * @param {AnnotationID} annotation
 */
function getDraft(state, annotation) {
  const drafts = state.drafts;
  for (let i = 0; i < drafts.length; i++) {
    const draft = drafts[i];
    if (draft.match(annotation)) {
      return draft;
    }
  }
  return null;
}

/**
 * Returns the draft changes for an annotation, or null if no draft exists
 * or the draft is empty.
 *
 * @param {State} state
 * @param {AnnotationID} annotation
 */
function getDraftIfNotEmpty(state, annotation) {
  const draft = getDraft(state, annotation);
  if (!draft) {
    return null;
  }
  return draft.isEmpty() ? null : draft;
}

/**
 * Returns a list of draft annotations which have no id.
 */
const unsavedAnnotations = createSelector( /** @param {State} state */
state => state.drafts, drafts => drafts.filter(d => !d.annotation.id).map(d => d.annotation));
const draftsModule = createStoreModule(initialState$9, {
  namespace: 'drafts',
  reducers: reducers$9,
  actionCreators: {
    createDraft,
    deleteNewAndEmptyDrafts,
    discardAllDrafts,
    removeDraft
  },
  selectors: {
    countDrafts,
    getDraft,
    getDraftIfNotEmpty,
    unsavedAnnotations
  }
});

/**
 * Manage state pertaining to the filtering of annotations in the UI.
 *
 * There are a few sources of filtering that gets applied to annotations:
 *
 * - focusFilters: Filters defined by config/settings. Currently supports a
 *   user filter. Application of these filters may be toggled on/off by user
 *   interaction (`focusActive`), but the values of these filters are set by
 *   config/settings or RPC (not by user directly). The value(s) of
 *   focusFilters are retained even when focus is inactive such that they might
 *   be re-applied later.
 * - filters: Filters set by faceting/filtering UI. Any filter here is currently
 *   active (applied).
 * - query: String query that is either typed in by the user or provided in
 *   settings. A query string may contain supported facets.
 *   (see `util/search-filter`)
 */

/**
 * @typedef {import('../../../types/config').FocusConfig} FocusConfig
 * @typedef {import('../../../types/config').SidebarSettings} SidebarSettings
 * @typedef {import('../../../types/rpc').FocusUserInfo} FocusUserInfo
 */

/**
 * @typedef FilterOption
 * @prop {string} value - The machine-readable value of the option
 * @prop {string} display - The human-facing "pretty" value of the option
 */

/**
 * Valid/recognized filters
 * @typedef {'user'} FilterKey
 */

/**
 * @typedef {Record<FilterKey, FilterOption|undefined>} Filters
 */

/**
 * @typedef FocusState
 * @prop {boolean} active
 * @prop {boolean} configured
 * @prop {string} displayName
 */

/** @param {SidebarSettings} settings */
function initialState$8(settings) {
  const focusConfig = settings.focus || {};
  return {
    filters: /** @type {Filters} */{},
    // immediately activate focus mode if there is a valid config
    focusActive: isValidFocusConfig(focusConfig),
    focusFilters: focusFiltersFromConfig(focusConfig),
    /** @type {string|null} */
    query: settings.query || null
  };
}

/** @typedef {ReturnType<typeof initialState>} State */

/**
 * Given the provided focusConfig: is it a valid configuration for focus?
 * At this time, a `user` filter is required.
 *
 * @param {FocusConfig} focusConfig
 * @return {boolean}
 */
function isValidFocusConfig(focusConfig) {
  var _focusConfig$user, _focusConfig$user2;
  return !!((_focusConfig$user = focusConfig.user) !== null && _focusConfig$user !== void 0 && _focusConfig$user.username || (_focusConfig$user2 = focusConfig.user) !== null && _focusConfig$user2 !== void 0 && _focusConfig$user2.userid);
}

/**
 * Compose an object of keyed `FilterOption`s from the given `focusConfig`.
 * At present, this will create a `user` `FilterOption` if the config is valid.
 *
 * @param {FocusConfig} focusConfig
 * @return {Filters}
 */
function focusFiltersFromConfig(focusConfig) {
  const user = focusConfig.user;
  if (!user || !isValidFocusConfig(focusConfig)) {
    return (/** @type {Filters} */{}
    );
  }
  const userFilterValue = user.username || user.userid || '';
  return {
    user: {
      value: userFilterValue,
      display: user.displayName || userFilterValue
    }
  };
}
const reducers$8 = {
  /**
   * @param {State} state
   * @param {{ user: FocusUserInfo }} action
   */
  CHANGE_FOCUS_MODE_USER(state, action) {
    return {
      focusActive: isValidFocusConfig({
        user: action.user
      }),
      focusFilters: focusFiltersFromConfig({
        user: action.user
      })
    };
  },
  /**
   * @param {State} state
   * @param {{ filterName: FilterKey, filterOption: FilterOption }} action
   */
  SET_FILTER(state, action) {
    var _action$filterOption;
    /** @type {Filters} */
    const updatedFilters = {
      ...state.filters,
      [action.filterName]: action.filterOption
    };
    // If the filter's value is empty, remove the filter
    if (((_action$filterOption = action.filterOption) === null || _action$filterOption === void 0 ? void 0 : _action$filterOption.value) === '') {
      delete updatedFilters[action.filterName];
    }
    return {
      filters: updatedFilters
    };
  },
  /**
   * @param {State} state
   * @param {{ query: string }} action
   */
  SET_FILTER_QUERY(state, action) {
    return {
      query: action.query
    };
  },
  /**
   * @param {State} state
   * @param {{ active?: boolean }} action
   */
  SET_FOCUS_MODE(state, action) {
    var _action$active;
    const active = (_action$active = action.active) !== null && _action$active !== void 0 ? _action$active : !state.focusActive;
    return {
      focusActive: active
    };
  },
  // Actions defined in other modules

  CLEAR_SELECTION() {
    return {
      filters: /** @type {Filters} */{},
      focusActive: false,
      query: null
    };
  }
};

// Action creators

/**
 * Change the focused user filter and activate focus
 *
 * @param {FocusUserInfo} user - The user to focus on
 */
function changeFocusModeUser(user) {
  return makeAction(reducers$8, 'CHANGE_FOCUS_MODE_USER', {
    user
  });
}

/**
 * @param {FilterKey} filterName
 * @param {FilterOption} filterOption
 */
function setFilter(filterName, filterOption) {
  /**
   * @param {import('redux').Dispatch} dispatch
   * @param {() => { filters: State }} getState
   */
  return (dispatch, getState) => {
    var _getState$filters$foc;
    // If there is a filter conflict with focusFilters, deactivate focus
    // mode to prevent unintended collisions and let the new filter value
    // take precedence.
    if ((_getState$filters$foc = getState().filters.focusFilters) !== null && _getState$filters$foc !== void 0 && _getState$filters$foc[filterName]) {
      dispatch(makeAction(reducers$8, 'SET_FOCUS_MODE', {
        active: false
      }));
    }
    dispatch(makeAction(reducers$8, 'SET_FILTER', {
      filterName,
      filterOption
    }));
  };
}

/**
 * Set the query used to filter displayed annotations.
 *
 * @param {string} query
 */
function setFilterQuery(query) {
  return makeAction(reducers$8, 'SET_FILTER_QUERY', {
    query
  });
}

/**
 * Toggle whether or not a (user-)focus mode is applied, either inverting the
 * current active state or setting it to a target `active` state, if provided.
 *
 * @param {boolean} [active] - Optional `active` state for focus mode
 */
function toggleFocusMode(active) {
  return makeAction(reducers$8, 'SET_FOCUS_MODE', {
    active
  });
}

// Selectors

/** @param {State} state */
function filterQuery(state) {
  return state.query;
}

/**
 * Summary of focus state
 */
const focusState = createSelector( /** @param {State} state */
state => state.focusActive, /** @param {State} state */
state => state.focusFilters, (focusActive, focusFilters) => {
  var _focusFilters$user;
  return {
    active: focusActive,
    configured: !!(focusFilters !== null && focusFilters !== void 0 && focusFilters.user),
    displayName: (focusFilters === null || focusFilters === void 0 ? void 0 : (_focusFilters$user = focusFilters.user) === null || _focusFilters$user === void 0 ? void 0 : _focusFilters$user.display) || ''
  };
});

/**
 * Get all currently-applied filters. If focus is active, will also return
 * `focusFilters`, though `filters` will supersede in the case of key collisions.
 * `query` is not considered a "filter" in this context.
 */
const getFilters = createSelector( /** @param {State} state */
state => state.filters, /** @param {State} state */
state => state.focusActive, /** @param {State} state */
state => state.focusFilters, (filters, focusActive, focusFilters) => {
  if (focusActive) {
    return {
      ...focusFilters,
      ...filters
    };
  }
  return {
    ...filters
  };
});

/**
 * Retrieve an applied filter by name/key
 *
 * @param {State} state
 * @param {FilterKey} filterName
 */
function getFilter(state, filterName) {
  const filters = getFilters(state);
  return filters[filterName];
}

/**
 * Retrieve the (string) values of all currently-applied filters.
 */
const getFilterValues = createSelector( /** @param {State} state */
state => getFilters(state), allFilters => {
  /** @type {Record<string,string>} */
  const filterValues = {};
  for (let [key, options] of Object.entries(allFilters)) {
    if (options) {
      filterValues[key] = options.value;
    }
  }
  return filterValues;
});

/** @param {State} state */
function getFocusFilters(state) {
  return state.focusFilters;
}

/**
 * Are there currently any active (applied) filters?
 *
 * @param {State} state
 */
function hasAppliedFilter(state) {
  return !!(state.query || Object.keys(getFilters(state)).length);
}
const filtersModule = createStoreModule(initialState$8, {
  namespace: 'filters',
  reducers: reducers$8,
  actionCreators: {
    changeFocusModeUser,
    setFilter,
    setFilterQuery,
    toggleFocusMode
  },
  selectors: {
    filterQuery,
    focusState,
    getFilter,
    getFilters,
    getFilterValues,
    getFocusFilters,
    hasAppliedFilter
  }
});

//

var shallowequal = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};

/**
 * @typedef {import('../../../types/annotator').ContentInfoConfig} ContentInfoConfig
 * @typedef {import('../../../types/annotator').DocumentMetadata} DocumentMetadata
 * @typedef {import('../../../types/annotator').SegmentInfo} SegmentInfo
 */

/**
 * @typedef Frame
 * @prop {string|null} id
 *   - Sub-frames will all have a id (frame identifier) set. The main frame's id is always `null`
 * @prop {DocumentMetadata} metadata - Metadata about the document currently loaded in this frame
 * @prop {string} uri - Current primary URI of the document being displayed
 * @prop {boolean} [isAnnotationFetchComplete]
 * @prop {boolean} persistent - Should this frame be retained in the sidebar
 *   if the guest disconnects?
 * @prop {SegmentInfo} [segment] - Information about the section of a document
 *   that is currently loaded. This is for content such as EPUBs, where the
 *   content displayed in a guest frame is only part of the whole document.
 */

const initialState$7 = {
  /** @type {Frame[]} */
  frames: [],
  /**
   * Data for the content information banner shown above the content in the main
   * guest frame.
   *
   * @type {ContentInfoConfig|null}
   */
  contentInfo: null
};

/** @typedef {typeof initialState} State */

const reducers$7 = {
  /**
   * @param {State} state
   * @param {{ frame: Frame }} action
   */
  CONNECT_FRAME(state, action) {
    const frameIndex = state.frames.findIndex(frame => frame.id === action.frame.id);
    const newFrames = [...state.frames];
    if (frameIndex !== -1) {
      newFrames[frameIndex] = action.frame;
    } else {
      newFrames.push(action.frame);
    }
    return {
      frames: newFrames
    };
  },
  /**
   * @param {State} state
   * @param {{ frame: Frame }} action
   */
  DESTROY_FRAME(state, action) {
    const frames = state.frames.filter(f => f !== action.frame);
    return {
      frames
    };
  },
  /**
   * @param {State} state
   * @param {{ uri: string, isAnnotationFetchComplete: boolean }} action
   */
  UPDATE_FRAME_ANNOTATION_FETCH_STATUS(state, action) {
    const frames = state.frames.map(frame => {
      const match = frame.uri && frame.uri === action.uri;
      if (match) {
        return Object.assign({}, frame, {
          isAnnotationFetchComplete: action.isAnnotationFetchComplete
        });
      } else {
        return frame;
      }
    });
    return {
      frames
    };
  },
  /**
   * @param {State} state
   * @param {{ info: ContentInfoConfig }} action
   */
  SET_CONTENT_INFO(state, action) {
    return {
      contentInfo: action.info
    };
  }
};

/**
 * Add or replace a frame in the list of connected frames.
 *
 * If a frame exists with the same ID as `frame` it is replaced, otherwise
 * a new frame is added.
 *
 * @param {Frame} frame
 */
function connectFrame(frame) {
  return makeAction(reducers$7, 'CONNECT_FRAME', {
    frame
  });
}

/**
 * Remove a frame from the list of connected frames.
 *
 * @param {Frame} frame
 */
function destroyFrame(frame) {
  return makeAction(reducers$7, 'DESTROY_FRAME', {
    frame
  });
}

/**
 * Update the `isAnnotationFetchComplete` flag of the frame.
 *
 * @param {string} uri
 * @param {boolean} isFetchComplete
 */
function updateFrameAnnotationFetchStatus(uri, isFetchComplete) {
  return makeAction(reducers$7, 'UPDATE_FRAME_ANNOTATION_FETCH_STATUS', {
    uri,
    isAnnotationFetchComplete: isFetchComplete
  });
}

/** @param {ContentInfoConfig} info */
function setContentInfo(info) {
  return makeAction(reducers$7, 'SET_CONTENT_INFO', {
    info
  });
}

/**
 * Return the list of frames currently connected to the sidebar app.
 *
 * @param {State} state
 */
function frames(state) {
  return state.frames;
}

/**
 * Return the "main" frame that the sidebar is connected to.
 *
 * The sidebar may be connected to multiple frames from different URLs.
 * For some purposes, the main frame (typically the top-level one that contains
 * the sidebar) needs to be distinguished. This selector returns the main frame
 * for that purpose.
 *
 * This may be `null` during startup.
 */
const mainFrame = createSelector( /** @param {State} state */
state => state.frames,
// Sub-frames will all have a "frame identifier" set. The main frame is the
// one with a `null` id.
frames => frames.find(f => !f.id) || null);

/**
 * @param {Frame} frame
 */
function searchUrisForFrame(frame) {
  let uris = [frame.uri];
  if (frame.metadata && frame.metadata.documentFingerprint) {
    uris = frame.metadata.link.map(link => {
      return link.href;
    });
  }
  if (frame.metadata && frame.metadata.link) {
    frame.metadata.link.forEach(link => {
      if (link.href.startsWith('doi:')) {
        uris.push(link.href);
      }
    });
  }
  return uris;
}

// "selector creator" that uses `shallowEqual` instead of `===` for memoization
const createShallowEqualSelector = createSelectorCreator(defaultMemoize, shallowequal);

/**
 * Memoized selector will return the same array (of URIs) reference unless the
 * values of the array change (are not shallow-equal).
 */
const searchUris = createShallowEqualSelector( /** @param {State} state */
state => state.frames.reduce((uris, frame) => uris.concat(searchUrisForFrame(frame)), /** @type {string[]} */[]), uris => uris);

/** @param {State} state */
function getContentInfo(state) {
  return state.contentInfo;
}
const framesModule = createStoreModule(initialState$7, {
  namespace: 'frames',
  reducers: reducers$7,
  actionCreators: {
    connectFrame,
    destroyFrame,
    setContentInfo,
    updateFrameAnnotationFetchStatus
  },
  selectors: {
    getContentInfo,
    frames,
    mainFrame,
    searchUris
  }
});

/**
 * @typedef {import('../../../types/api').Group} Group
 * @typedef {import('./session').State} SessionState
 */

const initialState$6 = {
  /**
   * When there are entries, only `groups` with `id`s included in this list
   * of will be displayed in the sidebar.
   *
   * @type {Group["id"][]|null}
   */
  filteredGroupIds: null,
  /**
   * List of groups.
   * @type {Group[]}
   */
  groups: [],
  /**
   * ID of currently selected group.
   * @type {string|null}
   */
  focusedGroupId: null
};

/** @typedef {typeof initialState} State */

const reducers$6 = {
  /**
   * @param {State} state
   * @param {{ filteredGroupIds: string[] }} action
   */
  FILTER_GROUPS(state, action) {
    var _action$filteredGroup;
    if (!((_action$filteredGroup = action.filteredGroupIds) !== null && _action$filteredGroup !== void 0 && _action$filteredGroup.length)) {
      return {
        filteredGroupIds: null
      };
    }
    const filteredGroups = state.groups.filter(g => action.filteredGroupIds.includes(g.id));
    if (!filteredGroups.length) {
      // If there are no matches in the full set of groups for any of the
      // provided `filteredGroupIds`, don't set the filter.
      return {
        filteredGroupIds: null
      };
    }
    // Ensure we have a focused group that is in the set of filtered groups
    let focusedGroupId = state.focusedGroupId;
    if (!focusedGroupId || !action.filteredGroupIds.includes(focusedGroupId)) {
      focusedGroupId = filteredGroups[0].id;
    }
    return {
      filteredGroupIds: action.filteredGroupIds,
      focusedGroupId
    };
  },
  /**
   * @param {State} state
   * @param {{ id: string }} action
   */
  FOCUS_GROUP(state, action) {
    const group = state.groups.find(g => g.id === action.id);
    if (!group) {
      console.error(`Attempted to focus group ${action.id} which is not loaded`);
      return {};
    }
    return {
      focusedGroupId: action.id
    };
  },
  /**
   * @param {State} state
   * @param {{ groups: Group[] }} action
   */
  LOAD_GROUPS(state, action) {
    const groups = action.groups;
    let focusedGroupId = state.focusedGroupId;

    // Reset focused group if not in the new set of groups.
    if (state.focusedGroupId === null || !groups.find(g => g.id === state.focusedGroupId)) {
      if (groups.length > 0) {
        focusedGroupId = groups[0].id;
      } else {
        focusedGroupId = null;
      }
    }
    return {
      focusedGroupId,
      groups: action.groups
    };
  },
  CLEAR_GROUPS() {
    return {
      filteredGroupIds: null,
      focusedGroupId: null,
      groups: []
    };
  }
};
function clearGroups() {
  return makeAction(reducers$6, 'CLEAR_GROUPS', undefined);
}

/**
 * Set filtered groups.
 *
 * @param {Group["id"][]} filteredGroupIds
 */
function filterGroups(filteredGroupIds) {
  return makeAction(reducers$6, 'FILTER_GROUPS', {
    filteredGroupIds
  });
}

/**
 * Set the current focused group.
 *
 * @param {string} id
 */
function focusGroup(id) {
  return makeAction(reducers$6, 'FOCUS_GROUP', {
    id
  });
}

/**
 * Update the set of loaded groups.
 *
 * @param {Group[]} groups
 */
function loadGroups(groups) {
  return makeAction(reducers$6, 'LOAD_GROUPS', {
    groups
  });
}

/**
 * Return the currently focused group.
 *
 * @param {State} state
 */
function focusedGroup(state) {
  if (!state.focusedGroupId) {
    return null;
  }
  return getGroup(state, state.focusedGroupId);
}

/**
 * Return the current focused group ID or `null`.
 *
 * @param {State} state
 */
function focusedGroupId(state) {
  return state.focusedGroupId;
}

/**
 * Return the list of all groups, ignoring any filter present.
 *
 * @param {State} state
 */
function allGroups(state) {
  return state.groups;
}

/**
 * Return a list of groups filtered by any values in `filteredGroupIds`
 *
 * @param {State} state
 */
function filteredGroups(state) {
  if (!state.filteredGroupIds) {
    return state.groups;
  }
  return state.groups.filter(g => {
    var _state$filteredGroupI;
    return (_state$filteredGroupI = state.filteredGroupIds) === null || _state$filteredGroupI === void 0 ? void 0 : _state$filteredGroupI.includes(g.id);
  });
}

/**
 * @param {State} state
 */
function filteredGroupIds(state) {
  return state.filteredGroupIds;
}

/**
 * Return the group with the given ID.
 *
 * @param {State} state
 * @param {string} id
 */
function getGroup(state, id) {
  return state.groups.find(g => g.id === id);
}

/**
 * Return groups the user isn't a member of that are scoped to the URI.
 */
const getFeaturedGroups = createSelector( /** @param {State} state */
state => filteredGroups(state), groups => groups.filter(group => !group.isMember && group.isScopedToUri));

/**
 * Return groups that are scoped to the uri. This is used to return the groups
 * that show up in the old groups menu. This should be removed once the new groups
 * menu is permanent.
 */
const getInScopeGroups = createSelector( /** @param {State} state */
state => filteredGroups(state), groups => groups.filter(g => g.isScopedToUri));

// Selectors that receive root state.

/**
 * @typedef {{ groups: State, session: SessionState }} RootState
 */

/**
 * Return groups the logged in user is a member of.
 */
const getMyGroups = createSelector( /** @param {RootState} rootState */
rootState => filteredGroups(rootState.groups), /** @param {RootState} rootState */
rootState => sessionModule.selectors.isLoggedIn(rootState.session), (groups, loggedIn) => {
  // If logged out, the Public group still has isMember set to true so only
  // return groups with membership in logged in state.
  if (loggedIn) {
    return groups.filter(g => g.isMember);
  }
  return [];
});

/**
 * Return groups that don't show up in Featured and My Groups.
 */
const getCurrentlyViewingGroups = createSelector( /** @param {RootState} rootState */
rootState => filteredGroups(rootState.groups), /** @param {RootState} rootState */
rootState => getMyGroups(rootState), /** @param {RootState} rootState */
rootState => getFeaturedGroups(rootState.groups), (allGroups, myGroups, featuredGroups) => {
  return allGroups.filter(g => !myGroups.includes(g) && !featuredGroups.includes(g));
});
const groupsModule = createStoreModule(initialState$6, {
  namespace: 'groups',
  reducers: reducers$6,
  actionCreators: {
    filterGroups,
    focusGroup,
    loadGroups,
    clearGroups
  },
  selectors: {
    allGroups,
    filteredGroups,
    filteredGroupIds,
    focusedGroup,
    focusedGroupId,
    getFeaturedGroups,
    getGroup,
    getInScopeGroups
  },
  rootSelectors: {
    getCurrentlyViewingGroups,
    getMyGroups
  }
});

/**
 * Replace parameters in a URL template with values from a `params` object.
 *
 * Returns an object containing the expanded URL and a dictionary of unused
 * parameters.
 *
 *   replaceURLParams('/things/:id', {id: 'foo', q: 'bar'}) =>
 *     {url: '/things/foo', unusedParams: {q: 'bar'}}
 *
 * @template Param
 * @param {string} url
 * @param {Record<string, Param>} params
 * @return {{ url: string, unusedParams: Record<string, Param>}}
 */
function replaceURLParams(url, params) {
  /** @type {Record<string, Param>} */
  const unusedParams = {};
  for (const param in params) {
    if (hasOwn(params, param)) {
      const value = params[param];
      const urlParam = ':' + param;
      if (url.indexOf(urlParam) !== -1) {
        url = url.replace(urlParam, encodeURIComponent(String(value)));
      } else {
        unusedParams[param] = value;
      }
    }
  }
  return {
    url,
    unusedParams
  };
}

/**
 * Resolve a relative URL against a base URL to get an absolute URL.
 *
 * @param {string} relativeURL
 * @param {string} baseURL
 */
function resolve(relativeURL, baseURL) {
  return new URL(relativeURL, baseURL).href;
}

const initialState$5 = /** @type {Record<string, string>|null} */null;

/** @typedef {typeof initialState} State */

const reducers$5 = {
  /**
   * @param {State} state
   * @param {{ links: Record<string, string> }} action
   */
  UPDATE_LINKS(state, action) {
    return {
      ...action.links
    };
  }
};

/**
 * Update the link map
 *
 * @param {Record<string, string>} links - Link map fetched from the `/api/links` endpoint
 */
function updateLinks(links) {
  return makeAction(reducers$5, 'UPDATE_LINKS', {
    links
  });
}

/**
 * Render a service link (URL) using the given `params`
 *
 * Returns an empty string if links have not been fetched yet.
 *
 * @param {State} state
 * @param {string} linkName
 * @param {Record<string, string>} [params]
 */
function getLink(state, linkName, params = {}) {
  if (!state) {
    return '';
  }
  const template = state[linkName];
  if (!template) {
    throw new Error(`Unknown link "${linkName}"`);
  }
  const {
    url,
    unusedParams
  } = replaceURLParams(template, params);
  const unusedKeys = Object.keys(unusedParams);
  if (unusedKeys.length > 0) {
    throw new Error(`Unused parameters: ${unusedKeys.join(', ')}`);
  }
  return url;
}
const linksModule = createStoreModule(initialState$5, {
  namespace: 'links',
  reducers: reducers$5,
  actionCreators: {
    updateLinks
  },
  selectors: {
    getLink
  }
});

/**
 * This module contains state related to real-time updates received via the
 * WebSocket connection to h's real-time API.
 */

/**
 * @typedef {Record<string, Annotation>} AnnotationMap
 * @typedef {Record<string, boolean>} BooleanMap
 */

const initialState$4 = {
  /**
   * Map of ID -> updated annotation for updates that have been received over
   * the WebSocket but not yet applied (ie. saved to the "annotations" store
   * module and shown in the UI).
   *
   * @type {AnnotationMap}
   */
  pendingUpdates: {},
  /**
   * Set of IDs of annotations which have been deleted but for which the
   * deletion has not yet been applied
   *
   * @type {BooleanMap}
   */
  pendingDeletions: {}
};

/** @typedef {typeof initialState} State */

const reducers$4 = {
  /**
   * @param {State} state
   * @param {{ pendingUpdates: AnnotationMap, pendingDeletions: BooleanMap }} action
   */
  RECEIVE_REAL_TIME_UPDATES(state, action) {
    return {
      pendingUpdates: {
        ...action.pendingUpdates
      },
      pendingDeletions: {
        ...action.pendingDeletions
      }
    };
  },
  CLEAR_PENDING_UPDATES() {
    return {
      pendingUpdates: {},
      pendingDeletions: {}
    };
  },
  /**
   * @param {State} state
   * @param {{ annotations: Annotation[] }} action
   */
  ADD_ANNOTATIONS(state, {
    annotations
  }) {
    // Discard any pending updates which conflict with an annotation added
    // locally or fetched via an API call.
    //
    // If there is a conflicting local update/remote delete then we keep
    // the pending delete. The UI should prevent the user from editing an
    // annotation that has been deleted on the server.
    const pendingUpdates = {
      ...state.pendingUpdates
    };
    for (let ann of annotations) {
      if (ann.id) {
        delete pendingUpdates[ann.id];
      }
    }
    return {
      pendingUpdates
    };
  },
  /**
   * @param {State} state
   * @param {{ annotationsToRemove: Annotation[] }} action
   */
  REMOVE_ANNOTATIONS(state, {
    annotationsToRemove
  }) {
    // Discard any pending updates which conflict with an annotation removed
    // locally.

    const pendingUpdates = {
      ...state.pendingUpdates
    };
    const pendingDeletions = {
      ...state.pendingDeletions
    };
    for (let ann of annotationsToRemove) {
      if (ann.id) {
        delete pendingUpdates[ann.id];
        delete pendingDeletions[ann.id];
      }
    }
    return {
      pendingUpdates,
      pendingDeletions
    };
  },
  FOCUS_GROUP() {
    // When switching groups we clear and re-fetch all annotations, so discard
    // any pending updates.
    return {
      pendingUpdates: {},
      pendingDeletions: {}
    };
  }
};

/**
 * Record pending updates representing changes on the server that the client
 * has been notified about but has not yet applied.
 *
 * @param {object} args
 * @param {Annotation[]} [args.updatedAnnotations]
 * @param {Annotation[]} [args.deletedAnnotations]
 */
function receiveRealTimeUpdates({
  updatedAnnotations = [],
  deletedAnnotations = []
}) {
  /**
   * @param {import('redux').Dispatch} dispatch
   * @param {() => { realTimeUpdates: State, annotations: AnnotationsState, groups: GroupsState, route: RouteState }} getState
   */
  return (dispatch, getState) => {
    const pendingUpdates = {
      ...getState().realTimeUpdates.pendingUpdates
    };
    const pendingDeletions = {
      ...getState().realTimeUpdates.pendingDeletions
    };
    updatedAnnotations.forEach(ann => {
      // In the sidebar, only save pending updates for annotations in the
      // focused group, since we only display annotations from the focused
      // group and reload all annotations and discard pending updates
      // when switching groups.
      const groupState = getState().groups;
      const routeState = getState().route;
      if (ann.group === groupsModule.selectors.focusedGroupId(groupState) || routeModule.selectors.route(routeState) !== 'sidebar') {
        pendingUpdates[/** @type {string} */ann.id] = ann;
      }
    });
    deletedAnnotations.forEach(ann => {
      const id = /** @type {string} */ann.id;
      // Discard any pending but not-yet-applied updates for this annotation
      delete pendingUpdates[id];

      // If we already have this annotation loaded, then record a pending
      // deletion. We do not check the group of the annotation here because a)
      // that information is not included with deletion notifications and b)
      // even if the annotation is from the current group, it might be for a
      // new annotation (saved in pendingUpdates and removed above), that has
      // not yet been loaded.
      const annotationsState = getState().annotations;
      if (annotationsModule.selectors.annotationExists(annotationsState, id)) {
        pendingDeletions[id] = true;
      }
    });
    dispatch(makeAction(reducers$4, 'RECEIVE_REAL_TIME_UPDATES', {
      pendingUpdates,
      pendingDeletions
    }));
  };
}

/**
 * Clear the queue of real-time updates which have been received but not applied.
 */
function clearPendingUpdates() {
  return makeAction(reducers$4, 'CLEAR_PENDING_UPDATES', undefined);
}

/**
 * Return added or updated annotations received via the WebSocket
 * which have not been applied to the local state.
 *
 * @param {State} state
 */
function pendingUpdates(state) {
  return state.pendingUpdates;
}

/**
 * Return IDs of annotations which have been deleted on the server but not
 * yet removed from the local state.
 *
 * @param {State} state
 */
function pendingDeletions(state) {
  return state.pendingDeletions;
}

/**
 * Return a total count of pending updates and deletions.
 */
const pendingUpdateCount = createSelector( /** @param {State} state */
state => [state.pendingUpdates, state.pendingDeletions], ([pendingUpdates, pendingDeletions]) => Object.keys(pendingUpdates).length + Object.keys(pendingDeletions).length);

/**
 * Return true if an annotation has been deleted on the server but the deletion
 * has not yet been applied.
 *
 * @param {State} state
 * @param {string} id
 */
function hasPendingDeletion(state, id) {
  return hasOwn(state.pendingDeletions, id);
}
const realTimeUpdatesModule = createStoreModule(initialState$4, {
  namespace: 'realTimeUpdates',
  reducers: reducers$4,
  actionCreators: {
    receiveRealTimeUpdates,
    clearPendingUpdates
  },
  selectors: {
    hasPendingDeletion,
    pendingDeletions,
    pendingUpdates,
    pendingUpdateCount
  }
});

/**
 * @typedef {import('../../../types/api').Annotation} Annotation
 * @typedef {import('../../../types/config').SidebarSettings} SidebarSettings
 * @typedef {import("../../../types/sidebar").TabName} TabName
 */

/**
 * @typedef {Record<string, boolean>} BooleanMap
 * @typedef {'Location'|'Newest'|'Oldest'} SortKey
 */

/**
 * Default sort keys for each tab.
 *
 * @type {Record<TabName, SortKey>}
 */
const TAB_SORTKEY_DEFAULT = {
  annotation: 'Location',
  note: 'Oldest',
  orphan: 'Location'
};

/** @param {SidebarSettings} settings */
function initialSelection(settings) {
  /** @type {BooleanMap} */
  const selection = {};
  // TODO: Do not take into account existence of `settings.query` here
  // once root-thread-building is fully updated: the decision of whether
  // selection trumps any query is not one for the store to make
  if (settings.annotations && !settings.query) {
    selection[settings.annotations] = true;
  }
  return selection;
}

/** @param {SidebarSettings} settings */
function initialState$3(settings) {
  return {
    /**
     * A set of annotations that are currently "selected" by the user —
     * these will supersede other filters/selections.
     */
    selected: initialSelection(settings),
    // Explicitly-expanded or -collapsed annotations (threads). A collapsed
    // annotation thread will not show its replies; an expanded thread will
    // show its replies. Note that there are other factors affecting
    // collapsed states, e.g., top-level threads are collapsed by default
    // until explicitly expanded.
    expanded: initialSelection(settings),
    /**
     * Set of threads that have been "forced" visible by the user
     * (e.g. by clicking on "Show x more" button) even though they may not
     * match the currently-applied filters.
     *
     * @type {BooleanMap}
     */
    forcedVisible: {},
    /** @type {TabName} */
    selectedTab: 'annotation',
    /**
     * Sort order for annotations.
     *
     * @type {SortKey}
     */
    sortKey: TAB_SORTKEY_DEFAULT.annotation,
    /**
     * ID or tag of an annotation that should be given keyboard focus.
     *
     * @type {string|null}
     */
    focusRequest: null
  };
}

/** @typedef {ReturnType<initialState>} State */

/**
 * @param {TabName} newTab
 * @param {TabName} oldTab
 */
const setTab = (newTab, oldTab) => {
  // Do nothing if the "new tab" is the same as the tab already selected.
  // This will avoid resetting the `sortKey`, too.
  if (oldTab === newTab) {
    return {};
  }
  return {
    selectedTab: newTab,
    sortKey: /** @type {SortKey} */TAB_SORTKEY_DEFAULT[newTab]
  };
};
const resetSelection = () => {
  return {
    forcedVisible: {},
    selected: {}
  };
};
const reducers$3 = {
  CLEAR_ANNOTATION_FOCUS_REQUEST() {
    return {
      focusRequest: null
    };
  },
  CLEAR_SELECTION() {
    return resetSelection();
  },
  /**
   * @param {State} state
   * @param {{ selection: BooleanMap }} action
   */
  SELECT_ANNOTATIONS(state, action) {
    return {
      selected: action.selection
    };
  },
  /**
   * @param {State} state
   * @param {{ tab: TabName }} action
   */
  SELECT_TAB(state, action) {
    return setTab(action.tab, state.selectedTab);
  },
  /**
   * @param {State} state
   * @param {{ id: string, expanded: boolean }} action
   */
  SET_EXPANDED(state, action) {
    const newExpanded = {
      ...state.expanded
    };
    newExpanded[action.id] = action.expanded;
    return {
      expanded: newExpanded
    };
  },
  /**
   * @param {State} state
   * @param {{ id: string }} action
   */
  SET_ANNOTATION_FOCUS_REQUEST(state, action) {
    return {
      focusRequest: action.id
    };
  },
  /**
   * @param {State} state
   * @param {{ id: string, visible: boolean }} action
   */
  SET_FORCED_VISIBLE(state, action) {
    return {
      forcedVisible: {
        ...state.forcedVisible,
        [action.id]: action.visible
      }
    };
  },
  /**
   * @param {State} state
   * @param {{ key: SortKey }} action
   */
  SET_SORT_KEY(state, action) {
    return {
      sortKey: action.key
    };
  },
  /**
   * @param {State} state
   * @param {{ toggleIds: string[] }} action
   */
  TOGGLE_SELECTED_ANNOTATIONS(state, action) {
    const selection = {
      ...state.selected
    };
    action.toggleIds.forEach(id => {
      selection[id] = !selection[id];
    });
    return {
      selected: selection
    };
  },
  /** Actions defined in other modules */

  /**
   * Automatically select the Page Notes tab, for convenience, if all of the
   * top-level annotations in `action.annotations` are Page Notes and the
   * previous annotation count was 0 (i.e. collection empty).
   *
   * @param {State} state
   * @param {{ annotations: Annotation[], currentAnnotationCount: number }} action
   */
  ADD_ANNOTATIONS(state, action) {
    const topLevelAnnotations = action.annotations.filter(annotation => !isReply(annotation));
    const noteCount = countIf(action.annotations, isPageNote);
    const haveOnlyPageNotes = noteCount === topLevelAnnotations.length;
    if (action.currentAnnotationCount === 0 && haveOnlyPageNotes) {
      return setTab('note', state.selectedTab);
    }
    return {};
  },
  CHANGE_FOCUS_MODE_USER() {
    return resetSelection();
  },
  SET_FILTER() {
    return {
      ...resetSelection(),
      expanded: {}
    };
  },
  SET_FILTER_QUERY() {
    return {
      ...resetSelection(),
      expanded: {}
    };
  },
  SET_FOCUS_MODE() {
    return resetSelection();
  },
  /**
   * @param {State} state
   * @param {{ annotationsToRemove: Annotation[], remainingAnnotations: Annotation[] }} action
   */
  REMOVE_ANNOTATIONS(state, action) {
    let newTab = state.selectedTab;
    // If the orphans tab is selected but no remaining annotations are orphans,
    // switch back to annotations tab
    if (newTab === 'orphan' && countIf(action.remainingAnnotations, isOrphan) === 0) {
      newTab = 'annotation';
    }

    /** @param {BooleanMap} collection */
    const removeAnns = collection => {
      action.annotationsToRemove.forEach(annotation => {
        if (annotation.id) {
          delete collection[annotation.id];
        }
        if (annotation.$tag) {
          delete collection[annotation.$tag];
        }
      });
      return collection;
    };
    return {
      ...setTab(newTab, state.selectedTab),
      expanded: removeAnns({
        ...state.expanded
      }),
      forcedVisible: removeAnns({
        ...state.forcedVisible
      }),
      selected: removeAnns({
        ...state.selected
      })
    };
  }
};

/**
 * Clear all selected annotations and filters. This will leave user-focus
 * alone, however.
 */
function clearSelection() {
  return makeAction(reducers$3, 'CLEAR_SELECTION', undefined);
}

/**
 * Set the currently selected annotation IDs. This will replace the current
 * selection. All provided annotation ids will be set to `true` in the selection.
 *
 * @param {string[]} ids - Identifiers of annotations to select
 */
function selectAnnotations(ids) {
  /** @param {import('redux').Dispatch} dispatch */
  return dispatch => {
    dispatch(clearSelection());
    dispatch(makeAction(reducers$3, 'SELECT_ANNOTATIONS', {
      selection: toTrueMap(ids)
    }));
  };
}

/**
 * Request the UI to give keyboard focus to a given annotation.
 *
 * Once the UI has processed this request, it should be cleared with
 * {@link clearAnnotationFocusRequest}.
 *
 * @param {string} id
 */
function setAnnotationFocusRequest(id) {
  return makeAction(reducers$3, 'SET_ANNOTATION_FOCUS_REQUEST', {
    id
  });
}

/**
 * Clear an annotation focus request created with {@link setAnnotationFocusRequest}.
 */
function clearAnnotationFocusRequest() {
  return makeAction(reducers$3, 'CLEAR_ANNOTATION_FOCUS_REQUEST', undefined);
}

/**
 * Set the currently-selected tab to `tabKey`.
 *
 * @param {TabName} tabKey
 */
function selectTab(tabKey) {
  return makeAction(reducers$3, 'SELECT_TAB', {
    tab: tabKey
  });
}

/**
 * Set the expanded state for a single annotation/thread.
 *
 * @param {string} id - annotation (or thread) id
 * @param {boolean} expanded - `true` for expanded replies, `false` to collapse
 */
function setExpanded(id, expanded) {
  return makeAction(reducers$3, 'SET_EXPANDED', {
    id,
    expanded
  });
}

/**
 * A user may "force" an thread to be visible, even if it would be otherwise
 * not be visible because of applied filters. Set the force-visibility for a
 * single thread, without affecting other forced-visible threads.
 *
 * @param {string} id - Thread id
 * @param {boolean} visible - Should this annotation be visible, even if it
 *        conflicts with current filters?
 */
function setForcedVisible(id, visible) {
  return makeAction(reducers$3, 'SET_FORCED_VISIBLE', {
    id,
    visible
  });
}

/**
 * Sets the sort key for the annotation list.
 *
 * @param {SortKey} key
 */
function setSortKey(key) {
  return makeAction(reducers$3, 'SET_SORT_KEY', {
    key
  });
}

/**
 * Toggle the selected state for the annotations in `toggledAnnotations`:
 * unselect any that are selected; select any that are unselected.
 *
 * @param {string[]} toggleIds - identifiers of annotations to toggle
 */
function toggleSelectedAnnotations(toggleIds) {
  return makeAction(reducers$3, 'TOGGLE_SELECTED_ANNOTATIONS', {
    toggleIds
  });
}

/**
 * Retrieve map of expanded/collapsed annotations (threads)
 *
 * @param {State} state
 */
function expandedMap(state) {
  return state.expanded;
}

/** @param {State} state */
function annotationFocusRequest(state) {
  return state.focusRequest;
}
const forcedVisibleThreads = createSelector( /** @param {State} state */
state => state.forcedVisible, forcedVisible => trueKeys(forcedVisible));

/**
 * Are any annotations currently selected?
 */
const hasSelectedAnnotations = createSelector( /** @param {State} state */
state => state.selected, selection => trueKeys(selection).length > 0);
const selectedAnnotations = createSelector( /** @param {State} state */
state => state.selected, selection => trueKeys(selection));

/**
 * Return the currently-selected tab
 *
 * @param {State} state
 */
function selectedTab(state) {
  return state.selectedTab;
}
const selectionState = createSelector( /** @param {State} state */
state => state, selection => {
  return {
    expanded: expandedMap(selection),
    forcedVisible: forcedVisibleThreads(selection),
    selected: selectedAnnotations(selection),
    sortKey: sortKey(selection),
    selectedTab: selectedTab(selection)
  };
});

/**
 * Retrieve the current sort option key.
 *
 * @param {State} state
 */
function sortKey(state) {
  return state.sortKey;
}

/**
 * Retrieve applicable sort options for the currently-selected tab.
 */
const sortKeys = createSelector( /** @param {State} state */
state => state.selectedTab, selectedTab => {
  /** @type {SortKey[]} */
  const sortKeysForTab = ['Newest', 'Oldest'];
  if (selectedTab !== 'note') {
    // Location is inapplicable to Notes tab
    sortKeysForTab.push('Location');
  }
  return sortKeysForTab;
});
const selectionModule = createStoreModule(initialState$3, {
  namespace: 'selection',
  reducers: reducers$3,
  actionCreators: {
    clearAnnotationFocusRequest,
    clearSelection,
    selectAnnotations,
    selectTab,
    setAnnotationFocusRequest,
    setExpanded,
    setForcedVisible,
    setSortKey,
    toggleSelectedAnnotations
  },
  selectors: {
    expandedMap,
    annotationFocusRequest,
    forcedVisibleThreads,
    hasSelectedAnnotations,
    selectedAnnotations,
    selectedTab,
    selectionState,
    sortKey,
    sortKeys
  }
});

/**
 * This module handles the state for `SidebarPanel` components used in the app.
 * It keeps track of the "active" `panelName` (simple string) and allows the
 * opening, closing or toggling of panels via their `panelName`. It merely
 * retains the `panelName` state as a string: it has no understanding nor
 * opinions about whether a given `panelName` corresponds to one or more
 * extant `SidebarPanel` components. Only one panel (as keyed by `panelName`)
 * may be "active" (open) at one time.
 */
const initialState$2 = {
  /**
   * The `panelName` of the currently-active sidebar panel.
   * Only one `panelName` may be active at a time, but it is valid (though not
   * the standard use case) for multiple `SidebarPanel` components to share
   * the same `panelName`—`panelName` is not intended as a unique ID/key.
   *
   * e.g. If `activePanelName` were `foobar`, all `SidebarPanel` components
   * with `panelName` of `foobar` would be active, and thus visible.
   *
   * @type {PanelName|null}
   */
  activePanelName: null
};

/** @typedef {typeof initialState} State */

const reducers$2 = {
  /**
   * @param {State} state
   * @param {{ panelName: PanelName }} action
   */
  OPEN_SIDEBAR_PANEL(state, action) {
    return {
      activePanelName: action.panelName
    };
  },
  /**
   * @param {State} state
   * @param {{ panelName: PanelName }} action
   */
  CLOSE_SIDEBAR_PANEL(state, action) {
    let activePanelName = state.activePanelName;
    if (action.panelName === activePanelName) {
      // `action.panelName` is indeed the currently-active panel; deactivate
      activePanelName = null;
    }
    // `action.panelName` is not the active panel; nothing to do here
    return {
      activePanelName
    };
  },
  /**
   * @param {State} state
   * @param {{ panelName: PanelName, panelState?: boolean }} action
   */
  TOGGLE_SIDEBAR_PANEL: function (state, action) {
    let activePanelName;
    // Is the panel in question currently the active panel?
    const panelIsActive = state.activePanelName === action.panelName;
    // What state should the panel in question move to next?
    const panelShouldBeActive = typeof action.panelState !== 'undefined' ? action.panelState : !panelIsActive;
    if (panelShouldBeActive) {
      // If the specified panel should be open (active), set it as active
      activePanelName = action.panelName;
    } else if (panelIsActive && !panelShouldBeActive) {
      // If the specified panel is currently open (active), but it shouldn't be anymore
      activePanelName = null;
    } else {
      // This panel is already inactive; do nothing
      activePanelName = state.activePanelName;
    }
    return {
      activePanelName
    };
  }
};

/**
 * Designate `panelName` as the currently-active panel name
 *
 * @param {PanelName} panelName
 */
function openSidebarPanel(panelName) {
  return makeAction(reducers$2, 'OPEN_SIDEBAR_PANEL', {
    panelName
  });
}

/**
 * `panelName` should not be the active panel
 *
 * @param {PanelName} panelName
 */
function closeSidebarPanel(panelName) {
  return makeAction(reducers$2, 'CLOSE_SIDEBAR_PANEL', {
    panelName
  });
}

/**
 * Toggle a sidebar panel from its current state, or set it to the
 * designated `panelState`.
 *
 * @param {PanelName} panelName
 * @param {boolean} [panelState] -
 *   Should the panel be active? Omit this prop to simply toggle the value.
 */
function toggleSidebarPanel(panelName, panelState) {
  return makeAction(reducers$2, 'TOGGLE_SIDEBAR_PANEL', {
    panelName,
    panelState
  });
}

/**
 * Is the panel indicated by `panelName` currently active (open)?
 *
 * @param {State} state
 * @param {PanelName} panelName
 */
function isSidebarPanelOpen(state, panelName) {
  return state.activePanelName === panelName;
}
const sidebarPanelsModule = createStoreModule(initialState$2, {
  namespace: 'sidebarPanels',
  reducers: reducers$2,
  actionCreators: {
    openSidebarPanel,
    closeSidebarPanel,
    toggleSidebarPanel
  },
  selectors: {
    isSidebarPanelOpen
  }
});

/**
 * @typedef ToastMessage
 * @prop {('error'|'success'|'notice')} type
 * @prop {string} id
 * @prop {string} message
 * @prop {string} moreInfoURL
 * @prop {boolean} isDismissed
 * @prop {boolean} visuallyHidden
 */

/**
 * A store module for managing a collection of toast messages. This module
 * maintains state only; it's up to other layers to handle the management
 * and interactions with these messages.
 */

const initialState$1 = {
  /** @type {ToastMessage[]} */
  messages: []
};

/** @typedef {typeof initialState} State */

const reducers$1 = {
  /**
   * @param {State} state
   * @param {{ message: ToastMessage }} action
   */
  ADD_MESSAGE(state, action) {
    return {
      messages: state.messages.concat({
        ...action.message
      })
    };
  },
  /**
   * @param {State} state
   * @param {{ id: string }} action
   */
  REMOVE_MESSAGE(state, action) {
    const updatedMessages = state.messages.filter(message => message.id !== action.id);
    return {
      messages: updatedMessages
    };
  },
  /**
   * @param {State} state
   * @param {{ message: ToastMessage }} action
   */
  UPDATE_MESSAGE(state, action) {
    const updatedMessages = state.messages.map(message => {
      if (message.id && message.id === action.message.id) {
        return {
          ...action.message
        };
      }
      return message;
    });
    return {
      messages: updatedMessages
    };
  }
};

/** Actions */

/**
 * @param {ToastMessage} message
 */
function addMessage(message) {
  return makeAction(reducers$1, 'ADD_MESSAGE', {
    message
  });
}

/**
 * Remove the `message` with the corresponding `id` property value.
 *
 * @param {string} id
 */
function removeMessage(id) {
  return makeAction(reducers$1, 'REMOVE_MESSAGE', {
    id
  });
}

/**
 * Update the `message` object (lookup is by `id`).
 *
 * @param {ToastMessage} message
 */
function updateMessage(message) {
  return makeAction(reducers$1, 'UPDATE_MESSAGE', {
    message
  });
}

/** Selectors */

/**
 * Retrieve a message by `id`
 *
 * @param {State} state
 * @param {string} id
 */
function getMessage(state, id) {
  return state.messages.find(message => message.id === id);
}

/**
 * Retrieve all current messages
 *
 * @param {State} state
 */
function getMessages(state) {
  return state.messages;
}

/**
 * Return boolean indicating whether a message with the same type and message
 * text exists in the state's collection of messages. This matches messages
 * by content, not by ID (true uniqueness).
 *
 * @param {State} state
 * @param {string} type
 * @param {string} text
 */
function hasMessage(state, type, text) {
  return state.messages.some(message => {
    return message.type === type && message.message === text;
  });
}
const toastMessagesModule = createStoreModule(initialState$1, {
  namespace: 'toastMessages',
  reducers: reducers$1,
  actionCreators: {
    addToastMessage: addMessage,
    removeToastMessage: removeMessage,
    updateToastMessage: updateMessage
  },
  selectors: {
    getToastMessage: getMessage,
    getToastMessages: getMessages,
    hasToastMessage: hasMessage
  }
});

/**
 * This module defines actions and state related to the display mode of the
 * sidebar.
 */

const initialState = {
  /**
   * Has the sidebar ever been opened? NB: This is not necessarily the
   * current state of the sidebar, but tracks whether it has ever been open
   */
  sidebarHasOpened: false
};

/** @typedef {typeof initialState} State */

const reducers = {
  /**
   * @param {State} state
   * @param {{ opened: boolean }} action
   */
  SET_SIDEBAR_OPENED(state, action) {
    if (action.opened === true) {
      // If the sidebar is open, track that it has ever been opened
      return {
        sidebarHasOpened: true
      };
    }
    // Otherwise, nothing to do here
    return {};
  }
};

/**
 * @param {boolean} opened - If the sidebar is open
 */
function setSidebarOpened(opened) {
  return makeAction(reducers, 'SET_SIDEBAR_OPENED', {
    opened
  });
}

/** @param {State} state */
function hasSidebarOpened(state) {
  return state.sidebarHasOpened;
}
const viewerModule = createStoreModule(initialState, {
  namespace: 'viewer',
  reducers,
  actionCreators: {
    setSidebarOpened
  },
  selectors: {
    hasSidebarOpened
  }
});

/**
 * Result of a cached store selector method call.
 */
class CacheEntry {
  /**
   * @param {string} name - Method name
   * @param {Function} method - Method implementation
   * @param {unknown[]} args - Arguments to the selector
   * @param {unknown} result - Result of the invocation
   */
  constructor(name, method, args, result) {
    this.name = name;
    this.method = method;
    this.args = args;
    this.result = result;
  }

  /**
   * @param {string} name
   * @param {unknown[]} args
   */
  matches(name, args) {
    return this.name === name && this.args.every((value, i) => args[i] === value);
  }
}

/**
 * Return a wrapper around a store that UI components can use to read from and
 * modify data in it.
 *
 * Unlike using the store directly, the wrapper tracks what data from
 * the store the current component uses, by recording calls to selector methods,
 * and re-renders the components when the results of those calls change.
 *
 * The returned wrapper has the same API as the store itself.
 *
 * The returned wrapper does not change its identity if the store updates. This
 * means you need to be careful when using it with hooks that have dependencies,
 * such as `useMemo`, `useEffect` or `useCallback`. Given code like this:
 *
 * ```
 * const calculatedValue = useMemo(() => calculateSomething(store.getSomeValue()), [store]);
 * ```
 *
 * `calulatedValue` will not be recalculated if the result of
 * `store.getSomeValue()` changes, because the `store` reference itself does not
 * change. A workaround is to extract the values from the store and pass those
 * into the closure:
 *
 * ```
 * const someValue = store.getSomeValue();
 * const calculatedValue = useMemo(() => calculateSomething(someValue), [someValue]);
 * ```
 *
 * @example
 *   // A hook which encapsulates looking up the specific store instance,
 *   // eg. via `useContext`.
 *   function useAppStore() {
 *     // Get the store from somewhere, eg. a prop or context.
 *     const appStore = ...;
 *     return useStore(appStore);
 *   }
 *
 *   function MyComponent() {
 *     const store = useAppStore();
 *     const currentUser = store.currentUser();
 *
 *     return (
 *       <div>
 *         Current user: {currentUser}.
 *         <button onClick={() => store.logOut()}>Log out</button>
 *       </div>
 *     );
 *   }
 *
 * @template {import('./create-store').Store<unknown, unknown, unknown>} Store
 * @param {Store} store - The store to wrap
 * @return {Store} - A proxy with the same API as `store`
 */
function useStore(store) {
  // Hack to trigger a component re-render.
  const [, forceUpdate] = y(x => x + 1, 0);

  // Cache of store method calls made by the current UI component and associated
  // results. There is one entry per combination of method and arguments.
  //
  // This is currently just an array on the assumption that it will
  // only have a small number of entries. It could be changed to a map keyed
  // by method to handle many entries better.
  const cacheRef = _$1( /** @type {CacheEntry[]} */[]);
  const cache = cacheRef.current;

  // Create the wrapper around the store.
  const proxy = _$1( /** @type {Store|null} */null);
  if (!proxy.current) {
    // Cached method wrappers.
    /** @type {Map<string, Function>} */
    const wrappedMethods = new Map();

    /**
     * @template {Store} StoreType
     * @param {StoreType} store
     * @param {keyof StoreType & string} prop
     */
    const get = (store, prop) => {
      const method = store[prop];
      if (typeof method !== 'function') {
        return method;
      }

      // Check for pre-existing method wrapper.
      let wrapped = wrappedMethods.get(prop);
      if (wrapped) {
        return wrapped;
      }

      // Create method wrapper.
      /** @param {unknown[]} args */
      wrapped = (...args) => {
        const cacheEntry = cache.find(entry => entry.matches(prop, args));
        if (cacheEntry) {
          return cacheEntry.result;
        }

        // Call the original method. It may be a selector that does not modify
        // the store but returns a result, or an action that modifies the state.
        const prevState = store.getState();
        const result = method.apply(store, args);
        const newState = store.getState();
        if (prevState === newState) {
          cache.push(new CacheEntry(prop, method, args, result));
        }
        return result;
      };
      wrappedMethods.set(prop, wrapped);
      return wrapped;
    };
    proxy.current = new Proxy(store, {
      get
    });
  }

  // Register a subscriber which clears cache and re-renders component when
  // relevant store state changes.
  s(() => {
    const cleanup = store.subscribe(() => {
      const invalidEntry = cache.find(
      // nb. A potential problem here is that the method arguments may refer
      // to things which no longer exist (for example, an object ID for an object
      // which has been unloaded). It is assumed that store selector methods are
      // robust to this.
      entry => entry.method.apply(store, entry.args) !== entry.result);
      if (invalidEntry) {
        // We currently just invalidate the entire cache when any entry becomes
        // invalid, but we could do more fine-grained checks.
        cache.splice(0, cache.length);
        forceUpdate(0);
      }
    });
    return cleanup;
  }, [cache, store]);
  return (/** @type {Store} */proxy.current
  );
}

/** @typedef {ReturnType<createSidebarStore>} SidebarStore */

/**
 * Create the central state store for the sidebar application.
 *
 * This is a Redux [1] store composed of several modules, augmented with
 * _selector_ methods for querying it and _action_ methods for applying updates.
 * See the `createStore` documentation for API and usage details.
 *
 * [1] https://redux.js.org
 *
 * @param {import('../../types/config').SidebarSettings} settings
 * @inject
 */
function createSidebarStore(settings) {
  const middleware = [debugMiddleware];

  // `const` type gives `modules` a tuple type, which allows `createStore`
  // to infer properties (eg. action and selector methods) of returned store.
  const modules = /** @type {const} */[activityModule, annotationsModule, defaultsModule, directLinkedModule, draftsModule, filtersModule, framesModule, linksModule, groupsModule, realTimeUpdatesModule, routeModule, selectionModule, sessionModule, sidebarPanelsModule, toastMessagesModule, viewerModule];
  return createStore(modules, [settings], middleware);
}

/**
 * Hook for accessing the sidebar's store in UI components.
 *
 * Returns a wrapper around the store which tracks its usage by the component
 * and re-renders the component when relevant data in the store changes. See
 * {@link useStore}.
 */
createSidebarStore.$inject = ["settings"];
function useSidebarStore() {
  const store = /** @type {SidebarStore} */useService('store');
  return useStore(store);
}

/**
 * @typedef {import('../../types/api').Annotation} Annotation
 *
 * @typedef Thread
 * @prop {string} id - The thread's id, which equivalent to the id of its
 *       annotation. For unsaved annotations, the id is derived from the
 *       annotation's local `$tag` property.
 * @prop {Annotation} [annotation] - This thread's annotation. Undefined in cases
 *       when an annotation _should_ exist—it's implied by a reference from
 *       another annotation—but is not present in our collection of annotations.
 *       This can happen when a reply has been deleted, but still has children
 *       that exist.
 * @prop {string} [parent] - The id of this thread's parent. Top-level threads
 *       do not have parents
 * @prop {boolean} visible - Whether this thread should be visible when rendered.
 *       true when the thread's annotation matches current annotation filters.
 * @prop {boolean} collapsed - Whether the replies in this thread should be
 *       rendered as collapsed (when true) or expanded (when false)
 * @prop {Thread[]} children
 * @prop {number} replyCount - Computed count of all replies to a thread
 * @prop {number} depth - The thread's depth in the hierarchy
 */

/**
 * Default state for new threads
 */
const DEFAULT_THREAD_STATE = {
  collapsed: false,
  depth: 0,
  visible: true,
  replyCount: 0
};

/**
 * Returns a persistent identifier for an Annotation.
 * If the Annotation has been created on the server, it will have
 * an id assigned, otherwise we fall back to the local-only '$tag'
 * property.
 *
 * @param {Annotation} annotation
 * @return {string}
 */
function annotationId(annotation) {
  return annotation.id || annotation.$tag;
}

/**
 * Is there a valid path from the thread indicated by `id` to the root thread,
 * with no circular references?
 *
 * @param {Record<string, Thread>} threads
 * @param {string} id - The id of the thread to be verified
 * @param {string} ancestorId - The ancestor of the thread indicated by id that
 *        is to be verified: is it extant and not a circular reference?
 * @return {boolean}
 */
function hasPathToRoot(threads, id, ancestorId) {
  const ancestor = threads[ancestorId];
  if (!ancestor || ancestor.parent === id) {
    // Thread for ancestor not found, or points at itself: circular reference
    return false;
  } else if (!ancestor.parent) {
    // Top of the tree: we've made it
    return true;
  }
  return hasPathToRoot(threads, id, ancestor.parent);
}

/**
 * Link the thread's annotation to its parent
 * @param {Record<string,Thread>} threads
 * @param {string} id
 * @param {string[]} [parents] - ids of parent annotations, from the
 *        annotation's `references` field. Immediate parent is last entry.
 */
function setParent(threads, id, parents = []) {
  if (threads[id].parent || !parents.length) {
    // Parent already assigned, do not try to change it.
    return;
  }
  const parentId = parents[parents.length - 1];
  if (!threads[parentId]) {
    // Parent does not exist. This may be a reply to an annotation which has
    // been deleted. Create a placeholder Thread with no annotation to
    // represent the missing annotation.
    threads[parentId] = {
      ...DEFAULT_THREAD_STATE,
      children: [],
      id: parentId
    };
    // Link up this new thread to _its_ parent, which should be the original
    // thread's grandparent
    setParent(threads, parentId, parents.slice(0, -1));
  }
  if (hasPathToRoot(threads, id, parentId)) {
    threads[id].parent = parentId;
    threads[parentId].children.push(threads[id]);
  }
}

/**
 * Creates a thread tree of annotations from a list of annotations.
 *
 * Given a flat list of annotations and replies, this generates a hierarchical
 * thread, using the `references` field of an annotation to link together
 * annotations and their replies. The `references` field is a possibly
 * incomplete ordered list of the parents of an annotation, from furthest to
 * nearest ancestor.
 *
 * @param {Annotation[]} annotations - The input annotations to thread.
 * @return {Thread} - The input annotations threaded into a tree structure.
 */
function threadAnnotations$1(annotations) {
  /** @type {Record<string,Thread>} */
  const threads = {};

  // Create a `Thread` for each annotation
  annotations.forEach(annotation => {
    const id = annotationId(annotation);
    threads[id] = {
      ...DEFAULT_THREAD_STATE,
      children: [],
      annotation,
      id
    };
  });

  // Establish ancestral relationships between annotations
  annotations.forEach(annotation => {
    // Remove references to self from `references` to avoid circular references
    const parents = (annotation.references || []).filter(id => id !== annotation.id);
    return setParent(threads, annotationId(annotation), parents);
  });

  // Collect the set of threads which have no parent as
  // children of the thread root
  const rootThreads = [];
  for (const rootThreadId in threads) {
    if (!threads[rootThreadId].parent) {
      // Top-level threads are collapsed by default
      threads[rootThreadId].collapsed = true;
      rootThreads.push(threads[rootThreadId]);
    }
  }
  const rootThread = {
    ...DEFAULT_THREAD_STATE,
    id: 'root',
    children: rootThreads
  };
  return rootThread;
}

/**
 * Returns a copy of `thread` with the thread
 * and each of its children transformed by mapFn(thread).
 *
 * @param {Thread} thread
 * @param {(t: Thread) => Thread} mapFn
 * @return {Thread}
 */
function mapThread(thread, mapFn) {
  return Object.assign({}, mapFn(thread), {
    children: thread.children.map(child => {
      return mapThread(child, mapFn);
    })
  });
}

/**
 * Return a new `Thread` object with all (recursive) `children` arrays sorted.
 * Sort the children of top-level threads using `compareFn` and all other
 * children using `replyCompareFn`.
 *
 * @param {Thread} thread
 * @param {(a: Thread, b: Thread) => number} compareFn - comparison function
 *   for sorting top-level annotations
 * @param {(a: Thread, b: Thread) => number} replyCompareFn - comparison
 *   function for sorting replies
 * @return {Thread}
 */
function sortThread(thread, compareFn, replyCompareFn) {
  const children = thread.children.map(child => sortThread(child, replyCompareFn, replyCompareFn));
  const sortedChildren = children.slice().sort(compareFn);
  return {
    ...thread,
    children: sortedChildren
  };
}

/**
 * Return a copy of `thread` with the `replyCount` and `depth` properties
 * updated.
 *
 * @param {Thread} thread
 * @param {number} depth
 * @return {Thread}
 */
function countRepliesAndDepth(thread, depth) {
  const children = thread.children.map(c => countRepliesAndDepth(c, depth + 1));
  const replyCount = children.reduce((total, child) => total + 1 + child.replyCount, 0);
  return {
    ...thread,
    children,
    depth,
    replyCount
  };
}

/**
 * Does this thread have any visible children?
 *
 * @param {Thread} thread
 * @return {boolean}
 */
function hasVisibleChildren(thread) {
  return thread.children.some(child => {
    return child.visible || hasVisibleChildren(child);
  });
}

/**
 * @typedef BuildThreadOptions
 * @prop {Record<string, boolean>} expanded - Map of thread id => expansion state
 * @prop {string[]} forcedVisible - List of $tags of annotations that have
 *       been explicitly expanded by the user, even if they don't
 *       match current filters
 * @prop {string[]} selected - List of currently-selected annotation ids, from
 *       the data store
 * @prop {(a: Thread, b: Thread) => number} sortCompareFn - comparison
 *       function for sorting top-level annotations
 * @prop {(a: Annotation) => boolean} [filterFn] - Predicate function that
 *       returns `true` if annotation should be visible
 * @prop {(t: Thread) => boolean} [threadFilterFn] - Predicate function that
 *       returns `true` if the annotation should be included in the thread tree
 */

/**
 * Sort by reply (Annotation) `created` date
 *
 * @param {Thread} a
 * @param {Thread} b
 * @return {number}
 */
const replySortCompareFn = (a, b) => {
  if (!a.annotation || !b.annotation) {
    return 0;
  }
  if (a.annotation.created < b.annotation.created) {
    return -1;
  } else if (a.annotation.created > b.annotation.created) {
    return 1;
  }
  return 0;
};

/**
 * Project, filter and sort a list of annotations into a thread structure for
 * display by the <Thread> component.
 *
 * buildThread() takes as inputs a flat list of annotations,
 * the current visibility filters and sort function and returns
 * the thread structure that should be rendered.
 *
 * An Annotation present in `annotations` will not be present in the returned threads if:
 * - The annotation does not match thread-level filters (options.threadFilterFn), OR
 * - The annotation is not in the current selection (options.selected), OR
 * - The annotation's thread is hidden and has no visible children
 *
 * Annotations that do not match the currently-applied annotation filters
 * (options.filterFn) will have their thread's `visible` property set to `hidden`
 * (an exception is made if that annotation's thead has been forced visible by
 * a user).
 *
 * @param {Annotation[]} annotations - A list of annotations and replies
 * @param {BuildThreadOptions} options
 * @return {Thread} - The root thread, whose children are the top-level
 *                    annotations to display.
 */
function buildThread(annotations, options) {
  const hasSelection = options.selected.length > 0;
  const hasForcedVisible = options.forcedVisible.length > 0;
  let thread = threadAnnotations$1(annotations);
  if (hasSelection) {
    // Remove threads (annotations) that are not selected or
    // are not forced-visible
    thread.children = thread.children.filter(child => {
      const isSelected = options.selected.includes(child.id);
      const isForcedVisible = hasForcedVisible && options.forcedVisible.includes(child.id);
      return isSelected || isForcedVisible;
    });
  }
  if (options.threadFilterFn) {
    // Remove threads not matching thread-level filters
    thread.children = thread.children.filter(options.threadFilterFn);
  }

  // Set visibility for threads.
  // The root thread itself should be set as non-visible, to avoid confusion
  // when counting visible threads. It's a container thread: its children
  // are the top-level annotations.
  thread.visible = false;
  thread = mapThread(thread, thread => {
    let threadIsVisible = thread.visible;
    if (options.filterFn) {
      if (hasForcedVisible && options.forcedVisible.includes(thread.id)) {
        // This thread may or may not match the filter, but we should
        // make sure it is visible because it has been forced visible by user
        threadIsVisible = true;
      } else if (thread.annotation) {
        // Otherwise, visibility depends on whether its annotation matches the filter
        threadIsVisible = !!options.filterFn(thread.annotation);
      } else {
        threadIsVisible = false;
      }
    }
    return {
      ...thread,
      visible: threadIsVisible
    };
  });

  // Remove top-level threads which contain no visible annotations
  thread.children = thread.children.filter(child => child.visible || hasVisibleChildren(child));

  // Determine collapsed state for UI
  thread = mapThread(thread, thread => {
    const threadStates = {
      collapsed: thread.collapsed
    };
    if (hasOwn(options.expanded, thread.id)) {
      // This thread has been explicitly expanded/collapsed by user
      threadStates.collapsed = !options.expanded[thread.id];
    } else {
      // If annotations are filtered, and at least one child matches
      // those filters, make sure thread is not collapsed
      const hasUnfilteredChildren = options.filterFn && hasVisibleChildren(thread);
      threadStates.collapsed = thread.collapsed && !hasUnfilteredChildren;
    }
    return {
      ...thread,
      ...threadStates
    };
  });

  // Sort the root thread according to the current search criteria
  //const compareFn = options.sortCompareFn ?? defaultSortCompareFn;
  thread = sortThread(thread, options.sortCompareFn, replySortCompareFn);

  // Update `replyCount` and `depth` properties
  thread = countRepliesAndDepth(thread, -1);
  return thread;
}

/**
 * A simple memoization function which caches the last result of
 * a single-argument function.
 *
 * The argument to the input function may be of any type and is compared
 * using reference equality.
 *
 * @template Arg
 * @template Result
 * @param {(arg: Arg) => Result} fn
 * @return {(arg: Arg) => Result}
 */
function memoize(fn) {
  if (fn.length !== 1) {
    throw new Error('Memoize input must be a function of one argument');
  }

  /** @type {Arg} */
  let lastArg;
  /** @type {Result} */
  let lastResult;
  return function (arg) {
    if (arg === lastArg) {
      return lastResult;
    }
    lastArg = arg;
    lastResult = fn(arg);
    return lastResult;
  };
}

/**
 * Parse annotation filter queries into structured representations.
 *
 * Provides methods to parse Lucene-style queries ("foo tag: bar")
 * into structured representations which are then used by other services to
 * filter annotations displayed to the user or fetched from the API.
 */

/**
 * Splits a search term into filter and data.
 *
 * ie. 'user:johndoe' -> ['user', 'johndoe']
 *     'example:text' -> [null, 'example:text']
 *
 * @param {string} term
 * @return {[null|string, string]}
 */
function splitTerm(term) {
  const filter = term.slice(0, term.indexOf(':'));
  if (!filter) {
    // The whole term is data
    return [null, term];
  }
  if (['group', 'quote', 'since', 'tag', 'text', 'uri', 'user'].includes(filter)) {
    const data = term.slice(filter.length + 1);
    return [filter, data];
  } else {
    // The filter is not a power search filter, so the whole term is data
    return [null, term];
  }
}

/**
 * Tokenize a search query.
 *
 * Splits `searchText` into tokens, separated by spaces.
 * Quoted phrases in `searchText` are returned as a single token.
 *
 * @param {string} searchText
 * @return {string[]}
 */
function tokenize(searchText) {
  if (!searchText) {
    return [];
  }

  /**
   * Remove a quote character from the beginning and end of the string, but
   * only if they match. ie:
   *
  -  *   'foo' -> foo
  -  *   "bar" -> bar
  -  *   'foo" -> 'foo"
  -  *    bar"  -> bar"
   *
   * @param {string} text
   */
  const removeQuoteCharacter = text => {
    const start = text.slice(0, 1);
    const end = text.slice(-1);
    if ((start === '"' || start === "'") && start === end) {
      text = text.slice(1, text.length - 1);
    }
    return text;
  };
  let tokens = searchText.match(/(?:[^\s"']+|"[^"]*"|'[^']*')+/g) || [];

  // Cut the opening and closing quote characters
  tokens = tokens.map(removeQuoteCharacter);

  // Remove quotes for power search.
  // I.e. 'tag:"foo bar"' -> 'tag:foo bar'
  for (let index = 0; index < tokens.length; index++) {
    const token = tokens[index];
    const [filter, data] = splitTerm(token);
    if (filter) {
      tokens[index] = filter + ':' + removeQuoteCharacter(data);
    }
  }
  return tokens;
}

/**
 * Parse a search query into a map of search field to term.
 *
 * @param {string} searchText
 * @return {Record<string,string[]>}
 */
function toObject(searchText) {
  /** @type {Record<string,string[]>} */
  const obj = {};

  /** @param {string} field */
  const backendFilter = field => field === 'tag' ? 'tags' : field;
  if (searchText) {
    const terms = tokenize(searchText);
    for (const term of terms) {
      let [field, data] = splitTerm(term);
      if (!field) {
        field = 'any';
        data = term;
      }
      const backendField = backendFilter(field);
      if (obj[backendField]) {
        obj[backendField].push(data);
      } else {
        obj[backendField] = [data];
      }
    }
  }
  return obj;
}

/**
 * @typedef Facet
 * @prop {'and'|'or'} operator
 * @prop {string[]|number[]} terms
 */

/**
 * @typedef FocusFilter
 * @prop {string} [user]
 */

/**
 * Parse a search query into a map of filters.
 *
 * Returns an object mapping facet names to Facet.
 *
 * Terms that are not associated with a particular facet are stored in the "any"
 * facet.
 *
 * @param {string} searchText - Filter query to parse
 * @param {FocusFilter} focusFilters - Additional filter terms to mix in
 * @return {Record<string,Facet>}
 */
function generateFacetedFilter(searchText, focusFilters = {}) {
  let terms;
  const any = [];
  const quote = [];
  const since = [];
  const tag = [];
  const text = [];
  const uri = [];
  const user = focusFilters.user ? [focusFilters.user] : [];
  if (searchText) {
    terms = tokenize(searchText);
    for (const term of terms) {
      const filter = term.slice(0, term.indexOf(':'));
      const fieldValue = term.slice(filter.length + 1);
      switch (filter) {
        case 'quote':
          quote.push(fieldValue);
          break;
        case 'since':
          {
            const time = term.slice(6).toLowerCase();
            const secondsPerDay = 24 * 60 * 60;
            const secondsPerUnit = {
              sec: 1,
              min: 60,
              hour: 60 * 60,
              day: secondsPerDay,
              week: 7 * secondsPerDay,
              month: 30 * secondsPerDay,
              year: 365 * secondsPerDay
            };
            const match = time.match(/^(\d+)(sec|min|hour|day|week|month|year)?$/);
            if (match) {
              const value = parseFloat(match[1]);
              const unit = /** @type {keyof secondsPerUnit} */
              match[2] || 'sec';
              since.push(value * secondsPerUnit[unit]);
            }
          }
          break;
        case 'tag':
          tag.push(fieldValue);
          break;
        case 'text':
          text.push(fieldValue);
          break;
        case 'uri':
          uri.push(fieldValue);
          break;
        case 'user':
          user.push(fieldValue);
          break;
        default:
          any.push(term);
      }
    }
  }
  return {
    any: {
      terms: any,
      operator: 'and'
    },
    quote: {
      terms: quote,
      operator: 'and'
    },
    since: {
      terms: since,
      operator: 'and'
    },
    tag: {
      terms: tag,
      operator: 'and'
    },
    text: {
      terms: text,
      operator: 'and'
    },
    uri: {
      terms: uri,
      operator: 'or'
    },
    user: {
      terms: user,
      operator: 'or'
    }
  };
}

/**
 * Unicode combining characters
 * from http://xregexp.com/addons/unicode/unicode-categories.js line:30
 */

// Lint warning suppressed to faciliate ESLint upgrade. The warning may still
// be valid.
//
const COMBINING_MARKS =
// eslint-disable-next-line no-misleading-character-class
/[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u08FE\u0900-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C01-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C82\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D02\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1DC0-\u1DE6\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26]/g;

/**
 * @param {string} str
 * @return {string}
 */
function fold(str) {
  return str.replace(COMBINING_MARKS, '');
}

/**
 * @param {string} str
 * @return {string}
 */
function normalize(str) {
  return str.normalize('NFKD');
}

/**
 * @typedef {import('../../types/api').Annotation} Annotation
 * @typedef {import('../util/search-filter').Facet} Facet
 */

/**
 * @typedef Filter
 * @prop {(ann: Annotation) => boolean} matches
 */

/**
 * A Matcher specifies how to test whether an annotation matches a query term
 * for a specific field.
 *
 * @template [T=string] - Type of parsed query terms and field values
 * @typedef Matcher
 * @prop {(ann: Annotation) => T[]} fieldValues - Extract the field values to be
 *   matched against a query term
 * @prop {(value: T, term: T) => boolean} matches - Test whether a query term
 *   matches a field value. Both value and term will have been normalized using
 *   `normalize`.
 * @prop {(val: T) => T} normalize - Normalize a parsed term or field value for
 *   comparison
 */

/**
 * Normalize a string query term or field value.
 *
 * @param {string} val
 */
function normalizeStr(val) {
  return fold(normalize(val)).toLowerCase();
}

/**
 * Filter that matches annotations against a single query term.
 *
 * @template TermType
 * @implements {Filter}
 */
class TermFilter {
  /**
   * @param {TermType} term
   * @param {Matcher<TermType>} matcher
   */
  constructor(term, matcher) {
    this.term = matcher.normalize(term);
    this.matcher = matcher;
  }

  /**
   * Return true if an annotation matches this filter.
   *
   * @param {Annotation} ann
   */
  matches(ann) {
    const matcher = this.matcher;
    return matcher.fieldValues(ann).some(value => matcher.matches(matcher.normalize(value), this.term));
  }
}

/**
 * Filter that combines other filters using AND or OR combinators.
 *
 * @implements {Filter}
 */
class BooleanOpFilter {
  /**
   * @param {'and'|'or'} op - Boolean operator
   * @param {Filter[]} filters - Array of filters to test against
   */
  constructor(op, filters) {
    this.operator = op;
    this.filters = filters;
  }

  /**
   * Return true if an annotation matches this filter.
   *
   * @param {Annotation} ann
   */
  matches(ann) {
    if (this.operator === 'and') {
      return this.filters.every(filter => filter.matches(ann));
    } else {
      return this.filters.some(filter => filter.matches(ann));
    }
  }
}

/**
 * Create a matcher that tests whether a query term appears anywhere in a
 * string field value.
 *
 * @param {(ann: Annotation) => string[]} fieldValues
 * @return {Matcher}
 */
function stringFieldMatcher(fieldValues) {
  return {
    fieldValues,
    matches: (value, term) => value.includes(term),
    normalize: normalizeStr
  };
}

/**
 * Map of field name (from a parsed query) to matcher for that field.
 *
 * @type {Record<string, Matcher|Matcher<number>>}
 */
const fieldMatchers = {
  quote: stringFieldMatcher(ann => {
    var _quote;
    return [(_quote = quote(ann)) !== null && _quote !== void 0 ? _quote : ''];
  }),
  /** @type {Matcher<number>} */
  since: {
    fieldValues: ann => [new Date(ann.updated).valueOf()],
    matches: (updatedTime, age) => {
      const delta = (Date.now() - updatedTime) / 1000;
      return delta <= age;
    },
    normalize: timestamp => timestamp
  },
  tag: stringFieldMatcher(ann => ann.tags),
  text: stringFieldMatcher(ann => [ann.text]),
  uri: stringFieldMatcher(ann => [ann.uri]),
  user: stringFieldMatcher(ann => {
    var _ann$user_info$displa, _ann$user_info;
    return [ann.user, (_ann$user_info$displa = (_ann$user_info = ann.user_info) === null || _ann$user_info === void 0 ? void 0 : _ann$user_info.display_name) !== null && _ann$user_info$displa !== void 0 ? _ann$user_info$displa : ''];
  })
};

/**
 * Filter a set of annotations against a parsed query.
 *
 * @param {Annotation[]} annotations
 * @param {Record<string, Facet>} filters
 * @return {string[]} IDs of matching annotations.
 */
function filterAnnotations(annotations, filters) {
  /**
   * @template TermType
   * @param {string} field
   * @param {TermType} term
   */
  const makeTermFilter = (field, term) => new TermFilter(term,
  // Suppress error about potential mismatch of query term type
  // and what the matcher expects. We assume these match up.
  /** @type {Matcher<any>} */
  fieldMatchers[field]);

  // Convert the input filter object into a filter tree, expanding "any"
  // filters.
  const fieldFilters = Object.entries(filters).filter(([, filter]) => filter.terms.length > 0).map(([field, filter]) => {
    let termFilters;
    if (field === 'any') {
      const anyFields = ['quote', 'text', 'tag', 'user'];
      termFilters = filter.terms.map(term => new BooleanOpFilter('or', anyFields.map(field => makeTermFilter(field, term))));
    } else {
      termFilters = filter.terms.map(term => makeTermFilter(field, term));
    }
    return new BooleanOpFilter(filter.operator, termFilters);
  });
  const rootFilter = new BooleanOpFilter('and', fieldFilters);
  return annotations.filter(ann => {
    return ann.id && rootFilter.matches(ann);
  }).map(ann => /** @type {string} */ann.id);
}

// Functions that determine which tab an annotation should be displayed in.

/**
 * @typedef {import('../../types/api').Annotation} Annotation
 * @typedef {import('../../types/sidebar').TabName} TabName
 */

/**
 * Return the tab in which an annotation should be displayed.
 *
 * @param {Annotation} ann
 * @return {TabName}
 */
function tabForAnnotation(ann) {
  if (isOrphan(ann)) {
    return 'orphan';
  } else if (isPageNote(ann)) {
    return 'note';
  } else {
    return 'annotation';
  }
}

/**
 * Return true if an annotation should be displayed in a given tab.
 *
 * @param {Annotation} ann
 * @param {TabName} tab
 */
function shouldShowInTab(ann, tab) {
  if (isWaitingToAnchor(ann)) {
    // Until this annotation anchors or fails to anchor, we do not know which
    // tab it should be displayed in.
    return false;
  }
  return tabForAnnotation(ann) === tab;
}

/**
 * Functions for working with EPUB Canonical Fragment Identifiers.
 *
 * See https://idpf.org/epub/linking/cfi/.
 */

/**
 * Compare two arrays.
 *
 * Arrays are compared as a sequence of values in priority order. If the two
 * arrays are of different length but their common indexes have the same values,
 * the shorter array is considered less than the longer one.
 *
 * This logic is similar to how eg. tuples are compared in Python.
 */
function compareArrays(a, b) {
  for (let i = 0; i < Math.min(a.length, b.length); i++) {
    if (a[i] === b[i]) {
      continue;
    } else if (typeof a[i] !== typeof b[i]) {
      // The result of comparing a number with a string is undefined if the
      // string cannot be coerced to a number. To simplify things, we just
      // decide that numbers sort before strings.
      return typeof a[i] === 'number' ? -1 : 1;
    } else if (a[i] < b[i]) {
      return -1;
    } else if (a[i] > b[i]) {
      return 1;
    }
  }
  return a.length - b.length;
}

/**
 * Strip assertions from a Canonical Fragment Identifier.
 *
 * Assertions are `[...]` enclosed sections which act as checks on the validity
 * of numbers but do not affect the sort order.
 *
 * @example
 *   stripCFIAssertions("/6/14[chap05ref]") // returns "/6/14"
 */
function stripCFIAssertions(cfi) {
  // Fast path for CFIs with no assertions.
  if (!cfi.includes('[')) {
    return cfi;
  }
  let result = '';

  // Has next char been escaped?
  let escaped = false;

  // Are we in a `[...]` assertion section?
  let inAssertion = false;
  for (const ch of cfi) {
    if (!escaped && ch === '^') {
      escaped = true;
      continue;
    }
    if (!escaped && ch === '[') {
      inAssertion = true;
    } else if (!escaped && inAssertion && ch === ']') {
      inAssertion = false;
    } else if (!inAssertion) {
      result += ch;
    }
    escaped = false;
  }
  return result;
}

/**
 * Compare two Canonical Fragment Identifiers.
 *
 * The full sorting rules for CFIs are specified by https://idpf.org/epub/linking/cfi/#sec-sorting.
 *
 * This function currently only implements what is necessary to compare simple
 * CFIs that specify a location within an EPUB's Package Document, without any step
 * indirections ("!"). These CFIs consist of a "/"-delimited sequence of numbers,
 * with optional assertions in `[...]` brackets (eg. "/2/4[chapter2ref]").
 *
 * Per the sorting rules linked above, the input CFIs are assumed to be
 * unescaped. This means that they may contain circumflex (^) escape characters,
 * but don't have the additional escaping that is needed when CFIs are used
 * inside URIs or HTML.
 *
 * @example
 *   compareCFIs("/2/3[chap3ref]", "/2/10[chap10ref]") // returns -1
 *
 * @param a - The first CFI
 * @param b - The second CFI
 * @return A value that is negative, zero or positive depending on
 *   whether `a` is less-than, equal-to or greater-than `b`
 */
function compareCFIs(a, b) {
  const parseCFI = cfi => {
    return stripCFIAssertions(cfi).split('/').map(str => {
      // CFI step values _should_ always be integers. We currently handle
      // invalid values by using a string comparison instead. We could
      // alternatively treat all invalid CFIs as equal.
      const intVal = parseInt(str, 10);
      return Number.isNaN(intVal) ? str : intVal;
    });
  };
  return compareArrays(parseCFI(a), parseCFI(b));
}

/**
 * Helper function for cases in which logically a reference is definitely
 * not nullish, but TS can't infer that correctly. This will cast the `arg`
 * and appease type-checking.
 *
 * @template T
 * @param {T} arg
 */
function notNull(arg) {
  return (/** @type {NonNullable<T>} */arg
  );
}

/** @typedef {import('../../types/api').Annotation} Annotation */
/** @typedef {import('./build-thread').Thread} Thread */

/**
 * Count the number of annotations/replies in the `thread` whose `visible`
 * property matches `visibility`.
 *
 * @param {Thread} thread
 * @param {boolean} visibility — `true`: count visible annotations
 *                               `false`: count hidden annotations
 * @return {number}
 */
function countByVisibility(thread, visibility) {
  const matchesVisibility = thread.visible === visibility;
  return thread.children.reduce((count, reply) => count + countByVisibility(reply, visibility), matchesVisibility ? 1 : 0);
}

/**
 * Count the hidden annotations/replies in the `thread`
 *
 * @param {Thread} thread
 */
function countHidden(thread) {
  return countByVisibility(thread, false);
}

/**
 * Count the visible annotations/replies in the `thread`
 *
 * @param {Thread} thread
 */
function countVisible(thread) {
  return countByVisibility(thread, true);
}

/**
 * Find the topmost annotations in a thread.
 *
 * For the (vast) majority of threads, this is the single annotation at the
 * top level of the thread hierarchy.
 *
 * However, when the top-level thread lacks
 * an annotation, as is the case if that annotation has been deleted but still
 * has replies, find the first level of descendants that has at least one
 * annotation (reply) and return the set of annotations (replies) at that level.
 *
 * For example, given the (overly-complex) thread-annotation structure of:
 *
 * [missing]
 *   - [missing]
 *       - reply 1
 *            - reply 2
 *            - reply 3
 *       - reply 4
 *   - [missing]
 *       - reply 5
 *   - [missing]
 *      - [missing]
 *          - reply 6
 *
 * Return [reply 1, reply 4, reply 5]
 *
 * @param {Thread[]} threads
 * @return {Annotation[]}
 */
function rootAnnotations(threads) {
  // If there are any threads at this level with extant annotations, return
  // those annotations
  const threadAnnotations = threads.filter(thread => !!thread.annotation).map(thread => notNull(thread.annotation));
  if (threadAnnotations.length) {
    return threadAnnotations;
  }

  // Else, search across all children at once (an entire hierarchical level)
  /** @type {Thread[]} */
  const allChildren = [];
  threads.forEach(thread => {
    if (thread.children) {
      allChildren.push(...thread.children);
    }
  });
  if (allChildren.length) {
    return rootAnnotations(allChildren);
  }
  throw new Error('Thread contains no annotations');
}

/** @typedef {import('./build-thread').Thread} Thread */

/**
 * Sort comparison function when one or both threads being compared is lacking
 * an annotation.
 * Sort such that a thread without an annotation sorts to the top
 *
 * @param {Thread} a
 * @param {Thread} b
 * @return {number}
 */
function compareHeadlessThreads(a, b) {
  if (!a.annotation && !b.annotation) {
    return 0;
  } else {
    return !a.annotation ? -1 : 1;
  }
}

/**
 * Find the most recent created date amongst a thread's root annotation set
 *
 * @param {Thread} thread
 * @return {string}
 */
function newestRootAnnotationDate(thread) {
  const annotations = rootAnnotations([thread]);
  return annotations.reduce((newestDate, annotation) => annotation.created > newestDate ? annotation.created : newestDate, '');
}

/**
 * Find the oldest created date amongst a thread's root annotation set
 *
 * @param {Thread} thread
 * @return {string}
 */
function oldestRootAnnotationDate(thread) {
  const annotations = rootAnnotations([thread]);
  return annotations.reduce((oldestDate, annotation) => {
    if (!oldestDate) {
      oldestDate = annotation.created;
    }
    return annotation.created < oldestDate ? annotation.created : oldestDate;
  }, '');
}

/** @typedef {(a: Thread, b: Thread) => number} SortFunction */

/**
 * Sorting comparison functions for the three defined application options for
 * sorting annotation (threads)
 */
const sorters = {
  /** @type {SortFunction} */
  Newest: (a, b) => {
    const dateA = newestRootAnnotationDate(a);
    const dateB = newestRootAnnotationDate(b);
    if (dateA > dateB) {
      return -1;
    } else if (dateA < dateB) {
      return 1;
    }
    return 0;
  },
  /** @type {SortFunction} */
  Oldest: (a, b) => {
    const dateA = oldestRootAnnotationDate(a);
    const dateB = oldestRootAnnotationDate(b);
    if (dateA < dateB) {
      return -1;
    } else if (dateA > dateB) {
      return 1;
    }
    return 0;
  },
  /** @type {SortFunction} */
  Location: (a, b) => {
    var _aLocation$position, _bLocation$position;
    if (!a.annotation || !b.annotation) {
      return compareHeadlessThreads(a, b);
    }
    const aLocation = location(a.annotation);
    const bLocation = location(b.annotation);

    // If these annotations come from an EPUB and specify which chapter they
    // came from via a CFI, compare the chapter order first.
    if (aLocation.cfi && bLocation.cfi) {
      const cfiResult = compareCFIs(aLocation.cfi, bLocation.cfi);
      if (cfiResult !== 0) {
        // Annotations are in different chapters.
        return Math.sign(cfiResult);
      }
    } else if (aLocation.cfi) {
      return -1;
    } else if (bLocation.cfi) {
      return 1;
    }

    // If the chapter number is the same or for other document types, compare
    // the text position instead. Missing positions sort after any present
    // positions.
    const aPos = (_aLocation$position = aLocation.position) !== null && _aLocation$position !== void 0 ? _aLocation$position : Number.MAX_SAFE_INTEGER;
    const bPos = (_bLocation$position = bLocation.position) !== null && _bLocation$position !== void 0 ? _bLocation$position : Number.MAX_SAFE_INTEGER;
    return Math.sign(aPos - bPos);
  }
};

/** @typedef {import('../../types/api').Annotation} Annotation */
/** @typedef {import('./build-thread').Thread} Thread */
/** @typedef {import('./build-thread').BuildThreadOptions} BuildThreadOptions */

/**
 * @typedef ThreadState
 * @prop {Annotation[]} annotations
 * @prop {object} selection
 *   @prop {Record<string,boolean>} selection.expanded
 *   @prop {string|null} selection.filterQuery
 *   @prop {Record<string,string>} selection.filters
 *   @prop {string[]} selection.forcedVisible
 *   @prop {string[]} selection.selected
 *   @prop {keyof sorters} selection.sortKey
 *   @prop {'annotation'|'note'|'orphan'} selection.selectedTab
 * @prop {string|null} route
 */

/**
 * Cobble together the right set of options and filters based on current
 * `threadState` to build the root thread.
 *
 * @param {ThreadState} threadState
 * @return {Thread}
 */
function buildRootThread(threadState) {
  const selection = threadState.selection;

  /** @type {BuildThreadOptions} */
  const options = {
    expanded: selection.expanded,
    forcedVisible: selection.forcedVisible,
    selected: selection.selected,
    sortCompareFn: sorters[selection.sortKey]
  };

  // Is there a filter query present, or an applied user (focus) filter?
  // If so, we'll need to filter the annotations
  const annotationsFiltered = !!selection.filterQuery || Object.keys(selection.filters).length > 0;
  if (annotationsFiltered) {
    const filters = generateFacetedFilter(selection.filterQuery || '', selection.filters);
    options.filterFn = ann => filterAnnotations([ann], filters).length > 0;
  }

  // If annotations aren't filtered, should we filter out tab-irrelevant
  // annotations (e.g. we should only show notes in the `Notes` tab)
  // in the sidebar?
  const threadFiltered = !annotationsFiltered && threadState.route === 'sidebar';
  if (threadFiltered) {
    options.threadFilterFn = thread => {
      if (!thread.annotation) {
        return false;
      }
      return shouldShowInTab(thread.annotation, selection.selectedTab);
    };
  }
  return buildThread(threadState.annotations, options);
}
const threadAnnotations = memoize(buildRootThread);

/** @typedef {import('../../helpers/build-thread').Thread} Thread */

/**
 * Gather together state relevant to building a root thread of annotations and
 * replies and return an updated root thread when changes occur.
 *
 * @return {Thread}
 */
function useRootThread() {
  const store = useSidebarStore();
  const annotations = store.allAnnotations();
  const query = store.filterQuery();
  const route = store.route();
  const selectionState = store.selectionState();
  const filters = store.getFilterValues();
  const threadState = F(() => {
    /** @type {Record<string,string>} */
    return {
      annotations,
      route,
      selection: {
        ...selectionState,
        filterQuery: query,
        filters
      }
    };
  }, [annotations, query, route, selectionState, filters]);
  return threadAnnotations(threadState);
}

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var lodash_debounce = debounce;

function _AsyncGenerator(gen) {
  var front, back;
  function resume(key, arg) {
    try {
      var result = gen[key](arg),
        value = result.value,
        overloaded = value instanceof _OverloadYield;
      Promise.resolve(overloaded ? value.v : value).then(function (arg) {
        if (overloaded) {
          var nextKey = "return" === key ? "return" : "next";
          if (!value.k || arg.done) return resume(nextKey, arg);
          arg = gen[nextKey](arg).value;
        }
        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }
  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: !0
        });
        break;
      case "throw":
        front.reject(value);
        break;
      default:
        front.resolve({
          value: value,
          done: !1
        });
    }
    (front = front.next) ? resume(front.key, front.arg) : back = null;
  }
  this._invoke = function (key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };
      back ? back = back.next = request : (front = back = request, resume(key, arg));
    });
  }, "function" != typeof gen.return && (this.return = void 0);
}
_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () {
  return this;
}, _AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
}, _AsyncGenerator.prototype.throw = function (arg) {
  return this._invoke("throw", arg);
}, _AsyncGenerator.prototype.return = function (arg) {
  return this._invoke("return", arg);
};
function _OverloadYield(value, kind) {
  this.v = value, this.k = kind;
}
function old_createMetadataMethodsForProperty(metadataMap, kind, property, decoratorFinishedRef) {
  return {
    getMetadata: function (key) {
      old_assertNotFinished(decoratorFinishedRef, "getMetadata"), old_assertMetadataKey(key);
      var metadataForKey = metadataMap[key];
      if (void 0 !== metadataForKey) if (1 === kind) {
        var pub = metadataForKey.public;
        if (void 0 !== pub) return pub[property];
      } else if (2 === kind) {
        var priv = metadataForKey.private;
        if (void 0 !== priv) return priv.get(property);
      } else if (Object.hasOwnProperty.call(metadataForKey, "constructor")) return metadataForKey.constructor;
    },
    setMetadata: function (key, value) {
      old_assertNotFinished(decoratorFinishedRef, "setMetadata"), old_assertMetadataKey(key);
      var metadataForKey = metadataMap[key];
      if (void 0 === metadataForKey && (metadataForKey = metadataMap[key] = {}), 1 === kind) {
        var pub = metadataForKey.public;
        void 0 === pub && (pub = metadataForKey.public = {}), pub[property] = value;
      } else if (2 === kind) {
        var priv = metadataForKey.priv;
        void 0 === priv && (priv = metadataForKey.private = new Map()), priv.set(property, value);
      } else metadataForKey.constructor = value;
    }
  };
}
function old_convertMetadataMapToFinal(obj, metadataMap) {
  var parentMetadataMap = obj[Symbol.metadata || Symbol.for("Symbol.metadata")],
    metadataKeys = Object.getOwnPropertySymbols(metadataMap);
  if (0 !== metadataKeys.length) {
    for (var i = 0; i < metadataKeys.length; i++) {
      var key = metadataKeys[i],
        metaForKey = metadataMap[key],
        parentMetaForKey = parentMetadataMap ? parentMetadataMap[key] : null,
        pub = metaForKey.public,
        parentPub = parentMetaForKey ? parentMetaForKey.public : null;
      pub && parentPub && Object.setPrototypeOf(pub, parentPub);
      var priv = metaForKey.private;
      if (priv) {
        var privArr = Array.from(priv.values()),
          parentPriv = parentMetaForKey ? parentMetaForKey.private : null;
        parentPriv && (privArr = privArr.concat(parentPriv)), metaForKey.private = privArr;
      }
      parentMetaForKey && Object.setPrototypeOf(metaForKey, parentMetaForKey);
    }
    parentMetadataMap && Object.setPrototypeOf(metadataMap, parentMetadataMap), obj[Symbol.metadata || Symbol.for("Symbol.metadata")] = metadataMap;
  }
}
function old_createAddInitializerMethod(initializers, decoratorFinishedRef) {
  return function (initializer) {
    old_assertNotFinished(decoratorFinishedRef, "addInitializer"), old_assertCallable(initializer, "An initializer"), initializers.push(initializer);
  };
}
function old_memberDec(dec, name, desc, metadataMap, initializers, kind, isStatic, isPrivate, value) {
  var kindStr;
  switch (kind) {
    case 1:
      kindStr = "accessor";
      break;
    case 2:
      kindStr = "method";
      break;
    case 3:
      kindStr = "getter";
      break;
    case 4:
      kindStr = "setter";
      break;
    default:
      kindStr = "field";
  }
  var metadataKind,
    metadataName,
    ctx = {
      kind: kindStr,
      name: isPrivate ? "#" + name : name,
      isStatic: isStatic,
      isPrivate: isPrivate
    },
    decoratorFinishedRef = {
      v: !1
    };
  if (0 !== kind && (ctx.addInitializer = old_createAddInitializerMethod(initializers, decoratorFinishedRef)), isPrivate) {
    metadataKind = 2, metadataName = Symbol(name);
    var access = {};
    0 === kind ? (access.get = desc.get, access.set = desc.set) : 2 === kind ? access.get = function () {
      return desc.value;
    } : (1 !== kind && 3 !== kind || (access.get = function () {
      return desc.get.call(this);
    }), 1 !== kind && 4 !== kind || (access.set = function (v) {
      desc.set.call(this, v);
    })), ctx.access = access;
  } else metadataKind = 1, metadataName = name;
  try {
    return dec(value, Object.assign(ctx, old_createMetadataMethodsForProperty(metadataMap, metadataKind, metadataName, decoratorFinishedRef)));
  } finally {
    decoratorFinishedRef.v = !0;
  }
}
function old_assertNotFinished(decoratorFinishedRef, fnName) {
  if (decoratorFinishedRef.v) throw new Error("attempted to call " + fnName + " after decoration was finished");
}
function old_assertMetadataKey(key) {
  if ("symbol" != typeof key) throw new TypeError("Metadata keys must be symbols, received: " + key);
}
function old_assertCallable(fn, hint) {
  if ("function" != typeof fn) throw new TypeError(hint + " must be a function");
}
function old_assertValidReturnValue(kind, value) {
  var type = typeof value;
  if (1 === kind) {
    if ("object" !== type || null === value) throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
    void 0 !== value.get && old_assertCallable(value.get, "accessor.get"), void 0 !== value.set && old_assertCallable(value.set, "accessor.set"), void 0 !== value.init && old_assertCallable(value.init, "accessor.init"), void 0 !== value.initializer && old_assertCallable(value.initializer, "accessor.initializer");
  } else if ("function" !== type) {
    var hint;
    throw hint = 0 === kind ? "field" : 10 === kind ? "class" : "method", new TypeError(hint + " decorators must return a function or void 0");
  }
}
function old_getInit(desc) {
  var initializer;
  return null == (initializer = desc.init) && (initializer = desc.initializer) && "undefined" != typeof console && console.warn(".initializer has been renamed to .init as of March 2022"), initializer;
}
function old_applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers) {
  var desc,
    initializer,
    value,
    newValue,
    get,
    set,
    decs = decInfo[0];
  if (isPrivate ? desc = 0 === kind || 1 === kind ? {
    get: decInfo[3],
    set: decInfo[4]
  } : 3 === kind ? {
    get: decInfo[3]
  } : 4 === kind ? {
    set: decInfo[3]
  } : {
    value: decInfo[3]
  } : 0 !== kind && (desc = Object.getOwnPropertyDescriptor(base, name)), 1 === kind ? value = {
    get: desc.get,
    set: desc.set
  } : 2 === kind ? value = desc.value : 3 === kind ? value = desc.get : 4 === kind && (value = desc.set), "function" == typeof decs) void 0 !== (newValue = old_memberDec(decs, name, desc, metadataMap, initializers, kind, isStatic, isPrivate, value)) && (old_assertValidReturnValue(kind, newValue), 0 === kind ? initializer = newValue : 1 === kind ? (initializer = old_getInit(newValue), get = newValue.get || value.get, set = newValue.set || value.set, value = {
    get: get,
    set: set
  }) : value = newValue);else for (var i = decs.length - 1; i >= 0; i--) {
    var newInit;
    if (void 0 !== (newValue = old_memberDec(decs[i], name, desc, metadataMap, initializers, kind, isStatic, isPrivate, value))) old_assertValidReturnValue(kind, newValue), 0 === kind ? newInit = newValue : 1 === kind ? (newInit = old_getInit(newValue), get = newValue.get || value.get, set = newValue.set || value.set, value = {
      get: get,
      set: set
    }) : value = newValue, void 0 !== newInit && (void 0 === initializer ? initializer = newInit : "function" == typeof initializer ? initializer = [initializer, newInit] : initializer.push(newInit));
  }
  if (0 === kind || 1 === kind) {
    if (void 0 === initializer) initializer = function (instance, init) {
      return init;
    };else if ("function" != typeof initializer) {
      var ownInitializers = initializer;
      initializer = function (instance, init) {
        for (var value = init, i = 0; i < ownInitializers.length; i++) value = ownInitializers[i].call(instance, value);
        return value;
      };
    } else {
      var originalInitializer = initializer;
      initializer = function (instance, init) {
        return originalInitializer.call(instance, init);
      };
    }
    ret.push(initializer);
  }
  0 !== kind && (1 === kind ? (desc.get = value.get, desc.set = value.set) : 2 === kind ? desc.value = value : 3 === kind ? desc.get = value : 4 === kind && (desc.set = value), isPrivate ? 1 === kind ? (ret.push(function (instance, args) {
    return value.get.call(instance, args);
  }), ret.push(function (instance, args) {
    return value.set.call(instance, args);
  })) : 2 === kind ? ret.push(value) : ret.push(function (instance, args) {
    return value.call(instance, args);
  }) : Object.defineProperty(base, name, desc));
}
function old_applyMemberDecs(ret, Class, protoMetadataMap, staticMetadataMap, decInfos) {
  for (var protoInitializers, staticInitializers, existingProtoNonFields = new Map(), existingStaticNonFields = new Map(), i = 0; i < decInfos.length; i++) {
    var decInfo = decInfos[i];
    if (Array.isArray(decInfo)) {
      var base,
        metadataMap,
        initializers,
        kind = decInfo[1],
        name = decInfo[2],
        isPrivate = decInfo.length > 3,
        isStatic = kind >= 5;
      if (isStatic ? (base = Class, metadataMap = staticMetadataMap, 0 !== (kind -= 5) && (initializers = staticInitializers = staticInitializers || [])) : (base = Class.prototype, metadataMap = protoMetadataMap, 0 !== kind && (initializers = protoInitializers = protoInitializers || [])), 0 !== kind && !isPrivate) {
        var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields,
          existingKind = existingNonFields.get(name) || 0;
        if (!0 === existingKind || 3 === existingKind && 4 !== kind || 4 === existingKind && 3 !== kind) throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
        !existingKind && kind > 2 ? existingNonFields.set(name, kind) : existingNonFields.set(name, !0);
      }
      old_applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers);
    }
  }
  old_pushInitializers(ret, protoInitializers), old_pushInitializers(ret, staticInitializers);
}
function old_pushInitializers(ret, initializers) {
  initializers && ret.push(function (instance) {
    for (var i = 0; i < initializers.length; i++) initializers[i].call(instance);
    return instance;
  });
}
function old_applyClassDecs(ret, targetClass, metadataMap, classDecs) {
  if (classDecs.length > 0) {
    for (var initializers = [], newClass = targetClass, name = targetClass.name, i = classDecs.length - 1; i >= 0; i--) {
      var decoratorFinishedRef = {
        v: !1
      };
      try {
        var ctx = Object.assign({
            kind: "class",
            name: name,
            addInitializer: old_createAddInitializerMethod(initializers, decoratorFinishedRef)
          }, old_createMetadataMethodsForProperty(metadataMap, 0, name, decoratorFinishedRef)),
          nextNewClass = classDecs[i](newClass, ctx);
      } finally {
        decoratorFinishedRef.v = !0;
      }
      void 0 !== nextNewClass && (old_assertValidReturnValue(10, nextNewClass), newClass = nextNewClass);
    }
    ret.push(newClass, function () {
      for (var i = 0; i < initializers.length; i++) initializers[i].call(newClass);
    });
  }
}
function _applyDecs(targetClass, memberDecs, classDecs) {
  var ret = [],
    staticMetadataMap = {},
    protoMetadataMap = {};
  return old_applyMemberDecs(ret, targetClass, protoMetadataMap, staticMetadataMap, memberDecs), old_convertMetadataMapToFinal(targetClass.prototype, protoMetadataMap), old_applyClassDecs(ret, targetClass, staticMetadataMap, classDecs), old_convertMetadataMapToFinal(targetClass, staticMetadataMap), ret;
}
function createAddInitializerMethod(initializers, decoratorFinishedRef) {
  return function (initializer) {
    assertNotFinished(decoratorFinishedRef, "addInitializer"), assertCallable(initializer, "An initializer"), initializers.push(initializer);
  };
}
function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, value) {
  var kindStr;
  switch (kind) {
    case 1:
      kindStr = "accessor";
      break;
    case 2:
      kindStr = "method";
      break;
    case 3:
      kindStr = "getter";
      break;
    case 4:
      kindStr = "setter";
      break;
    default:
      kindStr = "field";
  }
  var get,
    set,
    ctx = {
      kind: kindStr,
      name: isPrivate ? "#" + name : name,
      static: isStatic,
      private: isPrivate
    },
    decoratorFinishedRef = {
      v: !1
    };
  0 !== kind && (ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef)), 0 === kind ? isPrivate ? (get = desc.get, set = desc.set) : (get = function () {
    return this[name];
  }, set = function (v) {
    this[name] = v;
  }) : 2 === kind ? get = function () {
    return desc.value;
  } : (1 !== kind && 3 !== kind || (get = function () {
    return desc.get.call(this);
  }), 1 !== kind && 4 !== kind || (set = function (v) {
    desc.set.call(this, v);
  })), ctx.access = get && set ? {
    get: get,
    set: set
  } : get ? {
    get: get
  } : {
    set: set
  };
  try {
    return dec(value, ctx);
  } finally {
    decoratorFinishedRef.v = !0;
  }
}
function assertNotFinished(decoratorFinishedRef, fnName) {
  if (decoratorFinishedRef.v) throw new Error("attempted to call " + fnName + " after decoration was finished");
}
function assertCallable(fn, hint) {
  if ("function" != typeof fn) throw new TypeError(hint + " must be a function");
}
function assertValidReturnValue(kind, value) {
  var type = typeof value;
  if (1 === kind) {
    if ("object" !== type || null === value) throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
    void 0 !== value.get && assertCallable(value.get, "accessor.get"), void 0 !== value.set && assertCallable(value.set, "accessor.set"), void 0 !== value.init && assertCallable(value.init, "accessor.init");
  } else if ("function" !== type) {
    var hint;
    throw hint = 0 === kind ? "field" : 10 === kind ? "class" : "method", new TypeError(hint + " decorators must return a function or void 0");
  }
}
function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers) {
  var desc,
    init,
    value,
    newValue,
    get,
    set,
    decs = decInfo[0];
  if (isPrivate ? desc = 0 === kind || 1 === kind ? {
    get: decInfo[3],
    set: decInfo[4]
  } : 3 === kind ? {
    get: decInfo[3]
  } : 4 === kind ? {
    set: decInfo[3]
  } : {
    value: decInfo[3]
  } : 0 !== kind && (desc = Object.getOwnPropertyDescriptor(base, name)), 1 === kind ? value = {
    get: desc.get,
    set: desc.set
  } : 2 === kind ? value = desc.value : 3 === kind ? value = desc.get : 4 === kind && (value = desc.set), "function" == typeof decs) void 0 !== (newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, value)) && (assertValidReturnValue(kind, newValue), 0 === kind ? init = newValue : 1 === kind ? (init = newValue.init, get = newValue.get || value.get, set = newValue.set || value.set, value = {
    get: get,
    set: set
  }) : value = newValue);else for (var i = decs.length - 1; i >= 0; i--) {
    var newInit;
    if (void 0 !== (newValue = memberDec(decs[i], name, desc, initializers, kind, isStatic, isPrivate, value))) assertValidReturnValue(kind, newValue), 0 === kind ? newInit = newValue : 1 === kind ? (newInit = newValue.init, get = newValue.get || value.get, set = newValue.set || value.set, value = {
      get: get,
      set: set
    }) : value = newValue, void 0 !== newInit && (void 0 === init ? init = newInit : "function" == typeof init ? init = [init, newInit] : init.push(newInit));
  }
  if (0 === kind || 1 === kind) {
    if (void 0 === init) init = function (instance, init) {
      return init;
    };else if ("function" != typeof init) {
      var ownInitializers = init;
      init = function (instance, init) {
        for (var value = init, i = 0; i < ownInitializers.length; i++) value = ownInitializers[i].call(instance, value);
        return value;
      };
    } else {
      var originalInitializer = init;
      init = function (instance, init) {
        return originalInitializer.call(instance, init);
      };
    }
    ret.push(init);
  }
  0 !== kind && (1 === kind ? (desc.get = value.get, desc.set = value.set) : 2 === kind ? desc.value = value : 3 === kind ? desc.get = value : 4 === kind && (desc.set = value), isPrivate ? 1 === kind ? (ret.push(function (instance, args) {
    return value.get.call(instance, args);
  }), ret.push(function (instance, args) {
    return value.set.call(instance, args);
  })) : 2 === kind ? ret.push(value) : ret.push(function (instance, args) {
    return value.call(instance, args);
  }) : Object.defineProperty(base, name, desc));
}
function applyMemberDecs(ret, Class, decInfos) {
  for (var protoInitializers, staticInitializers, existingProtoNonFields = new Map(), existingStaticNonFields = new Map(), i = 0; i < decInfos.length; i++) {
    var decInfo = decInfos[i];
    if (Array.isArray(decInfo)) {
      var base,
        initializers,
        kind = decInfo[1],
        name = decInfo[2],
        isPrivate = decInfo.length > 3,
        isStatic = kind >= 5;
      if (isStatic ? (base = Class, 0 !== (kind -= 5) && (initializers = staticInitializers = staticInitializers || [])) : (base = Class.prototype, 0 !== kind && (initializers = protoInitializers = protoInitializers || [])), 0 !== kind && !isPrivate) {
        var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields,
          existingKind = existingNonFields.get(name) || 0;
        if (!0 === existingKind || 3 === existingKind && 4 !== kind || 4 === existingKind && 3 !== kind) throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
        !existingKind && kind > 2 ? existingNonFields.set(name, kind) : existingNonFields.set(name, !0);
      }
      applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers);
    }
  }
  pushInitializers(ret, protoInitializers), pushInitializers(ret, staticInitializers);
}
function pushInitializers(ret, initializers) {
  initializers && ret.push(function (instance) {
    for (var i = 0; i < initializers.length; i++) initializers[i].call(instance);
    return instance;
  });
}
function applyClassDecs(ret, targetClass, classDecs) {
  if (classDecs.length > 0) {
    for (var initializers = [], newClass = targetClass, name = targetClass.name, i = classDecs.length - 1; i >= 0; i--) {
      var decoratorFinishedRef = {
        v: !1
      };
      try {
        var nextNewClass = classDecs[i](newClass, {
          kind: "class",
          name: name,
          addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef)
        });
      } finally {
        decoratorFinishedRef.v = !0;
      }
      void 0 !== nextNewClass && (assertValidReturnValue(10, nextNewClass), newClass = nextNewClass);
    }
    ret.push(newClass, function () {
      for (var i = 0; i < initializers.length; i++) initializers[i].call(newClass);
    });
  }
}
function _applyDecs2203(targetClass, memberDecs, classDecs) {
  var ret = [];
  return applyMemberDecs(ret, targetClass, memberDecs), applyClassDecs(ret, targetClass, classDecs), ret;
}
function _asyncGeneratorDelegate(inner) {
  var iter = {},
    waiting = !1;
  function pump(key, value) {
    return waiting = !0, value = new Promise(function (resolve) {
      resolve(inner[key](value));
    }), {
      done: !1,
      value: new _OverloadYield(value, 1)
    };
  }
  return iter["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function () {
    return this;
  }, iter.next = function (value) {
    return waiting ? (waiting = !1, value) : pump("next", value);
  }, "function" == typeof inner.throw && (iter.throw = function (value) {
    if (waiting) throw waiting = !1, value;
    return pump("throw", value);
  }), "function" == typeof inner.return && (iter.return = function (value) {
    return waiting ? (waiting = !1, value) : pump("return", value);
  }), iter;
}
function _asyncIterator(iterable) {
  var method,
    async,
    sync,
    retry = 2;
  for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {
    if (async && null != (method = iterable[async])) return method.call(iterable);
    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
    async = "@@asyncIterator", sync = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(s) {
  function AsyncFromSyncIteratorContinuation(r) {
    if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
    var done = r.done;
    return Promise.resolve(r.value).then(function (value) {
      return {
        value: value,
        done: done
      };
    });
  }
  return AsyncFromSyncIterator = function (s) {
    this.s = s, this.n = s.next;
  }, AsyncFromSyncIterator.prototype = {
    s: null,
    n: null,
    next: function () {
      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
    },
    return: function (value) {
      var ret = this.s.return;
      return void 0 === ret ? Promise.resolve({
        value: value,
        done: !0
      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
    },
    throw: function (value) {
      var thr = this.s.return;
      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
    }
  }, new AsyncFromSyncIterator(s);
}
function _awaitAsyncGenerator(value) {
  return new _OverloadYield(value, 0);
}
var REACT_ELEMENT_TYPE;
function _jsx(type, props, key, children) {
  REACT_ELEMENT_TYPE || (REACT_ELEMENT_TYPE = "function" == typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103);
  var defaultProps = type && type.defaultProps,
    childrenLength = arguments.length - 3;
  if (props || 0 === childrenLength || (props = {
    children: void 0
  }), 1 === childrenLength) props.children = children;else if (childrenLength > 1) {
    for (var childArray = new Array(childrenLength), i = 0; i < childrenLength; i++) childArray[i] = arguments[i + 3];
    props.children = childArray;
  }
  if (props && defaultProps) for (var propName in defaultProps) void 0 === props[propName] && (props[propName] = defaultProps[propName]);else props || (props = defaultProps || {});
  return {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: void 0 === key ? null : "" + key,
    ref: null,
    props: props,
    _owner: null
  };
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _regeneratorRuntime() {
  "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }
      return ContinueSentinel;
    }
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";

  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$1(obj);
}
function _wrapRegExp() {
  _wrapRegExp = function (re, groups) {
    return new BabelRegExp(re, void 0, groups);
  };
  var _super = RegExp.prototype,
    _groups = new WeakMap();
  function BabelRegExp(re, flags, groups) {
    var _this = new RegExp(re, flags);
    return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf$1(_this, BabelRegExp.prototype);
  }
  function buildGroups(result, re) {
    var g = _groups.get(re);
    return Object.keys(g).reduce(function (groups, name) {
      var i = g[name];
      if ("number" == typeof i) groups[name] = result[i];else {
        for (var k = 0; void 0 === result[i[k]] && k + 1 < i.length;) k++;
        groups[name] = result[i[k]];
      }
      return groups;
    }, Object.create(null));
  }
  return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) {
    var result = _super.exec.call(this, str);
    if (result) {
      result.groups = buildGroups(result, this);
      var indices = result.indices;
      indices && (indices.groups = buildGroups(indices, this));
    }
    return result;
  }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
    if ("string" == typeof substitution) {
      var groups = _groups.get(this);
      return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
        var group = groups[name];
        return "$" + (Array.isArray(group) ? group.join("$") : group);
      }));
    }
    if ("function" == typeof substitution) {
      var _this = this;
      return _super[Symbol.replace].call(this, str, function () {
        var args = arguments;
        return "object" != typeof args[args.length - 1] && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);
      });
    }
    return _super[Symbol.replace].call(this, str, substitution);
  }, _wrapRegExp.apply(this, arguments);
}
function _AwaitValue(value) {
  this.wrapped = value;
}
function _wrapAsyncGenerator(fn) {
  return function () {
    return new _AsyncGenerator(fn.apply(this, arguments));
  };
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineEnumerableProperties(obj, descs) {
  for (var key in descs) {
    var desc = descs[key];
    desc.configurable = desc.enumerable = true;
    if ("value" in desc) desc.writable = true;
    Object.defineProperty(obj, key, desc);
  }
  if (Object.getOwnPropertySymbols) {
    var objectSymbols = Object.getOwnPropertySymbols(descs);
    for (var i = 0; i < objectSymbols.length; i++) {
      var sym = objectSymbols[i];
      var desc = descs[sym];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, sym, desc);
    }
  }
  return obj;
}
function _defaults(obj, defaults) {
  var keys = Object.getOwnPropertyNames(defaults);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = Object.getOwnPropertyDescriptor(defaults, key);
    if (value && value.configurable && obj[key] === undefined) {
      Object.defineProperty(obj, key, value);
    }
  }
  return obj;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? Object(arguments[i]) : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf$1(subClass, superClass);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$1(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf$1(o, p);
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct$1(Parent, args, Class) {
  if (_isNativeReflectConstruct$1()) {
    _construct$1 = Reflect.construct.bind();
  } else {
    _construct$1 = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf$1(instance, Class.prototype);
      return instance;
    };
  }
  return _construct$1.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct$1(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf$1(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}
function _instanceof(left, right) {
  if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
    return !!right[Symbol.hasInstance](left);
  } else {
    return left instanceof right;
  }
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function _newArrowCheck(innerThis, boundThis) {
  if (innerThis !== boundThis) {
    throw new TypeError("Cannot instantiate an arrow function");
  }
}
function _objectDestructuringEmpty(obj) {
  if (obj == null) throw new TypeError("Cannot destructure " + obj);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }
  return object;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function set(target, property, value, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.set) {
    set = Reflect.set;
  } else {
    set = function set(target, property, value, receiver) {
      var base = _superPropBase(target, property);
      var desc;
      if (base) {
        desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.set) {
          desc.set.call(receiver, value);
          return true;
        } else if (!desc.writable) {
          return false;
        }
      }
      desc = Object.getOwnPropertyDescriptor(receiver, property);
      if (desc) {
        if (!desc.writable) {
          return false;
        }
        desc.value = value;
        Object.defineProperty(receiver, property, desc);
      } else {
        _defineProperty(receiver, property, value);
      }
      return true;
    };
  }
  return set(target, property, value, receiver);
}
function _set(target, property, value, receiver, isStrict) {
  var s = set(target, property, value, receiver || target);
  if (!s && isStrict) {
    throw new Error('failed to set property');
  }
  return value;
}
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}
function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  strings.raw = raw;
  return strings;
}
function _readOnlyError(name) {
  throw new TypeError("\"" + name + "\" is read-only");
}
function _writeOnlyError(name) {
  throw new TypeError("\"" + name + "\" is write-only");
}
function _classNameTDZError(name) {
  throw new Error("Class \"" + name + "\" cannot be referenced in computed property keys.");
}
function _temporalUndefined() {}
function _tdz(name) {
  throw new ReferenceError(name + " is not defined - temporal dead zone");
}
function _temporalRef(val, name) {
  return val === _temporalUndefined ? _tdz(name) : val;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
}
function _slicedToArrayLoose(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimitLoose(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
}
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableRest();
}
function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _maybeArrayLike(next, arr, i) {
  if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
    var len = arr.length;
    return _arrayLikeToArray$1(arr, i !== void 0 && i < len ? i : len);
  }
  return next(arr, i);
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _iterableToArrayLimitLoose(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null) return;
  var _arr = [];
  for (_i = _i.call(arr), _step; !(_step = _i.next()).done;) {
    _arr.push(_step.value);
    if (i && _arr.length === i) break;
  }
  return _arr;
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function () {};
      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _skipFirstGeneratorNext(fn) {
  return function () {
    var it = fn.apply(this, arguments);
    it.next();
    return it;
  };
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _initializerWarningHelper(descriptor, context) {
  throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.');
}
function _initializerDefineProperty(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}
function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);
  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}
var id = 0;
function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}
function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
function _classPrivateFieldDestructureSet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  return _classApplyDescriptorDestructureSet(receiver, descriptor);
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
  _classCheckPrivateStaticAccess(receiver, classConstructor);
  _classCheckPrivateStaticFieldDescriptor(descriptor, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
  _classCheckPrivateStaticAccess(receiver, classConstructor);
  _classCheckPrivateStaticFieldDescriptor(descriptor, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
  _classCheckPrivateStaticAccess(receiver, classConstructor);
  return method;
}
function _classStaticPrivateMethodSet() {
  throw new TypeError("attempted to set read only static private field");
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classApplyDescriptorDestructureSet(receiver, descriptor) {
  if (descriptor.set) {
    if (!("__destrObj" in descriptor)) {
      descriptor.__destrObj = {
        set value(v) {
          descriptor.set.call(receiver, v);
        }
      };
    }
    return descriptor.__destrObj;
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    return descriptor;
  }
}
function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
  _classCheckPrivateStaticAccess(receiver, classConstructor);
  _classCheckPrivateStaticFieldDescriptor(descriptor, "set");
  return _classApplyDescriptorDestructureSet(receiver, descriptor);
}
function _classCheckPrivateStaticAccess(receiver, classConstructor) {
  if (receiver !== classConstructor) {
    throw new TypeError("Private static access of wrong provenance");
  }
}
function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
  if (descriptor === undefined) {
    throw new TypeError("attempted to " + action + " private static field before its declaration");
  }
}
function _decorate(decorators, factory, superClass, mixins) {
  var api = _getDecoratorsApi();
  if (mixins) {
    for (var i = 0; i < mixins.length; i++) {
      api = mixins[i](api);
    }
  }
  var r = factory(function initialize(O) {
    api.initializeInstanceElements(O, decorated.elements);
  }, superClass);
  var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators);
  api.initializeClassElements(r.F, decorated.elements);
  return api.runClassFinishers(r.F, decorated.finishers);
}
function _getDecoratorsApi() {
  _getDecoratorsApi = function () {
    return api;
  };
  var api = {
    elementsDefinitionOrder: [["method"], ["field"]],
    initializeInstanceElements: function (O, elements) {
      ["method", "field"].forEach(function (kind) {
        elements.forEach(function (element) {
          if (element.kind === kind && element.placement === "own") {
            this.defineClassElement(O, element);
          }
        }, this);
      }, this);
    },
    initializeClassElements: function (F, elements) {
      var proto = F.prototype;
      ["method", "field"].forEach(function (kind) {
        elements.forEach(function (element) {
          var placement = element.placement;
          if (element.kind === kind && (placement === "static" || placement === "prototype")) {
            var receiver = placement === "static" ? F : proto;
            this.defineClassElement(receiver, element);
          }
        }, this);
      }, this);
    },
    defineClassElement: function (receiver, element) {
      var descriptor = element.descriptor;
      if (element.kind === "field") {
        var initializer = element.initializer;
        descriptor = {
          enumerable: descriptor.enumerable,
          writable: descriptor.writable,
          configurable: descriptor.configurable,
          value: initializer === void 0 ? void 0 : initializer.call(receiver)
        };
      }
      Object.defineProperty(receiver, element.key, descriptor);
    },
    decorateClass: function (elements, decorators) {
      var newElements = [];
      var finishers = [];
      var placements = {
        static: [],
        prototype: [],
        own: []
      };
      elements.forEach(function (element) {
        this.addElementPlacement(element, placements);
      }, this);
      elements.forEach(function (element) {
        if (!_hasDecorators(element)) return newElements.push(element);
        var elementFinishersExtras = this.decorateElement(element, placements);
        newElements.push(elementFinishersExtras.element);
        newElements.push.apply(newElements, elementFinishersExtras.extras);
        finishers.push.apply(finishers, elementFinishersExtras.finishers);
      }, this);
      if (!decorators) {
        return {
          elements: newElements,
          finishers: finishers
        };
      }
      var result = this.decorateConstructor(newElements, decorators);
      finishers.push.apply(finishers, result.finishers);
      result.finishers = finishers;
      return result;
    },
    addElementPlacement: function (element, placements, silent) {
      var keys = placements[element.placement];
      if (!silent && keys.indexOf(element.key) !== -1) {
        throw new TypeError("Duplicated element (" + element.key + ")");
      }
      keys.push(element.key);
    },
    decorateElement: function (element, placements) {
      var extras = [];
      var finishers = [];
      for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {
        var keys = placements[element.placement];
        keys.splice(keys.indexOf(element.key), 1);
        var elementObject = this.fromElementDescriptor(element);
        var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject);
        element = elementFinisherExtras.element;
        this.addElementPlacement(element, placements);
        if (elementFinisherExtras.finisher) {
          finishers.push(elementFinisherExtras.finisher);
        }
        var newExtras = elementFinisherExtras.extras;
        if (newExtras) {
          for (var j = 0; j < newExtras.length; j++) {
            this.addElementPlacement(newExtras[j], placements);
          }
          extras.push.apply(extras, newExtras);
        }
      }
      return {
        element: element,
        finishers: finishers,
        extras: extras
      };
    },
    decorateConstructor: function (elements, decorators) {
      var finishers = [];
      for (var i = decorators.length - 1; i >= 0; i--) {
        var obj = this.fromClassDescriptor(elements);
        var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj);
        if (elementsAndFinisher.finisher !== undefined) {
          finishers.push(elementsAndFinisher.finisher);
        }
        if (elementsAndFinisher.elements !== undefined) {
          elements = elementsAndFinisher.elements;
          for (var j = 0; j < elements.length - 1; j++) {
            for (var k = j + 1; k < elements.length; k++) {
              if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) {
                throw new TypeError("Duplicated element (" + elements[j].key + ")");
              }
            }
          }
        }
      }
      return {
        elements: elements,
        finishers: finishers
      };
    },
    fromElementDescriptor: function (element) {
      var obj = {
        kind: element.kind,
        key: element.key,
        placement: element.placement,
        descriptor: element.descriptor
      };
      var desc = {
        value: "Descriptor",
        configurable: true
      };
      Object.defineProperty(obj, Symbol.toStringTag, desc);
      if (element.kind === "field") obj.initializer = element.initializer;
      return obj;
    },
    toElementDescriptors: function (elementObjects) {
      if (elementObjects === undefined) return;
      return _toArray(elementObjects).map(function (elementObject) {
        var element = this.toElementDescriptor(elementObject);
        this.disallowProperty(elementObject, "finisher", "An element descriptor");
        this.disallowProperty(elementObject, "extras", "An element descriptor");
        return element;
      }, this);
    },
    toElementDescriptor: function (elementObject) {
      var kind = String(elementObject.kind);
      if (kind !== "method" && kind !== "field") {
        throw new TypeError('An element descriptor\'s .kind property must be either "method" or' + ' "field", but a decorator created an element descriptor with' + ' .kind "' + kind + '"');
      }
      var key = _toPropertyKey(elementObject.key);
      var placement = String(elementObject.placement);
      if (placement !== "static" && placement !== "prototype" && placement !== "own") {
        throw new TypeError('An element descriptor\'s .placement property must be one of "static",' + ' "prototype" or "own", but a decorator created an element descriptor' + ' with .placement "' + placement + '"');
      }
      var descriptor = elementObject.descriptor;
      this.disallowProperty(elementObject, "elements", "An element descriptor");
      var element = {
        kind: kind,
        key: key,
        placement: placement,
        descriptor: Object.assign({}, descriptor)
      };
      if (kind !== "field") {
        this.disallowProperty(elementObject, "initializer", "A method descriptor");
      } else {
        this.disallowProperty(descriptor, "get", "The property descriptor of a field descriptor");
        this.disallowProperty(descriptor, "set", "The property descriptor of a field descriptor");
        this.disallowProperty(descriptor, "value", "The property descriptor of a field descriptor");
        element.initializer = elementObject.initializer;
      }
      return element;
    },
    toElementFinisherExtras: function (elementObject) {
      var element = this.toElementDescriptor(elementObject);
      var finisher = _optionalCallableProperty(elementObject, "finisher");
      var extras = this.toElementDescriptors(elementObject.extras);
      return {
        element: element,
        finisher: finisher,
        extras: extras
      };
    },
    fromClassDescriptor: function (elements) {
      var obj = {
        kind: "class",
        elements: elements.map(this.fromElementDescriptor, this)
      };
      var desc = {
        value: "Descriptor",
        configurable: true
      };
      Object.defineProperty(obj, Symbol.toStringTag, desc);
      return obj;
    },
    toClassDescriptor: function (obj) {
      var kind = String(obj.kind);
      if (kind !== "class") {
        throw new TypeError('A class descriptor\'s .kind property must be "class", but a decorator' + ' created a class descriptor with .kind "' + kind + '"');
      }
      this.disallowProperty(obj, "key", "A class descriptor");
      this.disallowProperty(obj, "placement", "A class descriptor");
      this.disallowProperty(obj, "descriptor", "A class descriptor");
      this.disallowProperty(obj, "initializer", "A class descriptor");
      this.disallowProperty(obj, "extras", "A class descriptor");
      var finisher = _optionalCallableProperty(obj, "finisher");
      var elements = this.toElementDescriptors(obj.elements);
      return {
        elements: elements,
        finisher: finisher
      };
    },
    runClassFinishers: function (constructor, finishers) {
      for (var i = 0; i < finishers.length; i++) {
        var newConstructor = (0, finishers[i])(constructor);
        if (newConstructor !== undefined) {
          if (typeof newConstructor !== "function") {
            throw new TypeError("Finishers must return a constructor.");
          }
          constructor = newConstructor;
        }
      }
      return constructor;
    },
    disallowProperty: function (obj, name, objectType) {
      if (obj[name] !== undefined) {
        throw new TypeError(objectType + " can't have a ." + name + " property.");
      }
    }
  };
  return api;
}
function _createElementDescriptor(def) {
  var key = _toPropertyKey(def.key);
  var descriptor;
  if (def.kind === "method") {
    descriptor = {
      value: def.value,
      writable: true,
      configurable: true,
      enumerable: false
    };
  } else if (def.kind === "get") {
    descriptor = {
      get: def.value,
      configurable: true,
      enumerable: false
    };
  } else if (def.kind === "set") {
    descriptor = {
      set: def.value,
      configurable: true,
      enumerable: false
    };
  } else if (def.kind === "field") {
    descriptor = {
      configurable: true,
      writable: true,
      enumerable: true
    };
  }
  var element = {
    kind: def.kind === "field" ? "field" : "method",
    key: key,
    placement: def.static ? "static" : def.kind === "field" ? "own" : "prototype",
    descriptor: descriptor
  };
  if (def.decorators) element.decorators = def.decorators;
  if (def.kind === "field") element.initializer = def.value;
  return element;
}
function _coalesceGetterSetter(element, other) {
  if (element.descriptor.get !== undefined) {
    other.descriptor.get = element.descriptor.get;
  } else {
    other.descriptor.set = element.descriptor.set;
  }
}
function _coalesceClassElements(elements) {
  var newElements = [];
  var isSameElement = function (other) {
    return other.kind === "method" && other.key === element.key && other.placement === element.placement;
  };
  for (var i = 0; i < elements.length; i++) {
    var element = elements[i];
    var other;
    if (element.kind === "method" && (other = newElements.find(isSameElement))) {
      if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {
        if (_hasDecorators(element) || _hasDecorators(other)) {
          throw new ReferenceError("Duplicated methods (" + element.key + ") can't be decorated.");
        }
        other.descriptor = element.descriptor;
      } else {
        if (_hasDecorators(element)) {
          if (_hasDecorators(other)) {
            throw new ReferenceError("Decorators can't be placed on different accessors with for " + "the same property (" + element.key + ").");
          }
          other.decorators = element.decorators;
        }
        _coalesceGetterSetter(element, other);
      }
    } else {
      newElements.push(element);
    }
  }
  return newElements;
}
function _hasDecorators(element) {
  return element.decorators && element.decorators.length;
}
function _isDataDescriptor(desc) {
  return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);
}
function _optionalCallableProperty(obj, name) {
  var value = obj[name];
  if (value !== undefined && typeof value !== "function") {
    throw new TypeError("Expected '" + name + "' to be a function");
  }
  return value;
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateMethodSet() {
  throw new TypeError("attempted to reassign private method");
}
function _identity(x) {
  return x;
}

/**
 * Return the event type that a listener will receive.
 *
 * For example `EventType<HTMLElement, 'keydown'>` evaluates to `KeyboardEvent`.
 *
 * The event type is extracted from the target's `on${Type}` property (eg.
 * `HTMLElement.onkeydown` here) If there is no such property, the type defaults
 * to `Event`.
 */

/**
 * Utility that provides a way to conveniently remove a set of DOM event
 * listeners when they are no longer needed.
 */
class ListenerCollection$1 {
  constructor() {
    _defineProperty(this, "_listeners", void 0);
    this._listeners = new Map();
  }

  /**
   * Add a listener and return an ID that can be used to remove it later
   */
  add(eventTarget, eventType, listener, options) {
    eventTarget.addEventListener(eventType, listener, options);
    const symbol = Symbol();
    this._listeners.set(symbol, {
      eventTarget,
      eventType,
      // eslint-disable-next-line object-shorthand
      listener: listener
    });
    return symbol;
  }

  /**
   * Remove a specific listener.
   */
  remove(listenerId) {
    const event = this._listeners.get(listenerId);
    if (event) {
      const {
        eventTarget,
        eventType,
        listener
      } = event;
      eventTarget.removeEventListener(eventType, listener);
      this._listeners.delete(listenerId);
    }
  }
  removeAll() {
    this._listeners.forEach(({
      eventTarget,
      eventType,
      listener
    }) => {
      eventTarget.removeEventListener(eventType, listener);
    });
    this._listeners.clear();
  }
}

/**
 * @typedef {import('../helpers/build-thread').Thread} Thread
 */

const THREAD_DIMENSION_DEFAULTS = {
  // When we don't have a real measurement of a thread card's height (yet)
  // from the browser, use this as an approximate value, in pixels.
  defaultHeight: 200,
  // Space above the viewport in pixels which should be considered 'on-screen'
  // when calculating the set of visible threads
  marginAbove: 800,
  // Same as MARGIN_ABOVE but for the space below the viewport
  marginBelow: 800
};

/**
 * Calculate the set of `ThreadCard`s that should be rendered by
 * estimating which of the threads are within or near the viewport.
 *
 * @param {Thread[]} threads - List of threads in the order they appear
 * @param {Map<string, number>} threadHeights - Map of thread ID to measured height
 * @param {number} scrollPos - Vertical scroll offset of scrollable container
 * @param {number} windowHeight -
 *   Height of the visible area of the scrollable container.
 * @param {typeof THREAD_DIMENSION_DEFAULTS} options - Dimensional overrides (in px) for defaults
 */
function calculateVisibleThreads(threads, threadHeights, scrollPos, windowHeight, options = THREAD_DIMENSION_DEFAULTS) {
  const {
    defaultHeight,
    marginAbove,
    marginBelow
  } = options;

  /** @type {Thread[]} */
  const visibleThreads = [];

  // Total height used up by the top-level thread cards
  let totalHeight = 0;
  // Estimated height, in px, of the thread cards above and below the viewport
  let offscreenUpperHeight = 0;
  let offscreenLowerHeight = 0;
  threads.forEach(thread => {
    const threadHeight = threadHeights.get(thread.id) || defaultHeight;
    const threadIsAboveViewport = totalHeight + threadHeight < scrollPos - marginAbove;
    const threadIsVisible = totalHeight < scrollPos + windowHeight + marginBelow;
    if (threadIsAboveViewport) {
      offscreenUpperHeight += threadHeight;
    } else if (threadIsVisible) {
      visibleThreads.push(thread);
    } else {
      // thread is below visible viewport
      offscreenLowerHeight += threadHeight;
    }
    totalHeight += threadHeight;
  });
  return {
    visibleThreads,
    offscreenUpperHeight,
    offscreenLowerHeight
  };
}

/**
 * Obtain the pixel height of the provided DOM element, including
 * top and bottom margins.
 *
 * Note that this function *only* accounts for margins on `element`, not any
 * descendants which may contribute to the effective margin due to CSS "margin
 * collapsing".
 *
 * @param {Element} element - DOM element to measure
 * @return {number|null} - The element's height in pixels
 */
function getElementHeightWithMargins(element) {
  const style = window.getComputedStyle(element);
  // Get the height of the element inside the border-box, excluding
  // top and bottom margins.
  const elementHeight = element.getBoundingClientRect().height;

  // Get the bottom margin of the element. style.margin{Side} will return
  // values of the form 'Npx', from which we extract 'N'.
  const marginHeight = parseFloat(style.marginTop) + parseFloat(style.marginBottom);
  return elementHeight + marginHeight;
}

/**
 * @typedef Listener
 * @prop {EventTarget} eventTarget
 * @prop {string} eventType
 * @prop {(event: Event) => void} listener
 */

/**
 * Return the event type that a listener will receive.
 *
 * For example `EventType<HTMLElement, 'keydown'>` evaluates to `KeyboardEvent`.
 *
 * The event type is extracted from the target's `on${Type}` property (eg.
 * `HTMLElement.onkeydown` here) If there is no such property, the type defaults
 * to `Event`.
 *
 * @template {EventTarget} Target
 * @template {string} Type
 * @typedef {`on${Type}` extends keyof Target ?
 *   Target[`on${Type}`] extends ((...args: any[]) => void)|null ?
 *     Parameters<NonNullable<Target[`on${Type}`]>>[0]
 *  : Event : Event} EventType
 */

/**
 * Utility that provides a way to conveniently remove a set of DOM event
 * listeners when they are no longer needed.
 */
class ListenerCollection {
  constructor() {
    /** @type {Map<Symbol, Listener>} */
    this._listeners = new Map();
  }
  /**
   * Add a listener and return an ID that can be used to remove it later
   *
   * @template {string} Type
   * @template {EventTarget} Target
   * @param {Target} eventTarget
   * @param {Type} eventType
   * @param {(event: EventType<Target, Type>) => void} listener
   * @param {AddEventListenerOptions} [options]
   */


  add(eventTarget, eventType, listener, options) {
    eventTarget.addEventListener(eventType,
    /** @type {EventListener} */
    listener, options);
    const symbol = Symbol();

    this._listeners.set(symbol, {
      eventTarget,
      eventType,
      // eslint-disable-next-line object-shorthand
      listener:
      /** @type {EventListener} */
      listener
    });

    return symbol;
  }
  /**
   * Remove a specific listener.
   *
   * @param {Symbol} listenerId
   */


  remove(listenerId) {
    const event = this._listeners.get(listenerId);

    if (event) {
      const {
        eventTarget,
        eventType,
        listener
      } = event;
      eventTarget.removeEventListener(eventType, listener);

      this._listeners.delete(listenerId);
    }
  }

  removeAll() {
    this._listeners.forEach(({
      eventTarget,
      eventType,
      listener
    }) => {
      eventTarget.removeEventListener(eventType, listener);
    });

    this._listeners.clear();
  }

}

/**
 * @param {HTMLElement & { disabled?: boolean }} element
 */

function isElementDisabled$1(element) {
  return typeof element.disabled === 'boolean' && element.disabled;
}
/** @param {HTMLElement} element */


function isElementVisible$2(element) {
  return element.offsetParent !== null;
}
/**
 * Enable arrow key navigation between interactive descendants of a
 * container element.
 *
 * In addition to moving focus between elements when arrow keys are pressed,
 * this also implements the "roving tabindex" pattern [1] which sets the
 * `tabindex` attribute of elements to control which element gets focus when the
 * user tabs into the container.
 *
 * See [2] for a reference of how keyboard navigation should work in web
 * applications and how it applies to various common widgets.
 *
 * @example
 *   function MyToolbar() {
 *     const container = useRef();
 *
 *     // Enable arrow key navigation between interactive elements in the
 *     // toolbar container.
 *     useArrowKeyNavigation(container);
 *
 *     return (
 *       <div ref={container} role="toolbar">
 *         <button>Bold</bold>
 *         <button>Italic</bold>
 *         <a href="https://example.com/help">Help</a>
 *       </div>
 *     )
 *   }
 *
 * [1] https://www.w3.org/TR/wai-aria-practices/#kbd_roving_tabindex
 * [2] https://www.w3.org/TR/wai-aria-practices/#keyboard
 *
 * @param {import('preact').RefObject<HTMLElement>} containerRef
 * @param {object} options
 *   @param {boolean} [options.autofocus] - Whether to focus the first element
 *     in the set of matching elements when the component is mounted
 *   @param {boolean} [options.horizontal] - Enable navigating elements using left/right arrow keys
 *   @param {boolean} [options.vertical] - Enable navigating elements using up/down arrow keys
 *   @param {string} [options.selector] - CSS selector which specifies the
 *     elements that navigation moves between
 */


function useArrowKeyNavigation$1(containerRef, {
  autofocus = false,
  horizontal = true,
  vertical = true,
  selector = 'a,button'
} = {}) {
  h(() => {
    if (!containerRef.current) {
      throw new Error('Container ref not set');
    }

    const container = containerRef.current;

    const getNavigableElements = () => {
      const elements =
      /** @type {HTMLElement[]} */
      Array.from(container.querySelectorAll(selector));
      return elements.filter(el => isElementVisible$2(el) && !isElementDisabled$1(el));
    };
    /**
     * Update the `tabindex` attribute of navigable elements.
     *
     * Exactly one element will have `tabindex=0` and all others will have
     * `tabindex=1`.
     *
     * @param {HTMLElement[]} elements
     * @param {number} currentIndex - Index of element in `elements` to make current.
     *   Defaults to the current element if there is one, or the first element
     *   otherwise.
     * @param {boolean} setFocus - Whether to focus the current element
     */


    const updateTabIndexes = (elements = getNavigableElements(), currentIndex = -1, setFocus = false) => {
      if (currentIndex < 0) {
        currentIndex = elements.findIndex(el => el.tabIndex === 0);

        if (currentIndex < 0) {
          currentIndex = 0;
        }
      }

      for (let [index, element] of elements.entries()) {
        element.tabIndex = index === currentIndex ? 0 : -1;

        if (index === currentIndex && setFocus) {
          element.focus();
        }
      }
    };
    /** @param {KeyboardEvent} event */


    const onKeyDown = event => {
      const elements = getNavigableElements();
      let currentIndex = elements.findIndex(item => item.tabIndex === 0);
      let handled = false;

      if (horizontal && event.key === 'ArrowLeft' || vertical && event.key === 'ArrowUp') {
        if (currentIndex === 0) {
          currentIndex = elements.length - 1;
        } else {
          --currentIndex;
        }

        handled = true;
      } else if (horizontal && event.key === 'ArrowRight' || vertical && event.key === 'ArrowDown') {
        if (currentIndex === elements.length - 1) {
          currentIndex = 0;
        } else {
          ++currentIndex;
        }

        handled = true;
      } else if (event.key === 'Home') {
        currentIndex = 0;
        handled = true;
      } else if (event.key === 'End') {
        currentIndex = elements.length - 1;
        handled = true;
      }

      if (!handled) {
        return;
      }

      updateTabIndexes(elements, currentIndex, true);
      event.preventDefault();
      event.stopPropagation();
    };

    updateTabIndexes(getNavigableElements(), 0, autofocus);
    const listeners = new ListenerCollection(); // Set an element as current when it gains focus. In Safari this event
    // may not be received if the element immediately loses focus after it
    // is triggered.

    listeners.add(container, 'focusin', event => {
      const elements = getNavigableElements();
      const targetIndex = elements.indexOf(
      /** @type {HTMLElement} */
      event.target);

      if (targetIndex >= 0) {
        updateTabIndexes(elements, targetIndex);
      }
    });
    listeners.add(container, 'keydown',
    /** @type {EventListener} */
    onKeyDown); // Update the tab indexes of elements as they are added, removed, enabled
    // or disabled.

    const mo = new MutationObserver(() => {
      updateTabIndexes();
    });
    mo.observe(container, {
      subtree: true,
      attributes: true,
      attributeFilter: ['disabled'],
      childList: true
    });
    return () => {
      listeners.removeAll();
      mo.disconnect();
    };
  }, [autofocus, containerRef, horizontal, selector, vertical]);
}

/**
 * @template T
 * @typedef {import('preact').RefObject<T>} RefObject
 */

/**
 * @template T
 * @typedef {import('preact').Ref<T>} Ref
 */

/**
 * Object ref which synchronizes its value to another ref.
 *
 * @template T
 * @implements {RefObject<T>}
 */

class SyncedRef {
  /**
   * @param {Ref<T>} [target] - Initial target for this ref to synchronize to.
   *   This is not called/set until the {@link current} property of the
   *   SyncedRef is set. This makes the target behave close to how it would
   *   if used in place of the SyncedRef.
   */
  constructor(target) {
    /** @type {Ref<T>|undefined} */
    this._target = target;
    /** @type {T|null} */

    this._value = null;
  }

  get current() {
    return this._value;
  }
  /** @param {T|null} value */


  set current(value) {
    this._value = value;

    this._updateTarget();
  }

  get target() {
    return this._target;
  }
  /** @param {Ref<T>|undefined} target */


  set target(target) {
    if (target === this._target) {
      return;
    }

    this._target = target; // If the target changes after the initial render, we currently synchronize
    // the value immediately. This is different than what happens if the target
    // were passed to an element directly, as it would be updated only after the
    // render.

    this._updateTarget();
  }

  _updateTarget() {
    const value = this._value;

    if (typeof this._target === 'function') {
      this._target(value);
    } else if (this._target) {
      this._target.current = value;
    }
  }

}
/**
 * Return an object ref which synchronizes its value to another "target" ref.
 *
 * This is useful when a component needs an object ref for an element for
 * internal use, but also wants to allow the caller to get a ref for the same
 * element.
 *
 * The target ref can be either a callback or an object.
 *
 * @example
 *   function Widget({ elementRef }) {
 *     const ref = useSyncedRef(elementRef);
 *
 *     useEffect(() => {
 *       ref.current.focus();
 *     }, []);
 *
 *     return <input ref={ref}>...</input>;
 *   }
 *
 * @template T
 * @param {import('preact').Ref<T>} [targetRef]
 * @return {import('preact').RefObject<T>}
 */


function useSyncedRef(targetRef) {
  const container = _$1(new SyncedRef(targetRef));
  container.current.target = targetRef;
  return container.current;
}

var _jsxFileName$37 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Annotate.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from annotate.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function AnnotateIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M15 0c.27 0 .505.099.703.297A.961.961 0 0 1 16 1v15l-4-3H1a.974.974 0 0 1-.703-.29A.953.953 0 0 1 0 12V1A.96.96 0 0 1 .29.29.966.966 0 0 1 1 0h14zM7 3l-.469.063c-.312.041-.656.187-1.031.437-.375.25-.719.646-1.031 1.188C4.156 5.229 4 6 4 7l.002.063.006.062a.896.896 0 0 1 .008.11l-.002.074-.006.066a1.447 1.447 0 0 0 .43 1.188C4.729 8.854 5.082 9 5.5 9c.417 0 .77-.146 1.063-.438C6.854 8.271 7 7.918 7 7.5c0-.417-.146-.77-.438-1.063A1.447 1.447 0 0 0 5.5 6a1.467 1.467 0 0 0-.422.062c.177-1.03.542-1.632 1.094-1.804L7 4V3zm5 0-.469.063c-.312.041-.656.187-1.031.437-.375.25-.719.646-1.031 1.188C9.156 5.229 9 6 9 7l.002.063.006.062a.896.896 0 0 1 .008.11l-.002.074-.006.066a1.447 1.447 0 0 0 .43 1.188c.291.291.645.437 1.062.437.417 0 .77-.146 1.063-.438.291-.291.437-.645.437-1.062 0-.417-.146-.77-.438-1.063A1.447 1.447 0 0 0 10.5 6a1.467 1.467 0 0 0-.422.062c.177-1.03.542-1.632 1.094-1.804L12 4V3z"
    }, void 0, false, {
      fileName: _jsxFileName$37,
      lineNumber: 17,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$37,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$36 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/AnnotateAlt.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from annotate-alt.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function AnnotateAltIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      children: [o("path", {
        fill: "none",
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$36,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        fill: "currentColor",
        d: "M14 0a2 2 0 0 1 2 2v13a1 1 0 0 1-1.555.832l-4.262-1.757A1 1 0 0 0 9.802 14H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h12zm-2.109 3.5h-.484l-.14.006-.122.018a.684.684 0 0 0-.2.071l-.076.054-.108.1-.097.1-1.632 1.999-.091.12-.084.129a2.56 2.56 0 0 0-.291.722l-.03.142-.027.218-.009.223v2.646l.01.086.027.08a.537.537 0 0 0 .236.236l.067.028.07.016.074.006h2.907l.074-.006.094-.024a.516.516 0 0 0 .169-.108.525.525 0 0 0 .082-.096l.029-.051.027-.081.01-.086V7.336l-.006-.073-.018-.068a.436.436 0 0 0-.124-.178.549.549 0 0 0-.103-.074l-.055-.026-.087-.024-.092-.009h-.579l-.057-.006-.054-.017a.307.307 0 0 1-.096-.07.175.175 0 0 1-.045-.078l-.004-.04.01-.043.022-.043 1.311-2.227.047-.09.037-.106a.492.492 0 0 0-.06-.394.531.531 0 0 0-.255-.22l-.084-.028-.092-.016-.1-.006zm-5.924 0h-.424l-.121.006-.108.018a.552.552 0 0 0-.174.071l-.067.054-.095.1-.084.1-1.429 1.999-.08.12-.096.174a2.798 2.798 0 0 0-.232.677l-.025.142-.024.218L3 7.402v2.646l.008.086.024.08a.486.486 0 0 0 .097.148.468.468 0 0 0 .11.088l.058.028.062.016.065.006h2.543l.065-.006.082-.024a.513.513 0 0 0 .22-.204l.025-.051.024-.081.008-.086V7.336l-.005-.073-.023-.09a.487.487 0 0 0-.191-.23l-.048-.026-.076-.024-.08-.009H5.46l-.05-.006-.047-.017a.273.273 0 0 1-.084-.07.182.182 0 0 1-.04-.078l-.003-.04.008-.043.02-.043L6.411 4.36l.04-.09.033-.106a.553.553 0 0 0-.053-.394.49.49 0 0 0-.222-.22l-.074-.028-.08-.016-.089-.006z"
      }, void 0, false, {
        fileName: _jsxFileName$36,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$36,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$36,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$35 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/ArrowDown.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from arrow-down.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ArrowDownIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$35,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "m12 9-4 4-4-4m4 3V3v9z"
      }, void 0, false, {
        fileName: _jsxFileName$35,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$35,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$35,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$34 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/ArrowLeft.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from arrow-left.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ArrowLeftIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$34,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M7 12 3 8l4-4M4 8h9-9z"
      }, void 0, false, {
        fileName: _jsxFileName$34,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$34,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$34,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$33 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/ArrowRight.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from arrow-right.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ArrowRightIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$33,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "m9 4 4 4-4 4m3-4H3h9z"
      }, void 0, false, {
        fileName: _jsxFileName$33,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$33,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$33,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$32 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/ArrowUp.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from arrow-up.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ArrowUpIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$32,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "m4 7 4-4 4 4M8 4v9-9z"
      }, void 0, false, {
        fileName: _jsxFileName$32,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$32,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$32,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$31 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Bookmark.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from bookmark.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function BookmarkIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$31,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M13 1v14l-5-4-5 4V1z"
      }, void 0, false, {
        fileName: _jsxFileName$31,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$31,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$31,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$30 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/BookmarkFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from bookmark-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function BookmarkFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      children: [o("path", {
        fill: "none",
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$30,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        fill: "currentColor",
        d: "M13 0a1 1 0 0 1 .993.883L14 1v14a1 1 0 0 1-1.534.846l-.09-.065L8 12.28l-4.375 3.5a1.001 1.001 0 0 1-1.6-.556l-.02-.112L2 15V1a1 1 0 0 1 .883-.993L3 0h10z"
      }, void 0, false, {
        fileName: _jsxFileName$30,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$30,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$30,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2$ = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Cancel.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from cancel.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CancelIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2$,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "m8 8 3.536-3.536L8 8 4.464 4.464 8 8zm0 0-3.536 3.536L8 8l3.536 3.536L8 8z"
      }, void 0, false, {
        fileName: _jsxFileName$2$,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2$,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2$,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2_ = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/CaretDown.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from caret-down.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CaretDownIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2_,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "m12 6-4 4-4-4"
      }, void 0, false, {
        fileName: _jsxFileName$2_,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2_,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2_,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2Z = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/CaretLeft.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from caret-left.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CaretLeftIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2Z,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M10 12 6 8l4-4"
      }, void 0, false, {
        fileName: _jsxFileName$2Z,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2Z,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2Z,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2Y = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/CaretRight.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from caret-right.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CaretRightIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2Y,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "m6 4 4 4-4 4"
      }, void 0, false, {
        fileName: _jsxFileName$2Y,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2Y,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2Y,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2X = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/CaretUp.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from caret-up.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CaretUpIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2X,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "m4 10 4-4 4 4"
      }, void 0, false, {
        fileName: _jsxFileName$2X,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2X,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2X,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2W = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Caution.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from caution.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CautionIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": "2.5",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    ...props,
    children: o("path", {
      d: "M10.29 3.86 1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0zM12 9v4M12 17h.01"
    }, void 0, false, {
      fileName: _jsxFileName$2W,
      lineNumber: 22,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2W,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2V = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/CcStd.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from cc-std.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CcStdIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      children: [o("path", {
        fill: "none",
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2V,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        fill: "currentColor",
        d: "M7.985 0c2.238 0 4.143.781 5.715 2.343a7.694 7.694 0 0 1 1.714 2.579C15.804 5.888 16 6.914 16 8a8.164 8.164 0 0 1-.579 3.078 7.344 7.344 0 0 1-1.707 2.536 8.222 8.222 0 0 1-2.657 1.772c-.99.41-2.014.614-3.071.614a7.775 7.775 0 0 1-3.036-.607 8.047 8.047 0 0 1-2.6-1.757A7.846 7.846 0 0 1 0 8c0-1.057.202-2.074.607-3.05a8.033 8.033 0 0 1 1.764-2.62C3.895.777 5.766 0 7.985 0zm.03 1.443c-1.83 0-3.367.638-4.615 1.914a6.878 6.878 0 0 0-1.45 2.15A6.301 6.301 0 0 0 1.443 8c0 .858.168 1.684.507 2.479a6.627 6.627 0 0 0 1.45 2.129 6.593 6.593 0 0 0 2.129 1.428c.79.329 1.619.493 2.485.493.857 0 1.688-.166 2.494-.5a6.91 6.91 0 0 0 2.178-1.442c1.247-1.22 1.871-2.748 1.871-4.586a6.57 6.57 0 0 0-.486-2.515 6.397 6.397 0 0 0-1.413-2.114C11.37 2.086 9.824 1.443 8.014 1.443zm-.1 5.229-1.073.557c-.114-.238-.254-.405-.42-.5a.95.95 0 0 0-.465-.143c-.714 0-1.072.472-1.072 1.415 0 .428.09.77.271 1.028.181.257.448.386.8.386.467 0 .796-.229.987-.686l.985.5a2.35 2.35 0 0 1-2.1 1.257c-.714 0-1.29-.218-1.729-.657-.438-.438-.657-1.047-.657-1.828 0-.762.222-1.367.665-1.814.442-.448 1.002-.672 1.678-.672.991 0 1.7.385 2.13 1.157zm4.613 0-1.057.557c-.114-.238-.255-.405-.421-.5a.972.972 0 0 0-.479-.143c-.714 0-1.072.472-1.072 1.415 0 .428.091.77.272 1.028.18.257.447.386.8.386.466 0 .795-.229.985-.686l1 .5c-.218.39-.514.698-.885.922a2.308 2.308 0 0 1-1.214.335c-.724 0-1.302-.218-1.735-.657-.434-.438-.65-1.047-.65-1.828 0-.762.22-1.367.664-1.814.442-.448 1.002-.672 1.678-.672.99 0 1.696.385 2.114 1.157z"
      }, void 0, false, {
        fileName: _jsxFileName$2V,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2V,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2V,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2U = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/CcStdFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from cc-std-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CcStdFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M7.985 0c2.238 0 4.143.781 5.715 2.343a7.694 7.694 0 0 1 1.714 2.579C15.804 5.888 16 6.914 16 8a8.164 8.164 0 0 1-.579 3.078 7.344 7.344 0 0 1-1.707 2.536 8.222 8.222 0 0 1-2.657 1.772c-.99.41-2.014.614-3.071.614a7.775 7.775 0 0 1-3.036-.607 8.047 8.047 0 0 1-2.6-1.757A7.846 7.846 0 0 1 0 8c0-1.057.202-2.074.607-3.05A8.033 8.033 0 0 1 2.371 2.33C3.895.777 5.766 0 7.985 0Zm-2.2 5.515c-.676 0-1.236.224-1.678.672-.443.447-.665 1.052-.665 1.814 0 .78.22 1.39.657 1.828.438.439 1.015.657 1.73.657.447 0 .857-.111 1.228-.335.318-.192.577-.445.776-.76l.095-.162-.985-.5c-.191.457-.52.686-.986.686-.353 0-.62-.129-.8-.386-.181-.257-.272-.6-.272-1.028 0-.943.358-1.415 1.072-1.415a.991.991 0 0 1 .814.509l.071.134 1.072-.557C7.485 5.9 6.776 5.515 5.785 5.515Zm4.629 0c-.676 0-1.236.224-1.678.672C8.292 6.634 8.07 7.239 8.07 8c0 .78.217 1.39.65 1.828.434.439 1.012.657 1.736.657.438 0 .843-.111 1.214-.335.31-.187.566-.431.77-.733l.115-.189-1-.5c-.19.457-.519.686-.985.686-.353 0-.62-.129-.8-.386-.18-.257-.272-.6-.272-1.028 0-.943.358-1.415 1.072-1.415a.992.992 0 0 1 .828.509l.072.134 1.057-.557c-.418-.772-1.124-1.157-2.114-1.157Z"
    }, void 0, false, {
      fileName: _jsxFileName$2U,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2U,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2T = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/CcZero.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from cc-zero.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CcZeroIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      children: [o("path", {
        fill: "none",
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2T,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        fill: "currentColor",
        d: "M7.983 0c2.238 0 4.148.78 5.72 2.342a7.662 7.662 0 0 1 1.715 2.582c.39.962.582 1.99.582 3.076a8.13 8.13 0 0 1-.583 3.087 7.262 7.262 0 0 1-1.703 2.526 8.213 8.213 0 0 1-2.655 1.77c-.99.41-2.018.617-3.076.617a7.902 7.902 0 0 1-3.042-.6 8.301 8.301 0 0 1-2.6-1.759A8.087 8.087 0 0 1 .6 11.042 7.84 7.84 0 0 1 0 8c0-1.057.2-2.07.6-3.042a8.12 8.12 0 0 1 1.77-2.633C3.893.772 5.764 0 7.983 0zm.034 1.44c-1.829 0-3.369.64-4.616 1.915a6.962 6.962 0 0 0-1.457 2.157 6.388 6.388 0 0 0 0 4.969 6.83 6.83 0 0 0 3.585 3.558c.79.324 1.62.487 2.488.487.857 0 1.681-.165 2.482-.498a6.88 6.88 0 0 0 2.184-1.446C13.931 11.364 14.56 9.838 14.56 8a6.57 6.57 0 0 0-.487-2.515 6.418 6.418 0 0 0-1.418-2.118C11.37 2.081 9.826 1.44 8.017 1.44zM8 3.395c2.641 0 3.305 2.492 3.305 4.605 0 2.113-.664 4.605-3.305 4.605S4.694 10.113 4.694 8l.007-.355c.073-2.027.804-4.25 3.299-4.25zm1.316 3.227L7.35 10.017c-.274.412-.083.645.219.774l.135.044c.091.022.19.034.297.034 1.357 0 1.422-1.938 1.422-2.869l-.007-.409a7.282 7.282 0 0 0-.06-.72l-.04-.25zM8 5.132c-1.258 0-1.406 1.66-1.421 2.646L6.577 8c0 .24.005.544.035.865l.027.244 1.759-3.232c.182-.316.09-.542-.101-.706A1.222 1.222 0 0 0 8 5.13z"
      }, void 0, false, {
        fileName: _jsxFileName$2T,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2T,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2T,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2S = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/CcZeroFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from cc-zero-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CcZeroFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M7.983 0c2.238 0 4.148.78 5.72 2.342a7.662 7.662 0 0 1 1.715 2.582c.39.962.582 1.99.582 3.076a8.13 8.13 0 0 1-.583 3.087 7.262 7.262 0 0 1-1.703 2.526 8.213 8.213 0 0 1-2.655 1.77c-.99.41-2.018.617-3.076.617a7.902 7.902 0 0 1-3.042-.6 8.301 8.301 0 0 1-2.6-1.759A8.087 8.087 0 0 1 .6 11.042 7.84 7.84 0 0 1 0 8c0-1.057.2-2.07.6-3.042a8.12 8.12 0 0 1 1.77-2.633C3.893.772 5.764 0 7.983 0ZM8 3.395c-2.419 0-3.18 2.09-3.29 4.065l-.01.185L4.695 8l.007.355.02.36c.145 1.921.931 3.89 3.279 3.89 2.641 0 3.305-2.492 3.305-4.605 0-2.113-.664-4.605-3.305-4.605Zm1.316 3.227.04.249c.024.166.039.331.049.49l.011.23.007.516-.008.363-.015.267-.026.279-.04.283c-.136.801-.478 1.57-1.333 1.57a1.31 1.31 0 0 1-.204-.015l-.093-.02-.135-.043c-.28-.12-.463-.327-.274-.682l.056-.092 1.965-3.395ZM8 5.132c.107 0 .205.016.297.039.17.146.261.34.152.604l-.051.101-1.76 3.233-.026-.244a8.691 8.691 0 0 1-.034-.674v-.413l.007-.249.015-.266.026-.279.04-.283c.136-.801.479-1.57 1.334-1.57Z"
    }, void 0, false, {
      fileName: _jsxFileName$2S,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2S,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2R = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Check.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from check.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CheckIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2R,
        lineNumber: 18,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M13 3 6 13 3 8"
      }, void 0, false, {
        fileName: _jsxFileName$2R,
        lineNumber: 19,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2R,
      lineNumber: 17,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2R,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2Q = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Checkbox.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from checkbox.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CheckboxIcon(props) {
  return o("svg", {
    width: "16",
    height: "16",
    viewBox: "-4 -4 39 39",
    "aria-hidden": "true",
    ...props,
    children: [o("rect", {
      class: "hyp-svg-checkbox--background",
      width: "35",
      height: "35",
      x: "-2",
      y: "-2",
      stroke: "currentColor",
      fill: "none",
      "stroke-width": "3",
      rx: "5",
      ry: "5"
    }, void 0, false, {
      fileName: _jsxFileName$2Q,
      lineNumber: 17,
      columnNumber: 7
    }, this), o("path", {
      class: "hyp-svg-checkbox--checkmark",
      stroke: "transparent",
      "stroke-width": "5",
      fill: "none",
      d: "m4 14 8 9L28 5"
    }, void 0, false, {
      fileName: _jsxFileName$2Q,
      lineNumber: 29,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$2Q,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2P = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/CheckboxChecked.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from checkbox-checked.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CheckboxCheckedIcon(props) {
  return o("svg", {
    width: "16",
    height: "16",
    viewBox: "-4 -4 39 39",
    "aria-hidden": "true",
    ...props,
    children: [o("rect", {
      width: "35",
      height: "35",
      x: "-2",
      y: "-2",
      stroke: "currentColor",
      fill: "none",
      "stroke-width": "3",
      rx: "5",
      ry: "5"
    }, void 0, false, {
      fileName: _jsxFileName$2P,
      lineNumber: 17,
      columnNumber: 7
    }, this), o("path", {
      stroke: "currentColor",
      "stroke-width": "5",
      fill: "none",
      d: "m4 14 8 9L28 5"
    }, void 0, false, {
      fileName: _jsxFileName$2P,
      lineNumber: 28,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$2P,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2O = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/CheckboxOutline.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from checkbox-outline.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CheckboxOutlineIcon(props) {
  return o("svg", {
    width: "16",
    height: "16",
    viewBox: "-4 -4 39 39",
    "aria-hidden": "true",
    ...props,
    children: o("rect", {
      width: "35",
      height: "35",
      x: "-2",
      y: "-2",
      stroke: "currentColor",
      fill: "none",
      "stroke-width": "3",
      rx: "5",
      ry: "5"
    }, void 0, false, {
      fileName: _jsxFileName$2O,
      lineNumber: 17,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2O,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2N = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Collapse.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from collapse.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CollapseIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2N,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "m5 11-4 4 4-4zm-3-1h4v4m9-13-4 4 4-4zm-1 5h-4V2"
      }, void 0, false, {
        fileName: _jsxFileName$2N,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2N,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2N,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2M = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Contrast.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from contrast.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ContrastIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2M,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M8 1C4.5 1 1 4.5 1 8s3.5 7 7 7 7-3.5 7-7-3.5-7-7-7zM7 2v12M6 2v12M4 3v10M2 5v6"
      }, void 0, false, {
        fileName: _jsxFileName$2M,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2M,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2M,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2L = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Copy.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from copy.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CopyIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2L,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M9 15H1V5h3m11-4v10H7V1h8z"
      }, void 0, false, {
        fileName: _jsxFileName$2L,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2L,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2L,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2K = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/CopyFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from copy-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function CopyFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M1 16a1 1 0 0 1-.993-.883L0 15V5a1 1 0 0 1 .883-.993L1 4h3a1 1 0 0 1 1 1v8h4a1 1 0 0 1 1 1v1a1 1 0 0 1-.883.993L9 16H1ZM15 0a1 1 0 0 1 .993.883L16 1v10a1 1 0 0 1-.883.993L15 12H7a1 1 0 0 1-.993-.883L6 11V1a1 1 0 0 1 .883-.993L7 0h8Z"
    }, void 0, false, {
      fileName: _jsxFileName$2K,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2K,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2J = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Edit.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from edit.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function EditIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2J,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "m11 4 1 1-9 9-2 1 1-2 9-9zm3-3 1 1-1 1-1-1 1-1z"
      }, void 0, false, {
        fileName: _jsxFileName$2J,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2J,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2J,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2I = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/EditorLatex.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from editor-latex.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function EditorLatexIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      children: [o("path", {
        fill: "none",
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2I,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        fill: "currentColor",
        d: "M13.392 16a.827.827 0 0 0 .423-.108c.123-.073.185-.155.185-.248v-1.778c0-.099-.062-.183-.185-.252a.848.848 0 0 0-.423-.104H6.85c-.138 0-.227-.028-.267-.083-.04-.055-.04-.105 0-.152l5.533-5.101c.158-.14.223-.265.193-.378a.755.755 0 0 0-.193-.325L6.88 2.707c-.04-.046-.042-.094-.007-.143.034-.05.13-.074.289-.074h6.17a.782.782 0 0 0 .416-.108c.119-.073.178-.155.178-.248V.356c0-.093-.06-.175-.178-.248A.782.782 0 0 0 13.333 0H2.905c-.158 0-.3.036-.423.108-.124.073-.185.155-.185.248v1.943a.5.5 0 0 0 .11.326l.171.204 5.31 4.815a.34.34 0 0 1 .075.178.221.221 0 0 1-.074.195l-5.622 5.154c-.04.047-.094.113-.163.2A.512.512 0 0 0 2 13.7v1.943c0 .093.062.175.185.248a.822.822 0 0 0 .423.108h10.784z"
      }, void 0, false, {
        fileName: _jsxFileName$2I,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2I,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2I,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2H = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/EditorQuote.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from editor-quote.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function EditorQuoteIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      children: [o("path", {
        fill: "none",
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2H,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        fill: "currentColor",
        d: "M2.701 14c.38 0 .659-.085.837-.255.177-.17.328-.343.45-.52l2.408-3.25c.246-.328.445-.725.598-1.19a4.69 4.69 0 0 0 .23-1.475V2.775a.752.752 0 0 0-.23-.539A.713.713 0 0 0 6.47 2H1.947a.713.713 0 0 0-.524.236.752.752 0 0 0-.23.539v4.649c0 .214.077.396.23.548a.726.726 0 0 0 .524.226h.901c.123 0 .23.054.322.161.092.107.101.224.028.35l-2.041 3.817c-.196.365-.208.702-.037 1.011.172.309.447.463.827.463h.754zm7.795 0c.367 0 .64-.085.818-.255.178-.17.328-.343.45-.52l2.409-3.25c.257-.328.46-.725.606-1.19A4.87 4.87 0 0 0 15 7.31V2.775a.752.752 0 0 0-.23-.539.713.713 0 0 0-.524-.236H9.742a.703.703 0 0 0-.533.236.767.767 0 0 0-.22.539v4.649a.74.74 0 0 0 .23.548.726.726 0 0 0 .523.226h.9c.123 0 .228.054.313.161.086.107.092.224.019.35L8.95 12.526c-.208.365-.223.702-.045 1.011.177.309.456.463.836.463h.754z"
      }, void 0, false, {
        fileName: _jsxFileName$2H,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2H,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2H,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2G = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/EditorTextBold.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from editor-text-bold.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function EditorTextBoldIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      children: [o("path", {
        fill: "none",
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2G,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        fill: "currentColor",
        d: "M8.661 16c.805 0 1.536-.117 2.193-.351a4.953 4.953 0 0 0 1.69-.993c.47-.428.831-.947 1.081-1.557s.375-1.287.375-2.03c0-.29-.038-.588-.114-.893a4.123 4.123 0 0 0-.325-.87 3.937 3.937 0 0 0-.495-.754 4.412 4.412 0 0 0-.604-.597c-.17-.126-.17-.264 0-.412.381-.335.699-.772.953-1.311.254-.54.382-1.062.382-1.568 0-.64-.132-1.244-.394-1.813a4.628 4.628 0 0 0-1.081-1.484c-.458-.42-1-.753-1.627-.999A5.531 5.531 0 0 0 8.66 0H2.52a.534.534 0 0 0-.362.14A.415.415 0 0 0 2 .456v15.086c0 .119.053.225.159.318a.534.534 0 0 0 .362.139h6.14zm-.127-9.852H5.826c-.17 0-.254-.075-.254-.223V3.437c0-.157.085-.235.254-.235h2.708c.45 0 .847.145 1.195.435.347.29.521.633.521 1.027 0 .394-.174.74-.521 1.038a1.784 1.784 0 0 1-1.195.446zm0 6.65H5.826c-.17 0-.254-.075-.254-.223v-2.99c0-.157.085-.235.254-.235h2.708c.56 0 1.004.177 1.335.53.33.353.495.75.495 1.188 0 .454-.165.856-.495 1.205-.33.35-.776.525-1.335.525z"
      }, void 0, false, {
        fileName: _jsxFileName$2G,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2G,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2G,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2F = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/EditorTextItalic.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from editor-text-italic.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function EditorTextItalicIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      children: [o("path", {
        fill: "none",
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2F,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        fill: "currentColor",
        d: "M10.61 16c.12 0 .23-.046.329-.14a.633.633 0 0 0 .191-.317l.457-2.176a.348.348 0 0 0-.064-.313.336.336 0 0 0-.276-.133H8.845c-.142-.008-.198-.086-.17-.235l1.892-9.372c.035-.149.124-.223.266-.223H13a.49.49 0 0 0 .335-.14.62.62 0 0 0 .196-.318L13.99.457a.542.542 0 0 0 .011-.1.337.337 0 0 0-.085-.223A.336.336 0 0 0 13.64 0H5.805a.49.49 0 0 0-.335.14.62.62 0 0 0-.196.317l-.457 2.176a.353.353 0 0 0 .069.318c.074.093.168.14.281.14h2.18c.141 0 .198.074.17.223l-1.893 9.372c-.028.156-.113.235-.255.235H2.967a.489.489 0 0 0-.324.133.59.59 0 0 0-.197.313l-.435 2.176a.542.542 0 0 0-.011.1c0 .082.025.156.074.223.071.09.16.134.266.134h8.27z"
      }, void 0, false, {
        fileName: _jsxFileName$2F,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2F,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2F,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2E = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Ellipsis.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from ellipsis.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function EllipsisIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2E,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M2 9a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm6 0a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm6 0a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"
      }, void 0, false, {
        fileName: _jsxFileName$2E,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2E,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2E,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2D = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Email.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from email.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function EmailIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2D,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M1 3v10h14V3H1zm0 0 7 6 7-6H1z"
      }, void 0, false, {
        fileName: _jsxFileName$2D,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2D,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2D,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2C = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/EmailFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from email-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function EmailFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M.031 3.647 7.7 9.4l.08.049a.5.5 0 0 0 .44 0L8.3 9.4l7.67-5.752.022.174L16 4v8a2 2 0 0 1-1.85 1.995L14 14H2a2 2 0 0 1-1.995-1.85L0 12V4c0-.12.01-.238.031-.353ZM14 2c.618 0 1.17.28 1.538.721L8 8.375.462 2.721c.33-.397.811-.663 1.355-.713L2 2h12Z"
    }, void 0, false, {
      fileName: _jsxFileName$2C,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2C,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2B = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Expand.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from expand.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ExpandIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2B,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "m2 14 4-4-4 4zm3 1H1v-4m13-9-4 4 4-4zm-3-1h4v4"
      }, void 0, false, {
        fileName: _jsxFileName$2B,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2B,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2B,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2A = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/External.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from external.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ExternalIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2A,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M7 3h6v6m-1-5-9 9 9-9z"
      }, void 0, false, {
        fileName: _jsxFileName$2A,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2A,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2A,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2z = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/FileCode.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from file-code.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FileCodeIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M12.333 0a.5.5 0 0 1 .352.144l2.167 2.143a.5.5 0 0 1 .148.356V15.5a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5h10.833ZM11 1H2v14h12V4h-2.5a.5.5 0 0 1-.5-.5V1ZM6.53 5.47a.75.75 0 0 1 .073.976l-.073.084L5.061 8l1.47 1.47a.75.75 0 0 1 .072.976l-.073.084a.75.75 0 0 1-.976.073l-.084-.073-2-2a.75.75 0 0 1-.073-.976l.073-.084 2-2a.75.75 0 0 1 1.06 0Zm3.916-.073.084.073 2 2 .073.084a.75.75 0 0 1 .007.882l-.08.094-2 2-.084.073a.75.75 0 0 1-.882.007l-.094-.08-.073-.084a.75.75 0 0 1-.007-.882l.08-.094L10.939 8l-1.47-1.47-.072-.084a.75.75 0 0 1 1.05-1.049Z"
    }, void 0, false, {
      fileName: _jsxFileName$2z,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2z,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2y = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/FileCodeFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from file-code-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FileCodeFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M11 0v3.5a.5.5 0 0 0 .41.492L11.5 4H15v11.5a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5H11ZM6.53 5.47a.75.75 0 0 0-1.06 0l-2 2-.073.084a.75.75 0 0 0 .073.976l2 2 .084.073a.75.75 0 0 0 .976-.073l.073-.084a.75.75 0 0 0-.073-.976L5.061 8l1.47-1.47.072-.084a.75.75 0 0 0-.073-.976Zm3.916-.073a.75.75 0 0 0-1.049 1.05l.073.083L10.939 8l-1.47 1.47-.08.094a.75.75 0 0 0 .008.882l.073.084.094.08a.75.75 0 0 0 .882-.007l.084-.073 2-2 .08-.094a.75.75 0 0 0-.007-.882l-.073-.084-2-2ZM12.333 0a.5.5 0 0 1 .352.144l2.167 2.143a.5.5 0 0 1 .148.356V3h-2.75a.25.25 0 0 1-.25-.25V0h.333Z"
    }, void 0, false, {
      fileName: _jsxFileName$2y,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2y,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2x = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/FileGeneric.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from file-generic.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FileGenericIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M12.333 0a.5.5 0 0 1 .352.144l2.167 2.143a.5.5 0 0 1 .148.356V15.5a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5h10.833ZM11 1H2v14h12V4h-2.5a.5.5 0 0 1-.5-.5V1Zm-3.75 9.5a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5Zm4-2.75a.75.75 0 1 1 0 1.5h-6.5a.75.75 0 0 1 0-1.5h6.5Zm0-2.75a.75.75 0 1 1 0 1.5h-6.5a.75.75 0 0 1 0-1.5h6.5Z"
    }, void 0, false, {
      fileName: _jsxFileName$2x,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2x,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2w = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/FileGenericFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from file-generic-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FileGenericFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M11 0v3.5a.5.5 0 0 0 .41.492L11.5 4H15v11.5a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5H11ZM7.25 10.5h-2.5a.75.75 0 1 0 0 1.5h2.5a.75.75 0 1 0 0-1.5Zm4-2.75h-6.5a.75.75 0 0 0 0 1.5h6.5a.75.75 0 1 0 0-1.5Zm0-2.75h-6.5a.75.75 0 0 0 0 1.5h6.5a.75.75 0 1 0 0-1.5Zm1.083-5a.5.5 0 0 1 .352.144l2.167 2.143a.5.5 0 0 1 .148.356V3h-2.75a.25.25 0 0 1-.25-.25V0h.333Z"
    }, void 0, false, {
      fileName: _jsxFileName$2w,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2w,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2v = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/FileImage.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from file-image.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FileImageIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M12.333 0a.5.5 0 0 1 .352.144l2.167 2.143a.5.5 0 0 1 .148.356V15.5a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5h10.833ZM11 1H2v14h12V4h-2.5a.5.5 0 0 1-.5-.5V1ZM9.541 5.122l.055.069 3.333 5.143a.432.432 0 0 1-.266.658l-.08.008H9.23a.931.931 0 0 0-.076-.98l-1.79-2.456 1.54-2.373a.41.41 0 0 1 .637-.069ZM6.19 6.818l.061.068 2.5 3.428c.19.261.038.625-.257.68L8.417 11h-5c-.317 0-.508-.344-.373-.619l.04-.067 2.5-3.428a.41.41 0 0 1 .605-.068Z"
    }, void 0, false, {
      fileName: _jsxFileName$2v,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2v,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2u = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/FileImageFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from file-image-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FileImageFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M11 0v3.5a.5.5 0 0 0 .41.492L11.5 4H15v11.5a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5H11ZM9.541 5.122a.41.41 0 0 0-.583 0l-.055.069-1.538 2.373 1.789 2.456c.2.274.224.602.12.88l-.044.1h3.353l.08-.008a.431.431 0 0 0 .305-.585l-.039-.073L9.596 5.19l-.055-.069ZM6.19 6.818a.409.409 0 0 0-.544 0l-.061.068-2.5 3.428-.04.067a.432.432 0 0 0 .297.612l.076.007h5l.076-.007c.27-.05.42-.36.297-.612l-.04-.067-2.5-3.428-.061-.068ZM12.333 0a.5.5 0 0 1 .352.144l2.167 2.143a.5.5 0 0 1 .148.356V3h-2.75a.25.25 0 0 1-.25-.25V0h.333Z"
    }, void 0, false, {
      fileName: _jsxFileName$2u,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2u,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2t = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/FilePdf.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from file-pdf.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FilePdfIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M12.333 0a.5.5 0 0 1 .352.144l2.167 2.143a.5.5 0 0 1 .148.356V15.5a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5h10.833ZM11 1H2v14h12V4h-2.5a.5.5 0 0 1-.5-.5V1ZM7.449 3c.272 0 1.043.274 1.089 1.507l-.004.204-.013.218c-.037.415-.15.932-.482 1.77.198.285.414.57.681.89l.348.4.195.216.129.137.222.255c.035.04.07.077.103.11h.363c1.043 0 1.86.183 2.359.457.68.411.59 1.096.499 1.37-.091.229-.408.64-1.089.64-.136 0-.317 0-.499-.092-.448-.113-.804-.318-1.499-1l-.32-.322-.177-.185c-.499.046-1.043.137-1.587.229-.454.091-.862.182-1.225.32-.082.16-.16.312-.237.455l-.22.403-.104.182-.196.328-.093.147-.173.262-.082.116-.152.203-.138.17-.125.137-.058.059-.106.098-.093.075-.083.057-.07.042-.112.05-.243.063a.925.925 0 0 1-.21.029c-.4 0-.653-.234-.809-.42l-.098-.128-.048-.09c-.127-.273-.23-.823.456-1.554l.197-.193.08-.073.187-.159c.377-.302.955-.665 1.895-.99.181-.411.408-.822.59-1.279.075-.167.146-.33.211-.485l.182-.445.15-.394c-.589-.959-.68-1.69-.68-2.511C6.36 3.319 7.04 3 7.45 3Zm-2.223 7.671c-.413.224-.67.425-.85.589l-.193.187c-.212.214-.259.371-.27.474l-.002.074.09.046h-.045l.028.023c.018.011.04.023.063.023 0 .045.045.045.09 0l.023-.007.039-.022.057-.044.075-.07.096-.103.116-.139.137-.181.076-.108.17-.255.194-.31c.035-.056.07-.115.106-.177Zm5.398-1.05.244.219c.362.312.52.382.709.42l.067.007.118.032c.016.004.03.007.042.007.181 0 .272-.046.272-.091.03-.092-.02-.163-.07-.213l-.066-.061-.115-.057-.136-.056a2.549 2.549 0 0 0-.087-.031l-.212-.063a3.981 3.981 0 0 0-.766-.113ZM7.676 7.703v.046l-.243.571a3.742 3.742 0 0 0-.075.205l-.13.268a2.31 2.31 0 0 0-.097.234h.046l-.09.046.249-.063c.079-.017.158-.028.25-.028l.263-.042.495-.1.239-.04a15.213 15.213 0 0 1-.398-.472L7.84 7.9l-.164-.197Zm-.227-3.79c-.09.046-.136.183-.136.411-.045.411 0 .776.181 1.324.121-.365.162-.629.175-.832l.007-.184v-.08c0-.41-.136-.593-.227-.639Z"
    }, void 0, false, {
      fileName: _jsxFileName$2t,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2t,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2s = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/FilePdfFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from file-pdf-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FilePdfFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M11 0v3.5a.5.5 0 0 0 .41.492L11.5 4H15v11.5a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5H11ZM7.449 3c-.408 0-1.089.32-1.089 1.279 0 .821.091 1.552.68 2.511l-.15.394-.182.445c-.065.155-.136.318-.212.485-.181.457-.408.868-.59 1.279-.939.325-1.517.688-1.894.99l-.187.159-.153.143-.124.123c-.686.73-.583 1.281-.456 1.555l.048.09.098.126c.156.187.41.421.809.421a.925.925 0 0 0 .21-.029l.243-.062.111-.051.071-.042.083-.057.093-.075.106-.098.119-.124.064-.073.138-.169.152-.203.167-.242a9.9 9.9 0 0 0 .088-.136l.189-.305c.065-.11.133-.227.204-.352l.22-.403c.076-.143.155-.294.237-.456.363-.137.77-.228 1.225-.32a22.131 22.131 0 0 1 1.587-.228l.178.185.32.322c.694.682 1.05.887 1.498 1 .182.092.363.092.5.092.68 0 .997-.411 1.088-.64.09-.274.181-.959-.5-1.37-.457-.25-1.18-.425-2.102-.452l-.256-.004h-.363l-.103-.11-.222-.256a3.738 3.738 0 0 0-.129-.137l-.195-.216-.348-.4a12.24 12.24 0 0 1-.681-.89c.332-.838.445-1.355.482-1.77l.013-.218.004-.204C8.492 3.274 7.72 3 7.449 3Zm-2.223 7.671-.205.34-.094.147-.17.255-.149.204-.126.16-.105.12-.086.085a1.098 1.098 0 0 1-.035.032l-.057.044-.04.022-.021.007c-.046.045-.091.045-.091 0a.118.118 0 0 1-.063-.023l-.028-.023h.046l-.091-.046.003-.074c.01-.103.057-.26.269-.474l.194-.187c.18-.164.436-.365.85-.589Zm5.398-1.05c.314.018.568.062.766.113l.212.063.087.03.186.08.065.034.065.06c.05.051.101.122.07.214 0 .045-.09.09-.271.09l-.042-.006-.118-.032a.354.354 0 0 0-.067-.007c-.17-.034-.315-.094-.606-.334l-.218-.188-.129-.117ZM7.676 7.703l.164.197.345.428.19.23.208.241-.239.041-.495.1c-.085.016-.173.03-.264.042-.09 0-.17.011-.25.028l-.249.063.09-.046h-.045a2.31 2.31 0 0 1 .097-.234l.13-.268.075-.205.243-.571v-.046Zm-.227-3.79c.09.046.227.229.227.64l-.002.167a3.164 3.164 0 0 1-.18.928c-.181-.548-.226-.913-.181-1.324 0-.228.045-.365.136-.41ZM12.333 0a.5.5 0 0 1 .352.144l2.167 2.143a.5.5 0 0 1 .148.356V3h-2.75a.25.25 0 0 1-.25-.25V0h.333Z"
    }, void 0, false, {
      fileName: _jsxFileName$2s,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2s,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2r = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Filter.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from filter.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FilterIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2r,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M1 3h14H1zm4 10h6-6zM3 8h10H3z"
      }, void 0, false, {
        fileName: _jsxFileName$2r,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2r,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2r,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2q = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Flag.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from flag.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FlagIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2q,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M3 9v6V1h12l-4 4 4 4H3z"
      }, void 0, false, {
        fileName: _jsxFileName$2q,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2q,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2q,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2p = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/FlagFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from flag-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FlagFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      children: [o("path", {
        fill: "none",
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2p,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        fill: "currentColor",
        d: "M2 1a1 1 0 0 1 .883-.993L3 0h12c.852 0 1.297.986.783 1.623l-.076.084L12.415 5l3.292 3.293c.575.575.253 1.523-.485 1.684l-.108.017L15 10H4v5a1 1 0 0 1-1.993.117L2 15V1z"
      }, void 0, false, {
        fileName: _jsxFileName$2p,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2p,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2p,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2o = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Folder.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from folder.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FolderIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M4.5 1a1.5 1.5 0 0 1 1.339.823l.056.125.018.052H14.5a1.5 1.5 0 0 1 1.473 1.215l.02.14L16 3.5v10a1.5 1.5 0 0 1-1.356 1.493L14.5 15h-13a1.5 1.5 0 0 1-1.493-1.356L0 13.5v-11a1.5 1.5 0 0 1 1.356-1.493L1.5 1h3ZM15 5H1v8.5a.5.5 0 0 0 .41.492L1.5 14h13a.5.5 0 0 0 .492-.41L15 13.5V5ZM4.5 2h-3a.5.5 0 0 0-.492.41L1 2.5V4h14v-.5a.5.5 0 0 0-.41-.492L14.5 3h-9a.5.5 0 0 1-.492-.41l-.016-.18a.5.5 0 0 0-.402-.402L4.5 2Z"
    }, void 0, false, {
      fileName: _jsxFileName$2o,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2o,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2n = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/FolderFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from folder-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FolderFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M16 5v8.5a1.5 1.5 0 0 1-1.356 1.493L14.5 15h-13a1.5 1.5 0 0 1-1.493-1.356L0 13.5V5h16ZM0 2.5a1.5 1.5 0 0 1 1.356-1.493L1.5 1h3a1.5 1.5 0 0 1 1.415 1H14.5a1.5 1.5 0 0 1 1.493 1.356L16 3.5V4H0V2.5Z"
    }, void 0, false, {
      fileName: _jsxFileName$2n,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2n,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2m = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/FolderOpen.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from folder-open.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FolderOpenIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M5.5 1a1.5 1.5 0 0 1 1.339.823l.056.125.018.052H13.5a1.5 1.5 0 0 1 1.473 1.215l.02.14L15 3.5l.001.633c.477.217.82.677.874 1.228l.008.153-.005.096L15 13.5a1.5 1.5 0 0 1-1.356 1.493L13.5 15h-11c-.78 0-1.42-.595-1.49-1.31l-.007-.135-.877-7.89A1.498 1.498 0 0 1 1 4.136V2.5a1.5 1.5 0 0 1 1.356-1.493L2.5 1h3ZM1.593 5l-.031.003a.5.5 0 0 0-.444.462l.002.09L2 13.5a.5.5 0 0 0 .41.492L2.5 14h11c.245 0 .45-.177.494-.449l.009-.106.878-7.904.002-.041a.5.5 0 0 0-.41-.492L14.383 5H1.593ZM5.5 2h-3a.5.5 0 0 0-.492.41L2 2.5V4h12v-.5a.5.5 0 0 0-.326-.469l-.084-.023L13.5 3h-7a.5.5 0 0 1-.492-.41L6 2.5a.5.5 0 0 0-.41-.492L5.5 2Z"
    }, void 0, false, {
      fileName: _jsxFileName$2m,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2m,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2l = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/FolderOpenFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from folder-open-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function FolderOpenFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M5.5 1a1.5 1.5 0 0 1 1.395.948L6.913 2H13.5a1.5 1.5 0 0 1 1.493 1.356L15 3.5v.633c.52.235.883.759.883 1.367l-.003.083-.006.083L15 13.5a1.5 1.5 0 0 1-1.356 1.493L13.5 15h-11c-.78 0-1.42-.595-1.49-1.31l-.007-.135-.877-7.89A1.5 1.5 0 0 1 1 4.134L1 2.5a1.5 1.5 0 0 1 1.356-1.493L2.5 1h3Zm0 1h-3a.5.5 0 0 0-.492.41L2 2.5V4h12v-.5a.5.5 0 0 0-.41-.492L13.5 3h-7a.5.5 0 0 1-.492-.41L6 2.5a.5.5 0 0 0-.41-.492L5.5 2Z"
    }, void 0, false, {
      fileName: _jsxFileName$2l,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2l,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2k = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Globe.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from globe.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function GlobeIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0zm2.655 11.535c.244-.242.442-.719.442-1.063a1.13 1.13 0 0 0-.288-.696l-.442-.442a1.033 1.033 0 0 0-.73-.302H7.484C7.181 8.88 6.791 8 6.452 8c-.34 0-.674-.08-.978-.231l-.357-.179a.386.386 0 0 1-.213-.345c0-.153.118-.317.263-.366l1.006-.335a.618.618 0 0 1 .163-.026c.106 0 .258.056.338.126l.3.26c.046.04.106.063.169.063h.182a.258.258 0 0 0 .23-.373l-.503-1.006a.306.306 0 0 1-.027-.116c0-.06.035-.143.078-.185l.32-.31a.258.258 0 0 1 .18-.074h.29c.06 0 .141-.034.183-.076l.258-.258c.1-.1.1-.264 0-.364l-.151-.152a.258.258 0 0 1 0-.365l.333-.333.151-.151a.516.516 0 0 0 0-.73l-.912-.913a6.45 6.45 0 0 0-.787.078v.365a.516.516 0 0 1-.747.461l-.775-.387a6.487 6.487 0 0 0-3.329 3.287c.32.474.813 1.205 1.116 1.65.138.203.4.503.582.668l.026.023c.308.278.65.516 1.021.702.452.227 1.111.586 1.575.842.328.182.53.527.53.903v1.032c0 .274.11.537.303.73.484.484.785 1.246.73 1.653v.884c.473 0 .932-.055 1.376-.152l.56-1.511c.067-.177.106-.362.155-.544a.771.771 0 0 1 .199-.346l.365-.364zm2.797-2.946.94.235c.036-.27.06-.544.06-.824a6.4 6.4 0 0 0-.688-2.882l-.419.21a.773.773 0 0 0-.298.263l-.632.947a.908.908 0 0 0-.13.43c0 .13.058.321.13.43l.58.87c.107.16.27.274.457.32z"
    }, void 0, false, {
      fileName: _jsxFileName$2k,
      lineNumber: 17,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2k,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2j = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/GlobeAlt.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from globe-alt.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function GlobeAltIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2j,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 0c1.105 0 2-3.134 2-7s-.895-7-2-7-2 3.134-2 7 .895 7 2 7zm6.272-9.61C13.127 6.049 10.748 6.501 8 6.501S2.873 6.05 1.728 5.39m12.544 5.221C13.127 9.953 10.748 9.5 8 9.5s-5.127.453-6.272 1.111"
      }, void 0, false, {
        fileName: _jsxFileName$2j,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2j,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2j,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2i = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Groups.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from groups.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function GroupsIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2i,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M1 15a3 3 0 0 1 6 0m2-4a3 3 0 0 1 6 0M4 9a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm8-4a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"
      }, void 0, false, {
        fileName: _jsxFileName$2i,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2i,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2i,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2h = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/GroupsFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from groups-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function GroupsFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M4 11a4 4 0 0 1 4 4 1 1 0 0 1-.883.993L7 16H1a1 1 0 0 1-1-1 4 4 0 0 1 4-4Zm8-4a4 4 0 0 1 4 4 1 1 0 0 1-.883.993L15 12H9a1 1 0 0 1-1-1 4 4 0 0 1 4-4ZM4 4a3 3 0 1 1 0 6 3 3 0 0 1 0-6Zm8-4a3 3 0 1 1 0 6 3 3 0 0 1 0-6Z"
    }, void 0, false, {
      fileName: _jsxFileName$2h,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2h,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2g = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Help.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from help.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function HelpIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2g,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M8 15a1 1 0 1 1 0-2 1 1 0 0 1 0 2zM4 4.5C4 2.567 5.79 1 8 1s4 1.567 4 3.5S10.21 8 8 8m0 0v1.5V8z"
      }, void 0, false, {
        fileName: _jsxFileName$2g,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2g,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2g,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2f = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Hide.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from hide.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function HideIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "m1.613.21.094.083 14 14a1 1 0 0 1-1.32 1.497l-.094-.083-14-14A1 1 0 0 1 1.613.21Zm.583 4.845a1 1 0 0 1 .292 1.384C2.165 6.935 2 7.46 2 8c0 2.123 2.628 4 6 4 .22 0 .44-.008.657-.024a1 1 0 0 1 .147 1.994c-.266.02-.534.03-.804.03-4.36 0-8-2.6-8-6 0-.937.283-1.84.812-2.653a1 1 0 0 1 1.384-.292ZM8 2c4.36 0 8 2.6 8 6 0 .937-.283 1.84-.812 2.653a1 1 0 0 1-1.676-1.092C13.835 9.065 14 8.54 14 8c0-2.123-2.628-4-6-4-.22 0-.44.008-.657.024a1 1 0 1 1-.147-1.994C7.462 2.01 7.73 2 8 2Z"
    }, void 0, false, {
      fileName: _jsxFileName$2f,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2f,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2e = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/HideFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from hide-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function HideFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "m1.613.21.094.083 14 14a1 1 0 0 1-1.32 1.497l-.094-.083-14-14A1 1 0 0 1 1.613.21Zm-.038 4.194 3.43 3.43L5 8a3 3 0 0 0 3 3l.166-.006 2.631 2.632C9.923 13.87 8.98 14 8 14c-4.36 0-8-2.6-8-6 0-1.367.588-2.604 1.575-3.596ZM8 2c4.36 0 8 2.6 8 6 0 1.367-.588 2.604-1.575 3.596l-3.43-3.43L11 8a3 3 0 0 0-3-3l-.167.005-2.631-2.631A10.492 10.492 0 0 1 8 2Z"
    }, void 0, false, {
      fileName: _jsxFileName$2e,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2e,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2d = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Highlight.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from highlight.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function HighlightIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2d,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M12 15H1h11zm-.5-6v2l-1 1v-2l1-1zm.5-7v6h-2V2h2zm0-1h-2 2zm0 8h-2 2z"
      }, void 0, false, {
        fileName: _jsxFileName$2d,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2d,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2d,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2c = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Image.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from image.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ImageIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$2c,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M15 1v14H1V1h14zM1 15l3-8 4 6 3-4 4 6m-4-9a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"
      }, void 0, false, {
        fileName: _jsxFileName$2c,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2c,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2c,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2b = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/ImageFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from image-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ImageFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M14 0a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2ZM9.541 5.122a.41.41 0 0 0-.638.069L7.365 7.564l1.789 2.456a.931.931 0 0 1 .076.98h3.353l.08-.008a.432.432 0 0 0 .266-.658L9.596 5.19ZM6.19 6.818a.41.41 0 0 0-.605.068l-2.5 3.428-.04.067c-.135.275.056.619.373.619h5l.076-.007a.432.432 0 0 0 .257-.679l-2.5-3.428Z"
    }, void 0, false, {
      fileName: _jsxFileName$2b,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2b,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$2a = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Leave.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from leave.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function LeaveIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M8 0c4.052 0 8 3.948 8 8s-3.948 8-8 8-8-3.948-8-8 3.948-8 8-8Zm0 2C5.052 2 2 5.052 2 8s3.052 6 6 6 6-3.052 6-6-3.052-6-6-6Zm2.786 4.62-.079.087L9.415 8l1.292 1.293a1 1 0 0 1-1.32 1.497l-.094-.083L8 9.415l-1.293 1.292c-.914.914-2.272-.388-1.493-1.327l.079-.087L6.585 8 5.293 6.707a1 1 0 0 1 1.32-1.497l.094.083L8 6.585l1.293-1.292c.914-.914 2.272.388 1.493 1.327Z"
    }, void 0, false, {
      fileName: _jsxFileName$2a,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$2a,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$29 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/LeaveFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from leave-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function LeaveFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M8 0c4.052 0 8 3.948 8 8s-3.948 8-8 8-8-3.948-8-8 3.948-8 8-8ZM6.613 5.21a1 1 0 0 0-1.226 0l-.094.083-.083.094a1 1 0 0 0 0 1.226l.083.094L6.585 8 5.293 9.293l-.083.094a1 1 0 0 0 .083 1.32l.094.083a1 1 0 0 0 1.32-.083L8 9.415l1.293 1.292.094.083a1 1 0 0 0 1.32-1.497L9.415 8l1.292-1.293.083-.094A1 1 0 0 0 9.387 5.21l-.094.083L8 6.585 6.707 5.293Z"
    }, void 0, false, {
      fileName: _jsxFileName$29,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$29,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$28 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Link.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from link.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function LinkIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M9.68 6.097a1 1 0 1 1-1.36 1.466c-.799-.741-1.85-.75-2.655-.028l-3.078 3.592-.079.082a1.544 1.544 0 0 0 0 2.29c.662.614 1.81.68 2.558.107l.09-.077 1.006-1.21a1 1 0 0 1 1.306-.205l.102.074a1 1 0 0 1 .205 1.307l-.074.101-1.058 1.274-.089.095c-1.525 1.415-3.956 1.346-5.406 0-1.442-1.338-1.564-3.607-.152-5.073l.099-.098 3.1-3.615.079-.082c1.576-1.463 3.83-1.463 5.406 0Zm5.172-5.062c1.442 1.338 1.564 3.607.152 5.073l-.1.097-3.118 3.638-.06.06c-1.576 1.463-3.83 1.463-5.406 0a1 1 0 1 1 1.36-1.466c.799.741 1.85.75 2.655.028l3.078-3.592.079-.082a1.544 1.544 0 0 0 0-2.29c-.662-.614-1.81-.68-2.558-.107l-.091.076-1.005 1.211a1 1 0 0 1-1.306.205l-.102-.074a1 1 0 0 1-.205-1.307l.074-.101L9.357 1.13l.089-.095c1.525-1.415 3.956-1.346 5.406 0Z"
    }, void 0, false, {
      fileName: _jsxFileName$28,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$28,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$27 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/List.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from list.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ListIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M15 12a1 1 0 0 1 .117 1.993L15 14H1a1 1 0 0 1-.117-1.993L1 12h14Zm0-5a1 1 0 0 1 .117 1.993L15 9H1a1 1 0 0 1-.117-1.993L1 7h14Zm0-5a1 1 0 0 1 .117 1.993L15 4H1a1 1 0 0 1-.117-1.993L1 2h14Z"
    }, void 0, false, {
      fileName: _jsxFileName$27,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$27,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$26 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/ListOrdered.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from list-ordered.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ListOrderedIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M2.748 11.5c.227 0 .443.034.646.103.203.069.381.164.534.286.155.123.276.267.364.432.089.168.134.35.134.543 0 .17-.042.333-.124.484a1.384 1.384 0 0 1-.19.269l-.062.061.047.035c.047.041.09.086.13.134l.058.075.075.122c.093.172.14.352.14.538 0 .201-.048.39-.143.566a1.44 1.44 0 0 1-.384.45c-.16.125-.344.223-.554.294-.21.072-.434.108-.67.108-.237 0-.461-.036-.671-.108a1.871 1.871 0 0 1-.555-.295 1.42 1.42 0 0 1-.382-.45 1.178 1.178 0 0 1-.132-.417L1 14.582l.002-.078.01-.05a.249.249 0 0 1 .077-.111.283.283 0 0 1 .121-.06l.07-.008h.708l.05.007c.044.01.084.028.12.056a.24.24 0 0 1 .089.133l.006.054v.047l.005.077a.279.279 0 0 0 .112.186c.088.066.213.101.378.101a.615.615 0 0 0 .376-.102.29.29 0 0 0 .12-.252.29.29 0 0 0-.12-.252.538.538 0 0 0-.262-.096l-.114-.007h-.1l-.051-.007a.292.292 0 0 1-.12-.059.244.244 0 0 1-.087-.13l-.006-.053.001-.57.01-.05a.249.249 0 0 1 .078-.112.283.283 0 0 1 .121-.06l.07-.008h.076l.112-.006a.454.454 0 0 0 .224-.086.26.26 0 0 0 .104-.222.246.246 0 0 0-.103-.213.533.533 0 0 0-.329-.09.527.527 0 0 0-.324.09.24.24 0 0 0-.098.148l-.006.065-.002.11-.01.05a.249.249 0 0 1-.081.112.292.292 0 0 1-.12.059l-.066.007h-.712l-.052-.007a.292.292 0 0 1-.12-.059.244.244 0 0 1-.087-.13l-.006-.054v-.096l.008-.135c.018-.141.062-.275.132-.402.091-.164.213-.307.366-.43.152-.122.33-.217.533-.286.203-.069.418-.103.645-.103ZM15 13a1 1 0 0 1 .117 1.993L15 15H7a1 1 0 0 1-.117-1.993L7 13h8ZM2.777 5.5c.234 0 .454.034.66.101.207.068.389.164.544.288.156.124.28.27.372.437.093.17.14.355.14.551 0 .19-.049.37-.145.542-.07.123-.156.237-.258.34l-.108.1L2.71 8.932l1.52.001.053.006c.044.01.084.029.12.056.047.036.078.08.091.132l.007.054-.002.59-.01.05a.25.25 0 0 1-.083.113.298.298 0 0 1-.121.059L4.216 10H1.27l-.053-.007a.298.298 0 0 1-.122-.059.246.246 0 0 1-.089-.132L1 9.748v-.711l.004-.05a.26.26 0 0 1 .04-.115l.034-.043.035-.033L3.04 7.167l.036-.036a.98.98 0 0 0 .08-.114.295.295 0 0 0 .055-.145.27.27 0 0 0-.099-.21c-.068-.062-.167-.094-.303-.094-.163 0-.285.032-.369.093a.244.244 0 0 0-.103.147l-.006.064-.002.123-.01.052a.25.25 0 0 1-.084.112.298.298 0 0 1-.12.058l-.069.008h-.726l-.053-.007a.298.298 0 0 1-.121-.059.246.246 0 0 1-.09-.132l-.006-.054V6.87l.01-.137c.017-.143.063-.28.135-.407.094-.167.22-.313.379-.437.157-.123.339-.219.544-.287.206-.067.425-.101.658-.101ZM15 7a1 1 0 0 1 .117 1.993L15 9H7a1 1 0 0 1-.117-1.993L7 7h8ZM3.237 0l.052.008c.044.01.084.031.12.061a.248.248 0 0 1 .083.132l.006.052-.004 3.167.744.001.051.007c.044.01.084.03.119.058.044.036.074.08.086.132l.006.053-.001.595-.01.05a.278.278 0 0 1-.197.176l-.07.008H1.29l-.051-.008a.287.287 0 0 1-.12-.061.248.248 0 0 1-.084-.132l-.006-.052.001-.596.01-.05a.247.247 0 0 1 .077-.113.28.28 0 0 1 .12-.06l.069-.008.932.002.003-1.959-.796.629-.068.037a.295.295 0 0 1-.196-.002.25.25 0 0 1-.172-.179L1 1.881v-.587l.007-.089.015-.075a.345.345 0 0 1 .073-.132l.06-.059.83-.758.04-.036A.994.994 0 0 1 2.139.07a.498.498 0 0 1 .183-.062L2.428 0h.809ZM15 1a1 1 0 0 1 .117 1.993L15 3H7a1 1 0 0 1-.117-1.993L7 1h8Z"
    }, void 0, false, {
      fileName: _jsxFileName$26,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$26,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$25 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/ListUnordered.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from list-unordered.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ListUnorderedIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M2 12a2 2 0 1 1 0 4 2 2 0 0 1 0-4Zm13 1a1 1 0 0 1 .117 1.993L15 15H7a1 1 0 0 1-.117-1.993L7 13h8ZM2 6a2 2 0 1 1 0 4 2 2 0 0 1 0-4Zm13 1a1 1 0 0 1 .117 1.993L15 9H7a1 1 0 0 1-.117-1.993L7 7h8ZM2 0a2 2 0 1 1 0 4 2 2 0 0 1 0-4Zm13 1a1 1 0 0 1 .117 1.993L15 3H7a1 1 0 0 1-.117-1.993L7 1h8Z"
    }, void 0, false, {
      fileName: _jsxFileName$25,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$25,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$24 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Lock.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from lock.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function LockIcon(props) {
  return o("svg", {
    width: "14",
    height: "16",
    viewBox: "0 0 48 56",
    xmlns: "http://www.w3.org/2000/svg",
    ...props,
    children: o("g", {
      fill: "currentColor",
      "fill-rule": "evenodd",
      children: [o("path", {
        d: "M0 24h48v32H0z"
      }, void 0, false, {
        fileName: _jsxFileName$24,
        lineNumber: 18,
        columnNumber: 9
      }, this), o("path", {
        d: "M24 0S8 0 8 16v16h8V16c0-8 8-8 8-8s8 0 8 8v16h8V16C40 0 24 0 24 0Z"
      }, void 0, false, {
        fileName: _jsxFileName$24,
        lineNumber: 19,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$24,
      lineNumber: 17,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$24,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$23 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/LockAlt.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from lock-alt.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function LockAltIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M8 0a5 5 0 0 1 4.995 4.783L13 5v2h2a1 1 0 0 1 .993.883L16 8v7a1 1 0 0 1-.883.993L15 16H1a1 1 0 0 1-.993-.883L0 15V8a1 1 0 0 1 .883-.993L1 7h2V5a5 5 0 0 1 5-5Zm6 9H2v5h12V9ZM8 2a3 3 0 0 0-2.995 2.824L5 5v2h6V5a3 3 0 0 0-3-3Z"
    }, void 0, false, {
      fileName: _jsxFileName$23,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$23,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$22 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/LockAltFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from lock-alt-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function LockAltFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M15 7a1 1 0 0 1 .993.883L16 8v7a1 1 0 0 1-.883.993L15 16H1a1 1 0 0 1-.993-.883L0 15V8a1 1 0 0 1 .883-.993L1 7h14ZM8 0a5 5 0 0 1 4.995 4.783L13 5v.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V5a3 3 0 0 0-5.995-.176L5 5v.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5V5a5 5 0 0 1 5-5Z"
    }, void 0, false, {
      fileName: _jsxFileName$22,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$22,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$21 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Logo.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from logo.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function LogoIcon(props) {
  return o("svg", {
    width: "24",
    height: "28",
    viewBox: "0 0 24 28",
    xmlns: "http://www.w3.org/2000/svg",
    ...props,
    children: [o("path", {
      fill: "#fff",
      d: "M3.886 3.945H21.03v16.047H3.886z"
    }, void 0, false, {
      fileName: _jsxFileName$21,
      lineNumber: 17,
      columnNumber: 7
    }, this), o("path", {
      d: "M0 2.005C0 .898.897 0 2.005 0h19.99C23.102 0 24 .897 24 2.005v19.99A2.005 2.005 0 0 1 21.995 24H2.005A2.005 2.005 0 0 1 0 21.995V2.005ZM9 24l3 4 3-4H9ZM7.008 4H4v16h3.008v-4.997C7.008 12.005 8.168 12.01 9 12c1 .007 2.019.06 2.019 2.003V20h3.008v-6.891C14.027 10 12 9.003 10 9.003c-1.99 0-2 0-2.992 1.999V4ZM19 19.987c1.105 0 2-.893 2-1.994A1.997 1.997 0 0 0 19 16c-1.105 0-2 .892-2 1.993s.895 1.994 2 1.994Z",
      fill: "currentColor",
      "fill-rule": "evenodd"
    }, void 0, false, {
      fileName: _jsxFileName$21,
      lineNumber: 18,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$21,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$20 = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Logout.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from logout.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function LogoutIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M9 0a1 1 0 0 1 .117 1.993L9 2H1.999v12H9a1 1 0 0 1 .993.883L10 15a1 1 0 0 1-.883.993L9 16H1a1 1 0 0 1-.993-.883L0 15V1A1 1 0 0 1 .883.007L1 0h8Zm2.613 3.21.094.083 4 4a1 1 0 0 1 .083 1.32l-.083.094-4 4a1 1 0 0 1-1.497-1.32l.083-.094L12.585 9H5a1 1 0 0 1-.117-1.993L5 7h7.585l-2.292-2.293a1 1 0 0 1-.083-1.32l.083-.094a1 1 0 0 1 1.32-.083Z"
    }, void 0, false, {
      fileName: _jsxFileName$20,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$20,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1$ = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/MenuCollapse.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from menu-collapse.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function MenuCollapseIcon(props) {
  return o("svg", {
    width: "16",
    height: "16",
    xmlns: "http://www.w3.org/2000/svg",
    ...props,
    children: o("path", {
      d: "m8.54 4.205 6.23 5.87a.69.69 0 0 1 0 1.03l-.72.68a.8.8 0 0 1-1.09 0L8 7.135l-4.96 4.65a.8.8 0 0 1-1.09 0l-.73-.69a.69.69 0 0 1 0-1.02l6.24-5.87a.8.8 0 0 1 1.08 0z",
      fill: "currentColor"
    }, void 0, false, {
      fileName: _jsxFileName$1$,
      lineNumber: 11,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1$,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1_ = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/MenuExpand.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from menu-expand.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function MenuExpandIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M7.456 11.788 1.226 5.92a.695.695 0 0 1 0-1.025l.726-.684a.804.804 0 0 1 1.087-.001L8 8.861l4.961-4.65a.804.804 0 0 1 1.087.001l.727.684c.3.283.3.742 0 1.025l-6.23 5.867a.804.804 0 0 1-1.09 0z"
    }, void 0, false, {
      fileName: _jsxFileName$1_,
      lineNumber: 17,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1_,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1Z = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Note.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from note.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function NoteIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M14 0a2 2 0 0 1 1.995 1.85L16 2v7a1 1 0 0 1-.31.724l-.09.076-8 6a1 1 0 0 1-.471.192L7 16H2a2 2 0 0 1-1.995-1.85L0 14V2A2 2 0 0 1 1.85.005L2 0h12Zm0 2H2v12h4V9a1 1 0 0 1 .883-.993L7 8h7V2Zm-2 8H8v3l4-3Z"
    }, void 0, false, {
      fileName: _jsxFileName$1Z,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1Z,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1Y = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/NoteFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from note-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function NoteFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M14 0a2 2 0 0 1 1.995 1.85L16 2v5a1 1 0 0 1-1 1H7a1 1 0 0 0-1 1v6a1 1 0 0 1-1 1H2a2 2 0 0 1-1.995-1.85L0 14V2A2 2 0 0 1 1.85.005L2 0h12Zm1.75 9a.25.25 0 0 1 .25.25L7.25 16a.25.25 0 0 1-.25-.25V10a1 1 0 0 1 1-1h7.75Z"
    }, void 0, false, {
      fileName: _jsxFileName$1Y,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1Y,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1X = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Plus.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from plus.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function PlusIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M8.993 2.867 9 3v3.999L13 7a1 1 0 0 1 .117 1.993L13 9H9v4c0 1.287-1.864 1.332-1.993.133L7 13V9H3a1 1 0 0 1-.117-1.993L3 7h4V3c0-1.287 1.864-1.332 1.993-.133Z"
    }, void 0, false, {
      fileName: _jsxFileName$1X,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1X,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1W = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/PointerDown.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from pointer-down.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function PointerDownIcon(props) {
  return o("svg", {
    width: "16",
    height: "9",
    xmlns: "http://www.w3.org/2000/svg",
    ...props,
    children: o("path", {
      d: "m15.5 0-7 8-8-8",
      stroke: "currentColor"
    }, void 0, false, {
      fileName: _jsxFileName$1W,
      lineNumber: 11,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1W,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1V = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/PointerUp.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from pointer-up.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function PointerUpIcon(props) {
  return o("svg", {
    width: "16",
    height: "9",
    xmlns: "http://www.w3.org/2000/svg",
    ...props,
    children: o("path", {
      d: "m.5 9 7-8 8 8",
      stroke: "currentColor"
    }, void 0, false, {
      fileName: _jsxFileName$1V,
      lineNumber: 11,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1V,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1U = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Preview.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from preview.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function PreviewIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0Zm0 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM6 5a1 1 0 0 1 1.508-.861L7.6 4.2l4 3a1 1 0 0 1 .1 1.515l-.1.085-4 3a1 1 0 0 1-1.594-.69L6 11V5Z"
    }, void 0, false, {
      fileName: _jsxFileName$1U,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1U,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1T = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/PreviewFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from preview-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function PreviewFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0Zm-.4 4.2a1 1 0 0 0-1.594.69L6 5v6a1 1 0 0 0 1.508.861L7.6 11.8l4-3a1 1 0 0 0 .1-1.515l-.1-.085-4-3Z"
    }, void 0, false, {
      fileName: _jsxFileName$1T,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1T,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1S = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Profile.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from profile.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ProfileIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$1S,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M1 15c0-2.761 3.134-5 7-5s7 2.239 7 5M8 7a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"
      }, void 0, false, {
        fileName: _jsxFileName$1S,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$1S,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1S,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1R = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/ProfileFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from profile-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ProfileFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M8 9c4.36 0 8 2.6 8 6a1 1 0 0 1-.883.993L15 16H1a1 1 0 0 1-1-1c0-3.4 3.64-6 8-6Zm0-9a4 4 0 1 1 0 8 4 4 0 0 1 0-8Z"
    }, void 0, false, {
      fileName: _jsxFileName$1R,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1R,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1Q = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Refresh.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from refresh.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function RefreshIcon(props) {
  return o("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg",
    ...props,
    children: o("g", {
      fill: "currentColor",
      "fill-rule": "evenodd",
      children: [o("path", {
        d: "M0 8A8 8 0 1 0 11.468.79l-.868 1.8a6 6 0 1 1-5.155-.022L4.594.761A8 8 0 0 0 0 8Z"
      }, void 0, false, {
        fileName: _jsxFileName$1Q,
        lineNumber: 18,
        columnNumber: 9
      }, this), o("path", {
        d: "M7 8.586V0h2v8.586l1.293-1.293.707-.707L12.414 8l-.707.707-3 3-.707.707-.354-.353-.353-.354-3-3L3.586 8 5 6.586l.707.707z"
      }, void 0, false, {
        fileName: _jsxFileName$1Q,
        lineNumber: 19,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$1Q,
      lineNumber: 17,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1Q,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1P = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Reply.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from reply.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ReplyIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M6.422 5.422c2 0 3.542.417 4.625 1.25 1.083.833 1.875 1.75 2.375 2.75s.792 1.917.875 2.75l.125 1.25h-2l-.094-.938c-.062-.625-.281-1.312-.656-2.062-.375-.75-.969-1.438-1.781-2.063-.813-.625-1.97-.937-3.47-.937H4.829l2 2-1.406 1.422L1 6.422 5.422 2l1.406 1.422-2 2h1.594z"
    }, void 0, false, {
      fileName: _jsxFileName$1P,
      lineNumber: 17,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1P,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1O = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/ReplyAlt.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from reply-alt.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ReplyAltIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M7.707.293a1 1 0 0 1 .083 1.32l-.083.094L5.415 4H8a6 6 0 1 1 0 12 1 1 0 0 1 0-2 4 4 0 1 0 0-8H5.415l2.292 2.293a1 1 0 0 1 .083 1.32l-.083.094a1 1 0 0 1-1.32.083l-.094-.083-4-4a1 1 0 0 1-.083-1.32l.083-.094 4-4a1 1 0 0 1 1.414 0Z"
    }, void 0, false, {
      fileName: _jsxFileName$1O,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1O,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1N = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Restricted.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from restricted.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function RestrictedIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M8 0c1.682 0 3.346.68 4.717 1.766l.08.063.285.241.31.285.128.125.16.165.243.265.311.373C15.32 4.653 16 6.318 16 8c0 4.052-3.948 8-8 8-1.682 0-3.346-.68-4.717-1.766l-.056-.045a9.253 9.253 0 0 1-.322-.27l-.131-.119-.167-.156-.132-.13-.152-.156-.253-.276-.304-.365C.68 11.347 0 9.682 0 8c0-4.052 3.948-8 8-8Zm4.765 4.651L4.65 12.765C5.654 13.523 6.835 14 8 14c2.948 0 6-3.052 6-6 0-1.165-.477-2.346-1.235-3.349ZM8 2C5.052 2 2 5.052 2 8c0 1.165.477 2.347 1.236 3.35l8.114-8.114C10.347 2.476 9.165 2 8 2Z"
    }, void 0, false, {
      fileName: _jsxFileName$1N,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1N,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1M = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Search.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from search.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function SearchIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M6 0a6 6 0 0 1 4.825 9.564l.065-.09 4.817 4.819a1 1 0 0 1-1.32 1.497l-.094-.083-4.818-4.815.058-.042A6 6 0 1 1 6 0Zm0 2a4 4 0 1 0 0 8c1 0 1.938-.367 2.651-1.003l.16-.152.15-.156A4 4 0 0 0 6 2Z"
    }, void 0, false, {
      fileName: _jsxFileName$1M,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1M,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1L = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Settings.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from settings.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function SettingsIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M13 10a3 3 0 1 1-2.835 3.985l-.048.008L10 14H1a1 1 0 0 1-.117-1.993L1 12h9c.057 0 .112.005.166.014A3 3 0 0 1 13 10Zm0 2a1 1 0 1 0 0 2 1 1 0 0 0 0-2ZM3 0c1.312 0 2.427.842 2.835 2.015l.048-.008L6 2h9a1 1 0 0 1 .117 1.993L15 4H6c-.057 0-.112-.005-.166-.014A3 3 0 1 1 3 0Zm0 2a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"
    }, void 0, false, {
      fileName: _jsxFileName$1L,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1L,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1K = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Share.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from share.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ShareIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M15 9a1 1 0 0 1 .993.883L16 10v5a1 1 0 0 1-.883.993L15 16H1a1 1 0 0 1-.993-.883L0 15v-5a1 1 0 0 1 1.993-.117L2 10v4h12v-4a1 1 0 0 1 .883-.993L15 9ZM8.613.21l.094.083 4 4a1 1 0 0 1-1.32 1.497l-.094-.083L9 3.415V11a1 1 0 0 1-1.993.117L7 11V3.415L4.707 5.707a1 1 0 0 1-1.32.083l-.094-.083a1 1 0 0 1-.083-1.32l.083-.094 4-4A1 1 0 0 1 8.51.14l.102.07Z"
    }, void 0, false, {
      fileName: _jsxFileName$1K,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1K,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1J = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Show.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from show.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ShowIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M8 2c4.36 0 8 2.6 8 6s-3.64 6-8 6c-4.36 0-8-2.6-8-6s3.64-6 8-6Zm0 2C4.628 4 2 5.877 2 8s2.628 4 6 4 6-1.877 6-4-2.628-4-6-4Zm0 2a2 2 0 1 1 0 4 2 2 0 0 1 0-4Z"
    }, void 0, false, {
      fileName: _jsxFileName$1J,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1J,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1I = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/ShowFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from show-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ShowFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M8 2c4.36 0 8 2.6 8 6s-3.64 6-8 6c-4.36 0-8-2.6-8-6s3.64-6 8-6Zm0 3a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z"
    }, void 0, false, {
      fileName: _jsxFileName$1I,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1I,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1H = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/SocialFacebook.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from social-facebook.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function SocialFacebookIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      children: [o("path", {
        fill: "none",
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$1H,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        fill: "currentColor",
        d: "M15.999 8.049c0-4.445-3.582-8.049-8-8.049S0 3.604 0 8.049C0 12.066 2.925 15.396 6.75 16v-5.624H4.717V8.049H6.75V6.276c0-2.018 1.195-3.132 3.022-3.132.875 0 1.79.157 1.79.157v1.981h-1.008c-.994 0-1.304.62-1.304 1.257v1.51h2.219l-.355 2.327H9.25V16c3.825-.604 6.75-3.934 6.75-7.951z"
      }, void 0, false, {
        fileName: _jsxFileName$1H,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$1H,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1H,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1G = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/SocialTwitter.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from social-twitter.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function SocialTwitterIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      children: [o("path", {
        fill: "none",
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$1G,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        fill: "currentColor",
        d: "M15.969 3.049c-.59.259-1.22.436-1.884.516a3.305 3.305 0 0 0 1.442-1.815c-.634.37-1.336.64-2.084.79a3.28 3.28 0 0 0-5.59 2.988 9.29 9.29 0 0 1-6.76-3.418A3.214 3.214 0 0 0 .65 3.76c0 1.14.58 2.142 1.459 2.73a3.27 3.27 0 0 1-1.485-.41v.04a3.282 3.282 0 0 0 2.63 3.218 3.33 3.33 0 0 1-1.474.057 3.291 3.291 0 0 0 3.069 2.278A6.578 6.578 0 0 1 .78 13.076c-.26 0-.52-.015-.78-.044a9.33 9.33 0 0 0 5.038 1.472c6.036 0 9.332-4.997 9.332-9.323 0-.14 0-.28-.01-.42a6.63 6.63 0 0 0 1.64-1.7l-.031-.012z"
      }, void 0, false, {
        fileName: _jsxFileName$1G,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$1G,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1G,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1F = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Sort.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from sort.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function SortIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$1F,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M5 9V2v7zM1 5l4-4 4 4m2 2v7-7zm-4 4 4 4 4-4"
      }, void 0, false, {
        fileName: _jsxFileName$1F,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$1F,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1F,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1E = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/SortAlt.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from sort-alt.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function SortAltIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M12 7a1 1 0 0 1 1 1v4.585l1.293-1.292a1 1 0 0 1 1.32-.083l.094.083a1 1 0 0 1 .083 1.32l-.083.094-3 3a1 1 0 0 1-1.32.083l-.094-.083-3-3a1 1 0 0 1 1.32-1.497l.094.083L11 12.585V8a1 1 0 0 1 1-1ZM4.613.21l.094.083 3 3a1 1 0 0 1-1.32 1.497l-.094-.083L5 3.415V8a1 1 0 1 1-2 0V3.415L1.707 4.707a1 1 0 0 1-1.32.083l-.094-.083a1 1 0 0 1-.083-1.32l.083-.094 3-3A1 1 0 0 1 4.613.21Z"
    }, void 0, false, {
      fileName: _jsxFileName$1E,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1E,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1D = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/SpinnerCircle.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from spinner--circle.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function SpinnerCircleIcon(props) {
  return o("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 38 38",
    xmlns: "http://www.w3.org/2000/svg",
    ...props,
    children: o("g", {
      transform: "translate(1 1)",
      fill: "none",
      "fill-rule": "evenodd",
      children: [o("path", {
        d: "M36 18c0-9.94-8.06-18-18-18",
        stroke: "currentColor",
        "stroke-width": "2",
        children: o("animateTransform", {
          attributeName: "transform",
          type: "rotate",
          from: "0 18 18",
          to: "360 18 18",
          dur: "0.9s",
          repeatCount: "indefinite"
        }, void 0, false, {
          fileName: _jsxFileName$1D,
          lineNumber: 23,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$1D,
        lineNumber: 18,
        columnNumber: 9
      }, this), o("circle", {
        fill: "#fff",
        cx: "36",
        cy: "18",
        r: "1",
        children: o("animateTransform", {
          attributeName: "transform",
          type: "rotate",
          from: "0 18 18",
          to: "360 18 18",
          dur: "0.9s",
          repeatCount: "indefinite"
        }, void 0, false, {
          fileName: _jsxFileName$1D,
          lineNumber: 33,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$1D,
        lineNumber: 32,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$1D,
      lineNumber: 17,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1D,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1C = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/SpinnerSpokes.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from spinner--spokes.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function SpinnerSpokesIcon(props) {
  return o("svg", {
    viewBox: "0 0 64 64",
    width: "16",
    height: "16",
    ...props,
    children: o("g", {
      "stroke-width": "6",
      stroke: "currentColor",
      "stroke-linecap": "round",
      children: [o("path", {
        d: "M32 16V4",
        children: o("animate", {
          attributeName: "stroke-opacity",
          dur: "750ms",
          values: "0;1;.8;.65;.45;.3;.15;0",
          repeatCount: "indefinite"
        }, void 0, false, {
          fileName: _jsxFileName$1C,
          lineNumber: 13,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$1C,
        lineNumber: 12,
        columnNumber: 9
      }, this), o("path", {
        d: "m43.314 20.686 8.485-8.485",
        children: o("animate", {
          attributeName: "stroke-opacity",
          dur: "750ms",
          values: ".15;0;1;.8;.65;.45;.3;.15",
          repeatCount: "indefinite"
        }, void 0, false, {
          fileName: _jsxFileName$1C,
          lineNumber: 21,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$1C,
        lineNumber: 20,
        columnNumber: 9
      }, this), o("path", {
        d: "M48 32h12",
        children: o("animate", {
          attributeName: "stroke-opacity",
          dur: "750ms",
          values: ".3;.15;0;1;.8;.65;.45;.3",
          repeatCount: "indefinite"
        }, void 0, false, {
          fileName: _jsxFileName$1C,
          lineNumber: 29,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$1C,
        lineNumber: 28,
        columnNumber: 9
      }, this), o("path", {
        d: "m43.314 43.314 8.485 8.485",
        children: o("animate", {
          attributeName: "stroke-opacity",
          dur: "750ms",
          values: ".45;.3;.15;0;1;.85;.65;.45",
          repeatCount: "indefinite"
        }, void 0, false, {
          fileName: _jsxFileName$1C,
          lineNumber: 37,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$1C,
        lineNumber: 36,
        columnNumber: 9
      }, this), o("path", {
        d: "M32 48v12",
        children: o("animate", {
          attributeName: "stroke-opacity",
          dur: "750ms",
          values: ".65;.45;.3;.15;0;1;.8;.65;",
          repeatCount: "indefinite"
        }, void 0, false, {
          fileName: _jsxFileName$1C,
          lineNumber: 45,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$1C,
        lineNumber: 44,
        columnNumber: 9
      }, this), o("path", {
        d: "m20.686 43.314-8.485 8.485",
        children: o("animate", {
          attributeName: "stroke-opacity",
          dur: "750ms",
          values: ".8;.65;.45;.3;.15;0;1;.8",
          repeatCount: "indefinite"
        }, void 0, false, {
          fileName: _jsxFileName$1C,
          lineNumber: 53,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$1C,
        lineNumber: 52,
        columnNumber: 9
      }, this), o("path", {
        d: "M16 32H4",
        children: o("animate", {
          attributeName: "stroke-opacity",
          dur: "750ms",
          values: "1;.85;.6;.45;.3;.15;0;1;",
          repeatCount: "indefinite"
        }, void 0, false, {
          fileName: _jsxFileName$1C,
          lineNumber: 61,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$1C,
        lineNumber: 60,
        columnNumber: 9
      }, this), o("path", {
        d: "m20.686 20.686-8.485-8.485",
        children: o("animate", {
          attributeName: "stroke-opacity",
          dur: "750ms",
          values: "0;1;.8;.65;.45;.3;.15;0",
          repeatCount: "indefinite"
        }, void 0, false, {
          fileName: _jsxFileName$1C,
          lineNumber: 69,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$1C,
        lineNumber: 68,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$1C,
      lineNumber: 11,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1C,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1B = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Tag.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from tag.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function TagIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M7 0a1 1 0 0 1 .563.174l.096.073 8 7a1 1 0 0 1 .222 1.227l-.067.107-5 7a1 1 0 0 1-1.38.244l-.098-.078-9-8a1 1 0 0 1-.329-.626L0 7V1A1 1 0 0 1 .883.007L1 0h6Zm-.376 2H2v4.551l7.833 6.962 3.826-5.358L6.624 2ZM5 3a2 2 0 1 1 0 4 2 2 0 0 1 0-4Z"
    }, void 0, false, {
      fileName: _jsxFileName$1B,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1B,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1A = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/TagAlt.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from tag-alt.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function TagAltIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M5 3a5 5 0 1 1 0 10A5 5 0 0 1 5 3Zm6 0a5 5 0 0 1 0 10 1 1 0 0 1-.117-1.993L11 11a3 3 0 0 0 0-6 1 1 0 0 1 0-2ZM5 5a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z"
    }, void 0, false, {
      fileName: _jsxFileName$1A,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1A,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1z = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/TagAltFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from tag-alt-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function TagAltFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M5 3a5 5 0 1 1 0 10A5 5 0 0 1 5 3Zm6 0a5 5 0 0 1 0 10 1 1 0 0 1-.117-1.993L11 11a3 3 0 0 0 0-6 1 1 0 0 1 0-2Z"
    }, void 0, false, {
      fileName: _jsxFileName$1z,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1z,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1y = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/TagFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from tag-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function TagFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M7 0a1 1 0 0 1 .563.174l.096.073 8 7a1 1 0 0 1 .222 1.227l-.067.107-5 7a1 1 0 0 1-1.38.244l-.098-.078-9-8a1 1 0 0 1-.329-.626L0 7V1A1 1 0 0 1 .883.007L1 0h6ZM5 3a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z"
    }, void 0, false, {
      fileName: _jsxFileName$1y,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1y,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1x = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Theme.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from theme.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function ThemeIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M8 12a1 1 0 0 1 .993.883L9 13v2a1 1 0 0 1-1.993.117L7 15v-2a1 1 0 0 1 1-1Zm-2.828-1.172a1 1 0 0 1 .077 1.327l-.077.088-1.415 1.414a1 1 0 0 1-1.492-1.327l.078-.087 1.414-1.415a1 1 0 0 1 1.415 0Zm6.983-.077.088.077 1.414 1.415a1 1 0 0 1-1.327 1.492l-.087-.078-1.415-1.414a1 1 0 0 1 1.327-1.492ZM8 5c1.552 0 3 1.448 3 3s-1.448 3-3 3-3-1.448-3-3 1.448-3 3-3Zm7 2a1 1 0 0 1 .117 1.993L15 9h-2a1 1 0 0 1-.117-1.993L13 7h2ZM3 7a1 1 0 0 1 .117 1.993L3 9H1a1 1 0 0 1-.117-1.993L1 7h2Zm10.657-4.657a1 1 0 0 1 .078 1.327l-.078.087-1.414 1.415a1 1 0 0 1-1.492-1.327l.077-.088 1.415-1.414a1 1 0 0 1 1.414 0ZM3.67 2.265l.087.078 1.415 1.414A1 1 0 0 1 3.845 5.25l-.088-.077-1.414-1.415A1 1 0 0 1 3.67 2.265ZM8 0a1 1 0 0 1 .993.883L9 1v2a1 1 0 0 1-1.993.117L7 3V1a1 1 0 0 1 1-1Z"
    }, void 0, false, {
      fileName: _jsxFileName$1x,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1x,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1w = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/Trash.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from trash.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function TrashIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("g", {
      "fill-rule": "evenodd",
      fill: "none",
      children: [o("path", {
        d: "M0 0h16v16H0z"
      }, void 0, false, {
        fileName: _jsxFileName$1w,
        lineNumber: 19,
        columnNumber: 9
      }, this), o("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "M2 4h12l-2 11H4L2 4zM1 1h14H1z"
      }, void 0, false, {
        fileName: _jsxFileName$1w,
        lineNumber: 20,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$1w,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1w,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

var _jsxFileName$1v = "/home/runner/work/frontend-shared/frontend-shared/src/components/icons/TrashFilled.js";
// This file was auto-generated using scripts/generate-icons.js

/**
 * Icon generated from trash-filled.svg
 *
 * @param {import('preact').JSX.SVGAttributes<SVGSVGElement>} props
 */
function TrashFilledIcon(props) {
  return o("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    "aria-hidden": "true",
    ...props,
    children: o("path", {
      fill: "currentColor",
      d: "M14 4a1 1 0 0 1 .997 1.08l-.016.116-2 10a1 1 0 0 1-.863.797L12 16H4a1 1 0 0 1-.95-.69l-.03-.114-2-10a1 1 0 0 1 .864-1.19L2 4h12Zm1-4a1 1 0 0 1 0 2H1a1 1 0 1 1 0-2h14Z"
    }, void 0, false, {
      fileName: _jsxFileName$1v,
      lineNumber: 18,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1v,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

// This file was auto-generated using scripts/generate-icons.js

var _jsxFileName$1u = "/home/runner/work/frontend-shared/frontend-shared/src/components/data/AspectRatio.js";

const AspectRatioNext = function AspectRatio({
  children,
  objectFit = 'cover',
  ratio = '16/9'
}) {
  // Find the first vNode. This is the element that will be constrained to the
  // aspect ratio. Typically, this is either:
  // - a "replaceable element", e.g. image or video (media), or
  // - a block element, e.g. a div that contains placeholder content. In this
  //   case, content within this node will be centered horizontally and
  //   vertically.
  const childNodes = x$1(children);
  const firstChildNode =
  /** @type {import('preact').VNode<any>|undefined} */
  childNodes.find(child => typeof child === 'object');
  const otherChildren = firstChildNode ? childNodes.filter(child => child !== firstChildNode) : children;
  const mediaClasses = classnames( // Position the element box relative to its container
  'absolute w-full h-full top-0 left-0', // Center any children horizontally and vertically
  'flex items-center justify-center', {
    'object-cover': objectFit === 'cover',
    // default
    'object-contain': objectFit === 'contain',
    'object-fill': objectFit === 'fill',
    'object-scale-down': objectFit === 'scale-down',
    'object-none': objectFit === 'none'
  });
  return o("div", {
    className: "w-full h-0 relative overflow-hidden",
    "data-component": "AspectRatio",
    style: {
      paddingBottom: `calc(100% / (${ratio}))`
    },
    children: [firstChildNode && q$1(firstChildNode, {
      class: classnames(mediaClasses, // Retain existing classes
      firstChildNode.props.className)
    }), otherChildren]
  }, void 0, true, {
    fileName: _jsxFileName$1u,
    lineNumber: 65,
    columnNumber: 5
  }, this);
};

/**
 * @typedef ScrollInfo
 * @prop {import('preact').RefObject<HTMLElement>} scrollRef
 */

const ScrollContext = B$1(
/** @type {ScrollInfo} */
{});

/**
 * @typedef TableInfo
 * @prop {boolean} interactive - This table has click-able, focus-able rows
 * @prop {boolean} stickyHeader - This table has a sticky header
 * @prop {import('preact').RefObject<HTMLElement>} tableRef
 */

const TableContext = B$1(
/** @type {TableInfo} */
{});

var _jsxFileName$1t = "/home/runner/work/frontend-shared/frontend-shared/src/components/data/Table.js";

const TableNext = function Table({
  children,
  classes,
  elementRef,
  interactive = false,
  title,
  stickyHeader,
  ...htmlAttributes
}) {
  const ref = useSyncedRef(elementRef);
  const tableContext =
  /** @type {TableInfo} */
  {
    interactive,
    stickyHeader,
    tableRef: ref
  };
  return o(TableContext.Provider, {
    value: tableContext,
    children: o("table", { ...htmlAttributes,
      "aria-label": title,
      className: classnames('w-full h-full', // Set the width of columns based on the width of the columns in the
      // first table row (typically headers)
      'table-fixed', // `border-separate` is required to handle borders on sticky headers.
      // A side effect is that borders need to be set primarily on table
      // cells, not rows
      'border-separate border-spacing-0', // No top border is set here: that border is set by `TableCell`.
      // If it is set here, there will be a 1-pixel wiggle in the sticky
      // header on scroll
      'border-x border-b', classes),
      ref: downcastRef(ref),
      "data-component": "Table",
      children: children
    }, void 0, false, {
      fileName: _jsxFileName$1t,
      lineNumber: 44,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1t,
    lineNumber: 43,
    columnNumber: 5
  }, this);
};

/**
 * @typedef TableSection
 * @prop {'head'|'body'|'footer'} section
 */

const TableSectionContext = B$1(
/** @type {TableSection} */
{});

var _jsxFileName$1s = "/home/runner/work/frontend-shared/frontend-shared/src/components/data/TableHead.js";

const TableHeadNext = function TableHead({
  children,
  classes,
  elementRef,
  ...htmlAttributes
}) {
  const tableContext = q(TableContext);
  const sectionContext =
  /** @type {TableSection} */
  {
    section: 'head'
  };
  return o(TableSectionContext.Provider, {
    value: sectionContext,
    children: o("thead", { ...htmlAttributes,
      ref: downcastRef(elementRef),
      className: classnames('bg-grey-2', {
        'sticky top-0': tableContext === null || tableContext === void 0 ? void 0 : tableContext.stickyHeader
      }, classes),
      "data-component": "TableHead",
      children: children
    }, void 0, false, {
      fileName: _jsxFileName$1s,
      lineNumber: 35,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1s,
    lineNumber: 34,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1r = "/home/runner/work/frontend-shared/frontend-shared/src/components/data/TableBody.js";

const TableBodyNext = function TableBody({
  children,
  classes,
  elementRef,
  ...htmlAttributes
}) {
  const tableContext = q(TableContext);
  const sectionContext =
  /** @type {TableSection} */
  {
    section: 'body'
  };
  return o(TableSectionContext.Provider, {
    value: sectionContext,
    children: o("tbody", { ...htmlAttributes,
      ref: downcastRef(elementRef),
      className: classnames({
        'cursor-pointer': tableContext === null || tableContext === void 0 ? void 0 : tableContext.interactive
      }, classes),
      "data-component": "TableBody",
      children: children
    }, void 0, false, {
      fileName: _jsxFileName$1r,
      lineNumber: 34,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1r,
    lineNumber: 33,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1q = "/home/runner/work/frontend-shared/frontend-shared/src/components/data/TableRow.js";

const TableRowNext = function TableRow({
  children,
  classes,
  elementRef,
  selected,
  ...htmlAttributes
}) {
  const rowRef = useSyncedRef(elementRef);
  const sectionContext = q(TableSectionContext);
  const tableContext = q(TableContext);
  const isHeadRow = (sectionContext === null || sectionContext === void 0 ? void 0 : sectionContext.section) === 'head';
  return o("tr", { ...htmlAttributes,
    "aria-selected": selected,
    ref: downcastRef(rowRef),
    className: classnames('group', {
      // Low-opacity backgrounds allow any scroll shadows to be visible
      'odd:bg-slate-9/[.03]': !isHeadRow && !selected,
      'bg-slate-7 text-color-text-inverted': selected,
      'focus-visible-ring ring-inset': tableContext === null || tableContext === void 0 ? void 0 : tableContext.interactive,
      'hover:bg-slate-9/[.08]': (tableContext === null || tableContext === void 0 ? void 0 : tableContext.interactive) && !selected
    }, classes),
    "data-component": "TableRow",
    "data-section": isHeadRow ? 'head' : 'body',
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$1q,
    lineNumber: 40,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1p = "/home/runner/work/frontend-shared/frontend-shared/src/components/data/TableCell.js";

const TableCellNext = function TableCell({
  children,
  classes,
  elementRef,
  ...htmlAttributes
}) {
  const sectionContext = q(TableSectionContext);
  const isHeadCell = sectionContext && sectionContext.section === 'head';
  const Cell = isHeadCell ? 'th' : 'td';
  return o(Cell, { ...htmlAttributes,
    ref: downcastRef(elementRef),
    className: classnames('p-3', {
      // Set horizontal borders here for table headers. This needs to be
      // done here (versus on the row or table) to prevent a 1-pixel wiggle
      // on scroll with sticky headers.
      'text-left border-t border-b border-b-grey-5': isHeadCell,
      'border-none': !isHeadCell
    }, classes),
    "data-component": "TableCell",
    scope: isHeadCell ? 'col' : undefined,
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$1p,
    lineNumber: 30,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1o = "/home/runner/work/frontend-shared/frontend-shared/src/components/data/DataTable.js";

const DataTableNext = function DataTable({
  children,
  elementRef,
  columns = [],
  rows = [],
  title,
  selectedRow,
  loading = false,
  renderItem = (row, field) =>
  /** @type {Children} */
  row[field],
  onSelectRow,
  onConfirmRow,
  emptyMessage,
  ...htmlAttributes
}) {
  const tableRef = useSyncedRef(elementRef);
  const scrollContext = q(ScrollContext);
  useArrowKeyNavigation$1(tableRef, {
    selector: 'tbody tr',
    horizontal: true,
    vertical: true
  });
  const noContent = loading || !rows.length && emptyMessage;
  const fields = columns.map(column => column.field);
  /** @param {Row} row */

  function selectRow(row) {
    onSelectRow === null || onSelectRow === void 0 ? void 0 : onSelectRow(row);
  }
  /** @param {Row} row */


  function confirmRow(row) {
    onConfirmRow === null || onConfirmRow === void 0 ? void 0 : onConfirmRow(row);
  }
  /**
   * @param {KeyboardEvent} event
   * @param {Row} row
   * */


  function handleKeyDown(event, row) {
    if (event.key === 'Enter') {
      confirmRow(row);
      event.preventDefault();
      event.stopPropagation();
    }
  } // Ensure that a selected row is visible when this table is within
  // a scrolling context


  h(() => {
    var _tableRef$current, _tableRef$current2;

    if (!selectedRow || !scrollContext) {
      return;
    }

    const scrollEl = scrollContext.scrollRef.current;
    const tableHead = (_tableRef$current = tableRef.current) === null || _tableRef$current === void 0 ? void 0 : _tableRef$current.querySelector('thead');
    /** @type {HTMLElement | undefined | null} */

    const selectedRowEl = (_tableRef$current2 = tableRef.current) === null || _tableRef$current2 === void 0 ? void 0 : _tableRef$current2.querySelector('tr[aria-selected="true"]');

    if (scrollEl && selectedRowEl) {
      // Ensure the row is visible within the scroll content area
      const scrollOffset = selectedRowEl.offsetTop - scrollEl.scrollTop;

      if (scrollOffset > scrollEl.clientHeight) {
        selectedRowEl.scrollIntoView();
      } // Ensure the row is not obscured by a sticky header


      if (tableHead) {
        const headingHeight = tableHead.clientHeight;
        const headingOffset = scrollOffset - headingHeight;

        if (headingOffset < 0) {
          scrollEl.scrollBy(0, headingOffset);
        }
      }
    }
  }, [selectedRow, tableRef, scrollContext]);
  return o(TableNext, { ...htmlAttributes,
    title: title,
    elementRef: downcastRef(tableRef),
    interactive: !!(onSelectRow || onConfirmRow),
    stickyHeader: true,
    role: "grid",
    "data-composite-component": "DataTable",
    children: [o(TableHeadNext, {
      children: o(TableRowNext, {
        children: columns.map(column => o(TableCellNext, {
          classes: column.classes,
          children: column.label
        }, column.field, false, {
          fileName: _jsxFileName$1o,
          lineNumber: 145,
          columnNumber: 13
        }, this))
      }, void 0, false, {
        fileName: _jsxFileName$1o,
        lineNumber: 143,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$1o,
      lineNumber: 142,
      columnNumber: 7
    }, this), o(TableBodyNext, {
      children: [!loading && rows.map((row, idx) => o(TableRowNext, {
        selected: row === selectedRow,
        onClick: () => selectRow(row),
        onFocus: () => selectRow(row),
        onDblClick: () => confirmRow(row),
        onKeyDown: event => handleKeyDown(event, row),
        children: fields.map(field => o(TableCellNext, {
          children: renderItem(row,
          /** @type {keyof Row} */
          field)
        }, field, false, {
          fileName: _jsxFileName$1o,
          lineNumber: 163,
          columnNumber: 17
        }, this))
      }, idx, false, {
        fileName: _jsxFileName$1o,
        lineNumber: 154,
        columnNumber: 13
      }, this)), noContent && o("tr", {
        children: o("td", {
          colSpan: columns.length,
          className: "text-center p-3",
          children: loading ? o(SpinnerSpokesIcon, {
            className: "inline w-4em h-4em"
          }, void 0, false, {
            fileName: _jsxFileName$1o,
            lineNumber: 173,
            columnNumber: 17
          }, this) : o(p$2, {
            children: emptyMessage
          }, void 0, false)
        }, void 0, false, {
          fileName: _jsxFileName$1o,
          lineNumber: 171,
          columnNumber: 13
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$1o,
        lineNumber: 170,
        columnNumber: 11
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$1o,
      lineNumber: 151,
      columnNumber: 7
    }, this), children]
  }, void 0, true, {
    fileName: _jsxFileName$1o,
    lineNumber: 133,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1n = "/home/runner/work/frontend-shared/frontend-shared/src/components/data/Scroll.js";

const ScrollNext = function Scroll({
  children,
  classes,
  elementRef,
  variant = 'raised',
  ...htmlAttributes
}) {
  const ref = useSyncedRef(elementRef);
  const scrollContext =
  /** @type {ScrollInfo} */
  {
    scrollRef: ref
  };
  return o(ScrollContext.Provider, {
    value: scrollContext,
    children: o("div", { ...htmlAttributes,
      ref: downcastRef(ref),
      className: classnames( // Prevent overflow by overriding `min-height: auto`.
      // See https://stackoverflow.com/a/66689926/434243.
      'min-h-0', 'h-full w-full overflow-auto', {
        'scroll-shadows': variant === 'raised'
      }, classes),
      "data-component": "Scroll",
      children: children
    }, void 0, false, {
      fileName: _jsxFileName$1n,
      lineNumber: 40,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1n,
    lineNumber: 39,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1m = "/home/runner/work/frontend-shared/frontend-shared/src/components/data/ScrollContainer.js";

const ScrollContainerNext = function ScrollContainer({
  children,
  classes,
  elementRef,
  borderless = false,
  ...htmlAttributes
}) {
  return o("div", { ...htmlAttributes,
    ref: downcastRef(elementRef),
    className: classnames('flex flex-col h-full w-full', // Prevent overflow by overriding `min-height: auto`.
    // See https://stackoverflow.com/a/66689926/434243.
    'min-h-0', {
      border: !borderless
    }, classes),
    "data-component": "ScrollContainer",
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$1m,
    lineNumber: 29,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1l = "/home/runner/work/frontend-shared/frontend-shared/src/components/data/ScrollContent.js";

const ScrollContentNext = function ScrollContent({
  children,
  classes,
  elementRef,
  ...htmlAttributes
}) {
  return o("div", { ...htmlAttributes,
    ref: downcastRef(elementRef),
    className: classnames('px-3 py-2', classes),
    "data-component": "ScrollContent",
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$1l,
    lineNumber: 22,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1k = "/home/runner/work/frontend-shared/frontend-shared/src/components/data/ScrollBox.js";

const ScrollBoxNext = function ScrollBox({
  children,
  elementRef,
  borderless = false,
  ...htmlAttributes
}) {
  return o(ScrollContainerNext, { ...htmlAttributes,
    borderless: borderless,
    elementRef: elementRef,
    "data-composite-component": "ScrollBox",
    children: o(ScrollNext, {
      children: o(ScrollContentNext, {
        children: children
      }, void 0, false, {
        fileName: _jsxFileName$1k,
        lineNumber: 35,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$1k,
      lineNumber: 34,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1k,
    lineNumber: 28,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1j = "/home/runner/work/frontend-shared/frontend-shared/src/components/feedback/Spinner.tsx";

/**
 * Style a spinner icon.
 */
const SpinnerNext = function Spinner({
  size = 'sm',
  color = 'text-light'
}) {
  return o(SpinnerSpokesIcon, {
    className: classnames({
      'text-color-text-light': color === 'text-light',
      // default
      'text-color-text': color === 'text',
      'text-color-text-inverted': color === 'text-inverted'
    }, {
      'w-em h-em': size === 'sm',
      // default
      'w-2em h-2em': size === 'md',
      'w-4em h-4em': size === 'lg'
    }),
    "data-component": "Spinner"
  }, void 0, false, {
    fileName: _jsxFileName$1j,
    lineNumber: 18,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1i = "/home/runner/work/frontend-shared/frontend-shared/src/components/data/Thumbnail.js";

const ThumbnailNext = function Thumbnail({
  children,
  elementRef,
  borderless = false,
  loading = false,
  placeholder,
  ratio = '16/9',
  size = 'md',
  ...htmlAttributes
}) {
  const emptyContent = placeholder !== null && placeholder !== void 0 ? placeholder : o(EllipsisIcon, {
    className: classnames('text-grey-5', {
      'w-4 h-4': size === 'sm' || size === 'md',
      // default (md)
      'w-8 h-8': size === 'lg'
    })
  }, void 0, false, {
    fileName: _jsxFileName$1i,
    lineNumber: 43,
    columnNumber: 5
  }, this); // If there are no `children`, render a placeholder (unless loading)

  const content = x$1(children).length ? children : o("div", {
    children: emptyContent
  }, void 0, false, {
    fileName: _jsxFileName$1i,
    lineNumber: 54,
    columnNumber: 5
  }, this);
  return o("div", { ...htmlAttributes,
    ref: downcastRef(elementRef),
    className: classnames('bg-grey-1 w-full h-full overflow-hidden', {
      'p-3': size === 'md' && !borderless,
      // default
      'p-2': size === 'sm' && !borderless,
      'p-4': size === 'lg' && !borderless,
      'p-0': borderless
    }),
    "data-composite-component": "Thumbnail",
    children: o("div", {
      className: "bg-white h-full w-full flex items-center justify-center overflow-hidden",
      children: o(AspectRatioNext, {
        ratio: ratio,
        children: loading ? o("div", {
          children: o(SpinnerNext, {
            size: size
          }, void 0, false, {
            fileName: _jsxFileName$1i,
            lineNumber: 73,
            columnNumber: 15
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName$1i,
          lineNumber: 72,
          columnNumber: 13
        }, this) : content
      }, void 0, false, {
        fileName: _jsxFileName$1i,
        lineNumber: 70,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$1i,
      lineNumber: 69,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1i,
    lineNumber: 58,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1h = "/home/runner/work/frontend-shared/frontend-shared/src/components/layout/Overlay.js";

const OverlayNext = function Overlay({
  children,
  classes,
  elementRef,
  open = true,
  variant = 'dark',
  ...htmlAttributes
}) {
  if (!open) {
    return null;
  }

  return o("div", { ...htmlAttributes,
    ref: downcastRef(elementRef),
    className: classnames('fixed top-0 left-0 w-full h-full z-10 flex items-center justify-center', {
      'bg-black/50': variant === 'dark',
      // default
      'bg-white/50': variant === 'light'
    }, classes),
    "data-component": "Overlay",
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$1h,
    lineNumber: 34,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1g = "/home/runner/work/frontend-shared/frontend-shared/src/components/feedback/SpinnerOverlay.js";

const SpinnerOverlayNext = function SpinnerOverlay({ ...htmlAttributes
}) {
  return o(OverlayNext, { ...htmlAttributes,
    variant: "light",
    "data-composite-component": "SpinnerOverlay",
    children: o(SpinnerNext, {
      size: "lg"
    }, void 0, false, {
      fileName: _jsxFileName$1g,
      lineNumber: 20,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1g,
    lineNumber: 15,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1f = "/home/runner/work/frontend-shared/frontend-shared/src/components/input/ButtonBase.js";

const ButtonBaseNext = function ButtonBase({
  elementRef,
  children,
  classes,
  unstyled = false,
  expanded,
  pressed,
  title,
  role,
  ...htmlAttributes
}) {
  /** @type {Record<string, unknown>} */
  const ariaProps = {
    'aria-label': title
  }; // aria-pressed and aria-expanded are not allowed for buttons with
  // an aria role of `tab`. Instead, the aria-selected attribute is expected.

  if (role === 'tab') {
    ariaProps['aria-selected'] = pressed;
  } else {
    ariaProps['aria-pressed'] = pressed;
    ariaProps['aria-expanded'] = expanded;
  }

  return o("button", {
    role: role !== null && role !== void 0 ? role : 'button',
    ...ariaProps,
    "data-base-component": "ButtonBase"
    /* data-component will be overwritten unless this component is used directly */
    ,
    "data-component": "ButtonBase",
    ...htmlAttributes,
    className: classnames({
      'focus-visible-ring': !unstyled,
      'transition-colors': !unstyled,
      // Set layout for button content
      'whitespace-nowrap flex items-center': !unstyled
    }, classes),
    title: title,
    ref: downcastRef(elementRef),
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$1f,
    lineNumber: 59,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1e = "/home/runner/work/frontend-shared/frontend-shared/src/components/input/Button.js";

const ButtonNext = function Button({
  children,
  classes,
  elementRef,
  expanded,
  pressed,
  title,
  icon: Icon,
  size = 'md',
  variant = 'secondary',
  ...htmlAttributes
}) {
  return o(ButtonBaseNext, { ...htmlAttributes,
    classes: classnames('focus-visible-ring transition-colors whitespace-nowrap flex items-center', 'font-semibold rounded-sm', {
      // Variants
      'text-grey-7 bg-grey-1 enabled:hover:text-grey-9 enabled:hover:bg-grey-2 aria-pressed:text-grey-9 aria-expanded:text-grey-9': variant === 'secondary',
      // default
      'text-grey-1 bg-grey-7 enabled:hover:bg-grey-8 disabled:text-grey-4': variant === 'primary'
    }, {
      // Sizes
      'p-2 gap-x-2': size === 'md',
      // default
      'p-1 gap-x-1': size === 'xs',
      'p-1.5 gap-x-1.5': size === 'sm',
      'p-2.5 gap-x-1.5': size === 'lg'
    }, classes),
    elementRef: downcastRef(elementRef),
    expanded: expanded,
    pressed: pressed,
    title: title,
    "data-component": "Button",
    unstyled: true,
    children: [Icon && o(Icon, {
      className: "w-em h-em"
    }, void 0, false, {
      fileName: _jsxFileName$1e,
      lineNumber: 70,
      columnNumber: 16
    }, this), children]
  }, void 0, true, {
    fileName: _jsxFileName$1e,
    lineNumber: 42,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1d = "/home/runner/work/frontend-shared/frontend-shared/src/components/input/Checkbox.js";

const CheckboxNext = function Checkbox({
  children,
  elementRef,
  checked,
  defaultChecked = false,
  icon: UncheckedIcon = CheckboxOutlineIcon,
  checkedIcon: CheckedIcon = CheckboxCheckedIcon,
  disabled,
  onChange,
  id,
  ...htmlAttributes
}) {
  // If `checked` is present, treat this as a controlled component
  const isControlled = typeof checked === 'boolean'; // Only use this local state if checkbox is uncontrolled

  const [uncontrolledChecked, setUncontrolledChecked] = p(defaultChecked);
  const isChecked = isControlled ? checked : uncontrolledChecked;
  /**
   * @param {import('preact').JSX.TargetedEvent<HTMLInputElement>} event
   * @this HTMLInputElement
   */

  function handleChange(event) {
    // preact event handlers expects `this` context to be of type `never`
    // https://github.com/preactjs/preact/issues/3137
    onChange === null || onChange === void 0 ? void 0 : onChange.call(
    /** @type {never} */
    this, event);

    if (!isControlled) {
      setUncontrolledChecked(
      /** @type {HTMLInputElement} */
      event.target.checked);
    }
  }

  return o("label", {
    className: classnames('relative flex items-center gap-x-1.5', {
      'cursor-pointer': !disabled,
      'opacity-70': disabled
    }),
    htmlFor: id,
    "data-composite-component": "Checkbox",
    children: [o("input", { ...htmlAttributes,
      type: "checkbox",
      ref: downcastRef(elementRef),
      className: classnames( // Position this atop the icon and size it to the same dimensions
      'absolute w-em h-em', // Make checkbox input visually hidden, but
      // some screen readers won't read out elements with 0 opacity
      'opacity-[.00001]', {
        'cursor-pointer': !disabled
      }),
      checked: isChecked,
      disabled: disabled,
      id: id,
      onChange: handleChange
    }, void 0, false, {
      fileName: _jsxFileName$1d,
      lineNumber: 75,
      columnNumber: 7
    }, this), isChecked ? o(CheckedIcon, {
      className: "w-em h-em"
    }, void 0, false, {
      fileName: _jsxFileName$1d,
      lineNumber: 95,
      columnNumber: 9
    }, this) : o(UncheckedIcon, {
      className: "w-em h-em"
    }, void 0, false, {
      fileName: _jsxFileName$1d,
      lineNumber: 97,
      columnNumber: 9
    }, this), children]
  }, void 0, true, {
    fileName: _jsxFileName$1d,
    lineNumber: 67,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1c = "/home/runner/work/frontend-shared/frontend-shared/src/components/input/InputGroup.js";
const inputGroupStyles = classnames( // All inputs within an InputGroup should have a border. Turn off border-radius
'input-group:border input-group:rounded-none', // Restore border-radius on the leftmost and rightmost components in the group
'input-group:first:rounded-l-sm input-group:last:rounded-r-sm', // "Collapse" borders between input components
'input-group:border-l-0 input-group:first:border-l');
/**
 * Render a container that lays out a group of input components
 *
 * @param {CommonProps & HTMLAttributes} props
 */

const InputGroupNext = function InputGroup({
  children,
  classes,
  elementRef,
  ...htmlAttributes
}) {
  return o("div", { ...htmlAttributes,
    ref: downcastRef(elementRef),
    className: classnames( // Set the `.input-group` class so that children may
    // use the `input-group:` variant in their styles
    'input-group', 'flex items-stretch w-full justify-center', classes),
    "data-component": "InputGroup",
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$1c,
    lineNumber: 34,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1b = "/home/runner/work/frontend-shared/frontend-shared/src/components/input/IconButton.js";

const IconButtonNext = function IconButton({
  children,
  classes,
  elementRef,
  pressed,
  expanded,
  icon: Icon,
  disableTouchSizing = false,
  size = 'md',
  title,
  variant = 'secondary',
  ...htmlAttributes
}) {
  return o(ButtonBaseNext, { ...htmlAttributes,
    classes: classnames('focus-visible-ring transition-colors whitespace-nowrap flex items-center', 'justify-center gap-x-2 rounded-sm', {
      // variant
      'text-grey-7 bg-transparent enabled:hover:text-grey-9 aria-pressed:text-brand aria-expanded:text-brand': variant === 'secondary',
      //default
      'text-brand bg-transparent enabled:hover:text-grey-9 disabled:text-grey-7': variant === 'primary',
      'text-grey-7 bg-grey-2 enabled:hover:text-grey-9 enabled:hover:bg-grey-3 disabled:text-grey-5 aria-pressed:bg-grey-3 aria-expanded:bg-grey-3': variant === 'dark',
      // size
      'p-2': size === 'md',
      // Default
      'p-1': size === 'xs',
      'p-1.5': size === 'sm',
      'p-2.5': size === 'lg',
      // Responsive
      'touch:min-w-touch-minimum touch:min-h-touch-minimum': !disableTouchSizing
    }, // Adapt styling when this component is inside an InputGroup
    inputGroupStyles, classes),
    elementRef: downcastRef(elementRef),
    title: title,
    pressed: pressed,
    expanded: expanded,
    "data-component": "IconButton",
    unstyled: true,
    children: [Icon && o(Icon, {
      className: "w-em h-em"
    }, void 0, false, {
      fileName: _jsxFileName$1b,
      lineNumber: 83,
      columnNumber: 16
    }, this), children]
  }, void 0, true, {
    fileName: _jsxFileName$1b,
    lineNumber: 48,
    columnNumber: 5
  }, this);
};

var _jsxFileName$1a = "/home/runner/work/frontend-shared/frontend-shared/src/components/input/Input.js";

const InputNext = function Input({
  children,
  classes,
  elementRef,
  hasError,
  type = 'text',
  ...htmlAttributes
}) {
  // @ts-expect-error - "aria-label" is missing from HTMLInputAttributes
  if (!htmlAttributes.id && !htmlAttributes['aria-label']) {
    console.warn('`Input` component should have either an `id` or an `aria-label` attribute');
  }

  return o("input", { ...htmlAttributes,
    type: type,
    ref: downcastRef(elementRef),
    className: classnames('focus-visible-ring ring-inset border rounded-sm w-full p-2', 'bg-grey-0 focus:bg-white disabled:bg-grey-1', 'placeholder:text-color-grey-5 disabled:placeholder:color-grey-6', {
      'ring-inset ring-2 ring-red-error': hasError
    }, // Adapt styles when this component is inside an InputGroup
    inputGroupStyles, classes),
    "data-component": "Input",
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$1a,
    lineNumber: 38,
    columnNumber: 5
  }, this);
};

var _jsxFileName$19 = "/home/runner/work/frontend-shared/frontend-shared/src/components/layout/Card.js";

const CardNext = function Card({
  children,
  classes,
  elementRef,
  active = false,
  variant = 'raised',
  width = 'full',
  ...htmlAttributes
}) {
  return o("div", { ...htmlAttributes,
    ref: downcastRef(elementRef),
    className: classnames('rounded-sm border bg-white', {
      'shadow hover:shadow-md': variant === 'raised',
      // default
      'shadow-md': active && variant === 'raised'
    }, {
      'w-full': width === 'full',
      // default
      'w-auto': width === 'auto' // No width is set if `width === 'custom'`

    }, classes),
    "data-component": "Card",
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$19,
    lineNumber: 36,
    columnNumber: 5
  }, this);
};

var _jsxFileName$18 = "/home/runner/work/frontend-shared/frontend-shared/src/components/layout/CardContent.js";

const CardContentNext = function CardContent({
  children,
  classes,
  elementRef,
  size = 'md',
  ...htmlAttributes
}) {
  return o("div", { ...htmlAttributes,
    ref: downcastRef(elementRef),
    className: classnames({
      'p-3 space-y-4': size === 'md',
      // Default
      'p-2 space-y-3': size === 'sm',
      'p-4 space-y-6': size === 'lg'
    }, classes),
    "data-component": "CardContent",
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$18,
    lineNumber: 28,
    columnNumber: 5
  }, this);
};

var _jsxFileName$17 = "/home/runner/work/frontend-shared/frontend-shared/src/components/layout/CardTitle.js";

const CardTitleNext = function CardTitle({
  children,
  classes,
  elementRef,
  ...htmlAttributes
}) {
  return o("div", { ...htmlAttributes,
    className: classnames('grow text-lg text-brand font-semibold', classes),
    ref: downcastRef(elementRef),
    "data-component": "CardTitle",
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$17,
    lineNumber: 24,
    columnNumber: 5
  }, this);
};

var _jsxFileName$16 = "/home/runner/work/frontend-shared/frontend-shared/src/components/layout/CardHeader.js";

const CardHeaderNext = function CardHeader({
  children,
  classes,
  elementRef,
  onClose,
  title,
  ...htmlAttributes
}) {
  return o("div", { ...htmlAttributes,
    className: classnames('flex items-center gap-x-2 mx-3 py-2 border-b', classes),
    ref: downcastRef(elementRef),
    "data-component": "CardHeader",
    children: [title && o(CardTitleNext, {
      children: title
    }, void 0, false, {
      fileName: _jsxFileName$16,
      lineNumber: 45,
      columnNumber: 17
    }, this), children, onClose && o(IconButtonNext, {
      onClick: onClose,
      title: "Close",
      children: o(CancelIcon, {}, void 0, false, {
        fileName: _jsxFileName$16,
        lineNumber: 49,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$16,
      lineNumber: 48,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$16,
    lineNumber: 36,
    columnNumber: 5
  }, this);
};

var _jsxFileName$15 = "/home/runner/work/frontend-shared/frontend-shared/src/components/layout/CardActions.js";

const CardActionsNext = function CardActions({
  children,
  classes,
  elementRef,
  ...htmlAttributes
}) {
  return o("div", { ...htmlAttributes,
    className: classnames('flex items-center justify-end space-x-3', classes),
    ref: downcastRef(elementRef),
    "data-component": "CardActions",
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$15,
    lineNumber: 23,
    columnNumber: 5
  }, this);
};

var _jsxFileName$14 = "/home/runner/work/frontend-shared/frontend-shared/src/components/layout/Panel.js";

const PanelNext = function Panel({
  children,
  elementRef,
  buttons,
  icon: Icon,
  onClose,
  title,
  ...htmlAttributes
}) {
  return o(CardNext, { ...htmlAttributes,
    elementRef: downcastRef(elementRef),
    "data-composite-component": "Panel",
    children: [o(CardHeaderNext, {
      onClose: onClose,
      children: [Icon && o(Icon, {
        className: "w-em h-em"
      }, void 0, false, {
        fileName: _jsxFileName$14,
        lineNumber: 47,
        columnNumber: 18
      }, this), o(CardTitleNext, {
        children: title
      }, void 0, false, {
        fileName: _jsxFileName$14,
        lineNumber: 48,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$14,
      lineNumber: 46,
      columnNumber: 7
    }, this), o(CardContentNext, {
      children: [children, buttons && o(CardActionsNext, {
        children: buttons
      }, void 0, false, {
        fileName: _jsxFileName$14,
        lineNumber: 52,
        columnNumber: 21
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$14,
      lineNumber: 50,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$14,
    lineNumber: 41,
    columnNumber: 5
  }, this);
};

var _jsxFileName$13 = "/home/runner/work/frontend-shared/frontend-shared/src/components/navigation/LinkBase.js";

const LinkBaseNext = function LinkBase({
  children,
  classes,
  elementRef,
  unstyled = false,
  ...htmlAttributes
}) {
  return o("a", {
    "data-base-component": "LinkBase"
    /* data-component will be overwritten unless this component is used directly */
    ,
    "data-component": "LinkBase",
    ...htmlAttributes,
    className: classnames({
      'focus-visible-ring': !unstyled
    }, classes),
    rel: "noopener noreferrer",
    ref: downcastRef(elementRef),
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$13,
    lineNumber: 24,
    columnNumber: 5
  }, this);
};

var _jsxFileName$12 = "/home/runner/work/frontend-shared/frontend-shared/src/components/navigation/Link.js";

const LinkNext = function Link({
  children,
  classes,
  elementRef,
  underline = 'none',
  color = 'brand',
  ...htmlAttributes
}) {
  return o(LinkBaseNext, { ...htmlAttributes,
    classes: classnames('rounded-sm', // NB: Base classes are applied by LinkBase
    {
      // color
      'text-brand hover:text-brand-dark': color === 'brand',
      // default
      'text-color-text-light hover:text-brand': color === 'text-light',
      'text-color-text hover:text-brand-dark': color === 'text'
    }, {
      // underline
      'no-underline hover:no-underline': underline === 'none',
      // default
      'underline hover:underline': underline === 'always',
      'no-underline hover:underline': underline === 'hover'
    }, classes),
    elementRef: downcastRef(elementRef),
    "data-component": "Link",
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$12,
    lineNumber: 32,
    columnNumber: 5
  }, this);
};

var _jsxFileName$11 = "/home/runner/work/frontend-shared/frontend-shared/src/components/navigation/LinkButton.js";

const LinkButtonNext = function LinkButton({
  children,
  classes,
  elementRef,
  color = 'brand',
  inline = false,
  underline = 'none',
  variant = 'secondary',
  ...htmlAttributes
}) {
  return o(ButtonBaseNext, { ...htmlAttributes,
    elementRef: downcastRef(elementRef),
    classes: classnames('focus-visible-ring transition-colors whitespace-nowrap', 'aria-pressed:font-semibold aria-expanded:font-semibold rounded-sm', {
      // inline
      inline: inline,
      'flex items-center': !inline
    }, {
      // color
      'text-brand enabled:hover:text-brand-dark': color === 'brand',
      // default
      'text-color-text enabled:hover:text-brand-dark': color === 'text',
      'text-color-text-light enabled:hover:text-brand': color === 'text-light'
    }, {
      // underline
      'no-underline hover:no-underline': underline === 'none',
      // default
      'underline enabled:hover:underline': underline === 'always',
      'no-underline enabled:hover:underline': underline === 'hover'
    }, {
      // variant
      // no exta styling for default 'secondary' variant
      'font-semibold': variant === 'primary'
    }, classes),
    "data-component": "LinkButton",
    unstyled: true,
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$11,
    lineNumber: 37,
    columnNumber: 5
  }, this);
};

// Hooks

/**
 * Parses H account names of the form 'acct:<username>@<provider>'
 * into a {username, provider} object or null if the input does not
 * match the expected form.
 *
 * @param {string|null} user
 */
function parseAccountID(user) {
  if (!user) {
    return null;
  }
  const match = user.match(/^acct:([^@]+)@(.+)/);
  if (!match) {
    return null;
  }
  return {
    username: match[1],
    provider: match[2]
  };
}

/**
 * Returns the username part of an account ID or an empty string.
 *
 * @param {string|null} user
 */
function username(user) {
  const account = parseAccountID(user);
  if (!account) {
    return '';
  }
  return account.username;
}

/**
 * Returns true if the user's provider (authority) differs from the default
 * authority for the application.
 *
 * @param {string|null} user
 * @param {string} defaultAuthority - The application's default authority
 *   (user identity provider)
 */
function isThirdPartyUser(user, defaultAuthority) {
  const account = parseAccountID(user);
  if (!account) {
    return false;
  }
  return account.provider !== defaultAuthority;
}

/**
 * @typedef {import("../../types/api").Annotation} Annotation
 * @typedef {import('../../types/config').SidebarSettings} SidebarSettings
 */

/**
 * What string should we use to represent the author (user) of a given
 * annotation: a display name or a username?
 *
 * The nice, human-readable display name should be used when a display_name
 * is available on the annotation AND:
 * - The author (user) associated with the annotation is a third-party user, OR
 * - The `client_display_names` feature flag is enabled
 *
 * Return the string that should be used for display on an annotation: either the
 * username or the display name.
 *
 * @param {Pick<Annotation, 'user'|'user_info'>} annotation
 * @param {string} defaultAuthority
 * @param {boolean} displayNamesEnabled
 *
 * @return {string}
 */
function annotationDisplayName(annotation, defaultAuthority, displayNamesEnabled) {
  var _annotation$user_info;
  const isThirdParty = isThirdPartyUser(annotation.user, defaultAuthority);
  const useDisplayName = displayNamesEnabled || isThirdParty;
  return useDisplayName && (_annotation$user_info = annotation.user_info) !== null && _annotation$user_info !== void 0 && _annotation$user_info.display_name ? annotation.user_info.display_name : username(annotation.user);
}

/**
 * Return a URL to the annotation author's user page, when available. Author
 * links for third-party users are only available if a `usernameUrl` is
 * provided in `settings`.
 *
 * @param {Pick<Annotation, 'user'>} annotation
 * @param {SidebarSettings} settings
 * @param {string} defaultAuthority
 * @param {string} [userLink]
 */
function annotationAuthorLink(annotation, settings, defaultAuthority, userLink) {
  var _ref;
  const isThirdParty = isThirdPartyUser(annotation.user, defaultAuthority);
  if (!isThirdParty && userLink) {
    return userLink;
  }
  return (_ref = settings.usernameUrl && `${settings.usernameUrl}${username(annotation.user)}`) !== null && _ref !== void 0 ? _ref : undefined;
}

/**
 * @typedef {import('../../types/api').Annotation} Annotation
 * @typedef {import('../../types/config').SidebarSettings} SidebarSettings
 */

/**
 * Retrieve an appropriate sharing link for this annotation.
 *
 * If the annotation is on a shareable document (i.e. its document is
 * web-accessible), prefer the `incontext` (bouncer) link, but fallback to the
 * `html` (single-annotation `h` web view) link if needed.
 *
 * If the annotation is not on a shareable document, don't use the `incontext`
 * link as that won't work; only use the single-annotation-view `html` link.
 *
 * Note that `html` links are not provided by the service for third-party
 * annotations.
 *
 * @param {Annotation} annotation
 * @return {string|null}
 */
function annotationSharingLink(annotation) {
  if (isShareableURI(annotation.uri)) {
    var _ref, _annotation$links$inc, _annotation$links, _annotation$links2;
    return (_ref = (_annotation$links$inc = (_annotation$links = annotation.links) === null || _annotation$links === void 0 ? void 0 : _annotation$links.incontext) !== null && _annotation$links$inc !== void 0 ? _annotation$links$inc : (_annotation$links2 = annotation.links) === null || _annotation$links2 === void 0 ? void 0 : _annotation$links2.html) !== null && _ref !== void 0 ? _ref : null;
  } else {
    var _annotation$links$htm, _annotation$links3;
    return (_annotation$links$htm = (_annotation$links3 = annotation.links) === null || _annotation$links3 === void 0 ? void 0 : _annotation$links3.html) !== null && _annotation$links$htm !== void 0 ? _annotation$links$htm : null;
  }
}

/**
 * Generate a URI for sharing: a bouncer link built to share annotations in
 * a specific group (groupID) on a specific document (documentURI). If the
 * `documentURI` provided is not a web-accessible URL, no link is generated.
 *
 * @param {string} documentURI
 * @param {string} groupID
 * @return {string|null}
 */
function pageSharingLink(documentURI, groupID) {
  if (!isShareableURI(documentURI)) {
    return null;
  }
  return `https://hyp.is/go?url=${encodeURIComponent(documentURI)}&group=${groupID}`;
}

/**
 * Are annotations made against `uri` meaningfully shareable? The
 * target URI needs to be available on the web, which here is determined by
 * a protocol of `http` or `https`.
 *
 * @param {string} uri
 * @return {boolean}
 */
function isShareableURI(uri) {
  return /^http(s?):/i.test(uri);
}

/**
 * Is the sharing of annotations enabled? Check for any defined `serviceConfig`,
 * but default to `true` if none found.
 *
 * @param {SidebarSettings} settings
 * @return {boolean}
 */
function sharingEnabled(settings) {
  const service = serviceConfig(settings);
  if ((service === null || service === void 0 ? void 0 : service.enableShareLinks) === false) {
    return false;
  }
  return true;
}

/**
 * Utils for working with permissions principals on annotations.
 *
 * This is the same as the `permissions` field retrieved on an annotation via
 * the API.
 *
 * Principals are strings of the form `type:id` where `type` is `'acct'` (for a
 * specific user) or `'group'` (for a group).
 *
 * @typedef Permissions
 * @prop {string[]} read - List of principals that can read the annotation
 * @prop {string[]} update - List of principals that can edit the annotation
 * @prop {string[]} delete - List of principals that can delete the
 * annotation
 */

/** @param {string|null} savedLevel */
function defaultLevel(savedLevel) {
  switch (savedLevel) {
    case 'private':
    case 'shared':
      return savedLevel;
    default:
      return 'shared';
  }
}

/**
 * Return the permissions for a private annotation.
 *
 * A private annotation is one which is readable only by its author.
 *
 * @param {string} userid - User ID of the author
 * @return {Permissions}
 */
function privatePermissions(userid) {
  return {
    read: [userid],
    update: [userid],
    delete: [userid]
  };
}

/**
 * Return the permissions for an annotation that is shared with the given
 * group.
 *
 * @param {string} userid - User ID of the author
 * @param {string} groupid - ID of the group the annotation is being
 * shared with
 * @return {Permissions}
 */
function sharedPermissions(userid, groupid) {
  return Object.assign(privatePermissions(userid), {
    read: ['group:' + groupid]
  });
}
/**
 * Return the default permissions for an annotation in a given group.
 *
 * @param {string} userid - User ID of the author
 * @param {string} groupid - ID of the group the annotation is being shared
 * with
 * @param {string|null} savedLevel
 * @return {Permissions}
 */
function defaultPermissions(userid, groupid, savedLevel) {
  if (defaultLevel(savedLevel) === 'private' && userid) {
    return privatePermissions(userid);
  } else {
    return sharedPermissions(userid, groupid);
  }
}

/**
 * Return true if an annotation with the given permissions is shared with any
 * group.
 *
 * @param {Permissions} perms
 * @return {boolean}
 */
function isShared(perms) {
  return perms.read.some(principal => {
    return principal.indexOf('group:') === 0;
  });
}

/**
 * Return true if an annotation with the given permissions is private.
 *
 * @param {Permissions} perms
 * @return {boolean}
 */
function isPrivate(perms) {
  return !isShared(perms);
}

/**
 * Return true if a user can perform the given `action` on an annotation.
 *
 * @param {Permissions} perms
 * @param {'update'|'delete'} action
 * @param {string|null} userid
 * @return {boolean}
 */
function permits(perms, action, userid) {
  return perms[action].indexOf(userid || '') !== -1;
}

/**
 * Copy the string `text` to the clipboard.
 *
 * In most browsers, this function can only be called in response to a user
 * gesture. For example in response to a "click" event.
 *
 * @throws {Error}
 *   This function may throw an exception if the browser rejects the attempt
 *   to copy text.
 * @param {string} text
 */
function copyText(text) {
  const temp = document.createElement('textarea'); // use textarea instead of input to preserve line breaks
  temp.value = text;
  temp.setAttribute('data-testid', 'copy-text');
  // Recipe from https://stackoverflow.com/a/34046084/14463679
  temp.contentEditable = 'true';
  document.body.appendChild(temp);
  temp.focus();
  try {
    const range = document.createRange();
    const selection = /** @type {Selection} */document.getSelection();
    selection.removeAllRanges();
    range.selectNodeContents(temp);
    selection.addRange(range);
    temp.setSelectionRange(0, temp.value.length);
    document.execCommand('copy');
  } finally {
    temp.remove();
  }
}

/**
 * Helper methods to identify browser versions and os types
 */

/**
 * Returns true when the OS is Mac OS.
 *
 * @param _userAgent {string} - Test seam
 */
const isMacOS = (_userAgent = window.navigator.userAgent) => {
  return _userAgent.indexOf('Mac OS') >= 0;
};

/**
 * Returns true when device is iOS.
 * https://stackoverflow.com/a/9039885/14463679
 *
 * @param _navigator {{platform: string, userAgent: string}}
 * @param _ontouchend {boolean}
 */
const isIOS = (_navigator = window.navigator, _ontouchend = 'ontouchend' in document) => {
  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(_navigator.platform) ||
  // iPad on iOS 13 detection
  _navigator.userAgent.includes('Mac') && _ontouchend;
};

/**
 * Returns true when the device is a touch device such
 * as android or iOS.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/@media/pointer#browser_compatibility
 *
 * @param _window {Window} - Test seam
 */
const isTouchDevice = (_window = window) => {
  return _window.matchMedia('(pointer: coarse)').matches;
};

var _jsxFileName$10 = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/MenuArrow.js";
function MenuArrow({
  classes,
  direction = 'up'
}) {
  const Icon = direction === 'up' ? PointerUpIcon : PointerDownIcon;
  return o(Icon, {
    name: "pointer",
    className: classnames('absolute inline z-2 text-grey-3 fill-white', classes)
  }, void 0, false, {
    fileName: _jsxFileName$10,
    lineNumber: 26,
    columnNumber: 5
  }, this);
}

var _jsxFileName$$ = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/ShareLinks.tsx";
/**
 * A single sharing link as a list item
 */
function ShareLink({
  label,
  icon: Icon,
  uri
}) {
  return o("li", {
    children: o(LinkBaseNext, {
      "aria-label": label,
      classes: "text-grey-6 hover:text-color-text block",
      href: uri,
      title: label,
      target: "_blank",
      children: o(Icon
      // Make the icons sized to the current text size to allow for
      // differently-sized sharing icon links
      , {
        className: "w-em h-em"
      }, void 0, false, {
        fileName: _jsxFileName$$,
        lineNumber: 33,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$$,
      lineNumber: 26,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$$,
    lineNumber: 25,
    columnNumber: 5
  }, this);
}
/**
 * A list of share links to social-media platforms.
 */
function ShareLinks({
  shareURI
}) {
  const encodedURI = encodeURIComponent(shareURI);
  return o("div", {
    className: "pt-2 border-t",
    children: o("ul", {
      className: "flex flex-row gap-x-4 items-center justify-center",
      children: [o(ShareLink, {
        icon: SocialTwitterIcon,
        label: "Tweet share link",
        uri: `https://twitter.com/intent/tweet?url=${encodedURI}&hashtags=annotated`
      }, void 0, false, {
        fileName: _jsxFileName$$,
        lineNumber: 56,
        columnNumber: 9
      }, this), o(ShareLink, {
        icon: SocialFacebookIcon,
        label: "Share on Facebook",
        uri: `https://www.facebook.com/sharer/sharer.php?u=${encodedURI}`
      }, void 0, false, {
        fileName: _jsxFileName$$,
        lineNumber: 62,
        columnNumber: 9
      }, this), o(ShareLink, {
        icon: EmailIcon,
        label: "Share via email",
        uri: `mailto:?subject=${encodeURIComponent("Let's Annotate")}&body=${encodedURI}`
      }, void 0, false, {
        fileName: _jsxFileName$$,
        lineNumber: 68,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$$,
      lineNumber: 55,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$$,
    lineNumber: 54,
    columnNumber: 5
  }, this);
}

var _jsxFileName$_ = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/AnnotationShareControl.js";
function selectionOverflowsInputElement() {
  // On iOS the selection overflows the input element
  // See: https://github.com/hypothesis/client/pull/2799
  return isIOS();
}

/**
 * "Popup"-style component for sharing a single annotation.
 *
 * @param {AnnotationShareControlProps} props
 */
function AnnotationShareControl({
  annotation,
  toastMessenger,
  group,
  shareUri
}) {
  const annotationIsPrivate = isPrivate(annotation.permissions);
  const inContextAvailable = isShareableURI(annotation.uri);
  const shareRef = _$1( /** @type {HTMLDivElement|null} */null);
  const inputRef = _$1( /** @type {HTMLInputElement|null} */null);
  const [isOpen, setOpen] = p(false);
  const wasOpen = _$1(isOpen);
  const toggleSharePanel = () => setOpen(!isOpen);
  const closePanel = () => setOpen(false);

  // Interactions outside of the component when it is open should close it
  useElementShouldClose(shareRef, isOpen, closePanel);
  h(() => {
    if (wasOpen.current !== isOpen) {
      wasOpen.current = isOpen;
      if (isOpen && !selectionOverflowsInputElement()) {
        var _inputRef$current, _inputRef$current2;
        // Panel was just opened: select and focus the share URI for convenience
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
        (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.select();
      }
    }
  }, [isOpen]);

  // FIXME: See https://github.com/hypothesis/client/issues/1542
  if (!group) {
    return null;
  }

  // NB: Sharing links (social media/email) are not currently shown for `html`
  // links. There are two reasons for this:
  // - Lack of vertical real estate available. The explanatory text about `html`
  //   links takes up several lines. Adding the sharing links below this runs
  //   the risk of interfering with the top bar or other elements outside of the
  //   annotation's card. This may be rectified with a design tweak, perhaps.
  // - Possible confusion about what the sharing link does. The difference
  //   between an `incontext` and `html` link likely isn't clear to users. This
  //   bears further discussion.
  const showShareLinks = inContextAvailable;
  const copyShareLink = () => {
    try {
      copyText(shareUri);
      toastMessenger.success('Copied share link to clipboard');
    } catch (err) {
      toastMessenger.error('Unable to copy link');
    }
  };

  // Generate some descriptive text about who may see the annotation if they
  // follow the share link.
  // First: Based on the type of the group the annotation is in, who would
  // be able to view it?
  const groupSharingInfo = group.type === 'private' ? o("span", {
    children: ["Only members of the group ", o("em", {
      children: group.name
    }, void 0, false, {
      fileName: _jsxFileName$_,
      lineNumber: 111,
      columnNumber: 35
    }, this), " may view this annotation."]
  }, void 0, true, {
    fileName: _jsxFileName$_,
    lineNumber: 110,
    columnNumber: 7
  }, this) : o("span", {
    children: "Anyone using this link may view this annotation."
  }, void 0, false, {
    fileName: _jsxFileName$_,
    lineNumber: 115,
    columnNumber: 7
  }, this);

  // However, if the annotation is marked as "only me" (`annotationIsPrivate` is `true`),
  // then group sharing settings are irrelevant—only the author may view the
  // annotation.
  const annotationSharingInfo = annotationIsPrivate ? o("span", {
    children: "Only you may view this annotation."
  }, void 0, false, {
    fileName: _jsxFileName$_,
    lineNumber: 122,
    columnNumber: 5
  }, this) : groupSharingInfo;
  return o("div", {
    className: "relative",
    ref: shareRef,
    children: [o(IconButton, {
      icon: "share",
      title: "Share",
      onClick: toggleSharePanel,
      expanded: isOpen
    }, void 0, false, {
      fileName: _jsxFileName$_,
      lineNumber: 129,
      columnNumber: 7
    }, this), isOpen && o(Card, {
      classes: classnames(
      // Prefer width 96 (24rem) but ensure that component isn't wider
      // than 85vw
      'w-96 max-w-[85vw]',
      // Position this Card above its IconButton. Account for larger
      // IconButtons in touch interfaces
      'absolute bottom-8 right-1 touch:bottom-touch-minimum', 'space-y-2 p-2',
      // Cards do not have a border in the clean theme. Turn it back on.
      'theme-clean:border theme-clean:border-solid theme-clean:border-grey-3'),
      children: [o("div", {
        className: "flex items-center",
        children: o("h2", {
          className: "text-brand text-lg font-medium",
          children: "Share this annotation"
        }, void 0, false, {
          fileName: _jsxFileName$_,
          lineNumber: 150,
          columnNumber: 13
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$_,
        lineNumber: 149,
        columnNumber: 11
      }, this), o("div", {
        className: classnames(
        // Slightly larger font size for touch devices to correspond with
        // larger button and input sizes
        'flex w-full text-sm touch:text-base'),
        children: o(TextInputWithButton, {
          children: [o(TextInput, {
            "aria-label": "Use this URL to share this annotation",
            type: "text",
            value: shareUri,
            readOnly: true,
            inputRef: inputRef
          }, void 0, false, {
            fileName: _jsxFileName$_,
            lineNumber: 162,
            columnNumber: 15
          }, this), o(IconButton, {
            icon: "copy",
            title: "Copy share link to clipboard",
            onClick: copyShareLink,
            variant: "dark"
          }, void 0, false, {
            fileName: _jsxFileName$_,
            lineNumber: 169,
            columnNumber: 15
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName$_,
          lineNumber: 161,
          columnNumber: 13
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$_,
        lineNumber: 154,
        columnNumber: 11
      }, this), o("div", {
        className: "text-base font-normal",
        "data-testid": "share-details",
        children: inContextAvailable ? o(p$2, {
          children: annotationSharingInfo
        }, void 0, false) : o(p$2, {
          children: "This annotation cannot be shared in its original context because it was made on a document that is not available on the web. This link shares the annotation by itself."
        }, void 0, false)
      }, void 0, false, {
        fileName: _jsxFileName$_,
        lineNumber: 177,
        columnNumber: 11
      }, this), showShareLinks && o(ShareLinks, {
        shareURI: shareUri
      }, void 0, false, {
        fileName: _jsxFileName$_,
        lineNumber: 188,
        columnNumber: 30
      }, this), o(MenuArrow, {
        direction: "down",
        classes: "bottom-[-9px] right-1 touch:right-[9px]"
      }, void 0, false, {
        fileName: _jsxFileName$_,
        lineNumber: 189,
        columnNumber: 11
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$_,
      lineNumber: 136,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$_,
    lineNumber: 128,
    columnNumber: 5
  }, this);
}
var AnnotationShareControl$1 = withServices(AnnotationShareControl, ['toastMessenger']);

var _jsxFileName$Z = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/AnnotationActionBar.tsx";
function flaggingEnabled(settings) {
  const service = serviceConfig(settings);
  if ((service === null || service === void 0 ? void 0 : service.allowFlagging) === false) {
    return false;
  }
  return true;
}
/**
 * A collection of buttons in the footer area of an annotation that take
 * actions on the annotation.
 *
 * @param {AnnotationActionBarProps} props
 */
function AnnotationActionBar({
  annotation,
  annotationsService,
  onReply,
  settings,
  toastMessenger
}) {
  const store = useSidebarStore();
  const userProfile = store.profile();
  const annotationGroup = store.getGroup(annotation.group);
  const isLoggedIn = store.isLoggedIn();

  // Is the current user allowed to take the given `action` on this annotation?
  const userIsAuthorizedTo = action => {
    return permits(annotation.permissions, action, userProfile.userid);
  };
  const showDeleteAction = userIsAuthorizedTo('delete');
  const showEditAction = userIsAuthorizedTo('update');

  //  Only authenticated users can flag an annotation, except the annotation's author.
  const showFlagAction = flaggingEnabled(settings) && !!userProfile.userid && userProfile.userid !== annotation.user;
  const shareLink = sharingEnabled(settings) && annotationSharingLink(annotation);
  const onDelete = async () => {
    const annType = annotationRole(annotation);
    if (await confirm({
      title: `Delete ${annType.toLowerCase()}?`,
      message: `Are you sure you want to delete this ${annType.toLowerCase()}?`,
      confirmAction: 'Delete'
    })) {
      try {
        await annotationsService.delete(annotation);
        toastMessenger.success(`${annType} deleted`, {
          visuallyHidden: true
        });
      } catch (err) {
        toastMessenger.error(err.message);
      }
    }
  };
  const onEdit = () => {
    store.createDraft(annotation, {
      tags: annotation.tags,
      text: annotation.text,
      isPrivate: isPrivate(annotation.permissions)
    });
  };
  const onFlag = () => {
    annotationsService.flag(annotation).catch(() => toastMessenger.error('Flagging annotation failed'));
  };
  const onReplyClick = () => {
    if (!isLoggedIn) {
      store.openSidebarPanel('loginPrompt');
      return;
    }
    onReply();
  };
  return o("div", {
    className: "flex text-xl",
    "data-testid": "annotation-action-bar",
    children: [showEditAction && o(IconButtonNext, {
      icon: EditIcon,
      title: "Edit",
      onClick: onEdit
    }, void 0, false, {
      fileName: _jsxFileName$Z,
      lineNumber: 124,
      columnNumber: 9
    }, this), showDeleteAction && o(IconButtonNext, {
      icon: TrashIcon,
      title: "Delete",
      onClick: onDelete
    }, void 0, false, {
      fileName: _jsxFileName$Z,
      lineNumber: 127,
      columnNumber: 9
    }, this), o(IconButtonNext, {
      icon: ReplyIcon,
      title: "Reply",
      onClick: onReplyClick
    }, void 0, false, {
      fileName: _jsxFileName$Z,
      lineNumber: 129,
      columnNumber: 7
    }, this), shareLink && o(AnnotationShareControl$1, {
      annotation: annotation,
      group: annotationGroup,
      shareUri: shareLink
    }, void 0, false, {
      fileName: _jsxFileName$Z,
      lineNumber: 131,
      columnNumber: 9
    }, this), showFlagAction && !annotation.flagged && o(IconButtonNext, {
      icon: FlagIcon,
      title: "Report this annotation to moderators",
      onClick: onFlag
    }, void 0, false, {
      fileName: _jsxFileName$Z,
      lineNumber: 138,
      columnNumber: 9
    }, this), showFlagAction && annotation.flagged && o(IconButtonNext, {
      pressed: true,
      icon: FlagFilledIcon,
      title: "Annotation has been reported to the moderators"
    }, void 0, false, {
      fileName: _jsxFileName$Z,
      lineNumber: 145,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$Z,
    lineNumber: 122,
    columnNumber: 5
  }, this);
}
var AnnotationActionBar$1 = withServices(AnnotationActionBar, ['annotationsService', 'settings', 'toastMessenger']);

/**
 * Watch for changes in the size (`clientWidth` and `clientHeight`) of
 * an element.
 *
 * Returns a cleanup function which should be called to remove observers when
 * updates are no longer needed.
 *
 * @param {Element} element - HTML element to watch
 * @param {(width: number, height: number) => void} onSizeChanged -
 *   Callback to invoke with the `clientWidth` and `clientHeight` of the
 *   element when a change in its size is detected.
 * @return {() => void}
 */
function observeElementSize(element, onSizeChanged) {
  if (typeof ResizeObserver !== 'undefined') {
    const observer = new ResizeObserver(() => onSizeChanged(element.clientWidth, element.clientHeight));
    observer.observe(element);
    return () => observer.disconnect();
  }
  const listeners = new ListenerCollection$1();

  // Fallback method which listens for the most common events that result in
  // element size changes:
  //
  // - Window size change
  // - Media loading and adjusting size to content
  // - DOM changes
  //
  // This is not comprehensive but it is simple to implement and good-enough for
  // our current use cases.

  let prevWidth = element.clientWidth;
  let prevHeight = element.clientHeight;
  const check = () => {
    if (prevWidth !== element.clientWidth || prevHeight !== element.clientHeight) {
      prevWidth = element.clientWidth;
      prevHeight = element.clientHeight;
      onSizeChanged(prevWidth, prevHeight);
    }
  };
  listeners.add(element, 'load', check);
  listeners.add(window, 'resize', check);
  const observer = new MutationObserver(check);
  observer.observe(element, {
    characterData: true,
    childList: true,
    subtree: true
  });
  return () => {
    listeners.removeAll();
    observer.disconnect();
  };
}

var _jsxFileName$Y = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Excerpt.js";
function InlineControls({
  isCollapsed,
  setCollapsed,
  linkStyle = {}
}) {
  return o("div", {
    className: classnames(
    // Position these controls at the bottom right of the excerpt
    'absolute block right-0 bottom-0',
    // Give extra width for larger tap target and gradient fade
    // Fade transparent-to-white left-to-right to make the toggle
    // control text (More/Less) more readable above other text.
    // This gradient is implemented to-left to take advantage of Tailwind's
    // automatic to-transparent calculation: this avoids Safari's problem
    // with transparents in gradients:
    // https://bugs.webkit.org/show_bug.cgi?id=150940
    // https://tailwindcss.com/docs/gradient-color-stops#fading-to-transparent
    'w-20 bg-gradient-to-l from-white'),
    children: o("div", {
      className: "flex justify-end",
      children: o(LinkButtonNext, {
        color: "text",
        onClick: () => setCollapsed(!isCollapsed),
        expanded: !isCollapsed,
        title: "Toggle visibility of full excerpt text",
        style: linkStyle,
        underline: "always",
        inline: true,
        children: isCollapsed ? 'More' : 'Less'
      }, void 0, false, {
        fileName: _jsxFileName$Y,
        lineNumber: 40,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$Y,
      lineNumber: 39,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$Y,
    lineNumber: 24,
    columnNumber: 5
  }, this);
}
const noop$1 = () => {};

/**
 * @typedef ExcerptProps
 * @prop {object} [children]
 * @prop {boolean} [inlineControls] - If `true`, the excerpt provides internal
 *   controls to expand and collapse the content. If `false`, the caller sets
 *   the collapsed state via the `collapse` prop.  When using inline controls,
 *   the excerpt is initially collapsed.
 * @prop {boolean} [collapse] - If the content should be truncated if its height
 *   exceeds `collapsedHeight + overflowThreshold`.  This prop is only used if
 *   `inlineControls` is false.
 * @prop {number} collapsedHeight - Maximum height of the container, in pixels,
 *   when it is collapsed.
 * @prop {number} [overflowThreshold] - An additional margin of pixels by which
 *   the content height can exceed `collapsedHeight` before it becomes collapsible.
 * @prop {(isCollapsible: boolean) => void} [onCollapsibleChanged] - Called when the content height
 *   exceeds or falls below `collapsedHeight + overflowThreshold`.
 * @prop {(collapsed: boolean) => void} [onToggleCollapsed] - When `inlineControls` is `false`, this
 *   function is called when the user requests to expand the content by clicking a
 *   zone at the bottom of the container.
 * @prop {object} [settings] - Used for theming.
 */

/**
 * A container which truncates its content when they exceed a specified height.
 *
 * The collapsed state of the container can be handled either via internal
 * controls (if `inlineControls` is `true`) or by the caller using the
 * `collapse` prop.
 *
 * @param {ExcerptProps} props
 */
function Excerpt({
  children,
  collapse = false,
  collapsedHeight,
  inlineControls = true,
  onCollapsibleChanged = noop$1,
  onToggleCollapsed = noop$1,
  overflowThreshold = 0,
  settings = {}
}) {
  const [collapsedByInlineControls, setCollapsedByInlineControls] = p(true);
  const contentElement = /** @type {{ current: HTMLDivElement }} */_$1();

  // Measured height of `contentElement` in pixels
  const [contentHeight, setContentHeight] = p(0);

  // Update the measured height of the content container after initial render,
  // and when the size of the content element changes.
  const updateContentHeight = T$1(() => {
    const newContentHeight = contentElement.current.clientHeight;
    setContentHeight(newContentHeight);

    // prettier-ignore
    const isCollapsible = newContentHeight > collapsedHeight + overflowThreshold;
    onCollapsibleChanged(isCollapsible);
  }, [collapsedHeight, onCollapsibleChanged, overflowThreshold]);
  s(() => {
    const cleanup = observeElementSize(contentElement.current, updateContentHeight);
    updateContentHeight();
    return cleanup;
  }, [updateContentHeight]);

  // Render the (possibly truncated) content and controls for
  // expanding/collapsing the content.
  // prettier-ignore
  const isOverflowing = contentHeight > collapsedHeight + overflowThreshold;
  const isCollapsed = inlineControls ? collapsedByInlineControls : collapse;
  const isExpandable = isOverflowing && isCollapsed;

  /** @type {Record<string, number>} */
  const contentStyle = {};
  if (contentHeight !== 0) {
    contentStyle['max-height'] = isExpandable ? collapsedHeight : contentHeight;
  }

  /** @param {boolean} collapsed */
  const setCollapsed = collapsed => inlineControls ? setCollapsedByInlineControls(collapsed) : onToggleCollapsed(collapsed);
  return o("div", {
    "data-testid": "excerpt-container",
    className: classnames('relative overflow-hidden', 'transition-[max-height] ease-in duration-150'),
    style: contentStyle,
    children: [o("div", {
      className: classnames(
      // Establish new block-formatting context to prevent margin-collapsing
      // in descendent elements from potentially "leaking out" and pushing
      // this element down from the top of the container.
      // See https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context
      // See https://github.com/hypothesis/client/issues/1518
      'inline-block w-full'),
      "data-testid": "excerpt-content",
      ref: contentElement,
      children: children
    }, void 0, false, {
      fileName: _jsxFileName$Y,
      lineNumber: 156,
      columnNumber: 7
    }, this), o("div", {
      "data-testid": "excerpt-expand",
      role: "presentation",
      onClick: () => setCollapsed(false),
      className: classnames(
      // This element provides a clickable area at the bottom of an
      // expandable excerpt to expand it.
      'transition-[opacity] duration-150 ease-linear', 'absolute w-full bottom-0 h-touch-minimum', {
        // For expandable excerpts not using inlineControls, style this
        // element with a custom shadow-like gradient
        'bg-gradient-to-b from-excerpt-stop-1 via-excerpt-stop-2 to-excerpt-stop-3': !inlineControls && isExpandable,
        'bg-none': inlineControls,
        // Don't make this shadow visible OR clickable if there's nothing
        // to do here (the excerpt isn't expandable)
        'opacity-0 pointer-events-none': !isExpandable
      }),
      title: "Show the full excerpt"
    }, void 0, false, {
      fileName: _jsxFileName$Y,
      lineNumber: 170,
      columnNumber: 7
    }, this), isOverflowing && inlineControls && o(InlineControls, {
      isCollapsed: collapsedByInlineControls,
      setCollapsed: setCollapsed,
      linkStyle: applyTheme(['selectionFontFamily'], settings)
    }, void 0, false, {
      fileName: _jsxFileName$Y,
      lineNumber: 193,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$Y,
    lineNumber: 148,
    columnNumber: 5
  }, this);
}
var Excerpt$1 = withServices(Excerpt, ['settings']);

/**
 * Return an HTML5 audio player with the given src URL.
 *
 * @param {string} src
 */
function audioElement(src) {
  const html5audio = document.createElement('audio');
  html5audio.controls = true;
  html5audio.src = src;
  return html5audio;
}

/**
 * Wrap an element in a container that causes the element to be displayed at
 * a given aspect ratio.
 *
 * See https://css-tricks.com/aspect-ratio-boxes/.
 *
 * @param {HTMLElement} element
 * @param {number} aspectRatio - Aspect ratio as `width/height`
 * @return {HTMLElement}
 */
function wrapInAspectRatioContainer(element, aspectRatio) {
  element.style.position = 'absolute';
  element.style.top = '0';
  element.style.left = '0';
  element.style.width = '100%';
  element.style.height = '100%';
  const container = document.createElement('div');
  container.style.paddingBottom = `${1 / aspectRatio * 100}%`;
  container.style.position = 'relative';
  container.appendChild(element);
  return container;
}

/**
 * Return an iframe DOM element with the given src URL.
 *
 * @param {string} src
 * @param {number} [aspectRatio]
 */
function iframe(src, aspectRatio = 16 / 9) {
  const iframe_ = document.createElement('iframe');
  iframe_.src = src;
  iframe_.setAttribute('frameborder', '0');
  iframe_.setAttribute('allowfullscreen', '');
  return wrapInAspectRatioContainer(iframe_, aspectRatio);
}

/**
 * Return timeValue as a value in seconds, supporting `t` param's optional
 * '\dh\dm\ds' format. If `timeValue` is numeric (only),
 * it's assumed to be seconds and is left alone.
 *
 * @param {string} timeValue - value of `t` or `start` param in YouTube URL
 * @return {string} timeValue in seconds
 * @example
 * formatYouTubeTime('5m'); // returns '300'
 * formatYouTubeTime('20m10s'); // returns '1210'
 * formatYouTubeTime('1h1s'); // returns '3601'
 * formatYouTubeTime('10'); // returns '10'
 **/
function parseTimeString(timeValue) {
  const timePattern = /(\d+)([hms]?)/g;
  const multipliers = {
    h: 60 * 60,
    m: 60,
    s: 1
  };
  let seconds = 0;
  let match;
  // match[1] - Numeric value
  // match[2] - Unit (e.g. 'h','m','s', or empty)
  while ((match = timePattern.exec(timeValue)) !== null) {
    if (match[2]) {
      const unit = /** @type {keyof multipliers} */match[2];
      seconds += Number(match[1]) * multipliers[unit];
    } else {
      seconds += +match[1]; // Treat values missing units as seconds
    }
  }

  return seconds.toString();
}

/**
 * Return a YouTube URL query string containing (only) whitelisted params.
 * See https://developers.google.com/youtube/player_parameters for
 * all parameter possibilities.
 *
 * @param {HTMLAnchorElement} link
 * @return {string} formatted filtered URL query string, e.g. '?start=90' or
 *   an empty string if the filtered query is empty.
 * @example
 * // returns '?end=10&start=5'
 * youTubeQueryParams(link); // where `link.search` = '?t=5&baz=foo&end=10'
 * // - `t` is translated to `start`
 * // - `baz` is not allowed param
 * // - param keys are sorted
 *
 * @param {HTMLAnchorElement} link
 */
function youTubeQueryParams(link) {
  const allowedParams = ['end', 'start', 't' // will be translated to `start`
  ];

  const linkParams = new URLSearchParams(link.search);
  const filteredQuery = new URLSearchParams();

  // Copy allowed params into `filteredQuery`.
  for (let [key, value] of linkParams) {
    if (!allowedParams.includes(key)) {
      continue;
    }
    if (key === 't') {
      // `t` is not supported in embeds; `start` is
      // `t` accepts more formats than `start`; start must be in seconds
      // so, format it as seconds first
      filteredQuery.append('start', parseTimeString(value));
    } else {
      filteredQuery.append(key, value);
    }
  }

  // Tests currently expect sorted parameters.
  filteredQuery.sort();
  let query = filteredQuery.toString();
  if (query) {
    query = `?${query}`;
  }
  return query;
}
/**
 * Return a YouTube embed (<iframe>) DOM element for the given video ID.
 *
 * @param {string} id
 * @param {HTMLAnchorElement} link
 */
function youTubeEmbed(id, link) {
  const query = youTubeQueryParams(link);
  return iframe(`https://www.youtube.com/embed/${id}${query}`);
}

/**
 * Create an iframe embed generator for links that have the form
 * `https://<hostname>/<path containing a video ID>`
 *
 * @param {string} hostname
 * @param {RegExp} pathPattern -
 *   Pattern to match against the pathname part of the link. This regex should
 *   contain a single capture group which matches the video ID within the path.
 * @param {(videoId: string) => string} iframeUrlGenerator -
 *   Generate the URL for an embedded video iframe from a video ID
 * @param {object} options
 *   @param {number} [options.aspectRatio]
 * @return {(link: HTMLAnchorElement) => HTMLElement|null}
 */
function createEmbedGenerator(hostname, pathPattern, iframeUrlGenerator, {
  aspectRatio
} = {}) {
  /** @param {HTMLAnchorElement} link */
  const generator = link => {
    if (link.hostname !== hostname) {
      return null;
    }
    const groups = pathPattern.exec(link.pathname);
    if (!groups) {
      return null;
    }
    const id = groups[1];
    return iframe(iframeUrlGenerator(id), aspectRatio);
  };
  return generator;
}

/**
 * A list of functions that return an "embed" DOM element (e.g. an <iframe> or
 * an html5 <audio> element) for a given link.
 *
 * Each function either returns `undefined` if it can't generate an embed for
 * the link, or a DOM element if it can.
 *
 * @type {Array<(link: HTMLAnchorElement) => (HTMLElement|null)>}
 */
const embedGenerators = [
// Matches URLs like https://www.youtube.com/watch?v=rw6oWkCojpw
function iframeFromYouTubeWatchURL(link) {
  if (link.hostname !== 'www.youtube.com') {
    return null;
  }
  if (!/\/watch\/?/.test(link.pathname)) {
    return null;
  }
  const groups = /[&?]v=([^&#]+)/.exec(link.search);
  if (groups) {
    return youTubeEmbed(groups[1], link);
  }
  return null;
},
// Matches URLs like https://youtu.be/rw6oWkCojpw
function iframeFromYouTubeShareURL(link) {
  if (link.hostname !== 'youtu.be') {
    return null;
  }

  // extract video ID from URL
  const groups = /^\/([^/]+)\/?$/.exec(link.pathname);
  if (groups) {
    return youTubeEmbed(groups[1], link);
  }
  return null;
},
// Matches URLs like https://vimeo.com/149000090
createEmbedGenerator('vimeo.com', /^\/([^/?#]+)\/?$/, id => `https://player.vimeo.com/video/${id}`),
// Matches URLs like https://vimeo.com/channels/staffpicks/148845534
createEmbedGenerator('vimeo.com', /^\/channels\/[^/]+\/([^/?#]+)\/?$/, id => `https://player.vimeo.com/video/${id}`),
// Matches URLs like https://flipgrid.com/s/030475b8ceff
createEmbedGenerator('flipgrid.com', /^\/s\/([^/]+)$/, id => `https://flipgrid.com/s/${id}?embed=true`),
/**
 * Match Internet Archive URLs
 *
 *  The patterns are:
 *
 *  1. https://archive.org/embed/{slug}?start={startTime}&end={endTime}
 *     (Embed links)
 *
 *  2. https://archive.org/details/{slug}?start={startTime}&end={endTime}
 *     (Video page links for most videos)
 *
 *  3. https://archive.org/details/{slug}/start/{startTime}/end/{endTime}
 *     (Video page links for the TV News Archive [1])
 *
 *  (2) and (3) allow users to copy and paste URLs from archive.org video
 *  details pages directly into the sidebar to generate video embeds.
 *
 *  [1] https://archive.org/details/tv
 */
function iFrameFromInternetArchiveLink(link) {
  if (link.hostname !== 'archive.org') {
    return null;
  }

  // Extract the unique slug from the path.
  const slugMatch = /^\/(embed|details)\/(.+)/.exec(link.pathname);
  if (!slugMatch) {
    return null;
  }

  // Extract start and end times, which may appear either as query string
  // params or path params.
  let slug = slugMatch[2];
  const linkParams = new URLSearchParams(link.search);
  let startTime = linkParams.get('start');
  let endTime = linkParams.get('end');
  if (!startTime) {
    const startPathParam = slug.match(/\/start\/([^/]+)/);
    if (startPathParam) {
      startTime = startPathParam[1];
      slug = slug.replace(startPathParam[0], '');
    }
  }
  if (!endTime) {
    const endPathParam = slug.match(/\/end\/([^/]+)/);
    if (endPathParam) {
      endTime = endPathParam[1];
      slug = slug.replace(endPathParam[0], '');
    }
  }

  // Generate embed URL.
  const iframeUrl = new URL(`https://archive.org/embed/${slug}`);
  if (startTime) {
    iframeUrl.searchParams.append('start', startTime);
  }
  if (endTime) {
    iframeUrl.searchParams.append('end', endTime);
  }
  return iframe(iframeUrl.href);
},
// Matches URLs that end with .mp3, .ogg, or .wav (assumed to be audio files)
function html5audioFromMp3Link(link) {
  if (link.pathname.endsWith('.mp3') || link.pathname.endsWith('.ogg') || link.pathname.endsWith('.wav')) {
    return audioElement(link.href);
  }
  return null;
}];

/**
 * Return an embed element for the given link if it's an embeddable link.
 *
 * If the link is a link for a YouTube video or other embeddable media then
 * return an embed DOM element (for example an <iframe>) for that media.
 *
 * Otherwise return undefined.
 *
 * @param {HTMLAnchorElement} link
 * @return {HTMLElement|null}
 */
function embedForLink(link) {
  let embed;
  let j;
  for (j = 0; j < embedGenerators.length; j++) {
    embed = embedGenerators[j](link);
    if (embed) {
      return embed;
    }
  }
  return null;
}

/**
 * Replace the given link element with an embed.
 *
 * If the given link element is a link to an embeddable media and if its link
 * text is the same as its href then it will be replaced in the DOM with an
 * embed (e.g. an <iframe> or html5 <audio> element) of the same media.
 *
 * If the link text is different from the href, then the link will be left
 * untouched. We want to convert links like these from the Markdown source into
 * embeds:
 *
 *     https://vimeo.com/channels/staffpicks/148845534
 *     <https://vimeo.com/channels/staffpicks/148845534>
 *
 * But we don't want to convert links like this:
 *
 *     [Custom link text](https://vimeo.com/channels/staffpicks/148845534)
 *
 * because doing so would destroy the user's custom link text, and leave users
 * with no way to just insert a media link without it being embedded.
 *
 * If the link is not a link to an embeddable media it will be left untouched.
 *
 * @param {HTMLAnchorElement} link
 * @return {HTMLElement|null}
 */
function replaceLinkWithEmbed(link) {
  // The link's text may or may not be percent encoded. The `link.href` property
  // will always be percent encoded. When comparing the two we need to be
  // agnostic as to which representation is used.
  if (link.href !== link.textContent) {
    try {
      const encodedText = encodeURI( /** @type {string} */link.textContent);
      if (link.href !== encodedText) {
        return null;
      }
    } catch {
      return null;
    }
  }
  const embed = embedForLink(link);
  if (embed) {
    /** @type {Element} */link.parentElement.replaceChild(embed, link);
  }
  return embed;
}

/**
 * Replace all embeddable link elements beneath the given element with embeds.
 *
 * All links to YouTube videos or other embeddable media will be replaced with
 * embeds of the same media.
 *
 * @param {HTMLElement} element
 * @param {object} options
 *   @param {string} [options.className] -
 *     Class name to apply to embed containers. An important function of this class is to set
 *     the width of the embed.
 */
function replaceLinksWithEmbeds(element, {
  className
} = {}) {
  // Get a static (non-live) list of <a> children of `element`.
  // It needs to be static because we may replace these elements as we iterate over them.
  const links = Array.from(element.getElementsByTagName('a'));
  for (let link of links) {
    const embed = replaceLinkWithEmbed(link);
    if (embed) {
      if (className) {
        embed.className = className;
      } else {
        // Default width.
        embed.style.width = '350px';
      }
    }
  }
}

/*! @license DOMPurify 2.4.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.0/LICENSE */

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var hasOwnProperty = Object.hasOwnProperty,
    setPrototypeOf = Object.setPrototypeOf,
    isFrozen = Object.isFrozen,
    getPrototypeOf = Object.getPrototypeOf,
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze,
    seal = Object.seal,
    create = Object.create; // eslint-disable-line import/no-mutable-exports

var _ref = typeof Reflect !== 'undefined' && Reflect,
    apply = _ref.apply,
    construct = _ref.construct;

if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}

if (!freeze) {
  freeze = function freeze(x) {
    return x;
  };
}

if (!seal) {
  seal = function seal(x) {
    return x;
  };
}

if (!construct) {
  construct = function construct(Func, args) {
    return _construct(Func, _toConsumableArray(args));
  };
}

var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function (thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return construct(func, args);
  };
}
/* Add properties to a lookup table */

function addToSet(set, array, transformCaseFunc) {
  transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;

  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }

  var l = array.length;

  while (l--) {
    var element = array[l];

    if (typeof element === 'string') {
      var lcElement = transformCaseFunc(element);

      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }

        element = lcElement;
      }
    }

    set[element] = true;
  }

  return set;
}
/* Shallow clone an object */

function clone(object) {
  var newObject = create(null);
  var property;

  for (property in object) {
    if (apply(hasOwnProperty, object, [property])) {
      newObject[property] = object[property];
    }
  }

  return newObject;
}
/* IE10 doesn't support __lookupGetter__ so lets'
 * simulate it. It also automatically checks
 * if the prop is function or getter and behaves
 * accordingly. */

function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);

    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }

      if (typeof desc.value === 'function') {
        return unapply(desc.value);
      }
    }

    object = getPrototypeOf(object);
  }

  function fallbackValue(element) {
    console.warn('fallback value for', element);
    return null;
  }

  return fallbackValue;
}

var html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

var svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.

var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
var mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']); // Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.

var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
var text$2 = freeze(['#text']);

var html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);
var svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
var mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);
var DOCTYPE_NAME = seal(/^html$/i);

var getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};
/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
 * @param {Document} document The document object (to determine policy name suffix)
 * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
 * are not supported).
 */


var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
  if (_typeof(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  } // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.


  var suffix = null;
  var ATTR_NAME = 'data-tt-policy-suffix';

  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document.currentScript.getAttribute(ATTR_NAME);
  }

  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html) {
        return html;
      },
      createScriptURL: function createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};

function createDOMPurify() {
  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

  var DOMPurify = function DOMPurify(root) {
    return createDOMPurify(root);
  };
  /**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */


  DOMPurify.version = '2.4.0';
  /**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */

  DOMPurify.removed = [];

  if (!window || !window.document || window.document.nodeType !== 9) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;
    return DOMPurify;
  }

  var originalDocument = window.document;
  var document = window.document;
  var DocumentFragment = window.DocumentFragment,
      HTMLTemplateElement = window.HTMLTemplateElement,
      Node = window.Node,
      Element = window.Element,
      NodeFilter = window.NodeFilter,
      _window$NamedNodeMap = window.NamedNodeMap,
      NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
      HTMLFormElement = window.HTMLFormElement,
      DOMParser = window.DOMParser,
      trustedTypes = window.trustedTypes;
  var ElementPrototype = Element.prototype;
  var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
  var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
  var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
  var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.

  if (typeof HTMLTemplateElement === 'function') {
    var template = document.createElement('template');

    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }

  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);

  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
  var _document = document,
      implementation = _document.implementation,
      createNodeIterator = _document.createNodeIterator,
      createDocumentFragment = _document.createDocumentFragment,
      getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;
  var documentMode = {};

  try {
    documentMode = clone(document).documentMode ? document.documentMode : {};
  } catch (_) {}

  var hooks = {};
  /**
   * Expose whether this browser supports running the full DOMPurify.
   */

  DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;
  var MUSTACHE_EXPR$1 = MUSTACHE_EXPR,
      ERB_EXPR$1 = ERB_EXPR,
      DATA_ATTR$1 = DATA_ATTR,
      ARIA_ATTR$1 = ARIA_ATTR,
      IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA,
      ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */

  /* allowed element names */

  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text$2)));
  /* Allowed attribute names */

  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
  /*
   * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
   */

  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

  var FORBID_TAGS = null;
  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

  var FORBID_ATTR = null;
  /* Decide if ARIA attributes are okay */

  var ALLOW_ARIA_ATTR = true;
  /* Decide if custom data attributes are okay */

  var ALLOW_DATA_ATTR = true;
  /* Decide if unknown protocols are okay */

  var ALLOW_UNKNOWN_PROTOCOLS = false;
  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */

  var SAFE_FOR_TEMPLATES = false;
  /* Decide if document with <html>... should be returned */

  var WHOLE_DOCUMENT = false;
  /* Track whether config is already set on this instance of DOMPurify. */

  var SET_CONFIG = false;
  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */

  var FORCE_BODY = false;
  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */

  var RETURN_DOM = false;
  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */

  var RETURN_DOM_FRAGMENT = false;
  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */

  var RETURN_TRUSTED_TYPE = false;
  /* Output should be free from DOM clobbering attacks?
   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
   */

  var SANITIZE_DOM = true;
  /* Achieve full DOM Clobbering protection by isolating the namespace of named
   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
   *
   * HTML/DOM spec rules that enable DOM Clobbering:
   *   - Named Access on Window (§7.3.3)
   *   - DOM Tree Accessors (§3.1.5)
   *   - Form Element Parent-Child Relations (§4.10.3)
   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
   *   - HTMLCollection (§4.2.10.2)
   *
   * Namespace isolation is implemented by prefixing `id` and `name` attributes
   * with a constant string, i.e., `user-content-`
   */

  var SANITIZE_NAMED_PROPS = false;
  var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
  /* Keep element content when removing element? */

  var KEEP_CONTENT = true;
  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */

  var IN_PLACE = false;
  /* Allow usage of profiles like html, svg and mathMl */

  var USE_PROFILES = {};
  /* Tags to ignore content of when KEEP_CONTENT is true */

  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
  /* Tags that are safe for data: URIs */

  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
  /* Attributes safe for values like "javascript:" */

  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
  var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
  /* Document namespace */

  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;
  /* Parsing of strict XHTML documents */

  var PARSER_MEDIA_TYPE;
  var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
  var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
  var transformCaseFunc;
  /* Keep a reference to config to pass to hooks */

  var CONFIG = null;
  /* Ideally, do not touch anything below this line */

  /* ______________________________________________ */

  var formElement = document.createElement('form');

  var isRegexOrFunction = function isRegexOrFunction(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  /**
   * _parseConfig
   *
   * @param  {Object} cfg optional config literal
   */
  // eslint-disable-next-line complexity


  var _parseConfig = function _parseConfig(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    /* Shield configuration object from tampering */


    if (!cfg || _typeof(cfg) !== 'object') {
      cfg = {};
    }
    /* Shield configuration object from prototype pollution */


    cfg = clone(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.

    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {
      return x;
    } : stringToLowerCase;
    /* Set configuration parameters */

    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent
    cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent
    transformCaseFunc // eslint-disable-line indent
    ) // eslint-disable-line indent
    : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent
    cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent
    transformCaseFunc // eslint-disable-line indent
    ) // eslint-disable-line indent
    : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

    RETURN_DOM = cfg.RETURN_DOM || false; // Default false

    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false

    FORCE_BODY = cfg.FORCE_BODY || false; // Default false

    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false

    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

    IN_PLACE = cfg.IN_PLACE || false; // Default false

    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;

    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }

    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }

    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }

    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }

    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    /* Parse profile info */


    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, _toConsumableArray(text$2));
      ALLOWED_ATTR = [];

      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }

      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    /* Merge configuration parameters */


    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }

      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }

    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }

      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }

    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }

    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }

      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    /* Add #text in case KEEP_CONTENT is set to true */


    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }
    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }
    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */


    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
      delete FORBID_TAGS.tbody;
    } // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.


    if (freeze) {
      freeze(cfg);
    }

    CONFIG = cfg;
  };

  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
  var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML
  // namespace. We need to specify them explicitly
  // so that they don't get erroneously deleted from
  // HTML namespace.

  var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */

  var ALL_SVG_TAGS = addToSet({}, svg$1);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  /**
   *
   *
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */

  var _checkValidNamespace = function _checkValidNamespace(element) {
    var parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.

    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: 'template'
      };
    }

    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);

    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg';
      } // The only way to switch from MathML to SVG is via
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.


      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      } // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.


      return Boolean(ALL_SVG_TAGS[tagName]);
    }

    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math';
      } // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points


      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
      } // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.


      return Boolean(ALL_MATHML_TAGS[tagName]);
    }

    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      } // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace


      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    } // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG or MathML). Return false just in case.


    return false;
  };
  /**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */


  var _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });

    try {
      // eslint-disable-next-line unicorn/prefer-dom-node-remove
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_) {
        node.remove();
      }
    }
  };
  /**
   * _removeAttribute
   *
   * @param  {String} name an Attribute name
   * @param  {Node} node a DOM node
   */


  var _removeAttribute = function _removeAttribute(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }

    node.removeAttribute(name); // We void attribute values for unremovable "is"" attributes

    if (name === 'is' && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {}
      } else {
        try {
          node.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };
  /**
   * _initDocument
   *
   * @param  {String} dirty a string of dirty markup
   * @return {Document} a DOM, filled with the dirty markup
   */


  var _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    var doc;
    var leadingWhitespace;

    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }

    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {
      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
    }

    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */

    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {}
    }
    /* Use createHTMLDocument in case DOMParser is not available */


    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null);

      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
      } catch (_) {// Syntax error if dirtyPayload is invalid xml
      }
    }

    var body = doc.body || doc.documentElement;

    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    /* Work on whole document or just its body */


    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    }

    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  /**
   * _createIterator
   *
   * @param  {Document} root document/fragment to create iterator for
   * @return {Iterator} iterator instance
   */


  var _createIterator = function _createIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
  };
  /**
   * _isClobbered
   *
   * @param  {Node} elm element to check for clobbering attacks
   * @return {Boolean} true if clobbered, false if safe
   */


  var _isClobbered = function _isClobbered(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');
  };
  /**
   * _isNode
   *
   * @param  {Node} obj object to check whether it's a DOM node
   * @return {Boolean} true is object is a DOM node
   */


  var _isNode = function _isNode(object) {
    return _typeof(Node) === 'object' ? object instanceof Node : object && _typeof(object) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
  };
  /**
   * _executeHook
   * Execute user configurable hooks
   *
   * @param  {String} entryPoint  Name of the hook's entry point
   * @param  {Node} currentNode node to work on with the hook
   * @param  {Object} data additional hook parameters
   */


  var _executeHook = function _executeHook(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }

    arrayForEach(hooks[entryPoint], function (hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   *
   * @param   {Node} currentNode to check for permission to exist
   * @return  {Boolean} true if node was killed, false if left alive
   */


  var _sanitizeElements = function _sanitizeElements(currentNode) {
    var content;
    /* Execute a hook if present */

    _executeHook('beforeSanitizeElements', currentNode, null);
    /* Check if element is clobbered or can clobber */


    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);

      return true;
    }
    /* Check if tagname contains Unicode */


    if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
      _forceRemove(currentNode);

      return true;
    }
    /* Now let's check the element's type and name */


    var tagName = transformCaseFunc(currentNode.nodeName);
    /* Execute a hook if present */

    _executeHook('uponSanitizeElement', currentNode, {
      tagName: tagName,
      allowedTags: ALLOWED_TAGS
    });
    /* Detect mXSS attempts abusing namespace confusion */


    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);

      return true;
    }
    /* Mitigate a problem with templates inside select */


    if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);

      return true;
    }
    /* Remove element if anything forbids its presence */


    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Check if we have a custom element to handle */
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
      }
      /* Keep content except for bad-listed elements */


      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

        if (childNodes && parentNode) {
          var childCount = childNodes.length;

          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }

      _forceRemove(currentNode);

      return true;
    }
    /* Check whether element has a valid namespace */


    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);

      return true;
    }

    if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);

      return true;
    }
    /* Sanitize element content to be template-safe */


    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      /* Get the element's text content */
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$1, ' ');
      content = stringReplace(content, ERB_EXPR$1, ' ');

      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    /* Execute a hook if present */


    _executeHook('afterSanitizeElements', currentNode, null);

    return false;
  };
  /**
   * _isValidAttribute
   *
   * @param  {string} lcTag Lowercase tag name of containing element.
   * @param  {string} lcName Lowercase attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity


  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }
    /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */


    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND
      // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
      _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
      // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
        return false;
      }
      /* Check value is safe. First, is attr inert? If so, is safe */

    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if (!value) ; else {
      return false;
    }

    return true;
  };
  /**
   * _basicCustomElementCheck
   * checks if at least one dash is included in tagName, and it's not the first char
   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
   * @param {string} tagName name of the tag of the node to sanitize
   */


  var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
    return tagName.indexOf('-') > 0;
  };
  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param  {Node} currentNode to sanitize
   */


  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    var attr;
    var value;
    var lcName;
    var l;
    /* Execute a hook if present */

    _executeHook('beforeSanitizeAttributes', currentNode, null);

    var attributes = currentNode.attributes;
    /* Check if we have attributes; if not we might have a text node */

    if (!attributes) {
      return;
    }

    var hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;
    /* Go backwards over all attributes; safely remove bad ones */

    while (l--) {
      attr = attributes[l];
      var _attr = attr,
          name = _attr.name,
          namespaceURI = _attr.namespaceURI;
      value = name === 'value' ? attr.value : stringTrim(attr.value);
      lcName = transformCaseFunc(name);
      /* Execute a hook if present */

      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set

      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

      value = hookEvent.attrValue;
      /* Did the hooks approve of the attribute? */

      if (hookEvent.forceKeepAttr) {
        continue;
      }
      /* Remove attribute */


      _removeAttribute(name, currentNode);
      /* Did the hooks approve of the attribute? */


      if (!hookEvent.keepAttr) {
        continue;
      }
      /* Work around a security issue in jQuery 3.0 */


      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);

        continue;
      }
      /* Sanitize attribute content to be template-safe */


      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$1, ' ');
        value = stringReplace(value, ERB_EXPR$1, ' ');
      }
      /* Is `value` valid for this attribute? */


      var lcTag = transformCaseFunc(currentNode.nodeName);

      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      /* Full DOM Clobbering protection via namespace isolation,
       * Prefix id and name attributes with `user-content-`
       */


      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
        // Remove the attribute with this value
        _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value


        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      /* Handle attributes that require Trusted Types */


      if (trustedTypesPolicy && _typeof(trustedTypes) === 'object' && typeof trustedTypes.getAttributeType === 'function') {
        if (namespaceURI) ; else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case 'TrustedHTML':
              value = trustedTypesPolicy.createHTML(value);
              break;

            case 'TrustedScriptURL':
              value = trustedTypesPolicy.createScriptURL(value);
              break;
          }
        }
      }
      /* Handle invalid data-* attribute set by try-catching it */


      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
          currentNode.setAttribute(name, value);
        }

        arrayPop(DOMPurify.removed);
      } catch (_) {}
    }
    /* Execute a hook if present */


    _executeHook('afterSanitizeAttributes', currentNode, null);
  };
  /**
   * _sanitizeShadowDOM
   *
   * @param  {DocumentFragment} fragment to iterate over recursively
   */


  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    var shadowNode;

    var shadowIterator = _createIterator(fragment);
    /* Execute a hook if present */


    _executeHook('beforeSanitizeShadowDOM', fragment, null);

    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHook('uponSanitizeShadowNode', shadowNode, null);
      /* Sanitize tags and elements */


      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      /* Deep shadow DOM detected */


      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }
      /* Check attributes, sanitize if necessary */


      _sanitizeAttributes(shadowNode);
    }
    /* Execute a hook if present */


    _executeHook('afterSanitizeShadowDOM', fragment, null);
  };
  /**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */
  // eslint-disable-next-line complexity


  DOMPurify.sanitize = function (dirty) {
    var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var body;
    var importedNode;
    var currentNode;
    var oldNode;
    var returnNode;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */

    IS_EMPTY_INPUT = !dirty;

    if (IS_EMPTY_INPUT) {
      dirty = '<!-->';
    }
    /* Stringify, in case dirty is an object */


    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      // eslint-disable-next-line no-negated-condition
      if (typeof dirty.toString !== 'function') {
        throw typeErrorCreate('toString is not a function');
      } else {
        dirty = dirty.toString();

        if (typeof dirty !== 'string') {
          throw typeErrorCreate('dirty is not a string, aborting');
        }
      }
    }
    /* Check we can run. Otherwise fall back or ignore */


    if (!DOMPurify.isSupported) {
      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
        if (typeof dirty === 'string') {
          return window.toStaticHTML(dirty);
        }

        if (_isNode(dirty)) {
          return window.toStaticHTML(dirty.outerHTML);
        }
      }

      return dirty;
    }
    /* Assign config vars */


    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    /* Clean up removed elements */


    DOMPurify.removed = [];
    /* Check if dirty is correctly typed for IN_PLACE */

    if (typeof dirty === 'string') {
      IN_PLACE = false;
    }

    if (IN_PLACE) {
      /* Do some early pre-sanitization to avoid unsafe root nodes */
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);

        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
        }
      }
    } else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->');
      importedNode = body.ownerDocument.importNode(dirty, true);

      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-dom-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      /* Initialize the document to work on */


      body = _initDocument(dirty);
      /* Check we have a DOM node from the data */

      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
      }
    }
    /* Remove first element node (ours) if FORCE_BODY is set */


    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    /* Get node iterator */


    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    /* Now start iterating over the created document */


    while (currentNode = nodeIterator.nextNode()) {
      /* Fix IE's strange behavior with manipulated textNodes #89 */
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }
      /* Sanitize tags and elements */


      if (_sanitizeElements(currentNode)) {
        continue;
      }
      /* Shadow DOM detected, sanitize it */


      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      /* Check attributes, sanitize if necessary */


      _sanitizeAttributes(currentNode);

      oldNode = currentNode;
    }

    oldNode = null;
    /* If we sanitized `dirty` in-place, return it. */

    if (IN_PLACE) {
      return dirty;
    }
    /* Return sanitized string or DOM */


    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);

        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }

      if (ALLOWED_ATTR.shadowroot) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }

      return returnNode;
    }

    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    /* Serialize doctype if allowed */

    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
    }
    /* Sanitize final string template-safe */


    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, ' ');
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, ' ');
    }

    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  /**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */


  DOMPurify.setConfig = function (cfg) {
    _parseConfig(cfg);

    SET_CONFIG = true;
  };
  /**
   * Public method to remove the configuration
   * clearConfig
   *
   */


  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };
  /**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */


  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }

    var lcTag = transformCaseFunc(tag);
    var lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  /**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */


  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }

    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  /**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   * @return {Function} removed(popped) hook
   */


  DOMPurify.removeHook = function (entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };
  /**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */


  DOMPurify.removeHooks = function (entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  /**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */


  DOMPurify.removeAllHooks = function () {
    hooks = {};
  };

  return DOMPurify;
}

var purify = createDOMPurify();

/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */

'use strict';

/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

var escapeHtml_1 = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}

/**
 * Lexing or parsing positional information for error reporting.
 * This object is immutable.
 */
class SourceLocation {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(lexer, start, end) {
    this.lexer = void 0;
    this.start = void 0;
    this.end = void 0;
    this.lexer = lexer;
    this.start = start;
    this.end = end;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */


  static range(first, second) {
    if (!second) {
      return first && first.loc;
    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
      return null;
    } else {
      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
    }
  }

}

/**
 * Interface required to break circular dependency between Token, Lexer, and
 * ParseError.
 */

/**
 * The resulting token returned from `lex`.
 *
 * It consists of the token text plus some position information.
 * The position information is essentially a range in an input string,
 * but instead of referencing the bare input string, we refer to the lexer.
 * That way it is possible to attach extra metadata to the input string,
 * like for example a file name or similar.
 *
 * The position information is optional, so it is OK to construct synthetic
 * tokens if appropriate. Not providing available position information may
 * lead to degraded error reporting, though.
 */
class Token {
  // don't expand the token
  // used in \noexpand
  constructor(text, // the text of this token
  loc) {
    this.text = void 0;
    this.loc = void 0;
    this.noexpand = void 0;
    this.treatAsRelax = void 0;
    this.text = text;
    this.loc = loc;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */


  range(endToken, // last token of the range, inclusive
  text // the text of the newly constructed token
  ) {
    return new Token(text, SourceLocation.range(this, endToken));
  }

}

/**
 * This is the ParseError class, which is the main error thrown by KaTeX
 * functions when something has gone wrong. This is used to distinguish internal
 * errors from errors in the expression that the user provided.
 *
 * If possible, a caller should provide a Token or ParseNode with information
 * about where in the source string the problem occurred.
 */
class ParseError {
  // Error position based on passed-in Token or ParseNode.
  constructor(message, // The error message
  token // An object providing position information
  ) {
    this.position = void 0;
    var error = "KaTeX parse error: " + message;
    var start;
    var loc = token && token.loc;

    if (loc && loc.start <= loc.end) {
      // If we have the input and a position, make the error a bit fancier
      // Get the input
      var input = loc.lexer.input; // Prepend some information

      start = loc.start;
      var end = loc.end;

      if (start === input.length) {
        error += " at end of input: ";
      } else {
        error += " at position " + (start + 1) + ": ";
      } // Underline token in question using combining underscores


      var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332"); // Extract some context from the input and add it to the error

      var left;

      if (start > 15) {
        left = "…" + input.slice(start - 15, start);
      } else {
        left = input.slice(0, start);
      }

      var right;

      if (end + 15 < input.length) {
        right = input.slice(end, end + 15) + "…";
      } else {
        right = input.slice(end);
      }

      error += left + underlined + right;
    } // Some hackery to make ParseError a prototype of Error
    // See http://stackoverflow.com/a/8460753


    var self = new Error(error);
    self.name = "ParseError"; // $FlowFixMe

    self.__proto__ = ParseError.prototype; // $FlowFixMe

    self.position = start;
    return self;
  }

} // $FlowFixMe More hackery


ParseError.prototype.__proto__ = Error.prototype;

/**
 * This file contains a list of utility functions which are useful in other
 * files.
 */

/**
 * Return whether an element is contained in a list
 */
var contains = function contains(list, elem) {
  return list.indexOf(elem) !== -1;
};
/**
 * Provide a default value if a setting is undefined
 * NOTE: Couldn't use `T` as the output type due to facebook/flow#5022.
 */


var deflt = function deflt(setting, defaultIfUndefined) {
  return setting === undefined ? defaultIfUndefined : setting;
}; // hyphenate and escape adapted from Facebook's React under Apache 2 license


var uppercase = /([A-Z])/g;

var hyphenate = function hyphenate(str) {
  return str.replace(uppercase, "-$1").toLowerCase();
};

var ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  "\"": "&quot;",
  "'": "&#x27;"
};
var ESCAPE_REGEX = /[&><"']/g;
/**
 * Escapes text to prevent scripting attacks.
 */

function escape(text) {
  return String(text).replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);
}
/**
 * Sometimes we want to pull out the innermost element of a group. In most
 * cases, this will just be the group itself, but when ordgroups and colors have
 * a single element, we want to pull that out.
 */


var getBaseElem = function getBaseElem(group) {
  if (group.type === "ordgroup") {
    if (group.body.length === 1) {
      return getBaseElem(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "color") {
    if (group.body.length === 1) {
      return getBaseElem(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "font") {
    return getBaseElem(group.body);
  } else {
    return group;
  }
};
/**
 * TeXbook algorithms often reference "character boxes", which are simply groups
 * with a single character in them. To decide if something is a character box,
 * we find its innermost group, and see if it is a single character.
 */


var isCharacterBox = function isCharacterBox(group) {
  var baseElem = getBaseElem(group); // These are all they types of groups which hold single characters

  return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
};

var assert = function assert(value) {
  if (!value) {
    throw new Error('Expected non-null, but got ' + String(value));
  }

  return value;
};
/**
 * Return the protocol of a URL, or "_relative" if the URL does not specify a
 * protocol (and thus is relative).
 */

var protocolFromUrl = function protocolFromUrl(url) {
  var protocol = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);
  return protocol != null ? protocol[1] : "_relative";
};
var utils = {
  contains,
  deflt,
  escape,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl
};

/* eslint no-console:0 */
// TODO: automatically generate documentation
// TODO: check all properties on Settings exist
// TODO: check the type of a property on Settings matches
var SETTINGS_SCHEMA = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in " + "display style (so \\int and \\sum are large, for example), and " + "centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: true,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) ins" + "tead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' " + "(no #). This option determines the color of errors rendered by the " + "-t option.",
    cliProcessor: color => "#" + color
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use " + "multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (def, defs) => {
      defs.push(def);
      return defs;
    }
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines," + " `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, " + "`\\hdashline`, `\\underline`, `\\overline`, and the borders of " + "`\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: t => Math.max(0, t),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, " + "instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an " + "error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: false
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: Infinity,
    description: "If non-zero, all user-specified sizes, e.g. in " + "\\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, " + "elements and spaces can be arbitrarily large",
    processor: s => Math.max(0, s),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1000,
    description: "Limit the number of macro expansions to the specified " + "number, to prevent e.g. infinite macro loops. If set to Infinity, " + "the macro expander will try to fully expand as in LaTeX.",
    processor: n => Math.max(0, n),
    cli: "-e, --max-expand <n>",
    cliProcessor: n => n === "Infinity" ? Infinity : parseInt(n)
  },
  globalGroup: {
    type: "boolean",
    cli: false
  }
};

function getDefaultValue(schema) {
  if (schema.default) {
    return schema.default;
  }

  var type = schema.type;
  var defaultType = Array.isArray(type) ? type[0] : type;

  if (typeof defaultType !== 'string') {
    return defaultType.enum[0];
  }

  switch (defaultType) {
    case 'boolean':
      return false;

    case 'string':
      return '';

    case 'number':
      return 0;

    case 'object':
      return {};
  }
}
/**
 * The main Settings object
 *
 * The current options stored are:
 *  - displayMode: Whether the expression should be typeset as inline math
 *                 (false, the default), meaning that the math starts in
 *                 \textstyle and is placed in an inline-block); or as display
 *                 math (true), meaning that the math starts in \displaystyle
 *                 and is placed in a block with vertical margin.
 */


class Settings {
  constructor(options) {
    this.displayMode = void 0;
    this.output = void 0;
    this.leqno = void 0;
    this.fleqn = void 0;
    this.throwOnError = void 0;
    this.errorColor = void 0;
    this.macros = void 0;
    this.minRuleThickness = void 0;
    this.colorIsTextColor = void 0;
    this.strict = void 0;
    this.trust = void 0;
    this.maxSize = void 0;
    this.maxExpand = void 0;
    this.globalGroup = void 0;
    // allow null options
    options = options || {};

    for (var prop in SETTINGS_SCHEMA) {
      if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
        // $FlowFixMe
        var schema = SETTINGS_SCHEMA[prop]; // TODO: validate options
        // $FlowFixMe

        this[prop] = options[prop] !== undefined ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
      }
    }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */


  reportNonstrict(errorCode, errorMsg, token) {
    var strict = this.strict;

    if (typeof strict === "function") {
      // Allow return value of strict function to be boolean or string
      // (or null/undefined, meaning no further processing).
      strict = strict(errorCode, errorMsg, token);
    }

    if (!strict || strict === "ignore") {
      return;
    } else if (strict === true || strict === "error") {
      throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
    } else {
      // won't happen in type-safe code
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */


  useStrictBehavior(errorCode, errorMsg, token) {
    var strict = this.strict;

    if (typeof strict === "function") {
      // Allow return value of strict function to be boolean or string
      // (or null/undefined, meaning no further processing).
      // But catch any exceptions thrown by function, treating them
      // like "error".
      try {
        strict = strict(errorCode, errorMsg, token);
      } catch (error) {
        strict = "error";
      }
    }

    if (!strict || strict === "ignore") {
      return false;
    } else if (strict === true || strict === "error") {
      return true;
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
      return false;
    } else {
      // won't happen in type-safe code
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
      return false;
    }
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */


  isTrusted(context) {
    if (context.url && !context.protocol) {
      context.protocol = utils.protocolFromUrl(context.url);
    }

    var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
    return Boolean(trust);
  }

}

/**
 * This file contains information and classes for the various kinds of styles
 * used in TeX. It provides a generic `Style` class, which holds information
 * about a specific style. It then provides instances of all the different kinds
 * of styles possible, and provides functions to move between them and get
 * information about them.
 */

/**
 * The main style class. Contains a unique id for the style, a size (which is
 * the same for cramped and uncramped version of a style), and a cramped flag.
 */
class Style {
  constructor(id, size, cramped) {
    this.id = void 0;
    this.size = void 0;
    this.cramped = void 0;
    this.id = id;
    this.size = size;
    this.cramped = cramped;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */


  sup() {
    return styles[sup[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */


  sub() {
    return styles[sub[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */


  fracNum() {
    return styles[fracNum[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */


  fracDen() {
    return styles[fracDen[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */


  cramp() {
    return styles[cramp[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */


  text() {
    return styles[text$1[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */


  isTight() {
    return this.size >= 2;
  }

} // Export an interface for type checking, but don't expose the implementation.
// This way, no more styles can be generated.


// IDs of the different styles
var D = 0;
var Dc = 1;
var T = 2;
var Tc = 3;
var S = 4;
var Sc = 5;
var SS = 6;
var SSc = 7; // Instances of the different styles

var styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)]; // Lookup tables for switching from one style to another

var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
var text$1 = [D, Dc, T, Tc, T, Tc, T, Tc]; // We only export some of the styles.

var Style$1 = {
  DISPLAY: styles[D],
  TEXT: styles[T],
  SCRIPT: styles[S],
  SCRIPTSCRIPT: styles[SS]
};

/*
 * This file defines the Unicode scripts and script families that we
 * support. To add new scripts or families, just add a new entry to the
 * scriptData array below. Adding scripts to the scriptData array allows
 * characters from that script to appear in \text{} environments.
 */

/**
 * Each script or script family has a name and an array of blocks.
 * Each block is an array of two numbers which specify the start and
 * end points (inclusive) of a block of Unicode codepoints.
 */

/**
 * Unicode block data for the families of scripts we support in \text{}.
 * Scripts only need to appear here if they do not have font metrics.
 */
var scriptData = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: 'latin',
  blocks: [[0x0100, 0x024f], // Latin Extended-A and Latin Extended-B
  [0x0300, 0x036f] // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: 'cyrillic',
  blocks: [[0x0400, 0x04ff]]
}, {
  // Armenian
  name: 'armenian',
  blocks: [[0x0530, 0x058F]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900–097F)
  // Bengali (0980–09FF)
  // Gurmukhi (0A00–0A7F)
  // Gujarati (0A80–0AFF)
  // Oriya (0B00–0B7F)
  // Tamil (0B80–0BFF)
  // Telugu (0C00–0C7F)
  // Kannada (0C80–0CFF)
  // Malayalam (0D00–0D7F)
  // Sinhala (0D80–0DFF)
  // Thai (0E00–0E7F)
  // Lao (0E80–0EFF)
  // Tibetan (0F00–0FFF)
  // Myanmar (1000–109F)
  name: 'brahmic',
  blocks: [[0x0900, 0x109F]]
}, {
  name: 'georgian',
  blocks: [[0x10A0, 0x10ff]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [[0x3000, 0x30FF], // CJK symbols and punctuation, Hiragana, Katakana
  [0x4E00, 0x9FAF], // CJK ideograms
  [0xFF00, 0xFF60] // Fullwidth punctuation
  // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: 'hangul',
  blocks: [[0xAC00, 0xD7AF]]
}];
/**
 * Given a codepoint, return the name of the script or script family
 * it is from, or null if it is not part of a known block
 */

function scriptFromCodepoint(codepoint) {
  for (var i = 0; i < scriptData.length; i++) {
    var script = scriptData[i];

    for (var _i = 0; _i < script.blocks.length; _i++) {
      var block = script.blocks[_i];

      if (codepoint >= block[0] && codepoint <= block[1]) {
        return script.name;
      }
    }
  }

  return null;
}
/**
 * A flattened version of all the supported blocks in a single array.
 * This is an optimization to make supportedCodepoint() fast.
 */

var allBlocks = [];
scriptData.forEach(s => s.blocks.forEach(b => allBlocks.push(...b)));
/**
 * Given a codepoint, return true if it falls within one of the
 * scripts or script families defined above and false otherwise.
 *
 * Micro benchmarks shows that this is faster than
 * /[\u3000-\u30FF\u4E00-\u9FAF\uFF00-\uFF60\uAC00-\uD7AF\u0900-\u109F]/.test()
 * in Firefox, Chrome and Node.
 */

function supportedCodepoint(codepoint) {
  for (var i = 0; i < allBlocks.length; i += 2) {
    if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
      return true;
    }
  }

  return false;
}

/**
 * This file provides support to domTree.js and delimiter.js.
 * It's a storehouse of path geometry for SVG images.
 */
// In all paths below, the viewBox-to-em scale is 1000:1.
var hLinePad = 80; // padding above a sqrt viniculum. Prevents image cropping.
// The viniculum of a \sqrt can be made thicker by a KaTeX rendering option.
// Think of variable extraViniculum as two detours in the SVG path.
// The detour begins at the lower left of the area labeled extraViniculum below.
// The detour proceeds one extraViniculum distance up and slightly to the right,
// displacing the radiused corner between surd and viniculum. The radius is
// traversed as usual, then the detour resumes. It goes right, to the end of
// the very long viniculumn, then down one extraViniculum distance,
// after which it resumes regular path geometry for the radical.

/*                                                  viniculum
                                                   /
         /▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒←extraViniculum
        / █████████████████████←0.04em (40 unit) std viniculum thickness
       / /
      / /
     / /\
    / / surd
*/

var sqrtMain = function sqrtMain(extraViniculum, hLinePad) {
  // sqrtMain path geometry is from glyph U221A in the font KaTeX Main
  return "M95," + (622 + extraViniculum + hLinePad) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraViniculum / 2.075 + " -" + extraViniculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraViniculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraViniculum) + " " + hLinePad + "h400000v" + (40 + extraViniculum) + "h-400000z";
};

var sqrtSize1 = function sqrtSize1(extraViniculum, hLinePad) {
  // size1 is from glyph U221A in the font KaTeX_Size1-Regular
  return "M263," + (601 + extraViniculum + hLinePad) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraViniculum / 2.084 + " -" + extraViniculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraViniculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraViniculum) + " " + hLinePad + "h400000v" + (40 + extraViniculum) + "h-400000z";
};

var sqrtSize2 = function sqrtSize2(extraViniculum, hLinePad) {
  // size2 is from glyph U221A in the font KaTeX_Size2-Regular
  return "M983 " + (10 + extraViniculum + hLinePad) + "\nl" + extraViniculum / 3.13 + " -" + extraViniculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraViniculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraViniculum) + " " + hLinePad + "h400000v" + (40 + extraViniculum) + "h-400000z";
};

var sqrtSize3 = function sqrtSize3(extraViniculum, hLinePad) {
  // size3 is from glyph U221A in the font KaTeX_Size3-Regular
  return "M424," + (2398 + extraViniculum + hLinePad) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraViniculum / 4.223 + " -" + extraViniculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraViniculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraViniculum) + " " + hLinePad + "\nh400000v" + (40 + extraViniculum) + "h-400000z";
};

var sqrtSize4 = function sqrtSize4(extraViniculum, hLinePad) {
  // size4 is from glyph U221A in the font KaTeX_Size4-Regular
  return "M473," + (2713 + extraViniculum + hLinePad) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraViniculum / 5.298 + " -" + extraViniculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraViniculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraViniculum) + " " + hLinePad + "h400000v" + (40 + extraViniculum) + "H1017.7z";
};

var phasePath = function phasePath(y) {
  var x = y / 2; // x coordinate at top of angle

  return "M400000 " + y + " H0 L" + x + " 0 l65 45 L145 " + (y - 80) + " H400000z";
};

var sqrtTall = function sqrtTall(extraViniculum, hLinePad, viewBoxHeight) {
  // sqrtTall is from glyph U23B7 in the font KaTeX_Size4-Regular
  // One path edge has a variable length. It runs vertically from the viniculumn
  // to a point near (14 units) the bottom of the surd. The viniculum
  // is normally 40 units thick. So the length of the line in question is:
  var vertSegment = viewBoxHeight - 54 - hLinePad - extraViniculum;
  return "M702 " + (extraViniculum + hLinePad) + "H400000" + (40 + extraViniculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad + "H400000v" + (40 + extraViniculum) + "H742z";
};

var sqrtPath = function sqrtPath(size, extraViniculum, viewBoxHeight) {
  extraViniculum = 1000 * extraViniculum; // Convert from document ems to viewBox.

  var path = "";

  switch (size) {
    case "sqrtMain":
      path = sqrtMain(extraViniculum, hLinePad);
      break;

    case "sqrtSize1":
      path = sqrtSize1(extraViniculum, hLinePad);
      break;

    case "sqrtSize2":
      path = sqrtSize2(extraViniculum, hLinePad);
      break;

    case "sqrtSize3":
      path = sqrtSize3(extraViniculum, hLinePad);
      break;

    case "sqrtSize4":
      path = sqrtSize4(extraViniculum, hLinePad);
      break;

    case "sqrtTall":
      path = sqrtTall(extraViniculum, hLinePad, viewBoxHeight);
  }

  return path;
};
var innerPath = function innerPath(name, height) {
  // The inner part of stretchy tall delimiters
  switch (name) {
    case "\u239c":
      return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";

    case "\u2223":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";

    case "\u2225":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");

    case "\u239f":
      return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";

    case "\u23a2":
      return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";

    case "\u23a5":
      return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";

    case "\u23aa":
      return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";

    case "\u23d0":
      return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";

    case "\u2016":
      return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");

    default:
      return "";
  }
};
var path = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
  leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
  leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
  leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
  leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
  leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
  leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
  leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
  longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
  midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
  midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
  oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
  oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
  oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
  oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
  rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
  rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
  rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
  rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
  rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
  rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
  rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
  rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
  rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
  righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
  rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
  rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
  twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
  // ditto tilde2, tilde3, & tilde4
  tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
  tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
  tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
  // ditto widehat2, widehat3, & widehat4
  widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  // widecheck paths are all inverted versions of widehat
  widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
  widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
  rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
  shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
  shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
};
var tallDelim = function tallDelim(label, midHeight) {
  switch (label) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";

    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";

    case "vert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";

    case "doublevert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";

    case "lfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";

    case "rfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";

    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";

    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";

    case "lparen":
      return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";

    case "rparen":
      return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";

    default:
      // We should not ever get here.
      throw new Error("Unknown stretchy delimiter.");
  }
};

/**
 * This node represents a document fragment, which contains elements, but when
 * placed into the DOM doesn't have any representation itself. It only contains
 * children and doesn't have any DOM node properties.
 */
class DocumentFragment {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(children) {
    this.children = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.children = children;
    this.classes = [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
  }

  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  /** Convert the fragment into a node. */


  toNode() {
    var frag = document.createDocumentFragment();

    for (var i = 0; i < this.children.length; i++) {
      frag.appendChild(this.children[i].toNode());
    }

    return frag;
  }
  /** Convert the fragment into HTML markup. */


  toMarkup() {
    var markup = ""; // Simply concatenate the markup for the children together.

    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */


  toText() {
    // To avoid this, we would subclass documentFragment separately for
    // MathML, but polyfills for subclassing is expensive per PR 1469.
    // $FlowFixMe: Only works for ChildType = MathDomNode.
    var toText = child => child.toText();

    return this.children.map(toText).join("");
  }

}

// This file is GENERATED by buildMetrics.sh. DO NOT MODIFY.
var fontMetricsData = {
  "AMS-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68889, 0, 0, 0.72222],
    "66": [0, 0.68889, 0, 0, 0.66667],
    "67": [0, 0.68889, 0, 0, 0.72222],
    "68": [0, 0.68889, 0, 0, 0.72222],
    "69": [0, 0.68889, 0, 0, 0.66667],
    "70": [0, 0.68889, 0, 0, 0.61111],
    "71": [0, 0.68889, 0, 0, 0.77778],
    "72": [0, 0.68889, 0, 0, 0.77778],
    "73": [0, 0.68889, 0, 0, 0.38889],
    "74": [0.16667, 0.68889, 0, 0, 0.5],
    "75": [0, 0.68889, 0, 0, 0.77778],
    "76": [0, 0.68889, 0, 0, 0.66667],
    "77": [0, 0.68889, 0, 0, 0.94445],
    "78": [0, 0.68889, 0, 0, 0.72222],
    "79": [0.16667, 0.68889, 0, 0, 0.77778],
    "80": [0, 0.68889, 0, 0, 0.61111],
    "81": [0.16667, 0.68889, 0, 0, 0.77778],
    "82": [0, 0.68889, 0, 0, 0.72222],
    "83": [0, 0.68889, 0, 0, 0.55556],
    "84": [0, 0.68889, 0, 0, 0.66667],
    "85": [0, 0.68889, 0, 0, 0.72222],
    "86": [0, 0.68889, 0, 0, 0.72222],
    "87": [0, 0.68889, 0, 0, 1.0],
    "88": [0, 0.68889, 0, 0, 0.72222],
    "89": [0, 0.68889, 0, 0, 0.72222],
    "90": [0, 0.68889, 0, 0, 0.66667],
    "107": [0, 0.68889, 0, 0, 0.55556],
    "160": [0, 0, 0, 0, 0.25],
    "165": [0, 0.675, 0.025, 0, 0.75],
    "174": [0.15559, 0.69224, 0, 0, 0.94666],
    "240": [0, 0.68889, 0, 0, 0.55556],
    "295": [0, 0.68889, 0, 0, 0.54028],
    "710": [0, 0.825, 0, 0, 2.33334],
    "732": [0, 0.9, 0, 0, 2.33334],
    "770": [0, 0.825, 0, 0, 2.33334],
    "771": [0, 0.9, 0, 0, 2.33334],
    "989": [0.08167, 0.58167, 0, 0, 0.77778],
    "1008": [0, 0.43056, 0.04028, 0, 0.66667],
    "8245": [0, 0.54986, 0, 0, 0.275],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8487": [0, 0.68889, 0, 0, 0.72222],
    "8498": [0, 0.68889, 0, 0, 0.55556],
    "8502": [0, 0.68889, 0, 0, 0.66667],
    "8503": [0, 0.68889, 0, 0, 0.44445],
    "8504": [0, 0.68889, 0, 0, 0.66667],
    "8513": [0, 0.68889, 0, 0, 0.63889],
    "8592": [-0.03598, 0.46402, 0, 0, 0.5],
    "8594": [-0.03598, 0.46402, 0, 0, 0.5],
    "8602": [-0.13313, 0.36687, 0, 0, 1.0],
    "8603": [-0.13313, 0.36687, 0, 0, 1.0],
    "8606": [0.01354, 0.52239, 0, 0, 1.0],
    "8608": [0.01354, 0.52239, 0, 0, 1.0],
    "8610": [0.01354, 0.52239, 0, 0, 1.11111],
    "8611": [0.01354, 0.52239, 0, 0, 1.11111],
    "8619": [0, 0.54986, 0, 0, 1.0],
    "8620": [0, 0.54986, 0, 0, 1.0],
    "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
    "8622": [-0.13313, 0.36687, 0, 0, 1.0],
    "8624": [0, 0.69224, 0, 0, 0.5],
    "8625": [0, 0.69224, 0, 0, 0.5],
    "8630": [0, 0.43056, 0, 0, 1.0],
    "8631": [0, 0.43056, 0, 0, 1.0],
    "8634": [0.08198, 0.58198, 0, 0, 0.77778],
    "8635": [0.08198, 0.58198, 0, 0, 0.77778],
    "8638": [0.19444, 0.69224, 0, 0, 0.41667],
    "8639": [0.19444, 0.69224, 0, 0, 0.41667],
    "8642": [0.19444, 0.69224, 0, 0, 0.41667],
    "8643": [0.19444, 0.69224, 0, 0, 0.41667],
    "8644": [0.1808, 0.675, 0, 0, 1.0],
    "8646": [0.1808, 0.675, 0, 0, 1.0],
    "8647": [0.1808, 0.675, 0, 0, 1.0],
    "8648": [0.19444, 0.69224, 0, 0, 0.83334],
    "8649": [0.1808, 0.675, 0, 0, 1.0],
    "8650": [0.19444, 0.69224, 0, 0, 0.83334],
    "8651": [0.01354, 0.52239, 0, 0, 1.0],
    "8652": [0.01354, 0.52239, 0, 0, 1.0],
    "8653": [-0.13313, 0.36687, 0, 0, 1.0],
    "8654": [-0.13313, 0.36687, 0, 0, 1.0],
    "8655": [-0.13313, 0.36687, 0, 0, 1.0],
    "8666": [0.13667, 0.63667, 0, 0, 1.0],
    "8667": [0.13667, 0.63667, 0, 0, 1.0],
    "8669": [-0.13313, 0.37788, 0, 0, 1.0],
    "8672": [-0.064, 0.437, 0, 0, 1.334],
    "8674": [-0.064, 0.437, 0, 0, 1.334],
    "8705": [0, 0.825, 0, 0, 0.5],
    "8708": [0, 0.68889, 0, 0, 0.55556],
    "8709": [0.08167, 0.58167, 0, 0, 0.77778],
    "8717": [0, 0.43056, 0, 0, 0.42917],
    "8722": [-0.03598, 0.46402, 0, 0, 0.5],
    "8724": [0.08198, 0.69224, 0, 0, 0.77778],
    "8726": [0.08167, 0.58167, 0, 0, 0.77778],
    "8733": [0, 0.69224, 0, 0, 0.77778],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8737": [0, 0.69224, 0, 0, 0.72222],
    "8738": [0.03517, 0.52239, 0, 0, 0.72222],
    "8739": [0.08167, 0.58167, 0, 0, 0.22222],
    "8740": [0.25142, 0.74111, 0, 0, 0.27778],
    "8741": [0.08167, 0.58167, 0, 0, 0.38889],
    "8742": [0.25142, 0.74111, 0, 0, 0.5],
    "8756": [0, 0.69224, 0, 0, 0.66667],
    "8757": [0, 0.69224, 0, 0, 0.66667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
    "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8774": [0.30274, 0.79383, 0, 0, 0.77778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8778": [0.08167, 0.58167, 0, 0, 0.77778],
    "8782": [0.06062, 0.54986, 0, 0, 0.77778],
    "8783": [0.06062, 0.54986, 0, 0, 0.77778],
    "8785": [0.08198, 0.58198, 0, 0, 0.77778],
    "8786": [0.08198, 0.58198, 0, 0, 0.77778],
    "8787": [0.08198, 0.58198, 0, 0, 0.77778],
    "8790": [0, 0.69224, 0, 0, 0.77778],
    "8791": [0.22958, 0.72958, 0, 0, 0.77778],
    "8796": [0.08198, 0.91667, 0, 0, 0.77778],
    "8806": [0.25583, 0.75583, 0, 0, 0.77778],
    "8807": [0.25583, 0.75583, 0, 0, 0.77778],
    "8808": [0.25142, 0.75726, 0, 0, 0.77778],
    "8809": [0.25142, 0.75726, 0, 0, 0.77778],
    "8812": [0.25583, 0.75583, 0, 0, 0.5],
    "8814": [0.20576, 0.70576, 0, 0, 0.77778],
    "8815": [0.20576, 0.70576, 0, 0, 0.77778],
    "8816": [0.30274, 0.79383, 0, 0, 0.77778],
    "8817": [0.30274, 0.79383, 0, 0, 0.77778],
    "8818": [0.22958, 0.72958, 0, 0, 0.77778],
    "8819": [0.22958, 0.72958, 0, 0, 0.77778],
    "8822": [0.1808, 0.675, 0, 0, 0.77778],
    "8823": [0.1808, 0.675, 0, 0, 0.77778],
    "8828": [0.13667, 0.63667, 0, 0, 0.77778],
    "8829": [0.13667, 0.63667, 0, 0, 0.77778],
    "8830": [0.22958, 0.72958, 0, 0, 0.77778],
    "8831": [0.22958, 0.72958, 0, 0, 0.77778],
    "8832": [0.20576, 0.70576, 0, 0, 0.77778],
    "8833": [0.20576, 0.70576, 0, 0, 0.77778],
    "8840": [0.30274, 0.79383, 0, 0, 0.77778],
    "8841": [0.30274, 0.79383, 0, 0, 0.77778],
    "8842": [0.13597, 0.63597, 0, 0, 0.77778],
    "8843": [0.13597, 0.63597, 0, 0, 0.77778],
    "8847": [0.03517, 0.54986, 0, 0, 0.77778],
    "8848": [0.03517, 0.54986, 0, 0, 0.77778],
    "8858": [0.08198, 0.58198, 0, 0, 0.77778],
    "8859": [0.08198, 0.58198, 0, 0, 0.77778],
    "8861": [0.08198, 0.58198, 0, 0, 0.77778],
    "8862": [0, 0.675, 0, 0, 0.77778],
    "8863": [0, 0.675, 0, 0, 0.77778],
    "8864": [0, 0.675, 0, 0, 0.77778],
    "8865": [0, 0.675, 0, 0, 0.77778],
    "8872": [0, 0.69224, 0, 0, 0.61111],
    "8873": [0, 0.69224, 0, 0, 0.72222],
    "8874": [0, 0.69224, 0, 0, 0.88889],
    "8876": [0, 0.68889, 0, 0, 0.61111],
    "8877": [0, 0.68889, 0, 0, 0.61111],
    "8878": [0, 0.68889, 0, 0, 0.72222],
    "8879": [0, 0.68889, 0, 0, 0.72222],
    "8882": [0.03517, 0.54986, 0, 0, 0.77778],
    "8883": [0.03517, 0.54986, 0, 0, 0.77778],
    "8884": [0.13667, 0.63667, 0, 0, 0.77778],
    "8885": [0.13667, 0.63667, 0, 0, 0.77778],
    "8888": [0, 0.54986, 0, 0, 1.11111],
    "8890": [0.19444, 0.43056, 0, 0, 0.55556],
    "8891": [0.19444, 0.69224, 0, 0, 0.61111],
    "8892": [0.19444, 0.69224, 0, 0, 0.61111],
    "8901": [0, 0.54986, 0, 0, 0.27778],
    "8903": [0.08167, 0.58167, 0, 0, 0.77778],
    "8905": [0.08167, 0.58167, 0, 0, 0.77778],
    "8906": [0.08167, 0.58167, 0, 0, 0.77778],
    "8907": [0, 0.69224, 0, 0, 0.77778],
    "8908": [0, 0.69224, 0, 0, 0.77778],
    "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
    "8910": [0, 0.54986, 0, 0, 0.76042],
    "8911": [0, 0.54986, 0, 0, 0.76042],
    "8912": [0.03517, 0.54986, 0, 0, 0.77778],
    "8913": [0.03517, 0.54986, 0, 0, 0.77778],
    "8914": [0, 0.54986, 0, 0, 0.66667],
    "8915": [0, 0.54986, 0, 0, 0.66667],
    "8916": [0, 0.69224, 0, 0, 0.66667],
    "8918": [0.0391, 0.5391, 0, 0, 0.77778],
    "8919": [0.0391, 0.5391, 0, 0, 0.77778],
    "8920": [0.03517, 0.54986, 0, 0, 1.33334],
    "8921": [0.03517, 0.54986, 0, 0, 1.33334],
    "8922": [0.38569, 0.88569, 0, 0, 0.77778],
    "8923": [0.38569, 0.88569, 0, 0, 0.77778],
    "8926": [0.13667, 0.63667, 0, 0, 0.77778],
    "8927": [0.13667, 0.63667, 0, 0, 0.77778],
    "8928": [0.30274, 0.79383, 0, 0, 0.77778],
    "8929": [0.30274, 0.79383, 0, 0, 0.77778],
    "8934": [0.23222, 0.74111, 0, 0, 0.77778],
    "8935": [0.23222, 0.74111, 0, 0, 0.77778],
    "8936": [0.23222, 0.74111, 0, 0, 0.77778],
    "8937": [0.23222, 0.74111, 0, 0, 0.77778],
    "8938": [0.20576, 0.70576, 0, 0, 0.77778],
    "8939": [0.20576, 0.70576, 0, 0, 0.77778],
    "8940": [0.30274, 0.79383, 0, 0, 0.77778],
    "8941": [0.30274, 0.79383, 0, 0, 0.77778],
    "8994": [0.19444, 0.69224, 0, 0, 0.77778],
    "8995": [0.19444, 0.69224, 0, 0, 0.77778],
    "9416": [0.15559, 0.69224, 0, 0, 0.90222],
    "9484": [0, 0.69224, 0, 0, 0.5],
    "9488": [0, 0.69224, 0, 0, 0.5],
    "9492": [0, 0.37788, 0, 0, 0.5],
    "9496": [0, 0.37788, 0, 0, 0.5],
    "9585": [0.19444, 0.68889, 0, 0, 0.88889],
    "9586": [0.19444, 0.74111, 0, 0, 0.88889],
    "9632": [0, 0.675, 0, 0, 0.77778],
    "9633": [0, 0.675, 0, 0, 0.77778],
    "9650": [0, 0.54986, 0, 0, 0.72222],
    "9651": [0, 0.54986, 0, 0, 0.72222],
    "9654": [0.03517, 0.54986, 0, 0, 0.77778],
    "9660": [0, 0.54986, 0, 0, 0.72222],
    "9661": [0, 0.54986, 0, 0, 0.72222],
    "9664": [0.03517, 0.54986, 0, 0, 0.77778],
    "9674": [0.11111, 0.69224, 0, 0, 0.66667],
    "9733": [0.19444, 0.69224, 0, 0, 0.94445],
    "10003": [0, 0.69224, 0, 0, 0.83334],
    "10016": [0, 0.69224, 0, 0, 0.83334],
    "10731": [0.11111, 0.69224, 0, 0, 0.66667],
    "10846": [0.19444, 0.75583, 0, 0, 0.61111],
    "10877": [0.13667, 0.63667, 0, 0, 0.77778],
    "10878": [0.13667, 0.63667, 0, 0, 0.77778],
    "10885": [0.25583, 0.75583, 0, 0, 0.77778],
    "10886": [0.25583, 0.75583, 0, 0, 0.77778],
    "10887": [0.13597, 0.63597, 0, 0, 0.77778],
    "10888": [0.13597, 0.63597, 0, 0, 0.77778],
    "10889": [0.26167, 0.75726, 0, 0, 0.77778],
    "10890": [0.26167, 0.75726, 0, 0, 0.77778],
    "10891": [0.48256, 0.98256, 0, 0, 0.77778],
    "10892": [0.48256, 0.98256, 0, 0, 0.77778],
    "10901": [0.13667, 0.63667, 0, 0, 0.77778],
    "10902": [0.13667, 0.63667, 0, 0, 0.77778],
    "10933": [0.25142, 0.75726, 0, 0, 0.77778],
    "10934": [0.25142, 0.75726, 0, 0, 0.77778],
    "10935": [0.26167, 0.75726, 0, 0, 0.77778],
    "10936": [0.26167, 0.75726, 0, 0, 0.77778],
    "10937": [0.26167, 0.75726, 0, 0, 0.77778],
    "10938": [0.26167, 0.75726, 0, 0, 0.77778],
    "10949": [0.25583, 0.75583, 0, 0, 0.77778],
    "10950": [0.25583, 0.75583, 0, 0, 0.77778],
    "10955": [0.28481, 0.79383, 0, 0, 0.77778],
    "10956": [0.28481, 0.79383, 0, 0, 0.77778],
    "57350": [0.08167, 0.58167, 0, 0, 0.22222],
    "57351": [0.08167, 0.58167, 0, 0, 0.38889],
    "57352": [0.08167, 0.58167, 0, 0, 0.77778],
    "57353": [0, 0.43056, 0.04028, 0, 0.66667],
    "57356": [0.25142, 0.75726, 0, 0, 0.77778],
    "57357": [0.25142, 0.75726, 0, 0, 0.77778],
    "57358": [0.41951, 0.91951, 0, 0, 0.77778],
    "57359": [0.30274, 0.79383, 0, 0, 0.77778],
    "57360": [0.30274, 0.79383, 0, 0, 0.77778],
    "57361": [0.41951, 0.91951, 0, 0, 0.77778],
    "57366": [0.25142, 0.75726, 0, 0, 0.77778],
    "57367": [0.25142, 0.75726, 0, 0, 0.77778],
    "57368": [0.25142, 0.75726, 0, 0, 0.77778],
    "57369": [0.25142, 0.75726, 0, 0, 0.77778],
    "57370": [0.13597, 0.63597, 0, 0, 0.77778],
    "57371": [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68333, 0, 0.19445, 0.79847],
    "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
    "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
    "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
    "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
    "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
    "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    "72": [0, 0.68333, 0.00965, 0.11111, 0.84452],
    "73": [0, 0.68333, 0.07382, 0, 0.54452],
    "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
    "76": [0, 0.68333, 0, 0.13889, 0.68972],
    "77": [0, 0.68333, 0, 0.13889, 1.2009],
    "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
    "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
    "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
    "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
    "82": [0, 0.68333, 0, 0.08334, 0.8475],
    "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
    "84": [0, 0.68333, 0.25417, 0, 0.54464],
    "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
    "86": [0, 0.68333, 0.08222, 0, 0.61278],
    "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
    "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
    "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69141, 0, 0, 0.29574],
    "34": [0, 0.69141, 0, 0, 0.21471],
    "38": [0, 0.69141, 0, 0, 0.73786],
    "39": [0, 0.69141, 0, 0, 0.21201],
    "40": [0.24982, 0.74947, 0, 0, 0.38865],
    "41": [0.24982, 0.74947, 0, 0, 0.38865],
    "42": [0, 0.62119, 0, 0, 0.27764],
    "43": [0.08319, 0.58283, 0, 0, 0.75623],
    "44": [0, 0.10803, 0, 0, 0.27764],
    "45": [0.08319, 0.58283, 0, 0, 0.75623],
    "46": [0, 0.10803, 0, 0, 0.27764],
    "47": [0.24982, 0.74947, 0, 0, 0.50181],
    "48": [0, 0.47534, 0, 0, 0.50181],
    "49": [0, 0.47534, 0, 0, 0.50181],
    "50": [0, 0.47534, 0, 0, 0.50181],
    "51": [0.18906, 0.47534, 0, 0, 0.50181],
    "52": [0.18906, 0.47534, 0, 0, 0.50181],
    "53": [0.18906, 0.47534, 0, 0, 0.50181],
    "54": [0, 0.69141, 0, 0, 0.50181],
    "55": [0.18906, 0.47534, 0, 0, 0.50181],
    "56": [0, 0.69141, 0, 0, 0.50181],
    "57": [0.18906, 0.47534, 0, 0, 0.50181],
    "58": [0, 0.47534, 0, 0, 0.21606],
    "59": [0.12604, 0.47534, 0, 0, 0.21606],
    "61": [-0.13099, 0.36866, 0, 0, 0.75623],
    "63": [0, 0.69141, 0, 0, 0.36245],
    "65": [0, 0.69141, 0, 0, 0.7176],
    "66": [0, 0.69141, 0, 0, 0.88397],
    "67": [0, 0.69141, 0, 0, 0.61254],
    "68": [0, 0.69141, 0, 0, 0.83158],
    "69": [0, 0.69141, 0, 0, 0.66278],
    "70": [0.12604, 0.69141, 0, 0, 0.61119],
    "71": [0, 0.69141, 0, 0, 0.78539],
    "72": [0.06302, 0.69141, 0, 0, 0.7203],
    "73": [0, 0.69141, 0, 0, 0.55448],
    "74": [0.12604, 0.69141, 0, 0, 0.55231],
    "75": [0, 0.69141, 0, 0, 0.66845],
    "76": [0, 0.69141, 0, 0, 0.66602],
    "77": [0, 0.69141, 0, 0, 1.04953],
    "78": [0, 0.69141, 0, 0, 0.83212],
    "79": [0, 0.69141, 0, 0, 0.82699],
    "80": [0.18906, 0.69141, 0, 0, 0.82753],
    "81": [0.03781, 0.69141, 0, 0, 0.82699],
    "82": [0, 0.69141, 0, 0, 0.82807],
    "83": [0, 0.69141, 0, 0, 0.82861],
    "84": [0, 0.69141, 0, 0, 0.66899],
    "85": [0, 0.69141, 0, 0, 0.64576],
    "86": [0, 0.69141, 0, 0, 0.83131],
    "87": [0, 0.69141, 0, 0, 1.04602],
    "88": [0, 0.69141, 0, 0, 0.71922],
    "89": [0.18906, 0.69141, 0, 0, 0.83293],
    "90": [0.12604, 0.69141, 0, 0, 0.60201],
    "91": [0.24982, 0.74947, 0, 0, 0.27764],
    "93": [0.24982, 0.74947, 0, 0, 0.27764],
    "94": [0, 0.69141, 0, 0, 0.49965],
    "97": [0, 0.47534, 0, 0, 0.50046],
    "98": [0, 0.69141, 0, 0, 0.51315],
    "99": [0, 0.47534, 0, 0, 0.38946],
    "100": [0, 0.62119, 0, 0, 0.49857],
    "101": [0, 0.47534, 0, 0, 0.40053],
    "102": [0.18906, 0.69141, 0, 0, 0.32626],
    "103": [0.18906, 0.47534, 0, 0, 0.5037],
    "104": [0.18906, 0.69141, 0, 0, 0.52126],
    "105": [0, 0.69141, 0, 0, 0.27899],
    "106": [0, 0.69141, 0, 0, 0.28088],
    "107": [0, 0.69141, 0, 0, 0.38946],
    "108": [0, 0.69141, 0, 0, 0.27953],
    "109": [0, 0.47534, 0, 0, 0.76676],
    "110": [0, 0.47534, 0, 0, 0.52666],
    "111": [0, 0.47534, 0, 0, 0.48885],
    "112": [0.18906, 0.52396, 0, 0, 0.50046],
    "113": [0.18906, 0.47534, 0, 0, 0.48912],
    "114": [0, 0.47534, 0, 0, 0.38919],
    "115": [0, 0.47534, 0, 0, 0.44266],
    "116": [0, 0.62119, 0, 0, 0.33301],
    "117": [0, 0.47534, 0, 0, 0.5172],
    "118": [0, 0.52396, 0, 0, 0.5118],
    "119": [0, 0.52396, 0, 0, 0.77351],
    "120": [0.18906, 0.47534, 0, 0, 0.38865],
    "121": [0.18906, 0.47534, 0, 0, 0.49884],
    "122": [0.18906, 0.47534, 0, 0, 0.39054],
    "160": [0, 0, 0, 0, 0.25],
    "8216": [0, 0.69141, 0, 0, 0.21471],
    "8217": [0, 0.69141, 0, 0, 0.21471],
    "58112": [0, 0.62119, 0, 0, 0.49749],
    "58113": [0, 0.62119, 0, 0, 0.4983],
    "58114": [0.18906, 0.69141, 0, 0, 0.33328],
    "58115": [0.18906, 0.69141, 0, 0, 0.32923],
    "58116": [0.18906, 0.47534, 0, 0, 0.50343],
    "58117": [0, 0.69141, 0, 0, 0.33301],
    "58118": [0, 0.62119, 0, 0, 0.33409],
    "58119": [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.35],
    "34": [0, 0.69444, 0, 0, 0.60278],
    "35": [0.19444, 0.69444, 0, 0, 0.95833],
    "36": [0.05556, 0.75, 0, 0, 0.575],
    "37": [0.05556, 0.75, 0, 0, 0.95833],
    "38": [0, 0.69444, 0, 0, 0.89444],
    "39": [0, 0.69444, 0, 0, 0.31944],
    "40": [0.25, 0.75, 0, 0, 0.44722],
    "41": [0.25, 0.75, 0, 0, 0.44722],
    "42": [0, 0.75, 0, 0, 0.575],
    "43": [0.13333, 0.63333, 0, 0, 0.89444],
    "44": [0.19444, 0.15556, 0, 0, 0.31944],
    "45": [0, 0.44444, 0, 0, 0.38333],
    "46": [0, 0.15556, 0, 0, 0.31944],
    "47": [0.25, 0.75, 0, 0, 0.575],
    "48": [0, 0.64444, 0, 0, 0.575],
    "49": [0, 0.64444, 0, 0, 0.575],
    "50": [0, 0.64444, 0, 0, 0.575],
    "51": [0, 0.64444, 0, 0, 0.575],
    "52": [0, 0.64444, 0, 0, 0.575],
    "53": [0, 0.64444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0, 0.64444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0, 0.64444, 0, 0, 0.575],
    "58": [0, 0.44444, 0, 0, 0.31944],
    "59": [0.19444, 0.44444, 0, 0, 0.31944],
    "60": [0.08556, 0.58556, 0, 0, 0.89444],
    "61": [-0.10889, 0.39111, 0, 0, 0.89444],
    "62": [0.08556, 0.58556, 0, 0, 0.89444],
    "63": [0, 0.69444, 0, 0, 0.54305],
    "64": [0, 0.69444, 0, 0, 0.89444],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0, 0, 0.81805],
    "67": [0, 0.68611, 0, 0, 0.83055],
    "68": [0, 0.68611, 0, 0, 0.88194],
    "69": [0, 0.68611, 0, 0, 0.75555],
    "70": [0, 0.68611, 0, 0, 0.72361],
    "71": [0, 0.68611, 0, 0, 0.90416],
    "72": [0, 0.68611, 0, 0, 0.9],
    "73": [0, 0.68611, 0, 0, 0.43611],
    "74": [0, 0.68611, 0, 0, 0.59444],
    "75": [0, 0.68611, 0, 0, 0.90138],
    "76": [0, 0.68611, 0, 0, 0.69166],
    "77": [0, 0.68611, 0, 0, 1.09166],
    "78": [0, 0.68611, 0, 0, 0.9],
    "79": [0, 0.68611, 0, 0, 0.86388],
    "80": [0, 0.68611, 0, 0, 0.78611],
    "81": [0.19444, 0.68611, 0, 0, 0.86388],
    "82": [0, 0.68611, 0, 0, 0.8625],
    "83": [0, 0.68611, 0, 0, 0.63889],
    "84": [0, 0.68611, 0, 0, 0.8],
    "85": [0, 0.68611, 0, 0, 0.88472],
    "86": [0, 0.68611, 0.01597, 0, 0.86944],
    "87": [0, 0.68611, 0.01597, 0, 1.18888],
    "88": [0, 0.68611, 0, 0, 0.86944],
    "89": [0, 0.68611, 0.02875, 0, 0.86944],
    "90": [0, 0.68611, 0, 0, 0.70277],
    "91": [0.25, 0.75, 0, 0, 0.31944],
    "92": [0.25, 0.75, 0, 0, 0.575],
    "93": [0.25, 0.75, 0, 0, 0.31944],
    "94": [0, 0.69444, 0, 0, 0.575],
    "95": [0.31, 0.13444, 0.03194, 0, 0.575],
    "97": [0, 0.44444, 0, 0, 0.55902],
    "98": [0, 0.69444, 0, 0, 0.63889],
    "99": [0, 0.44444, 0, 0, 0.51111],
    "100": [0, 0.69444, 0, 0, 0.63889],
    "101": [0, 0.44444, 0, 0, 0.52708],
    "102": [0, 0.69444, 0.10903, 0, 0.35139],
    "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
    "104": [0, 0.69444, 0, 0, 0.63889],
    "105": [0, 0.69444, 0, 0, 0.31944],
    "106": [0.19444, 0.69444, 0, 0, 0.35139],
    "107": [0, 0.69444, 0, 0, 0.60694],
    "108": [0, 0.69444, 0, 0, 0.31944],
    "109": [0, 0.44444, 0, 0, 0.95833],
    "110": [0, 0.44444, 0, 0, 0.63889],
    "111": [0, 0.44444, 0, 0, 0.575],
    "112": [0.19444, 0.44444, 0, 0, 0.63889],
    "113": [0.19444, 0.44444, 0, 0, 0.60694],
    "114": [0, 0.44444, 0, 0, 0.47361],
    "115": [0, 0.44444, 0, 0, 0.45361],
    "116": [0, 0.63492, 0, 0, 0.44722],
    "117": [0, 0.44444, 0, 0, 0.63889],
    "118": [0, 0.44444, 0.01597, 0, 0.60694],
    "119": [0, 0.44444, 0.01597, 0, 0.83055],
    "120": [0, 0.44444, 0, 0, 0.60694],
    "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
    "122": [0, 0.44444, 0, 0, 0.51111],
    "123": [0.25, 0.75, 0, 0, 0.575],
    "124": [0.25, 0.75, 0, 0, 0.31944],
    "125": [0.25, 0.75, 0, 0, 0.575],
    "126": [0.35, 0.34444, 0, 0, 0.575],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.86853],
    "168": [0, 0.69444, 0, 0, 0.575],
    "172": [0, 0.44444, 0, 0, 0.76666],
    "176": [0, 0.69444, 0, 0, 0.86944],
    "177": [0.13333, 0.63333, 0, 0, 0.89444],
    "184": [0.17014, 0, 0, 0, 0.51111],
    "198": [0, 0.68611, 0, 0, 1.04166],
    "215": [0.13333, 0.63333, 0, 0, 0.89444],
    "216": [0.04861, 0.73472, 0, 0, 0.89444],
    "223": [0, 0.69444, 0, 0, 0.59722],
    "230": [0, 0.44444, 0, 0, 0.83055],
    "247": [0.13333, 0.63333, 0, 0, 0.89444],
    "248": [0.09722, 0.54167, 0, 0, 0.575],
    "305": [0, 0.44444, 0, 0, 0.31944],
    "338": [0, 0.68611, 0, 0, 1.16944],
    "339": [0, 0.44444, 0, 0, 0.89444],
    "567": [0.19444, 0.44444, 0, 0, 0.35139],
    "710": [0, 0.69444, 0, 0, 0.575],
    "711": [0, 0.63194, 0, 0, 0.575],
    "713": [0, 0.59611, 0, 0, 0.575],
    "714": [0, 0.69444, 0, 0, 0.575],
    "715": [0, 0.69444, 0, 0, 0.575],
    "728": [0, 0.69444, 0, 0, 0.575],
    "729": [0, 0.69444, 0, 0, 0.31944],
    "730": [0, 0.69444, 0, 0, 0.86944],
    "732": [0, 0.69444, 0, 0, 0.575],
    "733": [0, 0.69444, 0, 0, 0.575],
    "915": [0, 0.68611, 0, 0, 0.69166],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0, 0, 0.89444],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0, 0, 0.76666],
    "928": [0, 0.68611, 0, 0, 0.9],
    "931": [0, 0.68611, 0, 0, 0.83055],
    "933": [0, 0.68611, 0, 0, 0.89444],
    "934": [0, 0.68611, 0, 0, 0.83055],
    "936": [0, 0.68611, 0, 0, 0.89444],
    "937": [0, 0.68611, 0, 0, 0.83055],
    "8211": [0, 0.44444, 0.03194, 0, 0.575],
    "8212": [0, 0.44444, 0.03194, 0, 1.14999],
    "8216": [0, 0.69444, 0, 0, 0.31944],
    "8217": [0, 0.69444, 0, 0, 0.31944],
    "8220": [0, 0.69444, 0, 0, 0.60278],
    "8221": [0, 0.69444, 0, 0, 0.60278],
    "8224": [0.19444, 0.69444, 0, 0, 0.51111],
    "8225": [0.19444, 0.69444, 0, 0, 0.51111],
    "8242": [0, 0.55556, 0, 0, 0.34444],
    "8407": [0, 0.72444, 0.15486, 0, 0.575],
    "8463": [0, 0.69444, 0, 0, 0.66759],
    "8465": [0, 0.69444, 0, 0, 0.83055],
    "8467": [0, 0.69444, 0, 0, 0.47361],
    "8472": [0.19444, 0.44444, 0, 0, 0.74027],
    "8476": [0, 0.69444, 0, 0, 0.83055],
    "8501": [0, 0.69444, 0, 0, 0.70277],
    "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8593": [0.19444, 0.69444, 0, 0, 0.575],
    "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8595": [0.19444, 0.69444, 0, 0, 0.575],
    "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8597": [0.25, 0.75, 0, 0, 0.575],
    "8598": [0.19444, 0.69444, 0, 0, 1.14999],
    "8599": [0.19444, 0.69444, 0, 0, 1.14999],
    "8600": [0.19444, 0.69444, 0, 0, 1.14999],
    "8601": [0.19444, 0.69444, 0, 0, 1.14999],
    "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8657": [0.19444, 0.69444, 0, 0, 0.70277],
    "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8659": [0.19444, 0.69444, 0, 0, 0.70277],
    "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8661": [0.25, 0.75, 0, 0, 0.70277],
    "8704": [0, 0.69444, 0, 0, 0.63889],
    "8706": [0, 0.69444, 0.06389, 0, 0.62847],
    "8707": [0, 0.69444, 0, 0, 0.63889],
    "8709": [0.05556, 0.75, 0, 0, 0.575],
    "8711": [0, 0.68611, 0, 0, 0.95833],
    "8712": [0.08556, 0.58556, 0, 0, 0.76666],
    "8715": [0.08556, 0.58556, 0, 0, 0.76666],
    "8722": [0.13333, 0.63333, 0, 0, 0.89444],
    "8723": [0.13333, 0.63333, 0, 0, 0.89444],
    "8725": [0.25, 0.75, 0, 0, 0.575],
    "8726": [0.25, 0.75, 0, 0, 0.575],
    "8727": [-0.02778, 0.47222, 0, 0, 0.575],
    "8728": [-0.02639, 0.47361, 0, 0, 0.575],
    "8729": [-0.02639, 0.47361, 0, 0, 0.575],
    "8730": [0.18, 0.82, 0, 0, 0.95833],
    "8733": [0, 0.44444, 0, 0, 0.89444],
    "8734": [0, 0.44444, 0, 0, 1.14999],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.31944],
    "8741": [0.25, 0.75, 0, 0, 0.575],
    "8743": [0, 0.55556, 0, 0, 0.76666],
    "8744": [0, 0.55556, 0, 0, 0.76666],
    "8745": [0, 0.55556, 0, 0, 0.76666],
    "8746": [0, 0.55556, 0, 0, 0.76666],
    "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
    "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
    "8768": [0.19444, 0.69444, 0, 0, 0.31944],
    "8771": [0.00222, 0.50222, 0, 0, 0.89444],
    "8773": [0.027, 0.638, 0, 0, 0.894],
    "8776": [0.02444, 0.52444, 0, 0, 0.89444],
    "8781": [0.00222, 0.50222, 0, 0, 0.89444],
    "8801": [0.00222, 0.50222, 0, 0, 0.89444],
    "8804": [0.19667, 0.69667, 0, 0, 0.89444],
    "8805": [0.19667, 0.69667, 0, 0, 0.89444],
    "8810": [0.08556, 0.58556, 0, 0, 1.14999],
    "8811": [0.08556, 0.58556, 0, 0, 1.14999],
    "8826": [0.08556, 0.58556, 0, 0, 0.89444],
    "8827": [0.08556, 0.58556, 0, 0, 0.89444],
    "8834": [0.08556, 0.58556, 0, 0, 0.89444],
    "8835": [0.08556, 0.58556, 0, 0, 0.89444],
    "8838": [0.19667, 0.69667, 0, 0, 0.89444],
    "8839": [0.19667, 0.69667, 0, 0, 0.89444],
    "8846": [0, 0.55556, 0, 0, 0.76666],
    "8849": [0.19667, 0.69667, 0, 0, 0.89444],
    "8850": [0.19667, 0.69667, 0, 0, 0.89444],
    "8851": [0, 0.55556, 0, 0, 0.76666],
    "8852": [0, 0.55556, 0, 0, 0.76666],
    "8853": [0.13333, 0.63333, 0, 0, 0.89444],
    "8854": [0.13333, 0.63333, 0, 0, 0.89444],
    "8855": [0.13333, 0.63333, 0, 0, 0.89444],
    "8856": [0.13333, 0.63333, 0, 0, 0.89444],
    "8857": [0.13333, 0.63333, 0, 0, 0.89444],
    "8866": [0, 0.69444, 0, 0, 0.70277],
    "8867": [0, 0.69444, 0, 0, 0.70277],
    "8868": [0, 0.69444, 0, 0, 0.89444],
    "8869": [0, 0.69444, 0, 0, 0.89444],
    "8900": [-0.02639, 0.47361, 0, 0, 0.575],
    "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
    "8902": [-0.02778, 0.47222, 0, 0, 0.575],
    "8968": [0.25, 0.75, 0, 0, 0.51111],
    "8969": [0.25, 0.75, 0, 0, 0.51111],
    "8970": [0.25, 0.75, 0, 0, 0.51111],
    "8971": [0.25, 0.75, 0, 0, 0.51111],
    "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
    "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
    "9651": [0.19444, 0.69444, 0, 0, 1.02222],
    "9657": [-0.02778, 0.47222, 0, 0, 0.575],
    "9661": [0.19444, 0.69444, 0, 0, 1.02222],
    "9667": [-0.02778, 0.47222, 0, 0, 0.575],
    "9711": [0.19444, 0.69444, 0, 0, 1.14999],
    "9824": [0.12963, 0.69444, 0, 0, 0.89444],
    "9825": [0.12963, 0.69444, 0, 0, 0.89444],
    "9826": [0.12963, 0.69444, 0, 0, 0.89444],
    "9827": [0.12963, 0.69444, 0, 0, 0.89444],
    "9837": [0, 0.75, 0, 0, 0.44722],
    "9838": [0.19444, 0.69444, 0, 0, 0.44722],
    "9839": [0.19444, 0.69444, 0, 0, 0.44722],
    "10216": [0.25, 0.75, 0, 0, 0.44722],
    "10217": [0.25, 0.75, 0, 0, 0.44722],
    "10815": [0, 0.68611, 0, 0, 0.9],
    "10927": [0.19667, 0.69667, 0, 0, 0.89444],
    "10928": [0.19667, 0.69667, 0, 0, 0.89444],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.11417, 0, 0.38611],
    "34": [0, 0.69444, 0.07939, 0, 0.62055],
    "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
    "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
    "38": [0, 0.69444, 0.08528, 0, 0.88555],
    "39": [0, 0.69444, 0.12945, 0, 0.35555],
    "40": [0.25, 0.75, 0.15806, 0, 0.47333],
    "41": [0.25, 0.75, 0.03306, 0, 0.47333],
    "42": [0, 0.75, 0.14333, 0, 0.59111],
    "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
    "44": [0.19444, 0.14722, 0, 0, 0.35555],
    "45": [0, 0.44444, 0.02611, 0, 0.41444],
    "46": [0, 0.14722, 0, 0, 0.35555],
    "47": [0.25, 0.75, 0.15806, 0, 0.59111],
    "48": [0, 0.64444, 0.13167, 0, 0.59111],
    "49": [0, 0.64444, 0.13167, 0, 0.59111],
    "50": [0, 0.64444, 0.13167, 0, 0.59111],
    "51": [0, 0.64444, 0.13167, 0, 0.59111],
    "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "53": [0, 0.64444, 0.13167, 0, 0.59111],
    "54": [0, 0.64444, 0.13167, 0, 0.59111],
    "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "56": [0, 0.64444, 0.13167, 0, 0.59111],
    "57": [0, 0.64444, 0.13167, 0, 0.59111],
    "58": [0, 0.44444, 0.06695, 0, 0.35555],
    "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
    "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    "63": [0, 0.69444, 0.11472, 0, 0.59111],
    "64": [0, 0.69444, 0.09208, 0, 0.88555],
    "65": [0, 0.68611, 0, 0, 0.86555],
    "66": [0, 0.68611, 0.0992, 0, 0.81666],
    "67": [0, 0.68611, 0.14208, 0, 0.82666],
    "68": [0, 0.68611, 0.09062, 0, 0.87555],
    "69": [0, 0.68611, 0.11431, 0, 0.75666],
    "70": [0, 0.68611, 0.12903, 0, 0.72722],
    "71": [0, 0.68611, 0.07347, 0, 0.89527],
    "72": [0, 0.68611, 0.17208, 0, 0.8961],
    "73": [0, 0.68611, 0.15681, 0, 0.47166],
    "74": [0, 0.68611, 0.145, 0, 0.61055],
    "75": [0, 0.68611, 0.14208, 0, 0.89499],
    "76": [0, 0.68611, 0, 0, 0.69777],
    "77": [0, 0.68611, 0.17208, 0, 1.07277],
    "78": [0, 0.68611, 0.17208, 0, 0.8961],
    "79": [0, 0.68611, 0.09062, 0, 0.85499],
    "80": [0, 0.68611, 0.0992, 0, 0.78721],
    "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
    "82": [0, 0.68611, 0.02559, 0, 0.85944],
    "83": [0, 0.68611, 0.11264, 0, 0.64999],
    "84": [0, 0.68611, 0.12903, 0, 0.7961],
    "85": [0, 0.68611, 0.17208, 0, 0.88083],
    "86": [0, 0.68611, 0.18625, 0, 0.86555],
    "87": [0, 0.68611, 0.18625, 0, 1.15999],
    "88": [0, 0.68611, 0.15681, 0, 0.86555],
    "89": [0, 0.68611, 0.19803, 0, 0.86555],
    "90": [0, 0.68611, 0.14208, 0, 0.70888],
    "91": [0.25, 0.75, 0.1875, 0, 0.35611],
    "93": [0.25, 0.75, 0.09972, 0, 0.35611],
    "94": [0, 0.69444, 0.06709, 0, 0.59111],
    "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
    "97": [0, 0.44444, 0.09426, 0, 0.59111],
    "98": [0, 0.69444, 0.07861, 0, 0.53222],
    "99": [0, 0.44444, 0.05222, 0, 0.53222],
    "100": [0, 0.69444, 0.10861, 0, 0.59111],
    "101": [0, 0.44444, 0.085, 0, 0.53222],
    "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
    "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "104": [0, 0.69444, 0.09426, 0, 0.59111],
    "105": [0, 0.69326, 0.11387, 0, 0.35555],
    "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
    "107": [0, 0.69444, 0.11111, 0, 0.53222],
    "108": [0, 0.69444, 0.10861, 0, 0.29666],
    "109": [0, 0.44444, 0.09426, 0, 0.94444],
    "110": [0, 0.44444, 0.09426, 0, 0.64999],
    "111": [0, 0.44444, 0.07861, 0, 0.59111],
    "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
    "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "114": [0, 0.44444, 0.11111, 0, 0.50167],
    "115": [0, 0.44444, 0.08167, 0, 0.48694],
    "116": [0, 0.63492, 0.09639, 0, 0.385],
    "117": [0, 0.44444, 0.09426, 0, 0.62055],
    "118": [0, 0.44444, 0.11111, 0, 0.53222],
    "119": [0, 0.44444, 0.11111, 0, 0.76777],
    "120": [0, 0.44444, 0.12583, 0, 0.56055],
    "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
    "122": [0, 0.44444, 0.13889, 0, 0.49055],
    "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0.11473, 0, 0.59111],
    "176": [0, 0.69444, 0, 0, 0.94888],
    "184": [0.17014, 0, 0, 0, 0.53222],
    "198": [0, 0.68611, 0.11431, 0, 1.02277],
    "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
    "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
    "230": [0, 0.44444, 0.085, 0, 0.82666],
    "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
    "305": [0, 0.44444, 0.09426, 0, 0.35555],
    "338": [0, 0.68611, 0.11431, 0, 1.14054],
    "339": [0, 0.44444, 0.085, 0, 0.82666],
    "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
    "710": [0, 0.69444, 0.06709, 0, 0.59111],
    "711": [0, 0.63194, 0.08271, 0, 0.59111],
    "713": [0, 0.59444, 0.10444, 0, 0.59111],
    "714": [0, 0.69444, 0.08528, 0, 0.59111],
    "715": [0, 0.69444, 0, 0, 0.59111],
    "728": [0, 0.69444, 0.10333, 0, 0.59111],
    "729": [0, 0.69444, 0.12945, 0, 0.35555],
    "730": [0, 0.69444, 0, 0, 0.94888],
    "732": [0, 0.69444, 0.11472, 0, 0.59111],
    "733": [0, 0.69444, 0.11472, 0, 0.59111],
    "915": [0, 0.68611, 0.12903, 0, 0.69777],
    "916": [0, 0.68611, 0, 0, 0.94444],
    "920": [0, 0.68611, 0.09062, 0, 0.88555],
    "923": [0, 0.68611, 0, 0, 0.80666],
    "926": [0, 0.68611, 0.15092, 0, 0.76777],
    "928": [0, 0.68611, 0.17208, 0, 0.8961],
    "931": [0, 0.68611, 0.11431, 0, 0.82666],
    "933": [0, 0.68611, 0.10778, 0, 0.88555],
    "934": [0, 0.68611, 0.05632, 0, 0.82666],
    "936": [0, 0.68611, 0.10778, 0, 0.88555],
    "937": [0, 0.68611, 0.0992, 0, 0.82666],
    "8211": [0, 0.44444, 0.09811, 0, 0.59111],
    "8212": [0, 0.44444, 0.09811, 0, 1.18221],
    "8216": [0, 0.69444, 0.12945, 0, 0.35555],
    "8217": [0, 0.69444, 0.12945, 0, 0.35555],
    "8220": [0, 0.69444, 0.16772, 0, 0.62055],
    "8221": [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.12417, 0, 0.30667],
    "34": [0, 0.69444, 0.06961, 0, 0.51444],
    "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
    "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
    "38": [0, 0.69444, 0.09694, 0, 0.76666],
    "39": [0, 0.69444, 0.12417, 0, 0.30667],
    "40": [0.25, 0.75, 0.16194, 0, 0.40889],
    "41": [0.25, 0.75, 0.03694, 0, 0.40889],
    "42": [0, 0.75, 0.14917, 0, 0.51111],
    "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
    "44": [0.19444, 0.10556, 0, 0, 0.30667],
    "45": [0, 0.43056, 0.02826, 0, 0.35778],
    "46": [0, 0.10556, 0, 0, 0.30667],
    "47": [0.25, 0.75, 0.16194, 0, 0.51111],
    "48": [0, 0.64444, 0.13556, 0, 0.51111],
    "49": [0, 0.64444, 0.13556, 0, 0.51111],
    "50": [0, 0.64444, 0.13556, 0, 0.51111],
    "51": [0, 0.64444, 0.13556, 0, 0.51111],
    "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "53": [0, 0.64444, 0.13556, 0, 0.51111],
    "54": [0, 0.64444, 0.13556, 0, 0.51111],
    "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "56": [0, 0.64444, 0.13556, 0, 0.51111],
    "57": [0, 0.64444, 0.13556, 0, 0.51111],
    "58": [0, 0.43056, 0.0582, 0, 0.30667],
    "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
    "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    "63": [0, 0.69444, 0.1225, 0, 0.51111],
    "64": [0, 0.69444, 0.09597, 0, 0.76666],
    "65": [0, 0.68333, 0, 0, 0.74333],
    "66": [0, 0.68333, 0.10257, 0, 0.70389],
    "67": [0, 0.68333, 0.14528, 0, 0.71555],
    "68": [0, 0.68333, 0.09403, 0, 0.755],
    "69": [0, 0.68333, 0.12028, 0, 0.67833],
    "70": [0, 0.68333, 0.13305, 0, 0.65277],
    "71": [0, 0.68333, 0.08722, 0, 0.77361],
    "72": [0, 0.68333, 0.16389, 0, 0.74333],
    "73": [0, 0.68333, 0.15806, 0, 0.38555],
    "74": [0, 0.68333, 0.14028, 0, 0.525],
    "75": [0, 0.68333, 0.14528, 0, 0.76888],
    "76": [0, 0.68333, 0, 0, 0.62722],
    "77": [0, 0.68333, 0.16389, 0, 0.89666],
    "78": [0, 0.68333, 0.16389, 0, 0.74333],
    "79": [0, 0.68333, 0.09403, 0, 0.76666],
    "80": [0, 0.68333, 0.10257, 0, 0.67833],
    "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
    "82": [0, 0.68333, 0.03868, 0, 0.72944],
    "83": [0, 0.68333, 0.11972, 0, 0.56222],
    "84": [0, 0.68333, 0.13305, 0, 0.71555],
    "85": [0, 0.68333, 0.16389, 0, 0.74333],
    "86": [0, 0.68333, 0.18361, 0, 0.74333],
    "87": [0, 0.68333, 0.18361, 0, 0.99888],
    "88": [0, 0.68333, 0.15806, 0, 0.74333],
    "89": [0, 0.68333, 0.19383, 0, 0.74333],
    "90": [0, 0.68333, 0.14528, 0, 0.61333],
    "91": [0.25, 0.75, 0.1875, 0, 0.30667],
    "93": [0.25, 0.75, 0.10528, 0, 0.30667],
    "94": [0, 0.69444, 0.06646, 0, 0.51111],
    "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
    "97": [0, 0.43056, 0.07671, 0, 0.51111],
    "98": [0, 0.69444, 0.06312, 0, 0.46],
    "99": [0, 0.43056, 0.05653, 0, 0.46],
    "100": [0, 0.69444, 0.10333, 0, 0.51111],
    "101": [0, 0.43056, 0.07514, 0, 0.46],
    "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
    "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "104": [0, 0.69444, 0.07671, 0, 0.51111],
    "105": [0, 0.65536, 0.1019, 0, 0.30667],
    "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
    "107": [0, 0.69444, 0.10764, 0, 0.46],
    "108": [0, 0.69444, 0.10333, 0, 0.25555],
    "109": [0, 0.43056, 0.07671, 0, 0.81777],
    "110": [0, 0.43056, 0.07671, 0, 0.56222],
    "111": [0, 0.43056, 0.06312, 0, 0.51111],
    "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
    "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "114": [0, 0.43056, 0.10764, 0, 0.42166],
    "115": [0, 0.43056, 0.08208, 0, 0.40889],
    "116": [0, 0.61508, 0.09486, 0, 0.33222],
    "117": [0, 0.43056, 0.07671, 0, 0.53666],
    "118": [0, 0.43056, 0.10764, 0, 0.46],
    "119": [0, 0.43056, 0.10764, 0, 0.66444],
    "120": [0, 0.43056, 0.12042, 0, 0.46389],
    "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
    "122": [0, 0.43056, 0.12292, 0, 0.40889],
    "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.66786, 0.10474, 0, 0.51111],
    "176": [0, 0.69444, 0, 0, 0.83129],
    "184": [0.17014, 0, 0, 0, 0.46],
    "198": [0, 0.68333, 0.12028, 0, 0.88277],
    "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
    "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
    "230": [0, 0.43056, 0.07514, 0, 0.71555],
    "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
    "338": [0, 0.68333, 0.12028, 0, 0.98499],
    "339": [0, 0.43056, 0.07514, 0, 0.71555],
    "710": [0, 0.69444, 0.06646, 0, 0.51111],
    "711": [0, 0.62847, 0.08295, 0, 0.51111],
    "713": [0, 0.56167, 0.10333, 0, 0.51111],
    "714": [0, 0.69444, 0.09694, 0, 0.51111],
    "715": [0, 0.69444, 0, 0, 0.51111],
    "728": [0, 0.69444, 0.10806, 0, 0.51111],
    "729": [0, 0.66786, 0.11752, 0, 0.30667],
    "730": [0, 0.69444, 0, 0, 0.83129],
    "732": [0, 0.66786, 0.11585, 0, 0.51111],
    "733": [0, 0.69444, 0.1225, 0, 0.51111],
    "915": [0, 0.68333, 0.13305, 0, 0.62722],
    "916": [0, 0.68333, 0, 0, 0.81777],
    "920": [0, 0.68333, 0.09403, 0, 0.76666],
    "923": [0, 0.68333, 0, 0, 0.69222],
    "926": [0, 0.68333, 0.15294, 0, 0.66444],
    "928": [0, 0.68333, 0.16389, 0, 0.74333],
    "931": [0, 0.68333, 0.12028, 0, 0.71555],
    "933": [0, 0.68333, 0.11111, 0, 0.76666],
    "934": [0, 0.68333, 0.05986, 0, 0.71555],
    "936": [0, 0.68333, 0.11111, 0, 0.76666],
    "937": [0, 0.68333, 0.10257, 0, 0.71555],
    "8211": [0, 0.43056, 0.09208, 0, 0.51111],
    "8212": [0, 0.43056, 0.09208, 0, 1.02222],
    "8216": [0, 0.69444, 0.12417, 0, 0.30667],
    "8217": [0, 0.69444, 0.12417, 0, 0.30667],
    "8220": [0, 0.69444, 0.1685, 0, 0.51444],
    "8221": [0, 0.69444, 0.06961, 0, 0.51444],
    "8463": [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.27778],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.77778],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.19444, 0.10556, 0, 0, 0.27778],
    "45": [0, 0.43056, 0, 0, 0.33333],
    "46": [0, 0.10556, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.64444, 0, 0, 0.5],
    "49": [0, 0.64444, 0, 0, 0.5],
    "50": [0, 0.64444, 0, 0, 0.5],
    "51": [0, 0.64444, 0, 0, 0.5],
    "52": [0, 0.64444, 0, 0, 0.5],
    "53": [0, 0.64444, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0, 0.64444, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0, 0.64444, 0, 0, 0.5],
    "58": [0, 0.43056, 0, 0, 0.27778],
    "59": [0.19444, 0.43056, 0, 0, 0.27778],
    "60": [0.0391, 0.5391, 0, 0, 0.77778],
    "61": [-0.13313, 0.36687, 0, 0, 0.77778],
    "62": [0.0391, 0.5391, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.77778],
    "65": [0, 0.68333, 0, 0, 0.75],
    "66": [0, 0.68333, 0, 0, 0.70834],
    "67": [0, 0.68333, 0, 0, 0.72222],
    "68": [0, 0.68333, 0, 0, 0.76389],
    "69": [0, 0.68333, 0, 0, 0.68056],
    "70": [0, 0.68333, 0, 0, 0.65278],
    "71": [0, 0.68333, 0, 0, 0.78472],
    "72": [0, 0.68333, 0, 0, 0.75],
    "73": [0, 0.68333, 0, 0, 0.36111],
    "74": [0, 0.68333, 0, 0, 0.51389],
    "75": [0, 0.68333, 0, 0, 0.77778],
    "76": [0, 0.68333, 0, 0, 0.625],
    "77": [0, 0.68333, 0, 0, 0.91667],
    "78": [0, 0.68333, 0, 0, 0.75],
    "79": [0, 0.68333, 0, 0, 0.77778],
    "80": [0, 0.68333, 0, 0, 0.68056],
    "81": [0.19444, 0.68333, 0, 0, 0.77778],
    "82": [0, 0.68333, 0, 0, 0.73611],
    "83": [0, 0.68333, 0, 0, 0.55556],
    "84": [0, 0.68333, 0, 0, 0.72222],
    "85": [0, 0.68333, 0, 0, 0.75],
    "86": [0, 0.68333, 0.01389, 0, 0.75],
    "87": [0, 0.68333, 0.01389, 0, 1.02778],
    "88": [0, 0.68333, 0, 0, 0.75],
    "89": [0, 0.68333, 0.025, 0, 0.75],
    "90": [0, 0.68333, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.27778],
    "92": [0.25, 0.75, 0, 0, 0.5],
    "93": [0.25, 0.75, 0, 0, 0.27778],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.31, 0.12056, 0.02778, 0, 0.5],
    "97": [0, 0.43056, 0, 0, 0.5],
    "98": [0, 0.69444, 0, 0, 0.55556],
    "99": [0, 0.43056, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.55556],
    "101": [0, 0.43056, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.07778, 0, 0.30556],
    "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.55556],
    "105": [0, 0.66786, 0, 0, 0.27778],
    "106": [0.19444, 0.66786, 0, 0, 0.30556],
    "107": [0, 0.69444, 0, 0, 0.52778],
    "108": [0, 0.69444, 0, 0, 0.27778],
    "109": [0, 0.43056, 0, 0, 0.83334],
    "110": [0, 0.43056, 0, 0, 0.55556],
    "111": [0, 0.43056, 0, 0, 0.5],
    "112": [0.19444, 0.43056, 0, 0, 0.55556],
    "113": [0.19444, 0.43056, 0, 0, 0.52778],
    "114": [0, 0.43056, 0, 0, 0.39167],
    "115": [0, 0.43056, 0, 0, 0.39445],
    "116": [0, 0.61508, 0, 0, 0.38889],
    "117": [0, 0.43056, 0, 0, 0.55556],
    "118": [0, 0.43056, 0.01389, 0, 0.52778],
    "119": [0, 0.43056, 0.01389, 0, 0.72222],
    "120": [0, 0.43056, 0, 0, 0.52778],
    "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
    "122": [0, 0.43056, 0, 0, 0.44445],
    "123": [0.25, 0.75, 0, 0, 0.5],
    "124": [0.25, 0.75, 0, 0, 0.27778],
    "125": [0.25, 0.75, 0, 0, 0.5],
    "126": [0.35, 0.31786, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.76909],
    "167": [0.19444, 0.69444, 0, 0, 0.44445],
    "168": [0, 0.66786, 0, 0, 0.5],
    "172": [0, 0.43056, 0, 0, 0.66667],
    "176": [0, 0.69444, 0, 0, 0.75],
    "177": [0.08333, 0.58333, 0, 0, 0.77778],
    "182": [0.19444, 0.69444, 0, 0, 0.61111],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "198": [0, 0.68333, 0, 0, 0.90278],
    "215": [0.08333, 0.58333, 0, 0, 0.77778],
    "216": [0.04861, 0.73194, 0, 0, 0.77778],
    "223": [0, 0.69444, 0, 0, 0.5],
    "230": [0, 0.43056, 0, 0, 0.72222],
    "247": [0.08333, 0.58333, 0, 0, 0.77778],
    "248": [0.09722, 0.52778, 0, 0, 0.5],
    "305": [0, 0.43056, 0, 0, 0.27778],
    "338": [0, 0.68333, 0, 0, 1.01389],
    "339": [0, 0.43056, 0, 0, 0.77778],
    "567": [0.19444, 0.43056, 0, 0, 0.30556],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.62847, 0, 0, 0.5],
    "713": [0, 0.56778, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.66786, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.75],
    "732": [0, 0.66786, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.68333, 0, 0, 0.625],
    "916": [0, 0.68333, 0, 0, 0.83334],
    "920": [0, 0.68333, 0, 0, 0.77778],
    "923": [0, 0.68333, 0, 0, 0.69445],
    "926": [0, 0.68333, 0, 0, 0.66667],
    "928": [0, 0.68333, 0, 0, 0.75],
    "931": [0, 0.68333, 0, 0, 0.72222],
    "933": [0, 0.68333, 0, 0, 0.77778],
    "934": [0, 0.68333, 0, 0, 0.72222],
    "936": [0, 0.68333, 0, 0, 0.77778],
    "937": [0, 0.68333, 0, 0, 0.72222],
    "8211": [0, 0.43056, 0.02778, 0, 0.5],
    "8212": [0, 0.43056, 0.02778, 0, 1.0],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5],
    "8224": [0.19444, 0.69444, 0, 0, 0.44445],
    "8225": [0.19444, 0.69444, 0, 0, 0.44445],
    "8230": [0, 0.123, 0, 0, 1.172],
    "8242": [0, 0.55556, 0, 0, 0.275],
    "8407": [0, 0.71444, 0.15382, 0, 0.5],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8465": [0, 0.69444, 0, 0, 0.72222],
    "8467": [0, 0.69444, 0, 0.11111, 0.41667],
    "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
    "8476": [0, 0.69444, 0, 0, 0.72222],
    "8501": [0, 0.69444, 0, 0, 0.61111],
    "8592": [-0.13313, 0.36687, 0, 0, 1.0],
    "8593": [0.19444, 0.69444, 0, 0, 0.5],
    "8594": [-0.13313, 0.36687, 0, 0, 1.0],
    "8595": [0.19444, 0.69444, 0, 0, 0.5],
    "8596": [-0.13313, 0.36687, 0, 0, 1.0],
    "8597": [0.25, 0.75, 0, 0, 0.5],
    "8598": [0.19444, 0.69444, 0, 0, 1.0],
    "8599": [0.19444, 0.69444, 0, 0, 1.0],
    "8600": [0.19444, 0.69444, 0, 0, 1.0],
    "8601": [0.19444, 0.69444, 0, 0, 1.0],
    "8614": [0.011, 0.511, 0, 0, 1.0],
    "8617": [0.011, 0.511, 0, 0, 1.126],
    "8618": [0.011, 0.511, 0, 0, 1.126],
    "8636": [-0.13313, 0.36687, 0, 0, 1.0],
    "8637": [-0.13313, 0.36687, 0, 0, 1.0],
    "8640": [-0.13313, 0.36687, 0, 0, 1.0],
    "8641": [-0.13313, 0.36687, 0, 0, 1.0],
    "8652": [0.011, 0.671, 0, 0, 1.0],
    "8656": [-0.13313, 0.36687, 0, 0, 1.0],
    "8657": [0.19444, 0.69444, 0, 0, 0.61111],
    "8658": [-0.13313, 0.36687, 0, 0, 1.0],
    "8659": [0.19444, 0.69444, 0, 0, 0.61111],
    "8660": [-0.13313, 0.36687, 0, 0, 1.0],
    "8661": [0.25, 0.75, 0, 0, 0.61111],
    "8704": [0, 0.69444, 0, 0, 0.55556],
    "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
    "8707": [0, 0.69444, 0, 0, 0.55556],
    "8709": [0.05556, 0.75, 0, 0, 0.5],
    "8711": [0, 0.68333, 0, 0, 0.83334],
    "8712": [0.0391, 0.5391, 0, 0, 0.66667],
    "8715": [0.0391, 0.5391, 0, 0, 0.66667],
    "8722": [0.08333, 0.58333, 0, 0, 0.77778],
    "8723": [0.08333, 0.58333, 0, 0, 0.77778],
    "8725": [0.25, 0.75, 0, 0, 0.5],
    "8726": [0.25, 0.75, 0, 0, 0.5],
    "8727": [-0.03472, 0.46528, 0, 0, 0.5],
    "8728": [-0.05555, 0.44445, 0, 0, 0.5],
    "8729": [-0.05555, 0.44445, 0, 0, 0.5],
    "8730": [0.2, 0.8, 0, 0, 0.83334],
    "8733": [0, 0.43056, 0, 0, 0.77778],
    "8734": [0, 0.43056, 0, 0, 1.0],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.27778],
    "8741": [0.25, 0.75, 0, 0, 0.5],
    "8743": [0, 0.55556, 0, 0, 0.66667],
    "8744": [0, 0.55556, 0, 0, 0.66667],
    "8745": [0, 0.55556, 0, 0, 0.66667],
    "8746": [0, 0.55556, 0, 0, 0.66667],
    "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8768": [0.19444, 0.69444, 0, 0, 0.27778],
    "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8773": [-0.022, 0.589, 0, 0, 0.778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8784": [-0.133, 0.673, 0, 0, 0.778],
    "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8804": [0.13597, 0.63597, 0, 0, 0.77778],
    "8805": [0.13597, 0.63597, 0, 0, 0.77778],
    "8810": [0.0391, 0.5391, 0, 0, 1.0],
    "8811": [0.0391, 0.5391, 0, 0, 1.0],
    "8826": [0.0391, 0.5391, 0, 0, 0.77778],
    "8827": [0.0391, 0.5391, 0, 0, 0.77778],
    "8834": [0.0391, 0.5391, 0, 0, 0.77778],
    "8835": [0.0391, 0.5391, 0, 0, 0.77778],
    "8838": [0.13597, 0.63597, 0, 0, 0.77778],
    "8839": [0.13597, 0.63597, 0, 0, 0.77778],
    "8846": [0, 0.55556, 0, 0, 0.66667],
    "8849": [0.13597, 0.63597, 0, 0, 0.77778],
    "8850": [0.13597, 0.63597, 0, 0, 0.77778],
    "8851": [0, 0.55556, 0, 0, 0.66667],
    "8852": [0, 0.55556, 0, 0, 0.66667],
    "8853": [0.08333, 0.58333, 0, 0, 0.77778],
    "8854": [0.08333, 0.58333, 0, 0, 0.77778],
    "8855": [0.08333, 0.58333, 0, 0, 0.77778],
    "8856": [0.08333, 0.58333, 0, 0, 0.77778],
    "8857": [0.08333, 0.58333, 0, 0, 0.77778],
    "8866": [0, 0.69444, 0, 0, 0.61111],
    "8867": [0, 0.69444, 0, 0, 0.61111],
    "8868": [0, 0.69444, 0, 0, 0.77778],
    "8869": [0, 0.69444, 0, 0, 0.77778],
    "8872": [0.249, 0.75, 0, 0, 0.867],
    "8900": [-0.05555, 0.44445, 0, 0, 0.5],
    "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
    "8902": [-0.03472, 0.46528, 0, 0, 0.5],
    "8904": [0.005, 0.505, 0, 0, 0.9],
    "8942": [0.03, 0.903, 0, 0, 0.278],
    "8943": [-0.19, 0.313, 0, 0, 1.172],
    "8945": [-0.1, 0.823, 0, 0, 1.282],
    "8968": [0.25, 0.75, 0, 0, 0.44445],
    "8969": [0.25, 0.75, 0, 0, 0.44445],
    "8970": [0.25, 0.75, 0, 0, 0.44445],
    "8971": [0.25, 0.75, 0, 0, 0.44445],
    "8994": [-0.14236, 0.35764, 0, 0, 1.0],
    "8995": [-0.14236, 0.35764, 0, 0, 1.0],
    "9136": [0.244, 0.744, 0, 0, 0.412],
    "9137": [0.244, 0.745, 0, 0, 0.412],
    "9651": [0.19444, 0.69444, 0, 0, 0.88889],
    "9657": [-0.03472, 0.46528, 0, 0, 0.5],
    "9661": [0.19444, 0.69444, 0, 0, 0.88889],
    "9667": [-0.03472, 0.46528, 0, 0, 0.5],
    "9711": [0.19444, 0.69444, 0, 0, 1.0],
    "9824": [0.12963, 0.69444, 0, 0, 0.77778],
    "9825": [0.12963, 0.69444, 0, 0, 0.77778],
    "9826": [0.12963, 0.69444, 0, 0, 0.77778],
    "9827": [0.12963, 0.69444, 0, 0, 0.77778],
    "9837": [0, 0.75, 0, 0, 0.38889],
    "9838": [0.19444, 0.69444, 0, 0, 0.38889],
    "9839": [0.19444, 0.69444, 0, 0, 0.38889],
    "10216": [0.25, 0.75, 0, 0, 0.38889],
    "10217": [0.25, 0.75, 0, 0, 0.38889],
    "10222": [0.244, 0.744, 0, 0, 0.412],
    "10223": [0.244, 0.745, 0, 0, 0.412],
    "10229": [0.011, 0.511, 0, 0, 1.609],
    "10230": [0.011, 0.511, 0, 0, 1.638],
    "10231": [0.011, 0.511, 0, 0, 1.859],
    "10232": [0.024, 0.525, 0, 0, 1.609],
    "10233": [0.024, 0.525, 0, 0, 1.638],
    "10234": [0.024, 0.525, 0, 0, 1.858],
    "10236": [0.011, 0.511, 0, 0, 1.638],
    "10815": [0, 0.68333, 0, 0, 0.75],
    "10927": [0.13597, 0.63597, 0, 0, 0.77778],
    "10928": [0.13597, 0.63597, 0, 0, 0.77778],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.44444, 0, 0, 0.575],
    "49": [0, 0.44444, 0, 0, 0.575],
    "50": [0, 0.44444, 0, 0, 0.575],
    "51": [0.19444, 0.44444, 0, 0, 0.575],
    "52": [0.19444, 0.44444, 0, 0, 0.575],
    "53": [0.19444, 0.44444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0.19444, 0.44444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0.19444, 0.44444, 0, 0, 0.575],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0.04835, 0, 0.8664],
    "67": [0, 0.68611, 0.06979, 0, 0.81694],
    "68": [0, 0.68611, 0.03194, 0, 0.93812],
    "69": [0, 0.68611, 0.05451, 0, 0.81007],
    "70": [0, 0.68611, 0.15972, 0, 0.68889],
    "71": [0, 0.68611, 0, 0, 0.88673],
    "72": [0, 0.68611, 0.08229, 0, 0.98229],
    "73": [0, 0.68611, 0.07778, 0, 0.51111],
    "74": [0, 0.68611, 0.10069, 0, 0.63125],
    "75": [0, 0.68611, 0.06979, 0, 0.97118],
    "76": [0, 0.68611, 0, 0, 0.75555],
    "77": [0, 0.68611, 0.11424, 0, 1.14201],
    "78": [0, 0.68611, 0.11424, 0, 0.95034],
    "79": [0, 0.68611, 0.03194, 0, 0.83666],
    "80": [0, 0.68611, 0.15972, 0, 0.72309],
    "81": [0.19444, 0.68611, 0, 0, 0.86861],
    "82": [0, 0.68611, 0.00421, 0, 0.87235],
    "83": [0, 0.68611, 0.05382, 0, 0.69271],
    "84": [0, 0.68611, 0.15972, 0, 0.63663],
    "85": [0, 0.68611, 0.11424, 0, 0.80027],
    "86": [0, 0.68611, 0.25555, 0, 0.67778],
    "87": [0, 0.68611, 0.15972, 0, 1.09305],
    "88": [0, 0.68611, 0.07778, 0, 0.94722],
    "89": [0, 0.68611, 0.25555, 0, 0.67458],
    "90": [0, 0.68611, 0.06979, 0, 0.77257],
    "97": [0, 0.44444, 0, 0, 0.63287],
    "98": [0, 0.69444, 0, 0, 0.52083],
    "99": [0, 0.44444, 0, 0, 0.51342],
    "100": [0, 0.69444, 0, 0, 0.60972],
    "101": [0, 0.44444, 0, 0, 0.55361],
    "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
    "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
    "104": [0, 0.69444, 0, 0, 0.66759],
    "105": [0, 0.69326, 0, 0, 0.4048],
    "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
    "107": [0, 0.69444, 0.01852, 0, 0.6037],
    "108": [0, 0.69444, 0.0088, 0, 0.34815],
    "109": [0, 0.44444, 0, 0, 1.0324],
    "110": [0, 0.44444, 0, 0, 0.71296],
    "111": [0, 0.44444, 0, 0, 0.58472],
    "112": [0.19444, 0.44444, 0, 0, 0.60092],
    "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
    "114": [0, 0.44444, 0.03194, 0, 0.5287],
    "115": [0, 0.44444, 0, 0, 0.53125],
    "116": [0, 0.63492, 0, 0, 0.41528],
    "117": [0, 0.44444, 0, 0, 0.68102],
    "118": [0, 0.44444, 0.03704, 0, 0.56666],
    "119": [0, 0.44444, 0.02778, 0, 0.83148],
    "120": [0, 0.44444, 0, 0, 0.65903],
    "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
    "122": [0, 0.44444, 0.04213, 0, 0.55509],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68611, 0.15972, 0, 0.65694],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0.03194, 0, 0.86722],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0.07458, 0, 0.84125],
    "928": [0, 0.68611, 0.08229, 0, 0.98229],
    "931": [0, 0.68611, 0.05451, 0, 0.88507],
    "933": [0, 0.68611, 0.15972, 0, 0.67083],
    "934": [0, 0.68611, 0, 0, 0.76666],
    "936": [0, 0.68611, 0.11653, 0, 0.71402],
    "937": [0, 0.68611, 0.04835, 0, 0.8789],
    "945": [0, 0.44444, 0, 0, 0.76064],
    "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
    "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
    "948": [0, 0.69444, 0.03819, 0, 0.52222],
    "949": [0, 0.44444, 0, 0, 0.52882],
    "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
    "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
    "952": [0, 0.69444, 0.03194, 0, 0.5618],
    "953": [0, 0.44444, 0, 0, 0.41204],
    "954": [0, 0.44444, 0, 0, 0.66759],
    "955": [0, 0.69444, 0, 0, 0.67083],
    "956": [0.19444, 0.44444, 0, 0, 0.70787],
    "957": [0, 0.44444, 0.06898, 0, 0.57685],
    "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
    "959": [0, 0.44444, 0, 0, 0.58472],
    "960": [0, 0.44444, 0.03704, 0, 0.68241],
    "961": [0.19444, 0.44444, 0, 0, 0.6118],
    "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
    "963": [0, 0.44444, 0.03704, 0, 0.68588],
    "964": [0, 0.44444, 0.13472, 0, 0.52083],
    "965": [0, 0.44444, 0.03704, 0, 0.63055],
    "966": [0.19444, 0.44444, 0, 0, 0.74722],
    "967": [0.19444, 0.44444, 0, 0, 0.71805],
    "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
    "969": [0, 0.44444, 0.03704, 0, 0.71782],
    "977": [0, 0.69444, 0, 0, 0.69155],
    "981": [0.19444, 0.69444, 0, 0, 0.7125],
    "982": [0, 0.44444, 0.03194, 0, 0.975],
    "1009": [0.19444, 0.44444, 0, 0, 0.6118],
    "1013": [0, 0.44444, 0, 0, 0.48333],
    "57649": [0, 0.44444, 0, 0, 0.39352],
    "57911": [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.43056, 0, 0, 0.5],
    "49": [0, 0.43056, 0, 0, 0.5],
    "50": [0, 0.43056, 0, 0, 0.5],
    "51": [0.19444, 0.43056, 0, 0, 0.5],
    "52": [0.19444, 0.43056, 0, 0, 0.5],
    "53": [0.19444, 0.43056, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0.19444, 0.43056, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0.19444, 0.43056, 0, 0, 0.5],
    "65": [0, 0.68333, 0, 0.13889, 0.75],
    "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
    "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
    "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
    "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
    "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
    "71": [0, 0.68333, 0, 0.08334, 0.78625],
    "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
    "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
    "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
    "76": [0, 0.68333, 0, 0.02778, 0.68056],
    "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
    "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
    "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
    "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
    "82": [0, 0.68333, 0.00773, 0.08334, 0.75929],
    "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
    "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
    "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
    "86": [0, 0.68333, 0.22222, 0, 0.58333],
    "87": [0, 0.68333, 0.13889, 0, 0.94445],
    "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
    "89": [0, 0.68333, 0.22222, 0, 0.58056],
    "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
    "97": [0, 0.43056, 0, 0, 0.52859],
    "98": [0, 0.69444, 0, 0, 0.42917],
    "99": [0, 0.43056, 0, 0.05556, 0.43276],
    "100": [0, 0.69444, 0, 0.16667, 0.52049],
    "101": [0, 0.43056, 0, 0.05556, 0.46563],
    "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    "104": [0, 0.69444, 0, 0, 0.57616],
    "105": [0, 0.65952, 0, 0, 0.34451],
    "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
    "107": [0, 0.69444, 0.03148, 0, 0.5206],
    "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
    "109": [0, 0.43056, 0, 0, 0.87801],
    "110": [0, 0.43056, 0, 0, 0.60023],
    "111": [0, 0.43056, 0, 0.05556, 0.48472],
    "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
    "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
    "115": [0, 0.43056, 0, 0.05556, 0.46875],
    "116": [0, 0.61508, 0, 0.08334, 0.36111],
    "117": [0, 0.43056, 0, 0.02778, 0.57246],
    "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
    "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
    "120": [0, 0.43056, 0, 0.02778, 0.57153],
    "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
    "916": [0, 0.68333, 0, 0.16667, 0.83334],
    "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "923": [0, 0.68333, 0, 0.16667, 0.69445],
    "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
    "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
    "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
    "934": [0, 0.68333, 0, 0.08334, 0.66667],
    "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
    "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
    "945": [0, 0.43056, 0.0037, 0.02778, 0.6397],
    "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
    "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
    "949": [0, 0.43056, 0, 0.08334, 0.46632],
    "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
    "953": [0, 0.43056, 0, 0.05556, 0.35394],
    "954": [0, 0.43056, 0, 0, 0.57616],
    "955": [0, 0.69444, 0, 0, 0.58334],
    "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
    "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
    "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    "959": [0, 0.43056, 0, 0.05556, 0.48472],
    "960": [0, 0.43056, 0.03588, 0, 0.57003],
    "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    "963": [0, 0.43056, 0.03588, 0, 0.57141],
    "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
    "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
    "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
    "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
    "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    "969": [0, 0.43056, 0.03588, 0, 0.62245],
    "977": [0, 0.69444, 0, 0.08334, 0.59144],
    "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
    "982": [0, 0.43056, 0.02778, 0, 0.82813],
    "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "1013": [0, 0.43056, 0, 0.05556, 0.4059],
    "57649": [0, 0.43056, 0, 0.02778, 0.32246],
    "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.36667],
    "34": [0, 0.69444, 0, 0, 0.55834],
    "35": [0.19444, 0.69444, 0, 0, 0.91667],
    "36": [0.05556, 0.75, 0, 0, 0.55],
    "37": [0.05556, 0.75, 0, 0, 1.02912],
    "38": [0, 0.69444, 0, 0, 0.83056],
    "39": [0, 0.69444, 0, 0, 0.30556],
    "40": [0.25, 0.75, 0, 0, 0.42778],
    "41": [0.25, 0.75, 0, 0, 0.42778],
    "42": [0, 0.75, 0, 0, 0.55],
    "43": [0.11667, 0.61667, 0, 0, 0.85556],
    "44": [0.10556, 0.13056, 0, 0, 0.30556],
    "45": [0, 0.45833, 0, 0, 0.36667],
    "46": [0, 0.13056, 0, 0, 0.30556],
    "47": [0.25, 0.75, 0, 0, 0.55],
    "48": [0, 0.69444, 0, 0, 0.55],
    "49": [0, 0.69444, 0, 0, 0.55],
    "50": [0, 0.69444, 0, 0, 0.55],
    "51": [0, 0.69444, 0, 0, 0.55],
    "52": [0, 0.69444, 0, 0, 0.55],
    "53": [0, 0.69444, 0, 0, 0.55],
    "54": [0, 0.69444, 0, 0, 0.55],
    "55": [0, 0.69444, 0, 0, 0.55],
    "56": [0, 0.69444, 0, 0, 0.55],
    "57": [0, 0.69444, 0, 0, 0.55],
    "58": [0, 0.45833, 0, 0, 0.30556],
    "59": [0.10556, 0.45833, 0, 0, 0.30556],
    "61": [-0.09375, 0.40625, 0, 0, 0.85556],
    "63": [0, 0.69444, 0, 0, 0.51945],
    "64": [0, 0.69444, 0, 0, 0.73334],
    "65": [0, 0.69444, 0, 0, 0.73334],
    "66": [0, 0.69444, 0, 0, 0.73334],
    "67": [0, 0.69444, 0, 0, 0.70278],
    "68": [0, 0.69444, 0, 0, 0.79445],
    "69": [0, 0.69444, 0, 0, 0.64167],
    "70": [0, 0.69444, 0, 0, 0.61111],
    "71": [0, 0.69444, 0, 0, 0.73334],
    "72": [0, 0.69444, 0, 0, 0.79445],
    "73": [0, 0.69444, 0, 0, 0.33056],
    "74": [0, 0.69444, 0, 0, 0.51945],
    "75": [0, 0.69444, 0, 0, 0.76389],
    "76": [0, 0.69444, 0, 0, 0.58056],
    "77": [0, 0.69444, 0, 0, 0.97778],
    "78": [0, 0.69444, 0, 0, 0.79445],
    "79": [0, 0.69444, 0, 0, 0.79445],
    "80": [0, 0.69444, 0, 0, 0.70278],
    "81": [0.10556, 0.69444, 0, 0, 0.79445],
    "82": [0, 0.69444, 0, 0, 0.70278],
    "83": [0, 0.69444, 0, 0, 0.61111],
    "84": [0, 0.69444, 0, 0, 0.73334],
    "85": [0, 0.69444, 0, 0, 0.76389],
    "86": [0, 0.69444, 0.01528, 0, 0.73334],
    "87": [0, 0.69444, 0.01528, 0, 1.03889],
    "88": [0, 0.69444, 0, 0, 0.73334],
    "89": [0, 0.69444, 0.0275, 0, 0.73334],
    "90": [0, 0.69444, 0, 0, 0.67223],
    "91": [0.25, 0.75, 0, 0, 0.34306],
    "93": [0.25, 0.75, 0, 0, 0.34306],
    "94": [0, 0.69444, 0, 0, 0.55],
    "95": [0.35, 0.10833, 0.03056, 0, 0.55],
    "97": [0, 0.45833, 0, 0, 0.525],
    "98": [0, 0.69444, 0, 0, 0.56111],
    "99": [0, 0.45833, 0, 0, 0.48889],
    "100": [0, 0.69444, 0, 0, 0.56111],
    "101": [0, 0.45833, 0, 0, 0.51111],
    "102": [0, 0.69444, 0.07639, 0, 0.33611],
    "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
    "104": [0, 0.69444, 0, 0, 0.56111],
    "105": [0, 0.69444, 0, 0, 0.25556],
    "106": [0.19444, 0.69444, 0, 0, 0.28611],
    "107": [0, 0.69444, 0, 0, 0.53056],
    "108": [0, 0.69444, 0, 0, 0.25556],
    "109": [0, 0.45833, 0, 0, 0.86667],
    "110": [0, 0.45833, 0, 0, 0.56111],
    "111": [0, 0.45833, 0, 0, 0.55],
    "112": [0.19444, 0.45833, 0, 0, 0.56111],
    "113": [0.19444, 0.45833, 0, 0, 0.56111],
    "114": [0, 0.45833, 0.01528, 0, 0.37222],
    "115": [0, 0.45833, 0, 0, 0.42167],
    "116": [0, 0.58929, 0, 0, 0.40417],
    "117": [0, 0.45833, 0, 0, 0.56111],
    "118": [0, 0.45833, 0.01528, 0, 0.5],
    "119": [0, 0.45833, 0.01528, 0, 0.74445],
    "120": [0, 0.45833, 0, 0, 0.5],
    "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
    "122": [0, 0.45833, 0, 0, 0.47639],
    "126": [0.35, 0.34444, 0, 0, 0.55],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0, 0, 0.55],
    "176": [0, 0.69444, 0, 0, 0.73334],
    "180": [0, 0.69444, 0, 0, 0.55],
    "184": [0.17014, 0, 0, 0, 0.48889],
    "305": [0, 0.45833, 0, 0, 0.25556],
    "567": [0.19444, 0.45833, 0, 0, 0.28611],
    "710": [0, 0.69444, 0, 0, 0.55],
    "711": [0, 0.63542, 0, 0, 0.55],
    "713": [0, 0.63778, 0, 0, 0.55],
    "728": [0, 0.69444, 0, 0, 0.55],
    "729": [0, 0.69444, 0, 0, 0.30556],
    "730": [0, 0.69444, 0, 0, 0.73334],
    "732": [0, 0.69444, 0, 0, 0.55],
    "733": [0, 0.69444, 0, 0, 0.55],
    "915": [0, 0.69444, 0, 0, 0.58056],
    "916": [0, 0.69444, 0, 0, 0.91667],
    "920": [0, 0.69444, 0, 0, 0.85556],
    "923": [0, 0.69444, 0, 0, 0.67223],
    "926": [0, 0.69444, 0, 0, 0.73334],
    "928": [0, 0.69444, 0, 0, 0.79445],
    "931": [0, 0.69444, 0, 0, 0.79445],
    "933": [0, 0.69444, 0, 0, 0.85556],
    "934": [0, 0.69444, 0, 0, 0.79445],
    "936": [0, 0.69444, 0, 0, 0.85556],
    "937": [0, 0.69444, 0, 0, 0.79445],
    "8211": [0, 0.45833, 0.03056, 0, 0.55],
    "8212": [0, 0.45833, 0.03056, 0, 1.10001],
    "8216": [0, 0.69444, 0, 0, 0.30556],
    "8217": [0, 0.69444, 0, 0, 0.30556],
    "8220": [0, 0.69444, 0, 0, 0.55834],
    "8221": [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.05733, 0, 0.31945],
    "34": [0, 0.69444, 0.00316, 0, 0.5],
    "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
    "36": [0.05556, 0.75, 0.11156, 0, 0.5],
    "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
    "38": [0, 0.69444, 0.03058, 0, 0.75834],
    "39": [0, 0.69444, 0.07816, 0, 0.27778],
    "40": [0.25, 0.75, 0.13164, 0, 0.38889],
    "41": [0.25, 0.75, 0.02536, 0, 0.38889],
    "42": [0, 0.75, 0.11775, 0, 0.5],
    "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0.01946, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0.13164, 0, 0.5],
    "48": [0, 0.65556, 0.11156, 0, 0.5],
    "49": [0, 0.65556, 0.11156, 0, 0.5],
    "50": [0, 0.65556, 0.11156, 0, 0.5],
    "51": [0, 0.65556, 0.11156, 0, 0.5],
    "52": [0, 0.65556, 0.11156, 0, 0.5],
    "53": [0, 0.65556, 0.11156, 0, 0.5],
    "54": [0, 0.65556, 0.11156, 0, 0.5],
    "55": [0, 0.65556, 0.11156, 0, 0.5],
    "56": [0, 0.65556, 0.11156, 0, 0.5],
    "57": [0, 0.65556, 0.11156, 0, 0.5],
    "58": [0, 0.44444, 0.02502, 0, 0.27778],
    "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
    "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
    "63": [0, 0.69444, 0.11809, 0, 0.47222],
    "64": [0, 0.69444, 0.07555, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0.08293, 0, 0.66667],
    "67": [0, 0.69444, 0.11983, 0, 0.63889],
    "68": [0, 0.69444, 0.07555, 0, 0.72223],
    "69": [0, 0.69444, 0.11983, 0, 0.59722],
    "70": [0, 0.69444, 0.13372, 0, 0.56945],
    "71": [0, 0.69444, 0.11983, 0, 0.66667],
    "72": [0, 0.69444, 0.08094, 0, 0.70834],
    "73": [0, 0.69444, 0.13372, 0, 0.27778],
    "74": [0, 0.69444, 0.08094, 0, 0.47222],
    "75": [0, 0.69444, 0.11983, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0.08094, 0, 0.875],
    "78": [0, 0.69444, 0.08094, 0, 0.70834],
    "79": [0, 0.69444, 0.07555, 0, 0.73611],
    "80": [0, 0.69444, 0.08293, 0, 0.63889],
    "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
    "82": [0, 0.69444, 0.08293, 0, 0.64584],
    "83": [0, 0.69444, 0.09205, 0, 0.55556],
    "84": [0, 0.69444, 0.13372, 0, 0.68056],
    "85": [0, 0.69444, 0.08094, 0, 0.6875],
    "86": [0, 0.69444, 0.1615, 0, 0.66667],
    "87": [0, 0.69444, 0.1615, 0, 0.94445],
    "88": [0, 0.69444, 0.13372, 0, 0.66667],
    "89": [0, 0.69444, 0.17261, 0, 0.66667],
    "90": [0, 0.69444, 0.11983, 0, 0.61111],
    "91": [0.25, 0.75, 0.15942, 0, 0.28889],
    "93": [0.25, 0.75, 0.08719, 0, 0.28889],
    "94": [0, 0.69444, 0.0799, 0, 0.5],
    "95": [0.35, 0.09444, 0.08616, 0, 0.5],
    "97": [0, 0.44444, 0.00981, 0, 0.48056],
    "98": [0, 0.69444, 0.03057, 0, 0.51667],
    "99": [0, 0.44444, 0.08336, 0, 0.44445],
    "100": [0, 0.69444, 0.09483, 0, 0.51667],
    "101": [0, 0.44444, 0.06778, 0, 0.44445],
    "102": [0, 0.69444, 0.21705, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
    "104": [0, 0.69444, 0.01778, 0, 0.51667],
    "105": [0, 0.67937, 0.09718, 0, 0.23889],
    "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
    "107": [0, 0.69444, 0.08336, 0, 0.48889],
    "108": [0, 0.69444, 0.09483, 0, 0.23889],
    "109": [0, 0.44444, 0.01778, 0, 0.79445],
    "110": [0, 0.44444, 0.01778, 0, 0.51667],
    "111": [0, 0.44444, 0.06613, 0, 0.5],
    "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
    "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
    "114": [0, 0.44444, 0.10836, 0, 0.34167],
    "115": [0, 0.44444, 0.0778, 0, 0.38333],
    "116": [0, 0.57143, 0.07225, 0, 0.36111],
    "117": [0, 0.44444, 0.04169, 0, 0.51667],
    "118": [0, 0.44444, 0.10836, 0, 0.46111],
    "119": [0, 0.44444, 0.10836, 0, 0.68334],
    "120": [0, 0.44444, 0.09169, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
    "122": [0, 0.44444, 0.08752, 0, 0.43472],
    "126": [0.35, 0.32659, 0.08826, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0.06385, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.73752],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0.04169, 0, 0.23889],
    "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
    "710": [0, 0.69444, 0.0799, 0, 0.5],
    "711": [0, 0.63194, 0.08432, 0, 0.5],
    "713": [0, 0.60889, 0.08776, 0, 0.5],
    "714": [0, 0.69444, 0.09205, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0.09483, 0, 0.5],
    "729": [0, 0.67937, 0.07774, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.73752],
    "732": [0, 0.67659, 0.08826, 0, 0.5],
    "733": [0, 0.69444, 0.09205, 0, 0.5],
    "915": [0, 0.69444, 0.13372, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0.07555, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0.12816, 0, 0.66667],
    "928": [0, 0.69444, 0.08094, 0, 0.70834],
    "931": [0, 0.69444, 0.11983, 0, 0.72222],
    "933": [0, 0.69444, 0.09031, 0, 0.77778],
    "934": [0, 0.69444, 0.04603, 0, 0.72222],
    "936": [0, 0.69444, 0.09031, 0, 0.77778],
    "937": [0, 0.69444, 0.08293, 0, 0.72222],
    "8211": [0, 0.44444, 0.08616, 0, 0.5],
    "8212": [0, 0.44444, 0.08616, 0, 1.0],
    "8216": [0, 0.69444, 0.07816, 0, 0.27778],
    "8217": [0, 0.69444, 0.07816, 0, 0.27778],
    "8220": [0, 0.69444, 0.14205, 0, 0.5],
    "8221": [0, 0.69444, 0.00316, 0, 0.5]
  },
  "SansSerif-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.31945],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.75834],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.65556, 0, 0, 0.5],
    "49": [0, 0.65556, 0, 0, 0.5],
    "50": [0, 0.65556, 0, 0, 0.5],
    "51": [0, 0.65556, 0, 0, 0.5],
    "52": [0, 0.65556, 0, 0, 0.5],
    "53": [0, 0.65556, 0, 0, 0.5],
    "54": [0, 0.65556, 0, 0, 0.5],
    "55": [0, 0.65556, 0, 0, 0.5],
    "56": [0, 0.65556, 0, 0, 0.5],
    "57": [0, 0.65556, 0, 0, 0.5],
    "58": [0, 0.44444, 0, 0, 0.27778],
    "59": [0.125, 0.44444, 0, 0, 0.27778],
    "61": [-0.13, 0.37, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0, 0, 0.66667],
    "67": [0, 0.69444, 0, 0, 0.63889],
    "68": [0, 0.69444, 0, 0, 0.72223],
    "69": [0, 0.69444, 0, 0, 0.59722],
    "70": [0, 0.69444, 0, 0, 0.56945],
    "71": [0, 0.69444, 0, 0, 0.66667],
    "72": [0, 0.69444, 0, 0, 0.70834],
    "73": [0, 0.69444, 0, 0, 0.27778],
    "74": [0, 0.69444, 0, 0, 0.47222],
    "75": [0, 0.69444, 0, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0, 0, 0.875],
    "78": [0, 0.69444, 0, 0, 0.70834],
    "79": [0, 0.69444, 0, 0, 0.73611],
    "80": [0, 0.69444, 0, 0, 0.63889],
    "81": [0.125, 0.69444, 0, 0, 0.73611],
    "82": [0, 0.69444, 0, 0, 0.64584],
    "83": [0, 0.69444, 0, 0, 0.55556],
    "84": [0, 0.69444, 0, 0, 0.68056],
    "85": [0, 0.69444, 0, 0, 0.6875],
    "86": [0, 0.69444, 0.01389, 0, 0.66667],
    "87": [0, 0.69444, 0.01389, 0, 0.94445],
    "88": [0, 0.69444, 0, 0, 0.66667],
    "89": [0, 0.69444, 0.025, 0, 0.66667],
    "90": [0, 0.69444, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.28889],
    "93": [0.25, 0.75, 0, 0, 0.28889],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.35, 0.09444, 0.02778, 0, 0.5],
    "97": [0, 0.44444, 0, 0, 0.48056],
    "98": [0, 0.69444, 0, 0, 0.51667],
    "99": [0, 0.44444, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.51667],
    "101": [0, 0.44444, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.06944, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.51667],
    "105": [0, 0.67937, 0, 0, 0.23889],
    "106": [0.19444, 0.67937, 0, 0, 0.26667],
    "107": [0, 0.69444, 0, 0, 0.48889],
    "108": [0, 0.69444, 0, 0, 0.23889],
    "109": [0, 0.44444, 0, 0, 0.79445],
    "110": [0, 0.44444, 0, 0, 0.51667],
    "111": [0, 0.44444, 0, 0, 0.5],
    "112": [0.19444, 0.44444, 0, 0, 0.51667],
    "113": [0.19444, 0.44444, 0, 0, 0.51667],
    "114": [0, 0.44444, 0.01389, 0, 0.34167],
    "115": [0, 0.44444, 0, 0, 0.38333],
    "116": [0, 0.57143, 0, 0, 0.36111],
    "117": [0, 0.44444, 0, 0, 0.51667],
    "118": [0, 0.44444, 0.01389, 0, 0.46111],
    "119": [0, 0.44444, 0.01389, 0, 0.68334],
    "120": [0, 0.44444, 0, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
    "122": [0, 0.44444, 0, 0, 0.43472],
    "126": [0.35, 0.32659, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.66667],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0, 0, 0.23889],
    "567": [0.19444, 0.44444, 0, 0, 0.26667],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.63194, 0, 0, 0.5],
    "713": [0, 0.60889, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.67937, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.66667],
    "732": [0, 0.67659, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.69444, 0, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0, 0, 0.66667],
    "928": [0, 0.69444, 0, 0, 0.70834],
    "931": [0, 0.69444, 0, 0, 0.72222],
    "933": [0, 0.69444, 0, 0, 0.77778],
    "934": [0, 0.69444, 0, 0, 0.72222],
    "936": [0, 0.69444, 0, 0, 0.77778],
    "937": [0, 0.69444, 0, 0, 0.72222],
    "8211": [0, 0.44444, 0.02778, 0, 0.5],
    "8212": [0, 0.44444, 0.02778, 0, 1.0],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.7, 0.22925, 0, 0.80253],
    "66": [0, 0.7, 0.04087, 0, 0.90757],
    "67": [0, 0.7, 0.1689, 0, 0.66619],
    "68": [0, 0.7, 0.09371, 0, 0.77443],
    "69": [0, 0.7, 0.18583, 0, 0.56162],
    "70": [0, 0.7, 0.13634, 0, 0.89544],
    "71": [0, 0.7, 0.17322, 0, 0.60961],
    "72": [0, 0.7, 0.29694, 0, 0.96919],
    "73": [0, 0.7, 0.19189, 0, 0.80907],
    "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
    "75": [0, 0.7, 0.31259, 0, 0.91364],
    "76": [0, 0.7, 0.19189, 0, 0.87373],
    "77": [0, 0.7, 0.15981, 0, 1.08031],
    "78": [0, 0.7, 0.3525, 0, 0.9015],
    "79": [0, 0.7, 0.08078, 0, 0.73787],
    "80": [0, 0.7, 0.08078, 0, 1.01262],
    "81": [0, 0.7, 0.03305, 0, 0.88282],
    "82": [0, 0.7, 0.06259, 0, 0.85],
    "83": [0, 0.7, 0.19189, 0, 0.86767],
    "84": [0, 0.7, 0.29087, 0, 0.74697],
    "85": [0, 0.7, 0.25815, 0, 0.79996],
    "86": [0, 0.7, 0.27523, 0, 0.62204],
    "87": [0, 0.7, 0.27523, 0, 0.80532],
    "88": [0, 0.7, 0.26006, 0, 0.94445],
    "89": [0, 0.7, 0.2939, 0, 0.70961],
    "90": [0, 0.7, 0.24037, 0, 0.8212],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.35001, 0.85, 0, 0, 0.45834],
    "41": [0.35001, 0.85, 0, 0, 0.45834],
    "47": [0.35001, 0.85, 0, 0, 0.57778],
    "91": [0.35001, 0.85, 0, 0, 0.41667],
    "92": [0.35001, 0.85, 0, 0, 0.57778],
    "93": [0.35001, 0.85, 0, 0, 0.41667],
    "123": [0.35001, 0.85, 0, 0, 0.58334],
    "125": [0.35001, 0.85, 0, 0, 0.58334],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.72222, 0, 0, 0.55556],
    "732": [0, 0.72222, 0, 0, 0.55556],
    "770": [0, 0.72222, 0, 0, 0.55556],
    "771": [0, 0.72222, 0, 0, 0.55556],
    "8214": [-0.00099, 0.601, 0, 0, 0.77778],
    "8593": [1e-05, 0.6, 0, 0, 0.66667],
    "8595": [1e-05, 0.6, 0, 0, 0.66667],
    "8657": [1e-05, 0.6, 0, 0, 0.77778],
    "8659": [1e-05, 0.6, 0, 0, 0.77778],
    "8719": [0.25001, 0.75, 0, 0, 0.94445],
    "8720": [0.25001, 0.75, 0, 0, 0.94445],
    "8721": [0.25001, 0.75, 0, 0, 1.05556],
    "8730": [0.35001, 0.85, 0, 0, 1.0],
    "8739": [-0.00599, 0.606, 0, 0, 0.33333],
    "8741": [-0.00599, 0.606, 0, 0, 0.55556],
    "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8896": [0.25001, 0.75, 0, 0, 0.83334],
    "8897": [0.25001, 0.75, 0, 0, 0.83334],
    "8898": [0.25001, 0.75, 0, 0, 0.83334],
    "8899": [0.25001, 0.75, 0, 0, 0.83334],
    "8968": [0.35001, 0.85, 0, 0, 0.47222],
    "8969": [0.35001, 0.85, 0, 0, 0.47222],
    "8970": [0.35001, 0.85, 0, 0, 0.47222],
    "8971": [0.35001, 0.85, 0, 0, 0.47222],
    "9168": [-0.00099, 0.601, 0, 0, 0.66667],
    "10216": [0.35001, 0.85, 0, 0, 0.47222],
    "10217": [0.35001, 0.85, 0, 0, 0.47222],
    "10752": [0.25001, 0.75, 0, 0, 1.11111],
    "10753": [0.25001, 0.75, 0, 0, 1.11111],
    "10754": [0.25001, 0.75, 0, 0, 1.11111],
    "10756": [0.25001, 0.75, 0, 0, 0.83334],
    "10758": [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.65002, 1.15, 0, 0, 0.59722],
    "41": [0.65002, 1.15, 0, 0, 0.59722],
    "47": [0.65002, 1.15, 0, 0, 0.81111],
    "91": [0.65002, 1.15, 0, 0, 0.47222],
    "92": [0.65002, 1.15, 0, 0, 0.81111],
    "93": [0.65002, 1.15, 0, 0, 0.47222],
    "123": [0.65002, 1.15, 0, 0, 0.66667],
    "125": [0.65002, 1.15, 0, 0, 0.66667],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1.0],
    "732": [0, 0.75, 0, 0, 1.0],
    "770": [0, 0.75, 0, 0, 1.0],
    "771": [0, 0.75, 0, 0, 1.0],
    "8719": [0.55001, 1.05, 0, 0, 1.27778],
    "8720": [0.55001, 1.05, 0, 0, 1.27778],
    "8721": [0.55001, 1.05, 0, 0, 1.44445],
    "8730": [0.65002, 1.15, 0, 0, 1.0],
    "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8896": [0.55001, 1.05, 0, 0, 1.11111],
    "8897": [0.55001, 1.05, 0, 0, 1.11111],
    "8898": [0.55001, 1.05, 0, 0, 1.11111],
    "8899": [0.55001, 1.05, 0, 0, 1.11111],
    "8968": [0.65002, 1.15, 0, 0, 0.52778],
    "8969": [0.65002, 1.15, 0, 0, 0.52778],
    "8970": [0.65002, 1.15, 0, 0, 0.52778],
    "8971": [0.65002, 1.15, 0, 0, 0.52778],
    "10216": [0.65002, 1.15, 0, 0, 0.61111],
    "10217": [0.65002, 1.15, 0, 0, 0.61111],
    "10752": [0.55001, 1.05, 0, 0, 1.51112],
    "10753": [0.55001, 1.05, 0, 0, 1.51112],
    "10754": [0.55001, 1.05, 0, 0, 1.51112],
    "10756": [0.55001, 1.05, 0, 0, 1.11111],
    "10758": [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.95003, 1.45, 0, 0, 0.73611],
    "41": [0.95003, 1.45, 0, 0, 0.73611],
    "47": [0.95003, 1.45, 0, 0, 1.04445],
    "91": [0.95003, 1.45, 0, 0, 0.52778],
    "92": [0.95003, 1.45, 0, 0, 1.04445],
    "93": [0.95003, 1.45, 0, 0, 0.52778],
    "123": [0.95003, 1.45, 0, 0, 0.75],
    "125": [0.95003, 1.45, 0, 0, 0.75],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1.44445],
    "732": [0, 0.75, 0, 0, 1.44445],
    "770": [0, 0.75, 0, 0, 1.44445],
    "771": [0, 0.75, 0, 0, 1.44445],
    "8730": [0.95003, 1.45, 0, 0, 1.0],
    "8968": [0.95003, 1.45, 0, 0, 0.58334],
    "8969": [0.95003, 1.45, 0, 0, 0.58334],
    "8970": [0.95003, 1.45, 0, 0, 0.58334],
    "8971": [0.95003, 1.45, 0, 0, 0.58334],
    "10216": [0.95003, 1.45, 0, 0, 0.75],
    "10217": [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [1.25003, 1.75, 0, 0, 0.79167],
    "41": [1.25003, 1.75, 0, 0, 0.79167],
    "47": [1.25003, 1.75, 0, 0, 1.27778],
    "91": [1.25003, 1.75, 0, 0, 0.58334],
    "92": [1.25003, 1.75, 0, 0, 1.27778],
    "93": [1.25003, 1.75, 0, 0, 0.58334],
    "123": [1.25003, 1.75, 0, 0, 0.80556],
    "125": [1.25003, 1.75, 0, 0, 0.80556],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.825, 0, 0, 1.8889],
    "732": [0, 0.825, 0, 0, 1.8889],
    "770": [0, 0.825, 0, 0, 1.8889],
    "771": [0, 0.825, 0, 0, 1.8889],
    "8730": [1.25003, 1.75, 0, 0, 1.0],
    "8968": [1.25003, 1.75, 0, 0, 0.63889],
    "8969": [1.25003, 1.75, 0, 0, 0.63889],
    "8970": [1.25003, 1.75, 0, 0, 0.63889],
    "8971": [1.25003, 1.75, 0, 0, 0.63889],
    "9115": [0.64502, 1.155, 0, 0, 0.875],
    "9116": [1e-05, 0.6, 0, 0, 0.875],
    "9117": [0.64502, 1.155, 0, 0, 0.875],
    "9118": [0.64502, 1.155, 0, 0, 0.875],
    "9119": [1e-05, 0.6, 0, 0, 0.875],
    "9120": [0.64502, 1.155, 0, 0, 0.875],
    "9121": [0.64502, 1.155, 0, 0, 0.66667],
    "9122": [-0.00099, 0.601, 0, 0, 0.66667],
    "9123": [0.64502, 1.155, 0, 0, 0.66667],
    "9124": [0.64502, 1.155, 0, 0, 0.66667],
    "9125": [-0.00099, 0.601, 0, 0, 0.66667],
    "9126": [0.64502, 1.155, 0, 0, 0.66667],
    "9127": [1e-05, 0.9, 0, 0, 0.88889],
    "9128": [0.65002, 1.15, 0, 0, 0.88889],
    "9129": [0.90001, 0, 0, 0, 0.88889],
    "9130": [0, 0.3, 0, 0, 0.88889],
    "9131": [1e-05, 0.9, 0, 0, 0.88889],
    "9132": [0.65002, 1.15, 0, 0, 0.88889],
    "9133": [0.90001, 0, 0, 0, 0.88889],
    "9143": [0.88502, 0.915, 0, 0, 1.05556],
    "10216": [1.25003, 1.75, 0, 0, 0.80556],
    "10217": [1.25003, 1.75, 0, 0, 0.80556],
    "57344": [-0.00499, 0.605, 0, 0, 1.05556],
    "57345": [-0.00499, 0.605, 0, 0, 1.05556],
    "57680": [0, 0.12, 0, 0, 0.45],
    "57681": [0, 0.12, 0, 0, 0.45],
    "57682": [0, 0.12, 0, 0, 0.45],
    "57683": [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    "32": [0, 0, 0, 0, 0.525],
    "33": [0, 0.61111, 0, 0, 0.525],
    "34": [0, 0.61111, 0, 0, 0.525],
    "35": [0, 0.61111, 0, 0, 0.525],
    "36": [0.08333, 0.69444, 0, 0, 0.525],
    "37": [0.08333, 0.69444, 0, 0, 0.525],
    "38": [0, 0.61111, 0, 0, 0.525],
    "39": [0, 0.61111, 0, 0, 0.525],
    "40": [0.08333, 0.69444, 0, 0, 0.525],
    "41": [0.08333, 0.69444, 0, 0, 0.525],
    "42": [0, 0.52083, 0, 0, 0.525],
    "43": [-0.08056, 0.53055, 0, 0, 0.525],
    "44": [0.13889, 0.125, 0, 0, 0.525],
    "45": [-0.08056, 0.53055, 0, 0, 0.525],
    "46": [0, 0.125, 0, 0, 0.525],
    "47": [0.08333, 0.69444, 0, 0, 0.525],
    "48": [0, 0.61111, 0, 0, 0.525],
    "49": [0, 0.61111, 0, 0, 0.525],
    "50": [0, 0.61111, 0, 0, 0.525],
    "51": [0, 0.61111, 0, 0, 0.525],
    "52": [0, 0.61111, 0, 0, 0.525],
    "53": [0, 0.61111, 0, 0, 0.525],
    "54": [0, 0.61111, 0, 0, 0.525],
    "55": [0, 0.61111, 0, 0, 0.525],
    "56": [0, 0.61111, 0, 0, 0.525],
    "57": [0, 0.61111, 0, 0, 0.525],
    "58": [0, 0.43056, 0, 0, 0.525],
    "59": [0.13889, 0.43056, 0, 0, 0.525],
    "60": [-0.05556, 0.55556, 0, 0, 0.525],
    "61": [-0.19549, 0.41562, 0, 0, 0.525],
    "62": [-0.05556, 0.55556, 0, 0, 0.525],
    "63": [0, 0.61111, 0, 0, 0.525],
    "64": [0, 0.61111, 0, 0, 0.525],
    "65": [0, 0.61111, 0, 0, 0.525],
    "66": [0, 0.61111, 0, 0, 0.525],
    "67": [0, 0.61111, 0, 0, 0.525],
    "68": [0, 0.61111, 0, 0, 0.525],
    "69": [0, 0.61111, 0, 0, 0.525],
    "70": [0, 0.61111, 0, 0, 0.525],
    "71": [0, 0.61111, 0, 0, 0.525],
    "72": [0, 0.61111, 0, 0, 0.525],
    "73": [0, 0.61111, 0, 0, 0.525],
    "74": [0, 0.61111, 0, 0, 0.525],
    "75": [0, 0.61111, 0, 0, 0.525],
    "76": [0, 0.61111, 0, 0, 0.525],
    "77": [0, 0.61111, 0, 0, 0.525],
    "78": [0, 0.61111, 0, 0, 0.525],
    "79": [0, 0.61111, 0, 0, 0.525],
    "80": [0, 0.61111, 0, 0, 0.525],
    "81": [0.13889, 0.61111, 0, 0, 0.525],
    "82": [0, 0.61111, 0, 0, 0.525],
    "83": [0, 0.61111, 0, 0, 0.525],
    "84": [0, 0.61111, 0, 0, 0.525],
    "85": [0, 0.61111, 0, 0, 0.525],
    "86": [0, 0.61111, 0, 0, 0.525],
    "87": [0, 0.61111, 0, 0, 0.525],
    "88": [0, 0.61111, 0, 0, 0.525],
    "89": [0, 0.61111, 0, 0, 0.525],
    "90": [0, 0.61111, 0, 0, 0.525],
    "91": [0.08333, 0.69444, 0, 0, 0.525],
    "92": [0.08333, 0.69444, 0, 0, 0.525],
    "93": [0.08333, 0.69444, 0, 0, 0.525],
    "94": [0, 0.61111, 0, 0, 0.525],
    "95": [0.09514, 0, 0, 0, 0.525],
    "96": [0, 0.61111, 0, 0, 0.525],
    "97": [0, 0.43056, 0, 0, 0.525],
    "98": [0, 0.61111, 0, 0, 0.525],
    "99": [0, 0.43056, 0, 0, 0.525],
    "100": [0, 0.61111, 0, 0, 0.525],
    "101": [0, 0.43056, 0, 0, 0.525],
    "102": [0, 0.61111, 0, 0, 0.525],
    "103": [0.22222, 0.43056, 0, 0, 0.525],
    "104": [0, 0.61111, 0, 0, 0.525],
    "105": [0, 0.61111, 0, 0, 0.525],
    "106": [0.22222, 0.61111, 0, 0, 0.525],
    "107": [0, 0.61111, 0, 0, 0.525],
    "108": [0, 0.61111, 0, 0, 0.525],
    "109": [0, 0.43056, 0, 0, 0.525],
    "110": [0, 0.43056, 0, 0, 0.525],
    "111": [0, 0.43056, 0, 0, 0.525],
    "112": [0.22222, 0.43056, 0, 0, 0.525],
    "113": [0.22222, 0.43056, 0, 0, 0.525],
    "114": [0, 0.43056, 0, 0, 0.525],
    "115": [0, 0.43056, 0, 0, 0.525],
    "116": [0, 0.55358, 0, 0, 0.525],
    "117": [0, 0.43056, 0, 0, 0.525],
    "118": [0, 0.43056, 0, 0, 0.525],
    "119": [0, 0.43056, 0, 0, 0.525],
    "120": [0, 0.43056, 0, 0, 0.525],
    "121": [0.22222, 0.43056, 0, 0, 0.525],
    "122": [0, 0.43056, 0, 0, 0.525],
    "123": [0.08333, 0.69444, 0, 0, 0.525],
    "124": [0.08333, 0.69444, 0, 0, 0.525],
    "125": [0.08333, 0.69444, 0, 0, 0.525],
    "126": [0, 0.61111, 0, 0, 0.525],
    "127": [0, 0.61111, 0, 0, 0.525],
    "160": [0, 0, 0, 0, 0.525],
    "176": [0, 0.61111, 0, 0, 0.525],
    "184": [0.19445, 0, 0, 0, 0.525],
    "305": [0, 0.43056, 0, 0, 0.525],
    "567": [0.22222, 0.43056, 0, 0, 0.525],
    "711": [0, 0.56597, 0, 0, 0.525],
    "713": [0, 0.56555, 0, 0, 0.525],
    "714": [0, 0.61111, 0, 0, 0.525],
    "715": [0, 0.61111, 0, 0, 0.525],
    "728": [0, 0.61111, 0, 0, 0.525],
    "730": [0, 0.61111, 0, 0, 0.525],
    "770": [0, 0.61111, 0, 0, 0.525],
    "771": [0, 0.61111, 0, 0, 0.525],
    "776": [0, 0.61111, 0, 0, 0.525],
    "915": [0, 0.61111, 0, 0, 0.525],
    "916": [0, 0.61111, 0, 0, 0.525],
    "920": [0, 0.61111, 0, 0, 0.525],
    "923": [0, 0.61111, 0, 0, 0.525],
    "926": [0, 0.61111, 0, 0, 0.525],
    "928": [0, 0.61111, 0, 0, 0.525],
    "931": [0, 0.61111, 0, 0, 0.525],
    "933": [0, 0.61111, 0, 0, 0.525],
    "934": [0, 0.61111, 0, 0, 0.525],
    "936": [0, 0.61111, 0, 0, 0.525],
    "937": [0, 0.61111, 0, 0, 0.525],
    "8216": [0, 0.61111, 0, 0, 0.525],
    "8217": [0, 0.61111, 0, 0, 0.525],
    "8242": [0, 0.61111, 0, 0, 0.525],
    "9251": [0.11111, 0.21944, 0, 0, 0.525]
  }
};

/**
 * This file contains metrics regarding fonts and individual symbols. The sigma
 * and xi variables, as well as the metricMap map contain data extracted from
 * TeX, TeX font metrics, and the TTF files. These data are then exposed via the
 * `metrics` variable and the getCharacterMetrics function.
 */
// In TeX, there are actually three sets of dimensions, one for each of
// textstyle (size index 5 and higher: >=9pt), scriptstyle (size index 3 and 4:
// 7-8pt), and scriptscriptstyle (size index 1 and 2: 5-6pt).  These are
// provided in the the arrays below, in that order.
//
// The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respsectively.
// This was determined by running the following script:
//
//     latex -interaction=nonstopmode \
//     '\documentclass{article}\usepackage{amsmath}\begin{document}' \
//     '$a$ \expandafter\show\the\textfont2' \
//     '\expandafter\show\the\scriptfont2' \
//     '\expandafter\show\the\scriptscriptfont2' \
//     '\stop'
//
// The metrics themselves were retreived using the following commands:
//
//     tftopl cmsy10
//     tftopl cmsy7
//     tftopl cmsy5
//
// The output of each of these commands is quite lengthy.  The only part we
// care about is the FONTDIMEN section. Each value is measured in EMs.
var sigmasAndXis = {
  slant: [0.250, 0.250, 0.250],
  // sigma1
  space: [0.000, 0.000, 0.000],
  // sigma2
  stretch: [0.000, 0.000, 0.000],
  // sigma3
  shrink: [0.000, 0.000, 0.000],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1.000, 1.171, 1.472],
  // sigma6
  extraSpace: [0.000, 0.000, 0.000],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.150, 0.143, 0.200],
  // sigma16
  sub2: [0.247, 0.286, 0.400],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.050, 0.071, 0.100],
  // sigma19
  delim1: [2.390, 1.700, 1.980],
  // sigma20
  delim2: [1.010, 1.157, 1.420],
  // sigma21
  axisHeight: [0.250, 0.250, 0.250],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.less; if you change it make sure the
  // values match.
  ptPerEm: [10.0, 10.0, 10.0],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04] // 0.4 pt / ptPerEm

}; // This map contains a mapping from font name and character code to character
// should have Latin-1 and Cyrillic characters, but may not depending on the
// operating system.  The metrics do not account for extra height from the
// accents.  In the case of Cyrillic characters which have both ascenders and
// descenders we prefer approximations with ascenders, primarily to prevent
// the fraction bar or root line from intersecting the glyph.
// TODO(kevinb) allow union of multiple glyph metrics for better accuracy.

var extraCharacterMap = {
  // Latin-1
  'Å': 'A',
  'Ð': 'D',
  'Þ': 'o',
  'å': 'a',
  'ð': 'd',
  'þ': 'o',
  // Cyrillic
  'А': 'A',
  'Б': 'B',
  'В': 'B',
  'Г': 'F',
  'Д': 'A',
  'Е': 'E',
  'Ж': 'K',
  'З': '3',
  'И': 'N',
  'Й': 'N',
  'К': 'K',
  'Л': 'N',
  'М': 'M',
  'Н': 'H',
  'О': 'O',
  'П': 'N',
  'Р': 'P',
  'С': 'C',
  'Т': 'T',
  'У': 'y',
  'Ф': 'O',
  'Х': 'X',
  'Ц': 'U',
  'Ч': 'h',
  'Ш': 'W',
  'Щ': 'W',
  'Ъ': 'B',
  'Ы': 'X',
  'Ь': 'B',
  'Э': '3',
  'Ю': 'X',
  'Я': 'R',
  'а': 'a',
  'б': 'b',
  'в': 'a',
  'г': 'r',
  'д': 'y',
  'е': 'e',
  'ж': 'm',
  'з': 'e',
  'и': 'n',
  'й': 'n',
  'к': 'n',
  'л': 'n',
  'м': 'm',
  'н': 'n',
  'о': 'o',
  'п': 'n',
  'р': 'p',
  'с': 'c',
  'т': 'o',
  'у': 'y',
  'ф': 'b',
  'х': 'x',
  'ц': 'n',
  'ч': 'n',
  'ш': 'w',
  'щ': 'w',
  'ъ': 'a',
  'ы': 'm',
  'ь': 'a',
  'э': 'e',
  'ю': 'm',
  'я': 'r'
};

/**
 * This function adds new font metrics to default metricMap
 * It can also override existing metrics
 */
function setFontMetrics(fontName, metrics) {
  fontMetricsData[fontName] = metrics;
}
/**
 * This function is a convenience function for looking up information in the
 * metricMap table. It takes a character as a string, and a font.
 *
 * Note: the `width` property may be undefined if fontMetricsData.js wasn't
 * built using `Make extended_metrics`.
 */

function getCharacterMetrics(character, font, mode) {
  if (!fontMetricsData[font]) {
    throw new Error("Font metrics not found for font: " + font + ".");
  }

  var ch = character.charCodeAt(0);
  var metrics = fontMetricsData[font][ch];

  if (!metrics && character[0] in extraCharacterMap) {
    ch = extraCharacterMap[character[0]].charCodeAt(0);
    metrics = fontMetricsData[font][ch];
  }

  if (!metrics && mode === 'text') {
    // We don't typically have font metrics for Asian scripts.
    // But since we support them in text mode, we need to return
    // some sort of metrics.
    // So if the character is in a script we support but we
    // don't have metrics for it, just use the metrics for
    // the Latin capital letter M. This is close enough because
    // we (currently) only care about the height of the glpyh
    // not its width.
    if (supportedCodepoint(ch)) {
      metrics = fontMetricsData[font][77]; // 77 is the charcode for 'M'
    }
  }

  if (metrics) {
    return {
      depth: metrics[0],
      height: metrics[1],
      italic: metrics[2],
      skew: metrics[3],
      width: metrics[4]
    };
  }
}
var fontMetricsBySizeIndex = {};
/**
 * Get the font metrics for a given size.
 */

function getGlobalMetrics(size) {
  var sizeIndex;

  if (size >= 5) {
    sizeIndex = 0;
  } else if (size >= 3) {
    sizeIndex = 1;
  } else {
    sizeIndex = 2;
  }

  if (!fontMetricsBySizeIndex[sizeIndex]) {
    var metrics = fontMetricsBySizeIndex[sizeIndex] = {
      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
    };

    for (var key in sigmasAndXis) {
      if (sigmasAndXis.hasOwnProperty(key)) {
        metrics[key] = sigmasAndXis[key][sizeIndex];
      }
    }
  }

  return fontMetricsBySizeIndex[sizeIndex];
}

/**
 * This file contains information about the options that the Parser carries
 * around with it while parsing. Data is held in an `Options` object, and when
 * recursing, a new `Options` object can be created with the `.with*` and
 * `.reset` functions.
 */
var sizeStyleMap = [// Each element contains [textsize, scriptsize, scriptscriptsize].
// The size mappings are taken from TeX with \normalsize=10pt.
[1, 1, 1], // size1: [5, 5, 5]              \tiny
[2, 1, 1], // size2: [6, 5, 5]
[3, 1, 1], // size3: [7, 5, 5]              \scriptsize
[4, 2, 1], // size4: [8, 6, 5]              \footnotesize
[5, 2, 1], // size5: [9, 6, 5]              \small
[6, 3, 1], // size6: [10, 7, 5]             \normalsize
[7, 4, 2], // size7: [12, 8, 6]             \large
[8, 6, 3], // size8: [14.4, 10, 7]          \Large
[9, 7, 6], // size9: [17.28, 12, 10]        \LARGE
[10, 8, 7], // size10: [20.74, 14.4, 12]     \huge
[11, 10, 9] // size11: [24.88, 20.74, 17.28] \HUGE
];
var sizeMultipliers = [// fontMetrics.js:getGlobalMetrics also uses size indexes, so if
// you change size indexes, change that function.
0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.44, 1.728, 2.074, 2.488];

var sizeAtStyle = function sizeAtStyle(size, style) {
  return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
}; // In these types, "" (empty string) means "no change".


/**
 * This is the main options class. It contains the current style, size, color,
 * and font.
 *
 * Options objects should not be modified. To create a new Options with
 * different properties, call a `.having*` method.
 */
class Options {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm

  /**
   * The base size index.
   */
  constructor(data) {
    this.style = void 0;
    this.color = void 0;
    this.size = void 0;
    this.textSize = void 0;
    this.phantom = void 0;
    this.font = void 0;
    this.fontFamily = void 0;
    this.fontWeight = void 0;
    this.fontShape = void 0;
    this.sizeMultiplier = void 0;
    this.maxSize = void 0;
    this.minRuleThickness = void 0;
    this._fontMetrics = void 0;
    this.style = data.style;
    this.color = data.color;
    this.size = data.size || Options.BASESIZE;
    this.textSize = data.textSize || this.size;
    this.phantom = !!data.phantom;
    this.font = data.font || "";
    this.fontFamily = data.fontFamily || "";
    this.fontWeight = data.fontWeight || '';
    this.fontShape = data.fontShape || '';
    this.sizeMultiplier = sizeMultipliers[this.size - 1];
    this.maxSize = data.maxSize;
    this.minRuleThickness = data.minRuleThickness;
    this._fontMetrics = undefined;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */


  extend(extension) {
    var data = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };

    for (var key in extension) {
      if (extension.hasOwnProperty(key)) {
        data[key] = extension[key];
      }
    }

    return new Options(data);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */


  havingStyle(style) {
    if (this.style === style) {
      return this;
    } else {
      return this.extend({
        style: style,
        size: sizeAtStyle(this.textSize, style)
      });
    }
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */


  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */


  havingSize(size) {
    if (this.size === size && this.textSize === size) {
      return this;
    } else {
      return this.extend({
        style: this.style.text(),
        size: size,
        textSize: size,
        sizeMultiplier: sizeMultipliers[size - 1]
      });
    }
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */


  havingBaseStyle(style) {
    style = style || this.style.text();
    var wantSize = sizeAtStyle(Options.BASESIZE, style);

    if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
      return this;
    } else {
      return this.extend({
        style: style,
        size: wantSize
      });
    }
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */


  havingBaseSizing() {
    var size;

    switch (this.style.id) {
      case 4:
      case 5:
        size = 3; // normalsize in scriptstyle

        break;

      case 6:
      case 7:
        size = 1; // normalsize in scriptscriptstyle

        break;

      default:
        size = 6;
      // normalsize in textstyle or displaystyle
    }

    return this.extend({
      style: this.style.text(),
      size: size
    });
  }
  /**
   * Create a new options object with the given color.
   */


  withColor(color) {
    return this.extend({
      color: color
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */


  withPhantom() {
    return this.extend({
      phantom: true
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */


  withFont(font) {
    return this.extend({
      font
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */


  withTextFontFamily(fontFamily) {
    return this.extend({
      fontFamily,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */


  withTextFontWeight(fontWeight) {
    return this.extend({
      fontWeight,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */


  withTextFontShape(fontShape) {
    return this.extend({
      fontShape,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */


  sizingClasses(oldOptions) {
    if (oldOptions.size !== this.size) {
      return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
    } else {
      return [];
    }
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */


  baseSizingClasses() {
    if (this.size !== Options.BASESIZE) {
      return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
    } else {
      return [];
    }
  }
  /**
   * Return the font metrics for this size.
   */


  fontMetrics() {
    if (!this._fontMetrics) {
      this._fontMetrics = getGlobalMetrics(this.size);
    }

    return this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */


  getColor() {
    if (this.phantom) {
      return "transparent";
    } else {
      return this.color;
    }
  }

}

Options.BASESIZE = 6;

/**
 * This file does conversion between units.  In particular, it provides
 * calculateSize to convert other units into ems.
 */
// Thus, multiplying a length by this number converts the length from units
// into pts.  Dividing the result by ptPerEm gives the number of ems
// *assuming* a font size of ptPerEm (normal size, normal style).

var ptPerUnit = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  "pt": 1,
  // TeX point
  "mm": 7227 / 2540,
  // millimeter
  "cm": 7227 / 254,
  // centimeter
  "in": 72.27,
  // inch
  "bp": 803 / 800,
  // big (PostScript) points
  "pc": 12,
  // pica
  "dd": 1238 / 1157,
  // didot
  "cc": 14856 / 1157,
  // cicero (12 didot)
  "nd": 685 / 642,
  // new didot
  "nc": 1370 / 107,
  // new cicero (12 new didot)
  "sp": 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  "px": 803 / 800 // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX

}; // Dictionary of relative units, for fast validity testing.

var relativeUnit = {
  "ex": true,
  "em": true,
  "mu": true
};

/**
 * Determine whether the specified unit (either a string defining the unit
 * or a "size" parse node containing a unit field) is valid.
 */
var validUnit = function validUnit(unit) {
  if (typeof unit !== "string") {
    unit = unit.unit;
  }

  return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
};
/*
 * Convert a "size" parse node (with numeric "number" and string "unit" fields,
 * as parsed by functions.js argType "size") into a CSS em value for the
 * current style/scale.  `options` gives the current options.
 */

var calculateSize = function calculateSize(sizeValue, options) {
  var scale;

  if (sizeValue.unit in ptPerUnit) {
    // Absolute units
    scale = ptPerUnit[sizeValue.unit] // Convert unit to pt
    / options.fontMetrics().ptPerEm // Convert pt to CSS em
    / options.sizeMultiplier; // Unscale to make absolute units
  } else if (sizeValue.unit === "mu") {
    // `mu` units scale with scriptstyle/scriptscriptstyle.
    scale = options.fontMetrics().cssEmPerMu;
  } else {
    // Other relative units always refer to the *textstyle* font
    // in the current size.
    var unitOptions;

    if (options.style.isTight()) {
      // isTight() means current style is script/scriptscript.
      unitOptions = options.havingStyle(options.style.text());
    } else {
      unitOptions = options;
    } // TODO: In TeX these units are relative to the quad of the current
    // *text* font, e.g. cmr10. KaTeX instead uses values from the
    // comparably-sized *Computer Modern symbol* font. At 10pt, these
    // match. At 7pt and 5pt, they differ: cmr7=1.138894, cmsy7=1.170641;
    // cmr5=1.361133, cmsy5=1.472241. Consider $\scriptsize a\kern1emb$.
    // TeX \showlists shows a kern of 1.13889 * fontsize;
    // KaTeX shows a kern of 1.171 * fontsize.


    if (sizeValue.unit === "ex") {
      scale = unitOptions.fontMetrics().xHeight;
    } else if (sizeValue.unit === "em") {
      scale = unitOptions.fontMetrics().quad;
    } else {
      throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
    }

    if (unitOptions !== options) {
      scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
    }
  }

  return Math.min(sizeValue.number * scale, options.maxSize);
};
/**
 * Round `n` to 4 decimal places, or to the nearest 1/10,000th em. See
 * https://github.com/KaTeX/KaTeX/pull/2460.
 */

var makeEm = function makeEm(n) {
  return +n.toFixed(4) + "em";
};

/**
 * These objects store the data about the DOM nodes we create, as well as some
 * extra data. They can then be transformed into real DOM nodes with the
 * `toNode` function or HTML markup using `toMarkup`. They are useful for both
 * storing extra properties on the nodes, as well as providing a way to easily
 * work with the DOM.
 *
 * Similar functions for working with MathML nodes exist in mathMLTree.js.
 *
 * TODO: refactor `span` and `anchor` into common superclass when
 * target environments support class inheritance
 */

/**
 * Create an HTML className based on a list of classes. In addition to joining
 * with spaces, we also remove empty classes.
 */
var createClass = function createClass(classes) {
  return classes.filter(cls => cls).join(" ");
};

var initNode = function initNode(classes, options, style) {
  this.classes = classes || [];
  this.attributes = {};
  this.height = 0;
  this.depth = 0;
  this.maxFontSize = 0;
  this.style = style || {};

  if (options) {
    if (options.style.isTight()) {
      this.classes.push("mtight");
    }

    var color = options.getColor();

    if (color) {
      this.style.color = color;
    }
  }
};
/**
 * Convert into an HTML node
 */


var toNode = function toNode(tagName) {
  var node = document.createElement(tagName); // Apply the class

  node.className = createClass(this.classes); // Apply inline styles

  for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      // $FlowFixMe Flow doesn't seem to understand span.style's type.
      node.style[style] = this.style[style];
    }
  } // Apply attributes


  for (var attr in this.attributes) {
    if (this.attributes.hasOwnProperty(attr)) {
      node.setAttribute(attr, this.attributes[attr]);
    }
  } // Append the children, also as HTML nodes


  for (var i = 0; i < this.children.length; i++) {
    node.appendChild(this.children[i].toNode());
  }

  return node;
};
/**
 * Convert into an HTML markup string
 */


var toMarkup = function toMarkup(tagName) {
  var markup = "<" + tagName; // Add the class

  if (this.classes.length) {
    markup += " class=\"" + utils.escape(createClass(this.classes)) + "\"";
  }

  var styles = ""; // Add the styles, after hyphenation

  for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
    }
  }

  if (styles) {
    markup += " style=\"" + utils.escape(styles) + "\"";
  } // Add the attributes


  for (var attr in this.attributes) {
    if (this.attributes.hasOwnProperty(attr)) {
      markup += " " + attr + "=\"" + utils.escape(this.attributes[attr]) + "\"";
    }
  }

  markup += ">"; // Add the markup of the children, also as markup

  for (var i = 0; i < this.children.length; i++) {
    markup += this.children[i].toMarkup();
  }

  markup += "</" + tagName + ">";
  return markup;
}; // Making the type below exact with all optional fields doesn't work due to
// - https://github.com/facebook/flow/issues/4582
// - https://github.com/facebook/flow/issues/5688
// However, since *all* fields are optional, $Shape<> works as suggested in 5688
// above.
// This type does not include all CSS properties. Additional properties should
// be added as needed.


/**
 * This node represents a span node, with a className, a list of children, and
 * an inline style. It also contains information about its height, depth, and
 * maxFontSize.
 *
 * Represents two types with different uses: SvgSpan to wrap an SVG and DomSpan
 * otherwise. This typesafety is important when HTML builders access a span's
 * children.
 */
class Span {
  constructor(classes, children, options, style) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options, style);
    this.children = children || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */


  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }

  hasClass(className) {
    return utils.contains(this.classes, className);
  }

  toNode() {
    return toNode.call(this, "span");
  }

  toMarkup() {
    return toMarkup.call(this, "span");
  }

}
/**
 * This node represents an anchor (<a>) element with a hyperlink.  See `span`
 * for further details.
 */

class Anchor {
  constructor(href, classes, children, options) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options);
    this.children = children || [];
    this.setAttribute('href', href);
  }

  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }

  hasClass(className) {
    return utils.contains(this.classes, className);
  }

  toNode() {
    return toNode.call(this, "a");
  }

  toMarkup() {
    return toMarkup.call(this, "a");
  }

}
/**
 * This node represents an image embed (<img>) element.
 */

class Img {
  constructor(src, alt, style) {
    this.src = void 0;
    this.alt = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.alt = alt;
    this.src = src;
    this.classes = ["mord"];
    this.style = style;
  }

  hasClass(className) {
    return utils.contains(this.classes, className);
  }

  toNode() {
    var node = document.createElement("img");
    node.src = this.src;
    node.alt = this.alt;
    node.className = "mord"; // Apply inline styles

    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        // $FlowFixMe
        node.style[style] = this.style[style];
      }
    }

    return node;
  }

  toMarkup() {
    var markup = "<img  src='" + this.src + " 'alt='" + this.alt + "' "; // Add the styles, after hyphenation

    var styles = "";

    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }

    if (styles) {
      markup += " style=\"" + utils.escape(styles) + "\"";
    }

    markup += "'/>";
    return markup;
  }

}
var iCombinations = {
  'î': '\u0131\u0302',
  'ï': '\u0131\u0308',
  'í': '\u0131\u0301',
  // 'ī': '\u0131\u0304', // enable when we add Extended Latin
  'ì': '\u0131\u0300'
};
/**
 * A symbol node contains information about a single symbol. It either renders
 * to a single text node, or a span with a single text node in it, depending on
 * whether it has CSS classes, styles, or needs italic correction.
 */

class SymbolNode {
  constructor(text, height, depth, italic, skew, width, classes, style) {
    this.text = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.italic = void 0;
    this.skew = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.classes = void 0;
    this.style = void 0;
    this.text = text;
    this.height = height || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew || 0;
    this.width = width || 0;
    this.classes = classes || [];
    this.style = style || {};
    this.maxFontSize = 0; // Mark text from non-Latin scripts with specific classes so that we
    // can specify which fonts to use.  This allows us to render these
    // characters with a serif font in situations where the browser would
    // either default to a sans serif or render a placeholder character.
    // We use CSS class names like cjk_fallback, hangul_fallback and
    // brahmic_fallback. See ./unicodeScripts.js for the set of possible
    // script names

    var script = scriptFromCodepoint(this.text.charCodeAt(0));

    if (script) {
      this.classes.push(script + "_fallback");
    }

    if (/[îïíì]/.test(this.text)) {
      // add ī when we add Extended Latin
      this.text = iCombinations[this.text];
    }
  }

  hasClass(className) {
    return utils.contains(this.classes, className);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */


  toNode() {
    var node = document.createTextNode(this.text);
    var span = null;

    if (this.italic > 0) {
      span = document.createElement("span");
      span.style.marginRight = makeEm(this.italic);
    }

    if (this.classes.length > 0) {
      span = span || document.createElement("span");
      span.className = createClass(this.classes);
    }

    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        span = span || document.createElement("span"); // $FlowFixMe Flow doesn't seem to understand span.style's type.

        span.style[style] = this.style[style];
      }
    }

    if (span) {
      span.appendChild(node);
      return span;
    } else {
      return node;
    }
  }
  /**
   * Creates markup for a symbol node.
   */


  toMarkup() {
    // TODO(alpert): More duplication than I'd like from
    // span.prototype.toMarkup and symbolNode.prototype.toNode...
    var needsSpan = false;
    var markup = "<span";

    if (this.classes.length) {
      needsSpan = true;
      markup += " class=\"";
      markup += utils.escape(createClass(this.classes));
      markup += "\"";
    }

    var styles = "";

    if (this.italic > 0) {
      styles += "margin-right:" + this.italic + "em;";
    }

    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }

    if (styles) {
      needsSpan = true;
      markup += " style=\"" + utils.escape(styles) + "\"";
    }

    var escaped = utils.escape(this.text);

    if (needsSpan) {
      markup += ">";
      markup += escaped;
      markup += "</span>";
      return markup;
    } else {
      return escaped;
    }
  }

}
/**
 * SVG nodes are used to render stretchy wide elements.
 */

class SvgNode {
  constructor(children, attributes) {
    this.children = void 0;
    this.attributes = void 0;
    this.children = children || [];
    this.attributes = attributes || {};
  }

  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "svg"); // Apply attributes

    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }

    for (var i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }

    return node;
  }

  toMarkup() {
    var markup = "<svg xmlns=\"http://www.w3.org/2000/svg\""; // Apply attributes

    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + "='" + this.attributes[attr] + "'";
      }
    }

    markup += ">";

    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    markup += "</svg>";
    return markup;
  }

}
class PathNode {
  constructor(pathName, alternate) {
    this.pathName = void 0;
    this.alternate = void 0;
    this.pathName = pathName;
    this.alternate = alternate; // Used only for \sqrt, \phase, & tall delims
  }

  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "path");

    if (this.alternate) {
      node.setAttribute("d", this.alternate);
    } else {
      node.setAttribute("d", path[this.pathName]);
    }

    return node;
  }

  toMarkup() {
    if (this.alternate) {
      return "<path d='" + this.alternate + "'/>";
    } else {
      return "<path d='" + path[this.pathName] + "'/>";
    }
  }

}
class LineNode {
  constructor(attributes) {
    this.attributes = void 0;
    this.attributes = attributes || {};
  }

  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "line"); // Apply attributes

    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }

    return node;
  }

  toMarkup() {
    var markup = "<line";

    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + "='" + this.attributes[attr] + "'";
      }
    }

    markup += "/>";
    return markup;
  }

}
function assertSymbolDomNode(group) {
  if (group instanceof SymbolNode) {
    return group;
  } else {
    throw new Error("Expected symbolNode but got " + String(group) + ".");
  }
}
function assertSpan(group) {
  if (group instanceof Span) {
    return group;
  } else {
    throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
  }
}

/**
 * This file holds a list of all no-argument functions and single-character
 * symbols (like 'a' or ';').
 *
 * For each of the symbols, there are three properties they can have:
 * - font (required): the font to be used for this symbol. Either "main" (the
     normal font), or "ams" (the ams fonts).
 * - group (required): the ParseNode group type the symbol should have (i.e.
     "textord", "mathord", etc).
     See https://github.com/KaTeX/KaTeX/wiki/Examining-TeX#group-types
 * - replace: the character that this symbol or function should be
 *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
 *   character in the main font).
 *
 * The outermost map in the table indicates what mode the symbols should be
 * accepted in (e.g. "math" or "text").
 */
// Some of these have a "-token" suffix since these are also used as `ParseNode`
// types for raw text tokens, and we want to avoid conflicts with higher-level
// `ParseNode` types. These `ParseNode`s are constructed within `Parser` by
// looking up the `symbols` map.
var ATOMS = {
  "bin": 1,
  "close": 1,
  "inner": 1,
  "open": 1,
  "punct": 1,
  "rel": 1
};
var NON_ATOMS = {
  "accent-token": 1,
  "mathord": 1,
  "op-token": 1,
  "spacing": 1,
  "textord": 1
};
var symbols = {
  "math": {},
  "text": {}
};
/** `acceptUnicodeChar = true` is only applicable if `replace` is set. */

function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
  symbols[mode][name] = {
    font,
    group,
    replace
  };

  if (acceptUnicodeChar && replace) {
    symbols[mode][replace] = symbols[mode][name];
  }
} // Some abbreviations for commonly used strings.
// This helps minify the code, and also spotting typos using jshint.
// modes:

var math = "math";
var text = "text"; // fonts:

var main = "main";
var ams = "ams"; // groups:

var accent = "accent-token";
var bin = "bin";
var close = "close";
var inner = "inner";
var mathord = "mathord";
var op = "op-token";
var open = "open";
var punct = "punct";
var rel = "rel";
var spacing = "spacing";
var textord = "textord"; // Now comes the symbol table
// Relation Symbols

defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
defineSymbol(math, main, rel, "\u227a", "\\prec", true);
defineSymbol(math, main, rel, "\u227b", "\\succ", true);
defineSymbol(math, main, rel, "\u223c", "\\sim", true);
defineSymbol(math, main, rel, "\u22a5", "\\perp");
defineSymbol(math, main, rel, "\u2aaf", "\\preceq", true);
defineSymbol(math, main, rel, "\u2ab0", "\\succeq", true);
defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
defineSymbol(math, main, rel, "\u2223", "\\mid", true);
defineSymbol(math, main, rel, "\u226a", "\\ll", true);
defineSymbol(math, main, rel, "\u226b", "\\gg", true);
defineSymbol(math, main, rel, "\u224d", "\\asymp", true);
defineSymbol(math, main, rel, "\u2225", "\\parallel");
defineSymbol(math, main, rel, "\u22c8", "\\bowtie", true);
defineSymbol(math, main, rel, "\u2323", "\\smile", true);
defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
defineSymbol(math, main, rel, "\u2322", "\\frown", true);
defineSymbol(math, main, rel, "\u220b", "\\ni", true);
defineSymbol(math, main, rel, "\u221d", "\\propto", true);
defineSymbol(math, main, rel, "\u22a2", "\\vdash", true);
defineSymbol(math, main, rel, "\u22a3", "\\dashv", true);
defineSymbol(math, main, rel, "\u220b", "\\owns"); // Punctuation

defineSymbol(math, main, punct, "\u002e", "\\ldotp");
defineSymbol(math, main, punct, "\u22c5", "\\cdotp"); // Misc Symbols

defineSymbol(math, main, textord, "\u0023", "\\#");
defineSymbol(text, main, textord, "\u0023", "\\#");
defineSymbol(math, main, textord, "\u0026", "\\&");
defineSymbol(text, main, textord, "\u0026", "\\&");
defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
defineSymbol(math, main, textord, "\u2200", "\\forall", true);
defineSymbol(math, main, textord, "\u210f", "\\hbar", true);
defineSymbol(math, main, textord, "\u2203", "\\exists", true);
defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
defineSymbol(math, main, textord, "\u266d", "\\flat", true);
defineSymbol(math, main, textord, "\u2113", "\\ell", true);
defineSymbol(math, main, textord, "\u266e", "\\natural", true);
defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
defineSymbol(math, main, textord, "\u2118", "\\wp", true);
defineSymbol(math, main, textord, "\u266f", "\\sharp", true);
defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
defineSymbol(math, main, textord, "\u211c", "\\Re", true);
defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
defineSymbol(math, main, textord, "\u2111", "\\Im", true);
defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
defineSymbol(math, main, textord, "\u00a7", "\\S", true);
defineSymbol(text, main, textord, "\u00a7", "\\S");
defineSymbol(math, main, textord, "\u00b6", "\\P", true);
defineSymbol(text, main, textord, "\u00b6", "\\P"); // Math and Text

defineSymbol(math, main, textord, "\u2020", "\\dag");
defineSymbol(text, main, textord, "\u2020", "\\dag");
defineSymbol(text, main, textord, "\u2020", "\\textdagger");
defineSymbol(math, main, textord, "\u2021", "\\ddag");
defineSymbol(text, main, textord, "\u2021", "\\ddag");
defineSymbol(text, main, textord, "\u2021", "\\textdaggerdbl"); // Large Delimiters

defineSymbol(math, main, close, "\u23b1", "\\rmoustache", true);
defineSymbol(math, main, open, "\u23b0", "\\lmoustache", true);
defineSymbol(math, main, close, "\u27ef", "\\rgroup", true);
defineSymbol(math, main, open, "\u27ee", "\\lgroup", true); // Binary Operators

defineSymbol(math, main, bin, "\u2213", "\\mp", true);
defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
defineSymbol(math, main, bin, "\u228e", "\\uplus", true);
defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
defineSymbol(math, main, bin, "\u2217", "\\ast");
defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
defineSymbol(math, main, bin, "\u25ef", "\\bigcirc", true);
defineSymbol(math, main, bin, "\u2219", "\\bullet", true);
defineSymbol(math, main, bin, "\u2021", "\\ddagger");
defineSymbol(math, main, bin, "\u2240", "\\wr", true);
defineSymbol(math, main, bin, "\u2a3f", "\\amalg");
defineSymbol(math, main, bin, "\u0026", "\\And"); // from amsmath
// Arrow Symbols

defineSymbol(math, main, rel, "\u27f5", "\\longleftarrow", true);
defineSymbol(math, main, rel, "\u21d0", "\\Leftarrow", true);
defineSymbol(math, main, rel, "\u27f8", "\\Longleftarrow", true);
defineSymbol(math, main, rel, "\u27f6", "\\longrightarrow", true);
defineSymbol(math, main, rel, "\u21d2", "\\Rightarrow", true);
defineSymbol(math, main, rel, "\u27f9", "\\Longrightarrow", true);
defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
defineSymbol(math, main, rel, "\u27f7", "\\longleftrightarrow", true);
defineSymbol(math, main, rel, "\u21d4", "\\Leftrightarrow", true);
defineSymbol(math, main, rel, "\u27fa", "\\Longleftrightarrow", true);
defineSymbol(math, main, rel, "\u21a6", "\\mapsto", true);
defineSymbol(math, main, rel, "\u27fc", "\\longmapsto", true);
defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
defineSymbol(math, main, rel, "\u21a9", "\\hookleftarrow", true);
defineSymbol(math, main, rel, "\u21aa", "\\hookrightarrow", true);
defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
defineSymbol(math, main, rel, "\u21bc", "\\leftharpoonup", true);
defineSymbol(math, main, rel, "\u21c0", "\\rightharpoonup", true);
defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
defineSymbol(math, main, rel, "\u21bd", "\\leftharpoondown", true);
defineSymbol(math, main, rel, "\u21c1", "\\rightharpoondown", true);
defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
defineSymbol(math, main, rel, "\u21cc", "\\rightleftharpoons", true); // AMS Negated Binary Relations

defineSymbol(math, ams, rel, "\u226e", "\\nless", true); // Symbol names preceeded by "@" each have a corresponding macro.

defineSymbol(math, ams, rel, "\ue010", "\\@nleqslant");
defineSymbol(math, ams, rel, "\ue011", "\\@nleqq");
defineSymbol(math, ams, rel, "\u2a87", "\\lneq", true);
defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
defineSymbol(math, ams, rel, "\ue00c", "\\@lvertneqq");
defineSymbol(math, ams, rel, "\u22e6", "\\lnsim", true);
defineSymbol(math, ams, rel, "\u2a89", "\\lnapprox", true);
defineSymbol(math, ams, rel, "\u2280", "\\nprec", true); // unicode-math maps \u22e0 to \npreccurlyeq. We'll use the AMS synonym.

defineSymbol(math, ams, rel, "\u22e0", "\\npreceq", true);
defineSymbol(math, ams, rel, "\u22e8", "\\precnsim", true);
defineSymbol(math, ams, rel, "\u2ab9", "\\precnapprox", true);
defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
defineSymbol(math, ams, rel, "\ue006", "\\@nshortmid");
defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
defineSymbol(math, ams, rel, "\u22ac", "\\nvdash", true);
defineSymbol(math, ams, rel, "\u22ad", "\\nvDash", true);
defineSymbol(math, ams, rel, "\u22ea", "\\ntriangleleft");
defineSymbol(math, ams, rel, "\u22ec", "\\ntrianglelefteq", true);
defineSymbol(math, ams, rel, "\u228a", "\\subsetneq", true);
defineSymbol(math, ams, rel, "\ue01a", "\\@varsubsetneq");
defineSymbol(math, ams, rel, "\u2acb", "\\subsetneqq", true);
defineSymbol(math, ams, rel, "\ue017", "\\@varsubsetneqq");
defineSymbol(math, ams, rel, "\u226f", "\\ngtr", true);
defineSymbol(math, ams, rel, "\ue00f", "\\@ngeqslant");
defineSymbol(math, ams, rel, "\ue00e", "\\@ngeqq");
defineSymbol(math, ams, rel, "\u2a88", "\\gneq", true);
defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
defineSymbol(math, ams, rel, "\ue00d", "\\@gvertneqq");
defineSymbol(math, ams, rel, "\u22e7", "\\gnsim", true);
defineSymbol(math, ams, rel, "\u2a8a", "\\gnapprox", true);
defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true); // unicode-math maps \u22e1 to \nsucccurlyeq. We'll use the AMS synonym.

defineSymbol(math, ams, rel, "\u22e1", "\\nsucceq", true);
defineSymbol(math, ams, rel, "\u22e9", "\\succnsim", true);
defineSymbol(math, ams, rel, "\u2aba", "\\succnapprox", true); // unicode-math maps \u2246 to \simneqq. We'll use the AMS synonym.

defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
defineSymbol(math, ams, rel, "\ue007", "\\@nshortparallel");
defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
defineSymbol(math, ams, rel, "\u22af", "\\nVDash", true);
defineSymbol(math, ams, rel, "\u22eb", "\\ntriangleright");
defineSymbol(math, ams, rel, "\u22ed", "\\ntrianglerighteq", true);
defineSymbol(math, ams, rel, "\ue018", "\\@nsupseteqq");
defineSymbol(math, ams, rel, "\u228b", "\\supsetneq", true);
defineSymbol(math, ams, rel, "\ue01b", "\\@varsupsetneq");
defineSymbol(math, ams, rel, "\u2acc", "\\supsetneqq", true);
defineSymbol(math, ams, rel, "\ue019", "\\@varsupsetneqq");
defineSymbol(math, ams, rel, "\u22ae", "\\nVdash", true);
defineSymbol(math, ams, rel, "\u2ab5", "\\precneqq", true);
defineSymbol(math, ams, rel, "\u2ab6", "\\succneqq", true);
defineSymbol(math, ams, rel, "\ue016", "\\@nsubseteqq");
defineSymbol(math, ams, bin, "\u22b4", "\\unlhd");
defineSymbol(math, ams, bin, "\u22b5", "\\unrhd"); // AMS Negated Arrows

defineSymbol(math, ams, rel, "\u219a", "\\nleftarrow", true);
defineSymbol(math, ams, rel, "\u219b", "\\nrightarrow", true);
defineSymbol(math, ams, rel, "\u21cd", "\\nLeftarrow", true);
defineSymbol(math, ams, rel, "\u21cf", "\\nRightarrow", true);
defineSymbol(math, ams, rel, "\u21ae", "\\nleftrightarrow", true);
defineSymbol(math, ams, rel, "\u21ce", "\\nLeftrightarrow", true); // AMS Misc

defineSymbol(math, ams, rel, "\u25b3", "\\vartriangle");
defineSymbol(math, ams, textord, "\u210f", "\\hslash");
defineSymbol(math, ams, textord, "\u25bd", "\\triangledown");
defineSymbol(math, ams, textord, "\u25ca", "\\lozenge");
defineSymbol(math, ams, textord, "\u24c8", "\\circledS");
defineSymbol(math, ams, textord, "\u00ae", "\\circledR");
defineSymbol(text, ams, textord, "\u00ae", "\\circledR");
defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
defineSymbol(math, ams, textord, "\u2204", "\\nexists");
defineSymbol(math, ams, textord, "\u2127", "\\mho");
defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
defineSymbol(math, ams, textord, "\u2035", "\\backprime");
defineSymbol(math, ams, textord, "\u25b2", "\\blacktriangle");
defineSymbol(math, ams, textord, "\u25bc", "\\blacktriangledown");
defineSymbol(math, ams, textord, "\u25a0", "\\blacksquare");
defineSymbol(math, ams, textord, "\u29eb", "\\blacklozenge");
defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
defineSymbol(math, ams, textord, "\u2201", "\\complement", true); // unicode-math maps U+F0 to \matheth. We map to AMS function \eth

defineSymbol(math, ams, textord, "\u00f0", "\\eth", true);
defineSymbol(text, main, textord, "\u00f0", "\u00f0");
defineSymbol(math, ams, textord, "\u2571", "\\diagup");
defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
defineSymbol(math, ams, textord, "\u25a1", "\\square");
defineSymbol(math, ams, textord, "\u25a1", "\\Box");
defineSymbol(math, ams, textord, "\u25ca", "\\Diamond"); // unicode-math maps U+A5 to \mathyen. We map to AMS function \yen

defineSymbol(math, ams, textord, "\u00a5", "\\yen", true);
defineSymbol(text, ams, textord, "\u00a5", "\\yen", true);
defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
defineSymbol(text, ams, textord, "\u2713", "\\checkmark"); // AMS Hebrew

defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
defineSymbol(math, ams, textord, "\u2137", "\\gimel", true); // AMS Greek

defineSymbol(math, ams, textord, "\u03dd", "\\digamma", true);
defineSymbol(math, ams, textord, "\u03f0", "\\varkappa"); // AMS Delimiters

defineSymbol(math, ams, open, "\u250c", "\\@ulcorner", true);
defineSymbol(math, ams, close, "\u2510", "\\@urcorner", true);
defineSymbol(math, ams, open, "\u2514", "\\@llcorner", true);
defineSymbol(math, ams, close, "\u2518", "\\@lrcorner", true); // AMS Binary Relations

defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
defineSymbol(math, ams, rel, "\u2a7d", "\\leqslant", true);
defineSymbol(math, ams, rel, "\u2a95", "\\eqslantless", true);
defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
defineSymbol(math, ams, rel, "\u2a85", "\\lessapprox", true);
defineSymbol(math, ams, rel, "\u224a", "\\approxeq", true);
defineSymbol(math, ams, bin, "\u22d6", "\\lessdot");
defineSymbol(math, ams, rel, "\u22d8", "\\lll", true);
defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
defineSymbol(math, ams, rel, "\u22da", "\\lesseqgtr", true);
defineSymbol(math, ams, rel, "\u2a8b", "\\lesseqqgtr", true);
defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
defineSymbol(math, ams, rel, "\u223d", "\\backsim", true);
defineSymbol(math, ams, rel, "\u22cd", "\\backsimeq", true);
defineSymbol(math, ams, rel, "\u2ac5", "\\subseteqq", true);
defineSymbol(math, ams, rel, "\u22d0", "\\Subset", true);
defineSymbol(math, ams, rel, "\u228f", "\\sqsubset", true);
defineSymbol(math, ams, rel, "\u227c", "\\preccurlyeq", true);
defineSymbol(math, ams, rel, "\u22de", "\\curlyeqprec", true);
defineSymbol(math, ams, rel, "\u227e", "\\precsim", true);
defineSymbol(math, ams, rel, "\u2ab7", "\\precapprox", true);
defineSymbol(math, ams, rel, "\u22b2", "\\vartriangleleft");
defineSymbol(math, ams, rel, "\u22b4", "\\trianglelefteq");
defineSymbol(math, ams, rel, "\u22a8", "\\vDash", true);
defineSymbol(math, ams, rel, "\u22aa", "\\Vvdash", true);
defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
defineSymbol(math, ams, rel, "\u224f", "\\bumpeq", true);
defineSymbol(math, ams, rel, "\u224e", "\\Bumpeq", true);
defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
defineSymbol(math, ams, rel, "\u2a7e", "\\geqslant", true);
defineSymbol(math, ams, rel, "\u2a96", "\\eqslantgtr", true);
defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
defineSymbol(math, ams, rel, "\u2a86", "\\gtrapprox", true);
defineSymbol(math, ams, bin, "\u22d7", "\\gtrdot");
defineSymbol(math, ams, rel, "\u22d9", "\\ggg", true);
defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
defineSymbol(math, ams, rel, "\u22db", "\\gtreqless", true);
defineSymbol(math, ams, rel, "\u2a8c", "\\gtreqqless", true);
defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
defineSymbol(math, ams, rel, "\u225c", "\\triangleq", true);
defineSymbol(math, ams, rel, "\u223c", "\\thicksim");
defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
defineSymbol(math, ams, rel, "\u2ac6", "\\supseteqq", true);
defineSymbol(math, ams, rel, "\u22d1", "\\Supset", true);
defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
defineSymbol(math, ams, rel, "\u227d", "\\succcurlyeq", true);
defineSymbol(math, ams, rel, "\u22df", "\\curlyeqsucc", true);
defineSymbol(math, ams, rel, "\u227f", "\\succsim", true);
defineSymbol(math, ams, rel, "\u2ab8", "\\succapprox", true);
defineSymbol(math, ams, rel, "\u22b3", "\\vartriangleright");
defineSymbol(math, ams, rel, "\u22b5", "\\trianglerighteq");
defineSymbol(math, ams, rel, "\u22a9", "\\Vdash", true);
defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
defineSymbol(math, ams, rel, "\u226c", "\\between", true);
defineSymbol(math, ams, rel, "\u22d4", "\\pitchfork", true);
defineSymbol(math, ams, rel, "\u221d", "\\varpropto");
defineSymbol(math, ams, rel, "\u25c0", "\\blacktriangleleft"); // unicode-math says that \therefore is a mathord atom.
// We kept the amssymb atom type, which is rel.

defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
defineSymbol(math, ams, rel, "\u220d", "\\backepsilon");
defineSymbol(math, ams, rel, "\u25b6", "\\blacktriangleright"); // unicode-math says that \because is a mathord atom.
// We kept the amssymb atom type, which is rel.

defineSymbol(math, ams, rel, "\u2235", "\\because", true);
defineSymbol(math, ams, rel, "\u22d8", "\\llless");
defineSymbol(math, ams, rel, "\u22d9", "\\gggtr");
defineSymbol(math, ams, bin, "\u22b2", "\\lhd");
defineSymbol(math, ams, bin, "\u22b3", "\\rhd");
defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
defineSymbol(math, main, rel, "\u22c8", "\\Join");
defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true); // AMS Binary Operators

defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
defineSymbol(math, ams, bin, "\u22d2", "\\Cap", true);
defineSymbol(math, ams, bin, "\u22d3", "\\Cup", true);
defineSymbol(math, ams, bin, "\u2a5e", "\\doublebarwedge", true);
defineSymbol(math, ams, bin, "\u229f", "\\boxminus", true);
defineSymbol(math, ams, bin, "\u229e", "\\boxplus", true);
defineSymbol(math, ams, bin, "\u22c7", "\\divideontimes", true);
defineSymbol(math, ams, bin, "\u22c9", "\\ltimes", true);
defineSymbol(math, ams, bin, "\u22ca", "\\rtimes", true);
defineSymbol(math, ams, bin, "\u22cb", "\\leftthreetimes", true);
defineSymbol(math, ams, bin, "\u22cc", "\\rightthreetimes", true);
defineSymbol(math, ams, bin, "\u22cf", "\\curlywedge", true);
defineSymbol(math, ams, bin, "\u22ce", "\\curlyvee", true);
defineSymbol(math, ams, bin, "\u229d", "\\circleddash", true);
defineSymbol(math, ams, bin, "\u229b", "\\circledast", true);
defineSymbol(math, ams, bin, "\u22c5", "\\centerdot");
defineSymbol(math, ams, bin, "\u22ba", "\\intercal", true);
defineSymbol(math, ams, bin, "\u22d2", "\\doublecap");
defineSymbol(math, ams, bin, "\u22d3", "\\doublecup");
defineSymbol(math, ams, bin, "\u22a0", "\\boxtimes", true); // AMS Arrows
// Note: unicode-math maps \u21e2 to their own function \rightdasharrow.
// We'll map it to AMS function \dashrightarrow. It produces the same atom.

defineSymbol(math, ams, rel, "\u21e2", "\\dashrightarrow", true); // unicode-math maps \u21e0 to \leftdasharrow. We'll use the AMS synonym.

defineSymbol(math, ams, rel, "\u21e0", "\\dashleftarrow", true);
defineSymbol(math, ams, rel, "\u21c7", "\\leftleftarrows", true);
defineSymbol(math, ams, rel, "\u21c6", "\\leftrightarrows", true);
defineSymbol(math, ams, rel, "\u21da", "\\Lleftarrow", true);
defineSymbol(math, ams, rel, "\u219e", "\\twoheadleftarrow", true);
defineSymbol(math, ams, rel, "\u21a2", "\\leftarrowtail", true);
defineSymbol(math, ams, rel, "\u21ab", "\\looparrowleft", true);
defineSymbol(math, ams, rel, "\u21cb", "\\leftrightharpoons", true);
defineSymbol(math, ams, rel, "\u21b6", "\\curvearrowleft", true); // unicode-math maps \u21ba to \acwopencirclearrow. We'll use the AMS synonym.

defineSymbol(math, ams, rel, "\u21ba", "\\circlearrowleft", true);
defineSymbol(math, ams, rel, "\u21b0", "\\Lsh", true);
defineSymbol(math, ams, rel, "\u21c8", "\\upuparrows", true);
defineSymbol(math, ams, rel, "\u21bf", "\\upharpoonleft", true);
defineSymbol(math, ams, rel, "\u21c3", "\\downharpoonleft", true);
defineSymbol(math, main, rel, "\u22b6", "\\origof", true); // not in font

defineSymbol(math, main, rel, "\u22b7", "\\imageof", true); // not in font

defineSymbol(math, ams, rel, "\u22b8", "\\multimap", true);
defineSymbol(math, ams, rel, "\u21ad", "\\leftrightsquigarrow", true);
defineSymbol(math, ams, rel, "\u21c9", "\\rightrightarrows", true);
defineSymbol(math, ams, rel, "\u21c4", "\\rightleftarrows", true);
defineSymbol(math, ams, rel, "\u21a0", "\\twoheadrightarrow", true);
defineSymbol(math, ams, rel, "\u21a3", "\\rightarrowtail", true);
defineSymbol(math, ams, rel, "\u21ac", "\\looparrowright", true);
defineSymbol(math, ams, rel, "\u21b7", "\\curvearrowright", true); // unicode-math maps \u21bb to \cwopencirclearrow. We'll use the AMS synonym.

defineSymbol(math, ams, rel, "\u21bb", "\\circlearrowright", true);
defineSymbol(math, ams, rel, "\u21b1", "\\Rsh", true);
defineSymbol(math, ams, rel, "\u21ca", "\\downdownarrows", true);
defineSymbol(math, ams, rel, "\u21be", "\\upharpoonright", true);
defineSymbol(math, ams, rel, "\u21c2", "\\downharpoonright", true);
defineSymbol(math, ams, rel, "\u21dd", "\\rightsquigarrow", true);
defineSymbol(math, ams, rel, "\u21dd", "\\leadsto");
defineSymbol(math, ams, rel, "\u21db", "\\Rrightarrow", true);
defineSymbol(math, ams, rel, "\u21be", "\\restriction");
defineSymbol(math, main, textord, "\u2018", "`");
defineSymbol(math, main, textord, "$", "\\$");
defineSymbol(text, main, textord, "$", "\\$");
defineSymbol(text, main, textord, "$", "\\textdollar");
defineSymbol(math, main, textord, "%", "\\%");
defineSymbol(text, main, textord, "%", "\\%");
defineSymbol(math, main, textord, "_", "\\_");
defineSymbol(text, main, textord, "_", "\\_");
defineSymbol(text, main, textord, "_", "\\textunderscore");
defineSymbol(math, main, textord, "\u2220", "\\angle", true);
defineSymbol(math, main, textord, "\u221e", "\\infty", true);
defineSymbol(math, main, textord, "\u2032", "\\prime");
defineSymbol(math, main, textord, "\u25b3", "\\triangle");
defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
defineSymbol(math, main, textord, "\u039b", "\\Lambda", true);
defineSymbol(math, main, textord, "\u039e", "\\Xi", true);
defineSymbol(math, main, textord, "\u03a0", "\\Pi", true);
defineSymbol(math, main, textord, "\u03a3", "\\Sigma", true);
defineSymbol(math, main, textord, "\u03a5", "\\Upsilon", true);
defineSymbol(math, main, textord, "\u03a6", "\\Phi", true);
defineSymbol(math, main, textord, "\u03a8", "\\Psi", true);
defineSymbol(math, main, textord, "\u03a9", "\\Omega", true);
defineSymbol(math, main, textord, "A", "\u0391");
defineSymbol(math, main, textord, "B", "\u0392");
defineSymbol(math, main, textord, "E", "\u0395");
defineSymbol(math, main, textord, "Z", "\u0396");
defineSymbol(math, main, textord, "H", "\u0397");
defineSymbol(math, main, textord, "I", "\u0399");
defineSymbol(math, main, textord, "K", "\u039A");
defineSymbol(math, main, textord, "M", "\u039C");
defineSymbol(math, main, textord, "N", "\u039D");
defineSymbol(math, main, textord, "O", "\u039F");
defineSymbol(math, main, textord, "P", "\u03A1");
defineSymbol(math, main, textord, "T", "\u03A4");
defineSymbol(math, main, textord, "X", "\u03A7");
defineSymbol(math, main, textord, "\u00ac", "\\neg", true);
defineSymbol(math, main, textord, "\u00ac", "\\lnot");
defineSymbol(math, main, textord, "\u22a4", "\\top");
defineSymbol(math, main, textord, "\u22a5", "\\bot");
defineSymbol(math, main, textord, "\u2205", "\\emptyset");
defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
defineSymbol(math, main, mathord, "\u03b1", "\\alpha", true);
defineSymbol(math, main, mathord, "\u03b2", "\\beta", true);
defineSymbol(math, main, mathord, "\u03b3", "\\gamma", true);
defineSymbol(math, main, mathord, "\u03b4", "\\delta", true);
defineSymbol(math, main, mathord, "\u03f5", "\\epsilon", true);
defineSymbol(math, main, mathord, "\u03b6", "\\zeta", true);
defineSymbol(math, main, mathord, "\u03b7", "\\eta", true);
defineSymbol(math, main, mathord, "\u03b8", "\\theta", true);
defineSymbol(math, main, mathord, "\u03b9", "\\iota", true);
defineSymbol(math, main, mathord, "\u03ba", "\\kappa", true);
defineSymbol(math, main, mathord, "\u03bb", "\\lambda", true);
defineSymbol(math, main, mathord, "\u03bc", "\\mu", true);
defineSymbol(math, main, mathord, "\u03bd", "\\nu", true);
defineSymbol(math, main, mathord, "\u03be", "\\xi", true);
defineSymbol(math, main, mathord, "\u03bf", "\\omicron", true);
defineSymbol(math, main, mathord, "\u03c0", "\\pi", true);
defineSymbol(math, main, mathord, "\u03c1", "\\rho", true);
defineSymbol(math, main, mathord, "\u03c3", "\\sigma", true);
defineSymbol(math, main, mathord, "\u03c4", "\\tau", true);
defineSymbol(math, main, mathord, "\u03c5", "\\upsilon", true);
defineSymbol(math, main, mathord, "\u03d5", "\\phi", true);
defineSymbol(math, main, mathord, "\u03c7", "\\chi", true);
defineSymbol(math, main, mathord, "\u03c8", "\\psi", true);
defineSymbol(math, main, mathord, "\u03c9", "\\omega", true);
defineSymbol(math, main, mathord, "\u03b5", "\\varepsilon", true);
defineSymbol(math, main, mathord, "\u03d1", "\\vartheta", true);
defineSymbol(math, main, mathord, "\u03d6", "\\varpi", true);
defineSymbol(math, main, mathord, "\u03f1", "\\varrho", true);
defineSymbol(math, main, mathord, "\u03c2", "\\varsigma", true);
defineSymbol(math, main, mathord, "\u03c6", "\\varphi", true);
defineSymbol(math, main, bin, "\u2217", "*", true);
defineSymbol(math, main, bin, "+", "+");
defineSymbol(math, main, bin, "\u2212", "-", true);
defineSymbol(math, main, bin, "\u22c5", "\\cdot", true);
defineSymbol(math, main, bin, "\u2218", "\\circ", true);
defineSymbol(math, main, bin, "\u00f7", "\\div", true);
defineSymbol(math, main, bin, "\u00b1", "\\pm", true);
defineSymbol(math, main, bin, "\u00d7", "\\times", true);
defineSymbol(math, main, bin, "\u2229", "\\cap", true);
defineSymbol(math, main, bin, "\u222a", "\\cup", true);
defineSymbol(math, main, bin, "\u2216", "\\setminus", true);
defineSymbol(math, main, bin, "\u2227", "\\land");
defineSymbol(math, main, bin, "\u2228", "\\lor");
defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
defineSymbol(math, main, bin, "\u2228", "\\vee", true);
defineSymbol(math, main, textord, "\u221a", "\\surd");
defineSymbol(math, main, open, "\u27e8", "\\langle", true);
defineSymbol(math, main, open, "\u2223", "\\lvert");
defineSymbol(math, main, open, "\u2225", "\\lVert");
defineSymbol(math, main, close, "?", "?");
defineSymbol(math, main, close, "!", "!");
defineSymbol(math, main, close, "\u27e9", "\\rangle", true);
defineSymbol(math, main, close, "\u2223", "\\rvert");
defineSymbol(math, main, close, "\u2225", "\\rVert");
defineSymbol(math, main, rel, "=", "=");
defineSymbol(math, main, rel, ":", ":");
defineSymbol(math, main, rel, "\u2248", "\\approx", true);
defineSymbol(math, main, rel, "\u2245", "\\cong", true);
defineSymbol(math, main, rel, "\u2265", "\\ge");
defineSymbol(math, main, rel, "\u2265", "\\geq", true);
defineSymbol(math, main, rel, "\u2190", "\\gets");
defineSymbol(math, main, rel, ">", "\\gt", true);
defineSymbol(math, main, rel, "\u2208", "\\in", true);
defineSymbol(math, main, rel, "\ue020", "\\@not");
defineSymbol(math, main, rel, "\u2282", "\\subset", true);
defineSymbol(math, main, rel, "\u2283", "\\supset", true);
defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
defineSymbol(math, main, rel, "\u22a8", "\\models");
defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
defineSymbol(math, main, rel, "\u2264", "\\le");
defineSymbol(math, main, rel, "\u2264", "\\leq", true);
defineSymbol(math, main, rel, "<", "\\lt", true);
defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
defineSymbol(math, main, rel, "\u2192", "\\to");
defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
defineSymbol(math, main, spacing, "\u00a0", "\\ ");
defineSymbol(math, main, spacing, "\u00a0", "\\space"); // Ref: LaTeX Source 2e: \DeclareRobustCommand{\nobreakspace}{%

defineSymbol(math, main, spacing, "\u00a0", "\\nobreakspace");
defineSymbol(text, main, spacing, "\u00a0", "\\ ");
defineSymbol(text, main, spacing, "\u00a0", " ");
defineSymbol(text, main, spacing, "\u00a0", "\\space");
defineSymbol(text, main, spacing, "\u00a0", "\\nobreakspace");
defineSymbol(math, main, spacing, null, "\\nobreak");
defineSymbol(math, main, spacing, null, "\\allowbreak");
defineSymbol(math, main, punct, ",", ",");
defineSymbol(math, main, punct, ";", ";");
defineSymbol(math, ams, bin, "\u22bc", "\\barwedge", true);
defineSymbol(math, ams, bin, "\u22bb", "\\veebar", true);
defineSymbol(math, main, bin, "\u2299", "\\odot", true);
defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
defineSymbol(math, main, textord, "\u2202", "\\partial", true);
defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
defineSymbol(math, ams, bin, "\u229a", "\\circledcirc", true);
defineSymbol(math, ams, bin, "\u22a1", "\\boxdot", true);
defineSymbol(math, main, bin, "\u25b3", "\\bigtriangleup");
defineSymbol(math, main, bin, "\u25bd", "\\bigtriangledown");
defineSymbol(math, main, bin, "\u2020", "\\dagger");
defineSymbol(math, main, bin, "\u22c4", "\\diamond");
defineSymbol(math, main, bin, "\u22c6", "\\star");
defineSymbol(math, main, bin, "\u25c3", "\\triangleleft");
defineSymbol(math, main, bin, "\u25b9", "\\triangleright");
defineSymbol(math, main, open, "{", "\\{");
defineSymbol(text, main, textord, "{", "\\{");
defineSymbol(text, main, textord, "{", "\\textbraceleft");
defineSymbol(math, main, close, "}", "\\}");
defineSymbol(text, main, textord, "}", "\\}");
defineSymbol(text, main, textord, "}", "\\textbraceright");
defineSymbol(math, main, open, "{", "\\lbrace");
defineSymbol(math, main, close, "}", "\\rbrace");
defineSymbol(math, main, open, "[", "\\lbrack", true);
defineSymbol(text, main, textord, "[", "\\lbrack", true);
defineSymbol(math, main, close, "]", "\\rbrack", true);
defineSymbol(text, main, textord, "]", "\\rbrack", true);
defineSymbol(math, main, open, "(", "\\lparen", true);
defineSymbol(math, main, close, ")", "\\rparen", true);
defineSymbol(text, main, textord, "<", "\\textless", true); // in T1 fontenc

defineSymbol(text, main, textord, ">", "\\textgreater", true); // in T1 fontenc

defineSymbol(math, main, open, "\u230a", "\\lfloor", true);
defineSymbol(math, main, close, "\u230b", "\\rfloor", true);
defineSymbol(math, main, open, "\u2308", "\\lceil", true);
defineSymbol(math, main, close, "\u2309", "\\rceil", true);
defineSymbol(math, main, textord, "\\", "\\backslash");
defineSymbol(math, main, textord, "\u2223", "|");
defineSymbol(math, main, textord, "\u2223", "\\vert");
defineSymbol(text, main, textord, "|", "\\textbar", true); // in T1 fontenc

defineSymbol(math, main, textord, "\u2225", "\\|");
defineSymbol(math, main, textord, "\u2225", "\\Vert");
defineSymbol(text, main, textord, "\u2225", "\\textbardbl");
defineSymbol(text, main, textord, "~", "\\textasciitilde");
defineSymbol(text, main, textord, "\\", "\\textbackslash");
defineSymbol(text, main, textord, "^", "\\textasciicircum");
defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
defineSymbol(math, main, rel, "\u21d1", "\\Uparrow", true);
defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
defineSymbol(math, main, rel, "\u21d3", "\\Downarrow", true);
defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
defineSymbol(math, main, rel, "\u21d5", "\\Updownarrow", true);
defineSymbol(math, main, op, "\u2210", "\\coprod");
defineSymbol(math, main, op, "\u22c1", "\\bigvee");
defineSymbol(math, main, op, "\u22c0", "\\bigwedge");
defineSymbol(math, main, op, "\u2a04", "\\biguplus");
defineSymbol(math, main, op, "\u22c2", "\\bigcap");
defineSymbol(math, main, op, "\u22c3", "\\bigcup");
defineSymbol(math, main, op, "\u222b", "\\int");
defineSymbol(math, main, op, "\u222b", "\\intop");
defineSymbol(math, main, op, "\u222c", "\\iint");
defineSymbol(math, main, op, "\u222d", "\\iiint");
defineSymbol(math, main, op, "\u220f", "\\prod");
defineSymbol(math, main, op, "\u2211", "\\sum");
defineSymbol(math, main, op, "\u2a02", "\\bigotimes");
defineSymbol(math, main, op, "\u2a01", "\\bigoplus");
defineSymbol(math, main, op, "\u2a00", "\\bigodot");
defineSymbol(math, main, op, "\u222e", "\\oint");
defineSymbol(math, main, op, "\u222f", "\\oiint");
defineSymbol(math, main, op, "\u2230", "\\oiiint");
defineSymbol(math, main, op, "\u2a06", "\\bigsqcup");
defineSymbol(math, main, op, "\u222b", "\\smallint");
defineSymbol(text, main, inner, "\u2026", "\\textellipsis");
defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
defineSymbol(text, main, inner, "\u2026", "\\ldots", true);
defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
defineSymbol(math, main, inner, "\u22ef", "\\@cdots", true);
defineSymbol(math, main, inner, "\u22f1", "\\ddots", true);
defineSymbol(math, main, textord, "\u22ee", "\\varvdots"); // \vdots is a macro

defineSymbol(math, main, accent, "\u02ca", "\\acute");
defineSymbol(math, main, accent, "\u02cb", "\\grave");
defineSymbol(math, main, accent, "\u00a8", "\\ddot");
defineSymbol(math, main, accent, "\u007e", "\\tilde");
defineSymbol(math, main, accent, "\u02c9", "\\bar");
defineSymbol(math, main, accent, "\u02d8", "\\breve");
defineSymbol(math, main, accent, "\u02c7", "\\check");
defineSymbol(math, main, accent, "\u005e", "\\hat");
defineSymbol(math, main, accent, "\u20d7", "\\vec");
defineSymbol(math, main, accent, "\u02d9", "\\dot");
defineSymbol(math, main, accent, "\u02da", "\\mathring"); // \imath and \jmath should be invariant to \mathrm, \mathbf, etc., so use PUA

defineSymbol(math, main, mathord, "\ue131", "\\@imath");
defineSymbol(math, main, mathord, "\ue237", "\\@jmath");
defineSymbol(math, main, textord, "\u0131", "\u0131");
defineSymbol(math, main, textord, "\u0237", "\u0237");
defineSymbol(text, main, textord, "\u0131", "\\i", true);
defineSymbol(text, main, textord, "\u0237", "\\j", true);
defineSymbol(text, main, textord, "\u00df", "\\ss", true);
defineSymbol(text, main, textord, "\u00e6", "\\ae", true);
defineSymbol(text, main, textord, "\u0153", "\\oe", true);
defineSymbol(text, main, textord, "\u00f8", "\\o", true);
defineSymbol(text, main, textord, "\u00c6", "\\AE", true);
defineSymbol(text, main, textord, "\u0152", "\\OE", true);
defineSymbol(text, main, textord, "\u00d8", "\\O", true);
defineSymbol(text, main, accent, "\u02ca", "\\'"); // acute

defineSymbol(text, main, accent, "\u02cb", "\\`"); // grave

defineSymbol(text, main, accent, "\u02c6", "\\^"); // circumflex

defineSymbol(text, main, accent, "\u02dc", "\\~"); // tilde

defineSymbol(text, main, accent, "\u02c9", "\\="); // macron

defineSymbol(text, main, accent, "\u02d8", "\\u"); // breve

defineSymbol(text, main, accent, "\u02d9", "\\."); // dot above

defineSymbol(text, main, accent, "\u00b8", "\\c"); // cedilla

defineSymbol(text, main, accent, "\u02da", "\\r"); // ring above

defineSymbol(text, main, accent, "\u02c7", "\\v"); // caron

defineSymbol(text, main, accent, "\u00a8", '\\"'); // diaresis

defineSymbol(text, main, accent, "\u02dd", "\\H"); // double acute

defineSymbol(text, main, accent, "\u25ef", "\\textcircled"); // \bigcirc glyph
// These ligatures are detected and created in Parser.js's `formLigatures`.

var ligatures = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};
defineSymbol(text, main, textord, "\u2013", "--", true);
defineSymbol(text, main, textord, "\u2013", "\\textendash");
defineSymbol(text, main, textord, "\u2014", "---", true);
defineSymbol(text, main, textord, "\u2014", "\\textemdash");
defineSymbol(text, main, textord, "\u2018", "`", true);
defineSymbol(text, main, textord, "\u2018", "\\textquoteleft");
defineSymbol(text, main, textord, "\u2019", "'", true);
defineSymbol(text, main, textord, "\u2019", "\\textquoteright");
defineSymbol(text, main, textord, "\u201c", "``", true);
defineSymbol(text, main, textord, "\u201c", "\\textquotedblleft");
defineSymbol(text, main, textord, "\u201d", "''", true);
defineSymbol(text, main, textord, "\u201d", "\\textquotedblright"); //  \degree from gensymb package

defineSymbol(math, main, textord, "\u00b0", "\\degree", true);
defineSymbol(text, main, textord, "\u00b0", "\\degree"); // \textdegree from inputenc package

defineSymbol(text, main, textord, "\u00b0", "\\textdegree", true); // TODO: In LaTeX, \pounds can generate a different character in text and math
// mode, but among our fonts, only Main-Regular defines this character "163".

defineSymbol(math, main, textord, "\u00a3", "\\pounds");
defineSymbol(math, main, textord, "\u00a3", "\\mathsterling", true);
defineSymbol(text, main, textord, "\u00a3", "\\pounds");
defineSymbol(text, main, textord, "\u00a3", "\\textsterling", true);
defineSymbol(math, ams, textord, "\u2720", "\\maltese");
defineSymbol(text, ams, textord, "\u2720", "\\maltese"); // There are lots of symbols which are the same, so we add them in afterwards.
// All of these are textords in math mode

var mathTextSymbols = "0123456789/@.\"";

for (var i = 0; i < mathTextSymbols.length; i++) {
  var ch = mathTextSymbols.charAt(i);
  defineSymbol(math, main, textord, ch, ch);
} // All of these are textords in text mode


var textSymbols = "0123456789!@*()-=+\";:?/.,";

for (var _i = 0; _i < textSymbols.length; _i++) {
  var _ch = textSymbols.charAt(_i);

  defineSymbol(text, main, textord, _ch, _ch);
} // All of these are textords in text mode, and mathords in math mode


var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

for (var _i2 = 0; _i2 < letters.length; _i2++) {
  var _ch2 = letters.charAt(_i2);

  defineSymbol(math, main, mathord, _ch2, _ch2);
  defineSymbol(text, main, textord, _ch2, _ch2);
} // Blackboard bold and script letters in Unicode range


defineSymbol(math, ams, textord, "C", "\u2102"); // blackboard bold

defineSymbol(text, ams, textord, "C", "\u2102");
defineSymbol(math, ams, textord, "H", "\u210D");
defineSymbol(text, ams, textord, "H", "\u210D");
defineSymbol(math, ams, textord, "N", "\u2115");
defineSymbol(text, ams, textord, "N", "\u2115");
defineSymbol(math, ams, textord, "P", "\u2119");
defineSymbol(text, ams, textord, "P", "\u2119");
defineSymbol(math, ams, textord, "Q", "\u211A");
defineSymbol(text, ams, textord, "Q", "\u211A");
defineSymbol(math, ams, textord, "R", "\u211D");
defineSymbol(text, ams, textord, "R", "\u211D");
defineSymbol(math, ams, textord, "Z", "\u2124");
defineSymbol(text, ams, textord, "Z", "\u2124");
defineSymbol(math, main, mathord, "h", "\u210E"); // italic h, Planck constant

defineSymbol(text, main, mathord, "h", "\u210E"); // The next loop loads wide (surrogate pair) characters.
// We support some letters in the Unicode range U+1D400 to U+1D7FF,
// Mathematical Alphanumeric Symbols.
// Some editors do not deal well with wide characters. So don't write the
// string into this file. Instead, create the string from the surrogate pair.

var wideChar = "";

for (var _i3 = 0; _i3 < letters.length; _i3++) {
  var _ch3 = letters.charAt(_i3); // The hex numbers in the next line are a surrogate pair.
  // 0xD835 is the high surrogate for all letters in the range we support.
  // 0xDC00 is the low surrogate for bold A.


  wideChar = String.fromCharCode(0xD835, 0xDC00 + _i3); // A-Z a-z bold

  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDC34 + _i3); // A-Z a-z italic

  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDC68 + _i3); // A-Z a-z bold italic

  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDD04 + _i3); // A-Z a-z Fractur

  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDDA0 + _i3); // A-Z a-z sans-serif

  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDDD4 + _i3); // A-Z a-z sans bold

  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDE08 + _i3); // A-Z a-z sans italic

  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDE70 + _i3); // A-Z a-z monospace

  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text, main, textord, _ch3, wideChar);

  if (_i3 < 26) {
    // KaTeX fonts have only capital letters for blackboard bold and script.
    // See exception for k below.
    wideChar = String.fromCharCode(0xD835, 0xDD38 + _i3); // A-Z double struck

    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(0xD835, 0xDC9C + _i3); // A-Z script

    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text, main, textord, _ch3, wideChar);
  } // TODO: Add bold script when it is supported by a KaTeX font.

} // "k" is the only double struck lower case letter in the KaTeX fonts.


wideChar = String.fromCharCode(0xD835, 0xDD5C); // k double struck

defineSymbol(math, main, mathord, "k", wideChar);
defineSymbol(text, main, textord, "k", wideChar); // Next, some wide character numerals

for (var _i4 = 0; _i4 < 10; _i4++) {
  var _ch4 = _i4.toString();

  wideChar = String.fromCharCode(0xD835, 0xDFCE + _i4); // 0-9 bold

  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDFE2 + _i4); // 0-9 sans serif

  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDFEC + _i4); // 0-9 bold sans

  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(0xD835, 0xDFF6 + _i4); // 0-9 monospace

  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text, main, textord, _ch4, wideChar);
} // We add these Latin-1 letters as symbols for backwards-compatibility,
// but they are not actually in the font, nor are they supported by the
// Unicode accent mechanism, so they fall back to Times font and look ugly.
// TODO(edemaine): Fix this.


var extraLatin = "\u00d0\u00de\u00fe";

for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
  var _ch5 = extraLatin.charAt(_i5);

  defineSymbol(math, main, mathord, _ch5, _ch5);
  defineSymbol(text, main, textord, _ch5, _ch5);
}

/**
 * This file provides support for Unicode range U+1D400 to U+1D7FF,
 * Mathematical Alphanumeric Symbols.
 *
 * Function wideCharacterFont takes a wide character as input and returns
 * the font information necessary to render it properly.
 */
/**
 * Data below is from https://www.unicode.org/charts/PDF/U1D400.pdf
 * That document sorts characters into groups by font type, say bold or italic.
 *
 * In the arrays below, each subarray consists three elements:
 *      * The CSS class of that group when in math mode.
 *      * The CSS class of that group when in text mode.
 *      * The font name, so that KaTeX can get font metrics.
 */

var wideLatinLetterData = [["mathbf", "textbf", "Main-Bold"], // A-Z bold upright
["mathbf", "textbf", "Main-Bold"], // a-z bold upright
["mathnormal", "textit", "Math-Italic"], // A-Z italic
["mathnormal", "textit", "Math-Italic"], // a-z italic
["boldsymbol", "boldsymbol", "Main-BoldItalic"], // A-Z bold italic
["boldsymbol", "boldsymbol", "Main-BoldItalic"], // a-z bold italic
// Map fancy A-Z letters to script, not calligraphic.
// This aligns with unicode-math and math fonts (except Cambria Math).
["mathscr", "textscr", "Script-Regular"], // A-Z script
["", "", ""], // a-z script.  No font
["", "", ""], // A-Z bold script. No font
["", "", ""], // a-z bold script. No font
["mathfrak", "textfrak", "Fraktur-Regular"], // A-Z Fraktur
["mathfrak", "textfrak", "Fraktur-Regular"], // a-z Fraktur
["mathbb", "textbb", "AMS-Regular"], // A-Z double-struck
["mathbb", "textbb", "AMS-Regular"], // k double-struck
["", "", ""], // A-Z bold Fraktur No font metrics
["", "", ""], // a-z bold Fraktur.   No font.
["mathsf", "textsf", "SansSerif-Regular"], // A-Z sans-serif
["mathsf", "textsf", "SansSerif-Regular"], // a-z sans-serif
["mathboldsf", "textboldsf", "SansSerif-Bold"], // A-Z bold sans-serif
["mathboldsf", "textboldsf", "SansSerif-Bold"], // a-z bold sans-serif
["mathitsf", "textitsf", "SansSerif-Italic"], // A-Z italic sans-serif
["mathitsf", "textitsf", "SansSerif-Italic"], // a-z italic sans-serif
["", "", ""], // A-Z bold italic sans. No font
["", "", ""], // a-z bold italic sans. No font
["mathtt", "texttt", "Typewriter-Regular"], // A-Z monospace
["mathtt", "texttt", "Typewriter-Regular"] // a-z monospace
];
var wideNumeralData = [["mathbf", "textbf", "Main-Bold"], // 0-9 bold
["", "", ""], // 0-9 double-struck. No KaTeX font.
["mathsf", "textsf", "SansSerif-Regular"], // 0-9 sans-serif
["mathboldsf", "textboldsf", "SansSerif-Bold"], // 0-9 bold sans-serif
["mathtt", "texttt", "Typewriter-Regular"] // 0-9 monospace
];
var wideCharacterFont = function wideCharacterFont(wideChar, mode) {
  // IE doesn't support codePointAt(). So work with the surrogate pair.
  var H = wideChar.charCodeAt(0); // high surrogate

  var L = wideChar.charCodeAt(1); // low surrogate

  var codePoint = (H - 0xD800) * 0x400 + (L - 0xDC00) + 0x10000;
  var j = mode === "math" ? 0 : 1; // column index for CSS class.

  if (0x1D400 <= codePoint && codePoint < 0x1D6A4) {
    // wideLatinLetterData contains exactly 26 chars on each row.
    // So we can calculate the relevant row. No traverse necessary.
    var i = Math.floor((codePoint - 0x1D400) / 26);
    return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
  } else if (0x1D7CE <= codePoint && codePoint <= 0x1D7FF) {
    // Numerals, ten per row.
    var _i = Math.floor((codePoint - 0x1D7CE) / 10);

    return [wideNumeralData[_i][2], wideNumeralData[_i][j]];
  } else if (codePoint === 0x1D6A5 || codePoint === 0x1D6A6) {
    // dotless i or j
    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
  } else if (0x1D6A6 < codePoint && codePoint < 0x1D7CE) {
    // Greek letters. Not supported, yet.
    return ["", ""];
  } else {
    // We don't support any wide characters outside 1D400–1D7FF.
    throw new ParseError("Unsupported character: " + wideChar);
  }
};

/* eslint no-console:0 */

/**
 * Looks up the given symbol in fontMetrics, after applying any symbol
 * replacements defined in symbol.js
 */
var lookupSymbol = function lookupSymbol(value, // TODO(#963): Use a union type for this.
fontName, mode) {
  // Replace the value with its replaced value from symbol.js
  if (symbols[mode][value] && symbols[mode][value].replace) {
    value = symbols[mode][value].replace;
  }

  return {
    value: value,
    metrics: getCharacterMetrics(value, fontName, mode)
  };
};
/**
 * Makes a symbolNode after translation via the list of symbols in symbols.js.
 * Correctly pulls out metrics for the character, and optionally takes a list of
 * classes to be attached to the node.
 *
 * TODO: make argument order closer to makeSpan
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 * TODO(#953): Make `options` mandatory and always pass it in.
 */


var makeSymbol = function makeSymbol(value, fontName, mode, options, classes) {
  var lookup = lookupSymbol(value, fontName, mode);
  var metrics = lookup.metrics;
  value = lookup.value;
  var symbolNode;

  if (metrics) {
    var italic = metrics.italic;

    if (mode === "text" || options && options.font === "mathit") {
      italic = 0;
    }

    symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
  } else {
    // TODO(emily): Figure out a good way to only print this in development
    typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
    symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
  }

  if (options) {
    symbolNode.maxFontSize = options.sizeMultiplier;

    if (options.style.isTight()) {
      symbolNode.classes.push("mtight");
    }

    var color = options.getColor();

    if (color) {
      symbolNode.style.color = color;
    }
  }

  return symbolNode;
};
/**
 * Makes a symbol in Main-Regular or AMS-Regular.
 * Used for rel, bin, open, close, inner, and punct.
 */


var mathsym = function mathsym(value, mode, options, classes) {
  if (classes === void 0) {
    classes = [];
  }

  // Decide what font to render the symbol in by its entry in the symbols
  // table.
  // Have a special case for when the value = \ because the \ is used as a
  // textord in unsupported command errors but cannot be parsed as a regular
  // text ordinal and is therefore not present as a symbol in the symbols
  // table for text, as well as a special case for boldsymbol because it
  // can be used for bold + and -
  if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
    return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
  } else if (value === "\\" || symbols[mode][value].font === "main") {
    return makeSymbol(value, "Main-Regular", mode, options, classes);
  } else {
    return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
  }
};
/**
 * Determines which of the two font names (Main-Bold and Math-BoldItalic) and
 * corresponding style tags (mathbf or boldsymbol) to use for font "boldsymbol",
 * depending on the symbol.  Use this function instead of fontMap for font
 * "boldsymbol".
 */


var boldsymbol = function boldsymbol(value, mode, options, classes, type) {
  if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
    return {
      fontName: "Math-BoldItalic",
      fontClass: "boldsymbol"
    };
  } else {
    // Some glyphs do not exist in Math-BoldItalic so we need to use
    // Main-Bold instead.
    return {
      fontName: "Main-Bold",
      fontClass: "mathbf"
    };
  }
};
/**
 * Makes either a mathord or textord in the correct font and color.
 */


var makeOrd = function makeOrd(group, options, type) {
  var mode = group.mode;
  var text = group.text;
  var classes = ["mord"]; // Math mode or Old font (i.e. \rm)

  var isFont = mode === "math" || mode === "text" && options.font;
  var fontOrFamily = isFont ? options.font : options.fontFamily;

  if (text.charCodeAt(0) === 0xD835) {
    // surrogate pairs get special treatment
    var [wideFontName, wideFontClass] = wideCharacterFont(text, mode);
    return makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));
  } else if (fontOrFamily) {
    var fontName;
    var fontClasses;

    if (fontOrFamily === "boldsymbol") {
      var fontData = boldsymbol(text, mode, options, classes, type);
      fontName = fontData.fontName;
      fontClasses = [fontData.fontClass];
    } else if (isFont) {
      fontName = fontMap[fontOrFamily].fontName;
      fontClasses = [fontOrFamily];
    } else {
      fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
      fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
    }

    if (lookupSymbol(text, fontName, mode).metrics) {
      return makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));
    } else if (ligatures.hasOwnProperty(text) && fontName.slice(0, 10) === "Typewriter") {
      // Deconstruct ligatures in monospace fonts (\texttt, \tt).
      var parts = [];

      for (var i = 0; i < text.length; i++) {
        parts.push(makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));
      }

      return makeFragment(parts);
    }
  } // Makes a symbol in the default font for mathords and textords.


  if (type === "mathord") {
    return makeSymbol(text, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
  } else if (type === "textord") {
    var font = symbols[mode][text] && symbols[mode][text].font;

    if (font === "ams") {
      var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);

      return makeSymbol(text, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
    } else if (font === "main" || !font) {
      var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);

      return makeSymbol(text, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
    } else {
      // fonts added by plugins
      var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape); // We add font name as a css class


      return makeSymbol(text, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
    }
  } else {
    throw new Error("unexpected type: " + type + " in makeOrd");
  }
};
/**
 * Returns true if subsequent symbolNodes have the same classes, skew, maxFont,
 * and styles.
 */


var canCombine = (prev, next) => {
  if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
    return false;
  } // If prev and next both are just "mbin"s or "mord"s we don't combine them
  // so that the proper spacing can be preserved.


  if (prev.classes.length === 1) {
    var cls = prev.classes[0];

    if (cls === "mbin" || cls === "mord") {
      return false;
    }
  }

  for (var style in prev.style) {
    if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
      return false;
    }
  }

  for (var _style in next.style) {
    if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
      return false;
    }
  }

  return true;
};
/**
 * Combine consecutive domTree.symbolNodes into a single symbolNode.
 * Note: this function mutates the argument.
 */


var tryCombineChars = chars => {
  for (var i = 0; i < chars.length - 1; i++) {
    var prev = chars[i];
    var next = chars[i + 1];

    if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
      prev.text += next.text;
      prev.height = Math.max(prev.height, next.height);
      prev.depth = Math.max(prev.depth, next.depth); // Use the last character's italic correction since we use
      // it to add padding to the right of the span created from
      // the combined characters.

      prev.italic = next.italic;
      chars.splice(i + 1, 1);
      i--;
    }
  }

  return chars;
};
/**
 * Calculate the height, depth, and maxFontSize of an element based on its
 * children.
 */


var sizeElementFromChildren = function sizeElementFromChildren(elem) {
  var height = 0;
  var depth = 0;
  var maxFontSize = 0;

  for (var i = 0; i < elem.children.length; i++) {
    var child = elem.children[i];

    if (child.height > height) {
      height = child.height;
    }

    if (child.depth > depth) {
      depth = child.depth;
    }

    if (child.maxFontSize > maxFontSize) {
      maxFontSize = child.maxFontSize;
    }
  }

  elem.height = height;
  elem.depth = depth;
  elem.maxFontSize = maxFontSize;
};
/**
 * Makes a span with the given list of classes, list of children, and options.
 *
 * TODO(#953): Ensure that `options` is always provided (currently some call
 * sites don't pass it) and make the type below mandatory.
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 */


var makeSpan$2 = function makeSpan(classes, children, options, style) {
  var span = new Span(classes, children, options, style);
  sizeElementFromChildren(span);
  return span;
}; // SVG one is simpler -- doesn't require height, depth, max-font setting.
// This is also a separate method for typesafety.


var makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);

var makeLineSpan = function makeLineSpan(className, options, thickness) {
  var line = makeSpan$2([className], [], options);
  line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
  line.style.borderBottomWidth = makeEm(line.height);
  line.maxFontSize = 1.0;
  return line;
};
/**
 * Makes an anchor with the given href, list of classes, list of children,
 * and options.
 */


var makeAnchor = function makeAnchor(href, classes, children, options) {
  var anchor = new Anchor(href, classes, children, options);
  sizeElementFromChildren(anchor);
  return anchor;
};
/**
 * Makes a document fragment with the given list of children.
 */


var makeFragment = function makeFragment(children) {
  var fragment = new DocumentFragment(children);
  sizeElementFromChildren(fragment);
  return fragment;
};
/**
 * Wraps group in a span if it's a document fragment, allowing to apply classes
 * and styles
 */


var wrapFragment = function wrapFragment(group, options) {
  if (group instanceof DocumentFragment) {
    return makeSpan$2([], [group], options);
  }

  return group;
}; // These are exact object types to catch typos in the names of the optional fields.


// Computes the updated `children` list and the overall depth.
//
// This helper function for makeVList makes it easier to enforce type safety by
// allowing early exits (returns) in the logic.
var getVListChildrenAndDepth = function getVListChildrenAndDepth(params) {
  if (params.positionType === "individualShift") {
    var oldChildren = params.children;
    var children = [oldChildren[0]]; // Add in kerns to the list of params.children to get each element to be
    // shifted to the correct specified shift

    var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;

    var currPos = _depth;

    for (var i = 1; i < oldChildren.length; i++) {
      var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
      var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
      currPos = currPos + diff;
      children.push({
        type: "kern",
        size
      });
      children.push(oldChildren[i]);
    }

    return {
      children,
      depth: _depth
    };
  }

  var depth;

  if (params.positionType === "top") {
    // We always start at the bottom, so calculate the bottom by adding up
    // all the sizes
    var bottom = params.positionData;

    for (var _i = 0; _i < params.children.length; _i++) {
      var child = params.children[_i];
      bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
    }

    depth = bottom;
  } else if (params.positionType === "bottom") {
    depth = -params.positionData;
  } else {
    var firstChild = params.children[0];

    if (firstChild.type !== "elem") {
      throw new Error('First child must have type "elem".');
    }

    if (params.positionType === "shift") {
      depth = -firstChild.elem.depth - params.positionData;
    } else if (params.positionType === "firstBaseline") {
      depth = -firstChild.elem.depth;
    } else {
      throw new Error("Invalid positionType " + params.positionType + ".");
    }
  }

  return {
    children: params.children,
    depth
  };
};
/**
 * Makes a vertical list by stacking elements and kerns on top of each other.
 * Allows for many different ways of specifying the positioning method.
 *
 * See VListParam documentation above.
 */


var makeVList = function makeVList(params, options) {
  var {
    children,
    depth
  } = getVListChildrenAndDepth(params); // Create a strut that is taller than any list item. The strut is added to
  // each item, where it will determine the item's baseline. Since it has
  // `overflow:hidden`, the strut's top edge will sit on the item's line box's
  // top edge and the strut's bottom edge will sit on the item's baseline,
  // with no additional line-height spacing. This allows the item baseline to
  // be positioned precisely without worrying about font ascent and
  // line-height.

  var pstrutSize = 0;

  for (var i = 0; i < children.length; i++) {
    var child = children[i];

    if (child.type === "elem") {
      var elem = child.elem;
      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
    }
  }

  pstrutSize += 2;
  var pstrut = makeSpan$2(["pstrut"], []);
  pstrut.style.height = makeEm(pstrutSize); // Create a new list of actual children at the correct offsets

  var realChildren = [];
  var minPos = depth;
  var maxPos = depth;
  var currPos = depth;

  for (var _i2 = 0; _i2 < children.length; _i2++) {
    var _child = children[_i2];

    if (_child.type === "kern") {
      currPos += _child.size;
    } else {
      var _elem = _child.elem;
      var classes = _child.wrapperClasses || [];
      var style = _child.wrapperStyle || {};
      var childWrap = makeSpan$2(classes, [pstrut, _elem], undefined, style);
      childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);

      if (_child.marginLeft) {
        childWrap.style.marginLeft = _child.marginLeft;
      }

      if (_child.marginRight) {
        childWrap.style.marginRight = _child.marginRight;
      }

      realChildren.push(childWrap);
      currPos += _elem.height + _elem.depth;
    }

    minPos = Math.min(minPos, currPos);
    maxPos = Math.max(maxPos, currPos);
  } // The vlist contents go in a table-cell with `vertical-align:bottom`.
  // This cell's bottom edge will determine the containing table's baseline
  // without overly expanding the containing line-box.


  var vlist = makeSpan$2(["vlist"], realChildren);
  vlist.style.height = makeEm(maxPos); // A second row is used if necessary to represent the vlist's depth.

  var rows;

  if (minPos < 0) {
    // We will define depth in an empty span with display: table-cell.
    // It should render with the height that we define. But Chrome, in
    // contenteditable mode only, treats that span as if it contains some
    // text content. And that min-height over-rides our desired height.
    // So we put another empty span inside the depth strut span.
    var emptySpan = makeSpan$2([], []);
    var depthStrut = makeSpan$2(["vlist"], [emptySpan]);
    depthStrut.style.height = makeEm(-minPos); // Safari wants the first row to have inline content; otherwise it
    // puts the bottom of the *second* row on the baseline.

    var topStrut = makeSpan$2(["vlist-s"], [new SymbolNode("\u200b")]);
    rows = [makeSpan$2(["vlist-r"], [vlist, topStrut]), makeSpan$2(["vlist-r"], [depthStrut])];
  } else {
    rows = [makeSpan$2(["vlist-r"], [vlist])];
  }

  var vtable = makeSpan$2(["vlist-t"], rows);

  if (rows.length === 2) {
    vtable.classes.push("vlist-t2");
  }

  vtable.height = maxPos;
  vtable.depth = -minPos;
  return vtable;
}; // Glue is a concept from TeX which is a flexible space between elements in
// either a vertical or horizontal list. In KaTeX, at least for now, it's
// static space between elements in a horizontal layout.


var makeGlue = (measurement, options) => {
  // Make an empty span for the space
  var rule = makeSpan$2(["mspace"], [], options);
  var size = calculateSize(measurement, options);
  rule.style.marginRight = makeEm(size);
  return rule;
}; // Takes font options, and returns the appropriate fontLookup name


var retrieveTextFontName = function retrieveTextFontName(fontFamily, fontWeight, fontShape) {
  var baseFontName = "";

  switch (fontFamily) {
    case "amsrm":
      baseFontName = "AMS";
      break;

    case "textrm":
      baseFontName = "Main";
      break;

    case "textsf":
      baseFontName = "SansSerif";
      break;

    case "texttt":
      baseFontName = "Typewriter";
      break;

    default:
      baseFontName = fontFamily;
    // use fonts added by a plugin
  }

  var fontStylesName;

  if (fontWeight === "textbf" && fontShape === "textit") {
    fontStylesName = "BoldItalic";
  } else if (fontWeight === "textbf") {
    fontStylesName = "Bold";
  } else if (fontWeight === "textit") {
    fontStylesName = "Italic";
  } else {
    fontStylesName = "Regular";
  }

  return baseFontName + "-" + fontStylesName;
};
/**
 * Maps TeX font commands to objects containing:
 * - variant: string used for "mathvariant" attribute in buildMathML.js
 * - fontName: the "style" parameter to fontMetrics.getCharacterMetrics
 */
// A map between tex font commands an MathML mathvariant attribute values


var fontMap = {
  // styles
  "mathbf": {
    variant: "bold",
    fontName: "Main-Bold"
  },
  "mathrm": {
    variant: "normal",
    fontName: "Main-Regular"
  },
  "textit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathnormal": {
    variant: "italic",
    fontName: "Math-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  "mathbb": {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  "mathcal": {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  "mathfrak": {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  "mathscr": {
    variant: "script",
    fontName: "Script-Regular"
  },
  "mathsf": {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  "mathtt": {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
};
var svgData = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
};

var staticSvg = function staticSvg(value, options) {
  // Create a span with inline SVG for the element.
  var [pathName, width, height] = svgData[value];
  var path = new PathNode(pathName);
  var svgNode = new SvgNode([path], {
    "width": makeEm(width),
    "height": makeEm(height),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1000 * width + " " + 1000 * height,
    "preserveAspectRatio": "xMinYMin"
  });
  var span = makeSvgSpan(["overlay"], [svgNode], options);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return span;
};

var buildCommon = {
  fontMap,
  makeSymbol,
  mathsym,
  makeSpan: makeSpan$2,
  makeSvgSpan,
  makeLineSpan,
  makeAnchor,
  makeFragment,
  wrapFragment,
  makeVList,
  makeOrd,
  makeGlue,
  staticSvg,
  svgData,
  tryCombineChars
};

/**
 * Describes spaces between different classes of atoms.
 */
var thinspace = {
  number: 3,
  unit: "mu"
};
var mediumspace = {
  number: 4,
  unit: "mu"
};
var thickspace = {
  number: 5,
  unit: "mu"
}; // Making the type below exact with all optional fields doesn't work due to
// - https://github.com/facebook/flow/issues/4582
// - https://github.com/facebook/flow/issues/5688
// However, since *all* fields are optional, $Shape<> works as suggested in 5688
// above.

// Spacing relationships for display and text styles
var spacings = {
  mord: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    minner: thinspace
  },
  mbin: {
    mord: mediumspace,
    mop: mediumspace,
    mopen: mediumspace,
    minner: mediumspace
  },
  mrel: {
    mord: thickspace,
    mop: thickspace,
    mopen: thickspace,
    minner: thickspace
  },
  mopen: {},
  mclose: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mpunct: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    mopen: thinspace,
    mclose: thinspace,
    mpunct: thinspace,
    minner: thinspace
  },
  minner: {
    mord: thinspace,
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    mopen: thinspace,
    mpunct: thinspace,
    minner: thinspace
  }
}; // Spacing relationships for script and scriptscript styles

var tightSpacings = {
  mord: {
    mop: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: thinspace
  },
  mpunct: {},
  minner: {
    mop: thinspace
  }
};

/** Context provided to function handlers for error messages. */
// Note: reverse the order of the return type union will cause a flow error.
// See https://github.com/facebook/flow/issues/3663.
// More general version of `HtmlBuilder` for nodes (e.g. \sum, accent types)
// whose presence impacts super/subscripting. In this case, ParseNode<"supsub">
// delegates its HTML building to the HtmlBuilder corresponding to these nodes.

/**
 * Final function spec for use at parse time.
 * This is almost identical to `FunctionPropSpec`, except it
 * 1. includes the function handler, and
 * 2. requires all arguments except argTypes.
 * It is generated by `defineFunction()` below.
 */

/**
 * All registered functions.
 * `functions.js` just exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary.
 */
var _functions = {};
/**
 * All HTML builders. Should be only used in the `define*` and the `build*ML`
 * functions.
 */

var _htmlGroupBuilders = {};
/**
 * All MathML builders. Should be only used in the `define*` and the `build*ML`
 * functions.
 */

var _mathmlGroupBuilders = {};
function defineFunction(_ref) {
  var {
    type,
    names,
    props,
    handler,
    htmlBuilder,
    mathmlBuilder
  } = _ref;
  // Set default values of functions
  var data = {
    type,
    numArgs: props.numArgs,
    argTypes: props.argTypes,
    allowedInArgument: !!props.allowedInArgument,
    allowedInText: !!props.allowedInText,
    allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,
    numOptionalArgs: props.numOptionalArgs || 0,
    infix: !!props.infix,
    primitive: !!props.primitive,
    handler: handler
  };

  for (var i = 0; i < names.length; ++i) {
    _functions[names[i]] = data;
  }

  if (type) {
    if (htmlBuilder) {
      _htmlGroupBuilders[type] = htmlBuilder;
    }

    if (mathmlBuilder) {
      _mathmlGroupBuilders[type] = mathmlBuilder;
    }
  }
}
/**
 * Use this to register only the HTML and MathML builders for a function (e.g.
 * if the function's ParseNode is generated in Parser.js rather than via a
 * stand-alone handler provided to `defineFunction`).
 */

function defineFunctionBuilders(_ref2) {
  var {
    type,
    htmlBuilder,
    mathmlBuilder
  } = _ref2;
  defineFunction({
    type,
    names: [],
    props: {
      numArgs: 0
    },

    handler() {
      throw new Error('Should never be called.');
    },

    htmlBuilder,
    mathmlBuilder
  });
}
var normalizeArgument = function normalizeArgument(arg) {
  return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
}; // Since the corresponding buildHTML/buildMathML function expects a
// list of elements, we normalize for different kinds of arguments

var ordargument = function ordargument(arg) {
  return arg.type === "ordgroup" ? arg.body : [arg];
};

/**
 * This file does the main work of building a domTree structure from a parse
 * tree. The entry point is the `buildHTML` function, which takes a parse tree.
 * Then, the buildExpression, buildGroup, and various groupBuilders functions
 * are called, to produce a final HTML tree.
 */
var makeSpan$1 = buildCommon.makeSpan; // Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)
// depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,
// and the text before Rule 19.

var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
var styleMap$1 = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
var DomEnum = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
};

/**
 * Take a list of nodes, build them in order, and return a list of the built
 * nodes. documentFragments are flattened into their contents, so the
 * returned list contains no fragments. `isRealGroup` is true if `expression`
 * is a real group (no atoms will be added on either side), as opposed to
 * a partial group (e.g. one created by \color). `surrounding` is an array
 * consisting type of nodes that will be added to the left and right.
 */
var buildExpression$1 = function buildExpression(expression, options, isRealGroup, surrounding) {
  if (surrounding === void 0) {
    surrounding = [null, null];
  }

  // Parse expressions into `groups`.
  var groups = [];

  for (var i = 0; i < expression.length; i++) {
    var output = buildGroup$1(expression[i], options);

    if (output instanceof DocumentFragment) {
      var children = output.children;
      groups.push(...children);
    } else {
      groups.push(output);
    }
  } // Combine consecutive domTree.symbolNodes into a single symbolNode.


  buildCommon.tryCombineChars(groups); // If `expression` is a partial group, let the parent handle spacings
  // to avoid processing groups multiple times.

  if (!isRealGroup) {
    return groups;
  }

  var glueOptions = options;

  if (expression.length === 1) {
    var node = expression[0];

    if (node.type === "sizing") {
      glueOptions = options.havingSize(node.size);
    } else if (node.type === "styling") {
      glueOptions = options.havingStyle(styleMap$1[node.style]);
    }
  } // Dummy spans for determining spacings between surrounding atoms.
  // If `expression` has no atoms on the left or right, class "leftmost"
  // or "rightmost", respectively, is used to indicate it.


  var dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options);
  var dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options); // TODO: These code assumes that a node's math class is the first element
  // of its `classes` array. A later cleanup should ensure this, for
  // instance by changing the signature of `makeSpan`.
  // Before determining what spaces to insert, perform bin cancellation.
  // Binary operators change to ordinary symbols in some contexts.

  var isRoot = isRealGroup === "root";
  traverseNonSpaceNodes(groups, (node, prev) => {
    var prevType = prev.classes[0];
    var type = node.classes[0];

    if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
      prev.classes[0] = "mord";
    } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
      node.classes[0] = "mord";
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  traverseNonSpaceNodes(groups, (node, prev) => {
    var prevType = getTypeOfDomTree(prev);
    var type = getTypeOfDomTree(node); // 'mtight' indicates that the node is script or scriptscript style.

    var space = prevType && type ? node.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;

    if (space) {
      // Insert glue (spacing) after the `prev`.
      return buildCommon.makeGlue(space, glueOptions);
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  return groups;
}; // Depth-first traverse non-space `nodes`, calling `callback` with the current and
// previous node as arguments, optionally returning a node to insert after the
// previous node. `prev` is an object with the previous node and `insertAfter`
// function to insert after it. `next` is a node that will be added to the right.
// Used for bin cancellation and inserting spacings.

var traverseNonSpaceNodes = function traverseNonSpaceNodes(nodes, callback, prev, next, isRoot) {
  if (next) {
    // temporarily append the right node, if exists
    nodes.push(next);
  }

  var i = 0;

  for (; i < nodes.length; i++) {
    var node = nodes[i];
    var partialGroup = checkPartialGroup(node);

    if (partialGroup) {
      // Recursive DFS
      // $FlowFixMe: make nodes a $ReadOnlyArray by returning a new array
      traverseNonSpaceNodes(partialGroup.children, callback, prev, null, isRoot);
      continue;
    } // Ignore explicit spaces (e.g., \;, \,) when determining what implicit
    // spacing should go between atoms of different classes


    var nonspace = !node.hasClass("mspace");

    if (nonspace) {
      var result = callback(node, prev.node);

      if (result) {
        if (prev.insertAfter) {
          prev.insertAfter(result);
        } else {
          // insert at front
          nodes.unshift(result);
          i++;
        }
      }
    }

    if (nonspace) {
      prev.node = node;
    } else if (isRoot && node.hasClass("newline")) {
      prev.node = makeSpan$1(["leftmost"]); // treat like beginning of line
    }

    prev.insertAfter = (index => n => {
      nodes.splice(index + 1, 0, n);
      i++;
    })(i);
  }

  if (next) {
    nodes.pop();
  }
}; // Check if given node is a partial group, i.e., does not affect spacing around.


var checkPartialGroup = function checkPartialGroup(node) {
  if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
    return node;
  }

  return null;
}; // Return the outermost node of a domTree.


var getOutermostNode = function getOutermostNode(node, side) {
  var partialGroup = checkPartialGroup(node);

  if (partialGroup) {
    var children = partialGroup.children;

    if (children.length) {
      if (side === "right") {
        return getOutermostNode(children[children.length - 1], "right");
      } else if (side === "left") {
        return getOutermostNode(children[0], "left");
      }
    }
  }

  return node;
}; // Return math atom class (mclass) of a domTree.
// If `side` is given, it will get the type of the outermost node at given side.


var getTypeOfDomTree = function getTypeOfDomTree(node, side) {
  if (!node) {
    return null;
  }

  if (side) {
    node = getOutermostNode(node, side);
  } // This makes a lot of assumptions as to where the type of atom
  // appears.  We should do a better job of enforcing this.


  return DomEnum[node.classes[0]] || null;
};
var makeNullDelimiter = function makeNullDelimiter(options, classes) {
  var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
  return makeSpan$1(classes.concat(moreClasses));
};
/**
 * buildGroup is the function that takes a group and calls the correct groupType
 * function for it. It also handles the interaction of size and style changes
 * between parents and children.
 */

var buildGroup$1 = function buildGroup(group, options, baseOptions) {
  if (!group) {
    return makeSpan$1();
  }

  if (_htmlGroupBuilders[group.type]) {
    // Call the groupBuilders function
    // $FlowFixMe
    var groupNode = _htmlGroupBuilders[group.type](group, options); // If the size changed between the parent and the current group, account
    // for that size difference.

    if (baseOptions && options.size !== baseOptions.size) {
      groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);
      var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
      groupNode.height *= multiplier;
      groupNode.depth *= multiplier;
    }

    return groupNode;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
/**
 * Combine an array of HTML DOM nodes (e.g., the output of `buildExpression`)
 * into an unbreakable HTML node of class .base, with proper struts to
 * guarantee correct vertical extent.  `buildHTML` calls this repeatedly to
 * make up the entire expression as a sequence of unbreakable units.
 */

function buildHTMLUnbreakable(children, options) {
  // Compute height and depth of this chunk.
  var body = makeSpan$1(["base"], children, options); // Add strut, which ensures that the top of the HTML element falls at
  // the height of the expression, and the bottom of the HTML element
  // falls at the depth of the expression.

  var strut = makeSpan$1(["strut"]);
  strut.style.height = makeEm(body.height + body.depth);

  if (body.depth) {
    strut.style.verticalAlign = makeEm(-body.depth);
  }

  body.children.unshift(strut);
  return body;
}
/**
 * Take an entire parse tree, and build it into an appropriate set of HTML
 * nodes.
 */


function buildHTML(tree, options) {
  // Strip off outer tag wrapper for processing below.
  var tag = null;

  if (tree.length === 1 && tree[0].type === "tag") {
    tag = tree[0].tag;
    tree = tree[0].body;
  } // Build the expression contained in the tree


  var expression = buildExpression$1(tree, options, "root");
  var eqnNum;

  if (expression.length === 2 && expression[1].hasClass("tag")) {
    // An environment with automatic equation numbers, e.g. {gather}.
    eqnNum = expression.pop();
  }

  var children = []; // Create one base node for each chunk between potential line breaks.
  // The TeXBook [p.173] says "A formula will be broken only after a
  // relation symbol like $=$ or $<$ or $\rightarrow$, or after a binary
  // operation symbol like $+$ or $-$ or $\times$, where the relation or
  // binary operation is on the ``outer level'' of the formula (i.e., not
  // enclosed in {...} and not part of an \over construction)."

  var parts = [];

  for (var i = 0; i < expression.length; i++) {
    parts.push(expression[i]);

    if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
      // Put any post-operator glue on same line as operator.
      // Watch for \nobreak along the way, and stop at \newline.
      var nobreak = false;

      while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
        i++;
        parts.push(expression[i]);

        if (expression[i].hasClass("nobreak")) {
          nobreak = true;
        }
      } // Don't allow break if \nobreak among the post-operator glue.


      if (!nobreak) {
        children.push(buildHTMLUnbreakable(parts, options));
        parts = [];
      }
    } else if (expression[i].hasClass("newline")) {
      // Write the line except the newline
      parts.pop();

      if (parts.length > 0) {
        children.push(buildHTMLUnbreakable(parts, options));
        parts = [];
      } // Put the newline at the top level


      children.push(expression[i]);
    }
  }

  if (parts.length > 0) {
    children.push(buildHTMLUnbreakable(parts, options));
  } // Now, if there was a tag, build it too and append it as a final child.


  var tagChild;

  if (tag) {
    tagChild = buildHTMLUnbreakable(buildExpression$1(tag, options, true));
    tagChild.classes = ["tag"];
    children.push(tagChild);
  } else if (eqnNum) {
    children.push(eqnNum);
  }

  var htmlNode = makeSpan$1(["katex-html"], children);
  htmlNode.setAttribute("aria-hidden", "true"); // Adjust the strut of the tag to be the maximum height of all children
  // (the height of the enclosing htmlNode) for proper vertical alignment.

  if (tagChild) {
    var strut = tagChild.children[0];
    strut.style.height = makeEm(htmlNode.height + htmlNode.depth);

    if (htmlNode.depth) {
      strut.style.verticalAlign = makeEm(-htmlNode.depth);
    }
  }

  return htmlNode;
}

/**
 * These objects store data about MathML nodes. This is the MathML equivalent
 * of the types in domTree.js. Since MathML handles its own rendering, and
 * since we're mainly using MathML to improve accessibility, we don't manage
 * any of the styling state that the plain DOM nodes do.
 *
 * The `toNode` and `toMarkup` functions work simlarly to how they do in
 * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.
 */
function newDocumentFragment(children) {
  return new DocumentFragment(children);
}
/**
 * This node represents a general purpose MathML node of any type. The
 * constructor requires the type of node to create (for example, `"mo"` or
 * `"mspace"`, corresponding to `<mo>` and `<mspace>` tags).
 */

class MathNode {
  constructor(type, children, classes) {
    this.type = void 0;
    this.attributes = void 0;
    this.children = void 0;
    this.classes = void 0;
    this.type = type;
    this.attributes = {};
    this.children = children || [];
    this.classes = classes || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */


  setAttribute(name, value) {
    this.attributes[name] = value;
  }
  /**
   * Gets an attribute on a MathML node.
   */


  getAttribute(name) {
    return this.attributes[name];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */


  toNode() {
    var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);

    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }

    if (this.classes.length > 0) {
      node.className = createClass(this.classes);
    }

    for (var i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }

    return node;
  }
  /**
   * Converts the math node into an HTML markup string.
   */


  toMarkup() {
    var markup = "<" + this.type; // Add the attributes

    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + "=\"";
        markup += utils.escape(this.attributes[attr]);
        markup += "\"";
      }
    }

    if (this.classes.length > 0) {
      markup += " class =\"" + utils.escape(createClass(this.classes)) + "\"";
    }

    markup += ">";

    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    markup += "</" + this.type + ">";
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */


  toText() {
    return this.children.map(child => child.toText()).join("");
  }

}
/**
 * This node represents a piece of text.
 */

class TextNode {
  constructor(text) {
    this.text = void 0;
    this.text = text;
  }
  /**
   * Converts the text node into a DOM text node.
   */


  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */


  toMarkup() {
    return utils.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text iteself).
   */


  toText() {
    return this.text;
  }

}
/**
 * This node represents a space, but may render as <mspace.../> or as text,
 * depending on the width.
 */

class SpaceNode {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(width) {
    this.width = void 0;
    this.character = void 0;
    this.width = width; // See https://www.w3.org/TR/2000/WD-MathML2-20000328/chapter6.html
    // for a table of space-like characters.  We use Unicode
    // representations instead of &LongNames; as it's not clear how to
    // make the latter via document.createTextNode.

    if (width >= 0.05555 && width <= 0.05556) {
      this.character = "\u200a"; // &VeryThinSpace;
    } else if (width >= 0.1666 && width <= 0.1667) {
      this.character = "\u2009"; // &ThinSpace;
    } else if (width >= 0.2222 && width <= 0.2223) {
      this.character = "\u2005"; // &MediumSpace;
    } else if (width >= 0.2777 && width <= 0.2778) {
      this.character = "\u2005\u200a"; // &ThickSpace;
    } else if (width >= -0.05556 && width <= -0.05555) {
      this.character = "\u200a\u2063"; // &NegativeVeryThinSpace;
    } else if (width >= -0.1667 && width <= -0.1666) {
      this.character = "\u2009\u2063"; // &NegativeThinSpace;
    } else if (width >= -0.2223 && width <= -0.2222) {
      this.character = "\u205f\u2063"; // &NegativeMediumSpace;
    } else if (width >= -0.2778 && width <= -0.2777) {
      this.character = "\u2005\u2063"; // &NegativeThickSpace;
    } else {
      this.character = null;
    }
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */


  toNode() {
    if (this.character) {
      return document.createTextNode(this.character);
    } else {
      var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
      node.setAttribute("width", makeEm(this.width));
      return node;
    }
  }
  /**
   * Converts the math node into an HTML markup string.
   */


  toMarkup() {
    if (this.character) {
      return "<mtext>" + this.character + "</mtext>";
    } else {
      return "<mspace width=\"" + makeEm(this.width) + "\"/>";
    }
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */


  toText() {
    if (this.character) {
      return this.character;
    } else {
      return " ";
    }
  }

}

var mathMLTree = {
  MathNode,
  TextNode,
  SpaceNode,
  newDocumentFragment
};

/**
 * This file converts a parse tree into a cooresponding MathML tree. The main
 * entry point is the `buildMathML` function, which takes a parse tree from the
 * parser.
 */

/**
 * Takes a symbol and converts it into a MathML text node after performing
 * optional replacement from symbols.js.
 */
var makeText = function makeText(text, mode, options) {
  if (symbols[mode][text] && symbols[mode][text].replace && text.charCodeAt(0) !== 0xD835 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
    text = symbols[mode][text].replace;
  }

  return new mathMLTree.TextNode(text);
};
/**
 * Wrap the given array of nodes in an <mrow> node if needed, i.e.,
 * unless the array has length 1.  Always returns a single node.
 */

var makeRow = function makeRow(body) {
  if (body.length === 1) {
    return body[0];
  } else {
    return new mathMLTree.MathNode("mrow", body);
  }
};
/**
 * Returns the math variant as a string or null if none is required.
 */

var getVariant = function getVariant(group, options) {
  // Handle \text... font specifiers as best we can.
  // MathML has a limited list of allowable mathvariant specifiers; see
  // https://www.w3.org/TR/MathML3/chapter3.html#presm.commatt
  if (options.fontFamily === "texttt") {
    return "monospace";
  } else if (options.fontFamily === "textsf") {
    if (options.fontShape === "textit" && options.fontWeight === "textbf") {
      return "sans-serif-bold-italic";
    } else if (options.fontShape === "textit") {
      return "sans-serif-italic";
    } else if (options.fontWeight === "textbf") {
      return "bold-sans-serif";
    } else {
      return "sans-serif";
    }
  } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
    return "bold-italic";
  } else if (options.fontShape === "textit") {
    return "italic";
  } else if (options.fontWeight === "textbf") {
    return "bold";
  }

  var font = options.font;

  if (!font || font === "mathnormal") {
    return null;
  }

  var mode = group.mode;

  if (font === "mathit") {
    return "italic";
  } else if (font === "boldsymbol") {
    return group.type === "textord" ? "bold" : "bold-italic";
  } else if (font === "mathbf") {
    return "bold";
  } else if (font === "mathbb") {
    return "double-struck";
  } else if (font === "mathfrak") {
    return "fraktur";
  } else if (font === "mathscr" || font === "mathcal") {
    // MathML makes no distinction between script and caligrahpic
    return "script";
  } else if (font === "mathsf") {
    return "sans-serif";
  } else if (font === "mathtt") {
    return "monospace";
  }

  var text = group.text;

  if (utils.contains(["\\imath", "\\jmath"], text)) {
    return null;
  }

  if (symbols[mode][text] && symbols[mode][text].replace) {
    text = symbols[mode][text].replace;
  }

  var fontName = buildCommon.fontMap[font].fontName;

  if (getCharacterMetrics(text, fontName, mode)) {
    return buildCommon.fontMap[font].variant;
  }

  return null;
};
/**
 * Takes a list of nodes, builds them, and returns a list of the generated
 * MathML nodes.  Also combine consecutive <mtext> outputs into a single
 * <mtext> tag.
 */

var buildExpression = function buildExpression(expression, options, isOrdgroup) {
  if (expression.length === 1) {
    var group = buildGroup(expression[0], options);

    if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
      // When TeX writers want to suppress spacing on an operator,
      // they often put the operator by itself inside braces.
      group.setAttribute("lspace", "0em");
      group.setAttribute("rspace", "0em");
    }

    return [group];
  }

  var groups = [];
  var lastGroup;

  for (var i = 0; i < expression.length; i++) {
    var _group = buildGroup(expression[i], options);

    if (_group instanceof MathNode && lastGroup instanceof MathNode) {
      // Concatenate adjacent <mtext>s
      if (_group.type === 'mtext' && lastGroup.type === 'mtext' && _group.getAttribute('mathvariant') === lastGroup.getAttribute('mathvariant')) {
        lastGroup.children.push(..._group.children);
        continue; // Concatenate adjacent <mn>s
      } else if (_group.type === 'mn' && lastGroup.type === 'mn') {
        lastGroup.children.push(..._group.children);
        continue; // Concatenate <mn>...</mn> followed by <mi>.</mi>
      } else if (_group.type === 'mi' && _group.children.length === 1 && lastGroup.type === 'mn') {
        var child = _group.children[0];

        if (child instanceof TextNode && child.text === '.') {
          lastGroup.children.push(..._group.children);
          continue;
        }
      } else if (lastGroup.type === 'mi' && lastGroup.children.length === 1) {
        var lastChild = lastGroup.children[0];

        if (lastChild instanceof TextNode && lastChild.text === '\u0338' && (_group.type === 'mo' || _group.type === 'mi' || _group.type === 'mn')) {
          var _child = _group.children[0];

          if (_child instanceof TextNode && _child.text.length > 0) {
            // Overlay with combining character long solidus
            _child.text = _child.text.slice(0, 1) + "\u0338" + _child.text.slice(1);
            groups.pop();
          }
        }
      }
    }

    groups.push(_group);
    lastGroup = _group;
  }

  return groups;
};
/**
 * Equivalent to buildExpression, but wraps the elements in an <mrow>
 * if there's more than one.  Returns a single node instead of an array.
 */

var buildExpressionRow = function buildExpressionRow(expression, options, isOrdgroup) {
  return makeRow(buildExpression(expression, options, isOrdgroup));
};
/**
 * Takes a group from the parser and calls the appropriate groupBuilders function
 * on it to produce a MathML node.
 */

var buildGroup = function buildGroup(group, options) {
  if (!group) {
    return new mathMLTree.MathNode("mrow");
  }

  if (_mathmlGroupBuilders[group.type]) {
    // Call the groupBuilders function
    // $FlowFixMe
    var result = _mathmlGroupBuilders[group.type](group, options); // $FlowFixMe

    return result;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
/**
 * Takes a full parse tree and settings and builds a MathML representation of
 * it. In particular, we put the elements from building the parse tree into a
 * <semantics> tag so we can also include that TeX source as an annotation.
 *
 * Note that we actually return a domTree element with a `<math>` inside it so
 * we can do appropriate styling.
 */

function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
  var expression = buildExpression(tree, options); // TODO: Make a pass thru the MathML similar to buildHTML.traverseNonSpaceNodes
  // and add spacing nodes. This is necessary only adjacent to math operators
  // like \sin or \lim or to subsup elements that contain math operators.
  // MathML takes care of the other spacing issues.
  // Wrap up the expression in an mrow so it is presented in the semantics
  // tag correctly, unless it's a single <mrow> or <mtable>.

  var wrapper;

  if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
    wrapper = expression[0];
  } else {
    wrapper = new mathMLTree.MathNode("mrow", expression);
  } // Build a TeX annotation of the source


  var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
  annotation.setAttribute("encoding", "application/x-tex");
  var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
  var math = new mathMLTree.MathNode("math", [semantics]);
  math.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");

  if (isDisplayMode) {
    math.setAttribute("display", "block");
  } // You can't style <math> nodes, so we wrap the node in a span.
  // NOTE: The span class is not typed to have <math> nodes as children, and
  // we don't want to make the children type more generic since the children
  // of span are expected to have more fields in `buildHtml` contexts.


  var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml"; // $FlowFixMe

  return buildCommon.makeSpan([wrapperClass], [math]);
}

var optionsFromSettings = function optionsFromSettings(settings) {
  return new Options({
    style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
    maxSize: settings.maxSize,
    minRuleThickness: settings.minRuleThickness
  });
};

var displayWrap = function displayWrap(node, settings) {
  if (settings.displayMode) {
    var classes = ["katex-display"];

    if (settings.leqno) {
      classes.push("leqno");
    }

    if (settings.fleqn) {
      classes.push("fleqn");
    }

    node = buildCommon.makeSpan(classes, [node]);
  }

  return node;
};

var buildTree = function buildTree(tree, expression, settings) {
  var options = optionsFromSettings(settings);
  var katexNode;

  if (settings.output === "mathml") {
    return buildMathML(tree, expression, options, settings.displayMode, true);
  } else if (settings.output === "html") {
    var htmlNode = buildHTML(tree, options);
    katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  } else {
    var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);

    var _htmlNode = buildHTML(tree, options);

    katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
  }

  return displayWrap(katexNode, settings);
};
var buildHTMLTree = function buildHTMLTree(tree, expression, settings) {
  var options = optionsFromSettings(settings);
  var htmlNode = buildHTML(tree, options);
  var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  return displayWrap(katexNode, settings);
};

/**
 * This file provides support to buildMathML.js and buildHTML.js
 * for stretchy wide elements rendered from SVG files
 * and other CSS trickery.
 */
var stretchyCodePoint = {
  widehat: "^",
  widecheck: "ˇ",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "\u2190",
  underleftarrow: "\u2190",
  xleftarrow: "\u2190",
  overrightarrow: "\u2192",
  underrightarrow: "\u2192",
  xrightarrow: "\u2192",
  underbrace: "\u23df",
  overbrace: "\u23de",
  overgroup: "\u23e0",
  undergroup: "\u23e1",
  overleftrightarrow: "\u2194",
  underleftrightarrow: "\u2194",
  xleftrightarrow: "\u2194",
  Overrightarrow: "\u21d2",
  xRightarrow: "\u21d2",
  overleftharpoon: "\u21bc",
  xleftharpoonup: "\u21bc",
  overrightharpoon: "\u21c0",
  xrightharpoonup: "\u21c0",
  xLeftarrow: "\u21d0",
  xLeftrightarrow: "\u21d4",
  xhookleftarrow: "\u21a9",
  xhookrightarrow: "\u21aa",
  xmapsto: "\u21a6",
  xrightharpoondown: "\u21c1",
  xleftharpoondown: "\u21bd",
  xrightleftharpoons: "\u21cc",
  xleftrightharpoons: "\u21cb",
  xtwoheadleftarrow: "\u219e",
  xtwoheadrightarrow: "\u21a0",
  xlongequal: "=",
  xtofrom: "\u21c4",
  xrightleftarrows: "\u21c4",
  xrightequilibrium: "\u21cc",
  // Not a perfect match.
  xleftequilibrium: "\u21cb",
  // None better available.
  "\\cdrightarrow": "\u2192",
  "\\cdleftarrow": "\u2190",
  "\\cdlongequal": "="
};

var mathMLnode = function mathMLnode(label) {
  var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, '')])]);
  node.setAttribute("stretchy", "true");
  return node;
}; // Many of the KaTeX SVG images have been adapted from glyphs in KaTeX fonts.
// Copyright (c) 2009-2010, Design Science, Inc. (<www.mathjax.org>)
// Copyright (c) 2014-2017 Khan Academy (<www.khanacademy.org>)
// Licensed under the SIL Open Font License, Version 1.1.
// See \nhttp://scripts.sil.org/OFL
// Very Long SVGs
//    Many of the KaTeX stretchy wide elements use a long SVG image and an
//    overflow: hidden tactic to achieve a stretchy image while avoiding
//    distortion of arrowheads or brace corners.
//    The SVG typically contains a very long (400 em) arrow.
//    The SVG is in a container span that has overflow: hidden, so the span
//    acts like a window that exposes only part of the  SVG.
//    The SVG always has a longer, thinner aspect ratio than the container span.
//    After the SVG fills 100% of the height of the container span,
//    there is a long arrow shaft left over. That left-over shaft is not shown.
//    Instead, it is sliced off because the span's CSS has overflow: hidden.
//    Thus, the reader sees an arrow that matches the subject matter width
//    without distortion.
//    Some functions, such as \cancel, need to vary their aspect ratio. These
//    functions do not get the overflow SVG treatment.
// Second Brush Stroke
//    Low resolution monitors struggle to display images in fine detail.
//    So browsers apply anti-aliasing. A long straight arrow shaft therefore
//    will sometimes appear as if it has a blurred edge.
//    To mitigate this, these SVG files contain a second "brush-stroke" on the
//    arrow shafts. That is, a second long thin rectangular SVG path has been
//    written directly on top of each arrow shaft. This reinforcement causes
//    some of the screen pixels to display as black instead of the anti-aliased
//    gray pixel that a  single path would generate. So we get arrow shafts
//    whose edges appear to be sharper.
// In the katexImagesData object just below, the dimensions all
// correspond to path geometry inside the relevant SVG.
// For example, \overrightarrow uses the same arrowhead as glyph U+2192
// from the KaTeX Main font. The scaling factor is 1000.
// That is, inside the font, that arrowhead is 522 units tall, which
// corresponds to 0.522 em inside the document.


var katexImagesData = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3.0, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3.0, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3.0, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
};

var groupLength = function groupLength(arg) {
  if (arg.type === "ordgroup") {
    return arg.body.length;
  } else {
    return 1;
  }
};

var svgSpan = function svgSpan(group, options) {
  // Create a span with inline SVG for the element.
  function buildSvgSpan_() {
    var viewBoxWidth = 400000; // default

    var label = group.label.slice(1);

    if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
      // Each type in the `if` statement corresponds to one of the ParseNode
      // types below. This narrowing is required to access `grp.base`.
      // $FlowFixMe
      var grp = group; // There are four SVG images available for each function.
      // Choose a taller image when there are more characters.

      var numChars = groupLength(grp.base);
      var viewBoxHeight;
      var pathName;

      var _height;

      if (numChars > 5) {
        if (label === "widehat" || label === "widecheck") {
          viewBoxHeight = 420;
          viewBoxWidth = 2364;
          _height = 0.42;
          pathName = label + "4";
        } else {
          viewBoxHeight = 312;
          viewBoxWidth = 2340;
          _height = 0.34;
          pathName = "tilde4";
        }
      } else {
        var imgIndex = [1, 1, 2, 2, 3, 3][numChars];

        if (label === "widehat" || label === "widecheck") {
          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
          _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
          pathName = label + imgIndex;
        } else {
          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
          _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
          pathName = "tilde" + imgIndex;
        }
      }

      var path = new PathNode(pathName);
      var svgNode = new SvgNode([path], {
        "width": "100%",
        "height": makeEm(_height),
        "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
        "preserveAspectRatio": "none"
      });
      return {
        span: buildCommon.makeSvgSpan([], [svgNode], options),
        minWidth: 0,
        height: _height
      };
    } else {
      var spans = [];
      var data = katexImagesData[label];
      var [paths, _minWidth, _viewBoxHeight] = data;

      var _height2 = _viewBoxHeight / 1000;

      var numSvgChildren = paths.length;
      var widthClasses;
      var aligns;

      if (numSvgChildren === 1) {
        // $FlowFixMe: All these cases must be of the 4-tuple type.
        var align1 = data[3];
        widthClasses = ["hide-tail"];
        aligns = [align1];
      } else if (numSvgChildren === 2) {
        widthClasses = ["halfarrow-left", "halfarrow-right"];
        aligns = ["xMinYMin", "xMaxYMin"];
      } else if (numSvgChildren === 3) {
        widthClasses = ["brace-left", "brace-center", "brace-right"];
        aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      } else {
        throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
      }

      for (var i = 0; i < numSvgChildren; i++) {
        var _path = new PathNode(paths[i]);

        var _svgNode = new SvgNode([_path], {
          "width": "400em",
          "height": makeEm(_height2),
          "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
          "preserveAspectRatio": aligns[i] + " slice"
        });

        var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options);

        if (numSvgChildren === 1) {
          return {
            span: _span,
            minWidth: _minWidth,
            height: _height2
          };
        } else {
          _span.style.height = makeEm(_height2);
          spans.push(_span);
        }
      }

      return {
        span: buildCommon.makeSpan(["stretchy"], spans, options),
        minWidth: _minWidth,
        height: _height2
      };
    }
  } // buildSvgSpan_()


  var {
    span,
    minWidth,
    height
  } = buildSvgSpan_(); // Note that we are returning span.depth = 0.
  // Any adjustments relative to the baseline must be done in buildHTML.

  span.height = height;
  span.style.height = makeEm(height);

  if (minWidth > 0) {
    span.style.minWidth = makeEm(minWidth);
  }

  return span;
};

var encloseSpan = function encloseSpan(inner, label, topPad, bottomPad, options) {
  // Return an image span for \cancel, \bcancel, \xcancel, \fbox, or \angl
  var img;
  var totalHeight = inner.height + inner.depth + topPad + bottomPad;

  if (/fbox|color|angl/.test(label)) {
    img = buildCommon.makeSpan(["stretchy", label], [], options);

    if (label === "fbox") {
      var color = options.color && options.getColor();

      if (color) {
        img.style.borderColor = color;
      }
    }
  } else {
    // \cancel, \bcancel, or \xcancel
    // Since \cancel's SVG is inline and it omits the viewBox attribute,
    // its stroke-width will not vary with span area.
    var lines = [];

    if (/^[bx]cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "0",
        "x2": "100%",
        "y2": "100%",
        "stroke-width": "0.046em"
      }));
    }

    if (/^x?cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "100%",
        "x2": "100%",
        "y2": "0",
        "stroke-width": "0.046em"
      }));
    }

    var svgNode = new SvgNode(lines, {
      "width": "100%",
      "height": makeEm(totalHeight)
    });
    img = buildCommon.makeSvgSpan([], [svgNode], options);
  }

  img.height = totalHeight;
  img.style.height = makeEm(totalHeight);
  return img;
};

var stretchy = {
  encloseSpan,
  mathMLnode,
  svgSpan
};

/**
 * Asserts that the node is of the given type and returns it with stricter
 * typing. Throws if the node's type does not match.
 */
function assertNodeType(node, type) {
  if (!node || node.type !== type) {
    throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
  } // $FlowFixMe, >=0.125


  return node;
}
/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */

function assertSymbolNodeType(node) {
  var typedNode = checkSymbolNodeType(node);

  if (!typedNode) {
    throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
  }

  return typedNode;
}
/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */

function checkSymbolNodeType(node) {
  if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
    // $FlowFixMe
    return node;
  }

  return null;
}

// NOTE: Unlike most `htmlBuilder`s, this one handles not only "accent", but
// also "supsub" since an accent can affect super/subscripting.
var htmlBuilder$a = (grp, options) => {
  // Accents are handled in the TeXbook pg. 443, rule 12.
  var base;
  var group;
  var supSubGroup;

  if (grp && grp.type === "supsub") {
    // If our base is a character box, and we have superscripts and
    // subscripts, the supsub will defer to us. In particular, we want
    // to attach the superscripts and subscripts to the inner body (so
    // that the position of the superscripts and subscripts won't be
    // affected by the height of the accent). We accomplish this by
    // sticking the base of the accent into the base of the supsub, and
    // rendering that, while keeping track of where the accent is.
    // The real accent group is the base of the supsub group
    group = assertNodeType(grp.base, "accent"); // The character box is the base of the accent group

    base = group.base; // Stick the character box into the base of the supsub group

    grp.base = base; // Rerender the supsub group with its new base, and store that
    // result.

    supSubGroup = assertSpan(buildGroup$1(grp, options)); // reset original base

    grp.base = group;
  } else {
    group = assertNodeType(grp, "accent");
    base = group.base;
  } // Build the base group


  var body = buildGroup$1(base, options.havingCrampedStyle()); // Does the accent need to shift for the skew of a character?

  var mustShift = group.isShifty && utils.isCharacterBox(base); // Calculate the skew of the accent. This is based on the line "If the
  // nucleus is not a single character, let s = 0; otherwise set s to the
  // kern amount for the nucleus followed by the \skewchar of its font."
  // Note that our skew metrics are just the kern between each character
  // and the skewchar.

  var skew = 0;

  if (mustShift) {
    // If the base is a character box, then we want the skew of the
    // innermost character. To do that, we find the innermost character:
    var baseChar = utils.getBaseElem(base); // Then, we render its group to get the symbol inside it

    var baseGroup = buildGroup$1(baseChar, options.havingCrampedStyle()); // Finally, we pull the skew off of the symbol.

    skew = assertSymbolDomNode(baseGroup).skew; // Note that we now throw away baseGroup, because the layers we
    // removed with getBaseElem might contain things like \color which
    // we can't get rid of.
    // TODO(emily): Find a better way to get the skew
  }

  var accentBelow = group.label === "\\c"; // calculate the amount of space between the body and the accent

  var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight); // Build the accent

  var accentBody;

  if (!group.isStretchy) {
    var accent;
    var width;

    if (group.label === "\\vec") {
      // Before version 0.9, \vec used the combining font glyph U+20D7.
      // But browsers, especially Safari, are not consistent in how they
      // render combining characters when not preceded by a character.
      // So now we use an SVG.
      // If Safari reforms, we should consider reverting to the glyph.
      accent = buildCommon.staticSvg("vec", options);
      width = buildCommon.svgData.vec[1];
    } else {
      accent = buildCommon.makeOrd({
        mode: group.mode,
        text: group.label
      }, options, "textord");
      accent = assertSymbolDomNode(accent); // Remove the italic correction of the accent, because it only serves to
      // shift the accent over to a place we don't want.

      accent.italic = 0;
      width = accent.width;

      if (accentBelow) {
        clearance += accent.depth;
      }
    }

    accentBody = buildCommon.makeSpan(["accent-body"], [accent]); // "Full" accents expand the width of the resulting symbol to be
    // at least the width of the accent, and overlap directly onto the
    // character without any vertical offset.

    var accentFull = group.label === "\\textcircled";

    if (accentFull) {
      accentBody.classes.push('accent-full');
      clearance = body.height;
    } // Shift the accent over by the skew.


    var left = skew; // CSS defines `.katex .accent .accent-body:not(.accent-full) { width: 0 }`
    // so that the accent doesn't contribute to the bounding box.
    // We need to shift the character by its width (effectively half
    // its width) to compensate.

    if (!accentFull) {
      left -= width / 2;
    }

    accentBody.style.left = makeEm(left); // \textcircled uses the \bigcirc glyph, so it needs some
    // vertical adjustment to match LaTeX.

    if (group.label === "\\textcircled") {
      accentBody.style.top = ".2em";
    }

    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: -clearance
      }, {
        type: "elem",
        elem: accentBody
      }]
    }, options);
  } else {
    accentBody = stretchy.svgSpan(group, options);
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"],
        wrapperStyle: skew > 0 ? {
          width: "calc(100% - " + makeEm(2 * skew) + ")",
          marginLeft: makeEm(2 * skew)
        } : undefined
      }]
    }, options);
  }

  var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);

  if (supSubGroup) {
    // Here, we replace the "base" child of the supsub with our newly
    // generated accent.
    supSubGroup.children[0] = accentWrap; // Since we don't rerun the height calculation after replacing the
    // accent, we manually recalculate height.

    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height); // Accents should always be ords, even when their innards are not.

    supSubGroup.classes[0] = "mord";
    return supSubGroup;
  } else {
    return accentWrap;
  }
};

var mathmlBuilder$9 = (group, options) => {
  var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
  var node = new mathMLTree.MathNode("mover", [buildGroup(group.base, options), accentNode]);
  node.setAttribute("accent", "true");
  return node;
};

var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(accent => "\\" + accent).join("|")); // Accents

defineFunction({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (context, args) => {
    var base = normalizeArgument(args[0]);
    var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
    var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: context.parser.mode,
      label: context.funcName,
      isStretchy: isStretchy,
      isShifty: isShifty,
      base: base
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
}); // Text-mode accents

defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    var base = args[0];
    var mode = context.parser.mode;

    if (mode === "math") {
      context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
      mode = "text";
    }

    return {
      type: "accent",
      mode: mode,
      label: context.funcName,
      isStretchy: false,
      isShifty: true,
      base: base
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});

// Horizontal overlap functions
defineFunction({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var base = args[0];
    return {
      type: "accentUnder",
      mode: parser.mode,
      label: funcName,
      base: base
    };
  },
  htmlBuilder: (group, options) => {
    // Treat under accents much like underlines.
    var innerGroup = buildGroup$1(group.base, options);
    var accentBody = stretchy.svgSpan(group, options);
    var kern = group.label === "\\utilde" ? 0.12 : 0; // Generate the vlist, with the appropriate kerns

    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: kern
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
  },
  mathmlBuilder: (group, options) => {
    var accentNode = stretchy.mathMLnode(group.label);
    var node = new mathMLTree.MathNode("munder", [buildGroup(group.base, options), accentNode]);
    node.setAttribute("accentunder", "true");
    return node;
  }
});

// Helper function
var paddedNode = group => {
  var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
  node.setAttribute("width", "+0.6em");
  node.setAttribute("lspace", "0.3em");
  return node;
}; // Stretchy arrows with an optional argument


defineFunction({
  type: "xArrow",
  names: ["\\xleftarrow", "\\xrightarrow", "\\xLeftarrow", "\\xRightarrow", "\\xleftrightarrow", "\\xLeftrightarrow", "\\xhookleftarrow", "\\xhookrightarrow", "\\xmapsto", "\\xrightharpoondown", "\\xrightharpoonup", "\\xleftharpoondown", "\\xleftharpoonup", "\\xrightleftharpoons", "\\xleftrightharpoons", "\\xlongequal", "\\xtwoheadrightarrow", "\\xtwoheadleftarrow", "\\xtofrom", // The next 3 functions are here to support the mhchem extension.
  // Direct use of these functions is discouraged and may break someday.
  "\\xrightleftarrows", "\\xrightequilibrium", "\\xleftequilibrium", // The next 3 functions are here only to support the {CD} environment.
  "\\\\cdrightarrow", "\\\\cdleftarrow", "\\\\cdlongequal"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },

  handler(_ref, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "xArrow",
      mode: parser.mode,
      label: funcName,
      body: args[0],
      below: optArgs[0]
    };
  },

  // Flow is unable to correctly infer the type of `group`, even though it's
  // unamibiguously determined from the passed-in `type` above.
  htmlBuilder(group, options) {
    var style = options.style; // Build the argument groups in the appropriate style.
    // Ref: amsmath.dtx:   \hbox{$\scriptstyle\mkern#3mu{#6}\mkern#4mu$}%
    // Some groups can return document fragments.  Handle those by wrapping
    // them in a span.

    var newOptions = options.havingStyle(style.sup());
    var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options), options);
    var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
    upperGroup.classes.push(arrowPrefix + "-arrow-pad");
    var lowerGroup;

    if (group.below) {
      // Build the lower group
      newOptions = options.havingStyle(style.sub());
      lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options), options);
      lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
    }

    var arrowBody = stretchy.svgSpan(group, options); // Re shift: Note that stretchy.svgSpan returned arrowBody.depth = 0.
    // The point we want on the math axis is at 0.5 * arrowBody.height.

    var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height; // 2 mu kern. Ref: amsmath.dtx: #7\if0#2\else\mkern#2mu\fi

    var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111; // 0.111 em = 2 mu

    if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
      upperShift -= upperGroup.depth; // shift up if depth encroaches
    } // Generate the vlist


    var vlist;

    if (lowerGroup) {
      var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }, {
          type: "elem",
          elem: lowerGroup,
          shift: lowerShift
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }]
      }, options);
    } // $FlowFixMe: Replace this with passing "svg-align" into makeVList.


    vlist.children[0].children[0].children[1].classes.push("svg-align");
    return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
  },

  mathmlBuilder(group, options) {
    var arrowNode = stretchy.mathMLnode(group.label);
    arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var node;

    if (group.body) {
      var upperNode = paddedNode(buildGroup(group.body, options));

      if (group.below) {
        var lowerNode = paddedNode(buildGroup(group.below, options));
        node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
      } else {
        node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
      }
    } else if (group.below) {
      var _lowerNode = paddedNode(buildGroup(group.below, options));

      node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
    } else {
      // This should never happen.
      // Parser.js throws an error if there is no argument.
      node = paddedNode();
      node = new mathMLTree.MathNode("mover", [arrowNode, node]);
    }

    return node;
  }

});

var makeSpan = buildCommon.makeSpan;

function htmlBuilder$9(group, options) {
  var elements = buildExpression$1(group.body, options, true);
  return makeSpan([group.mclass], elements, options);
}

function mathmlBuilder$8(group, options) {
  var node;
  var inner = buildExpression(group.body, options);

  if (group.mclass === "minner") {
    node = new mathMLTree.MathNode("mpadded", inner);
  } else if (group.mclass === "mord") {
    if (group.isCharacterBox) {
      node = inner[0];
      node.type = "mi";
    } else {
      node = new mathMLTree.MathNode("mi", inner);
    }
  } else {
    if (group.isCharacterBox) {
      node = inner[0];
      node.type = "mo";
    } else {
      node = new mathMLTree.MathNode("mo", inner);
    } // Set spacing based on what is the most likely adjacent atom type.
    // See TeXbook p170.


    if (group.mclass === "mbin") {
      node.attributes.lspace = "0.22em"; // medium space

      node.attributes.rspace = "0.22em";
    } else if (group.mclass === "mpunct") {
      node.attributes.lspace = "0em";
      node.attributes.rspace = "0.17em"; // thinspace
    } else if (group.mclass === "mopen" || group.mclass === "mclose") {
      node.attributes.lspace = "0em";
      node.attributes.rspace = "0em";
    } else if (group.mclass === "minner") {
      node.attributes.lspace = "0.0556em"; // 1 mu is the most likely option

      node.attributes.width = "+0.1111em";
    } // MathML <mo> default space is 5/18 em, so <mrel> needs no action.
    // Ref: https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo

  }

  return node;
} // Math class commands except \mathop


defineFunction({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: true
  },

  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: "m" + funcName.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: ordargument(body),
      isCharacterBox: utils.isCharacterBox(body)
    };
  },

  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
var binrelClass = arg => {
  // \binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.
  // (by rendering separately and with {}s before and after, and measuring
  // the change in spacing).  We'll do roughly the same by detecting the
  // atom type directly.
  var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;

  if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
    return "m" + atom.family;
  } else {
    return "mord";
  }
}; // \@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.
// This is equivalent to \binrel@{x}\binrel@@{y} in AMSTeX.

defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },

  handler(_ref2, args) {
    var {
      parser
    } = _ref2;
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[1]),
      isCharacterBox: utils.isCharacterBox(args[1])
    };
  }

}); // Build a relation or stacked op by placing one symbol on top of another

defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },

  handler(_ref3, args) {
    var {
      parser,
      funcName
    } = _ref3;
    var baseArg = args[1];
    var shiftedArg = args[0];
    var mclass;

    if (funcName !== "\\stackrel") {
      // LaTeX applies \binrel spacing to \overset and \underset.
      mclass = binrelClass(baseArg);
    } else {
      mclass = "mrel"; // for \stackrel
    }

    var baseOp = {
      type: "op",
      mode: baseArg.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      suppressBaseShift: funcName !== "\\stackrel",
      body: ordargument(baseArg)
    };
    var supsub = {
      type: "supsub",
      mode: shiftedArg.mode,
      base: baseOp,
      sup: funcName === "\\underset" ? null : shiftedArg,
      sub: funcName === "\\underset" ? shiftedArg : null
    };
    return {
      type: "mclass",
      mode: parser.mode,
      mclass,
      body: [supsub],
      isCharacterBox: utils.isCharacterBox(supsub)
    };
  },

  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});

// \pmb is a simulation of bold font.
// The version of \pmb in ambsy.sty works by typesetting three copies
// with small offsets. We use CSS text-shadow.
// It's a hack. Not as good as a real bold font. Better than nothing.
defineFunction({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: true
  },

  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "pmb",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[0])
    };
  },

  htmlBuilder(group, options) {
    var elements = buildExpression$1(group.body, options, true);
    var node = buildCommon.makeSpan([group.mclass], elements, options);
    node.style.textShadow = "0.02em 0.01em 0.04px";
    return node;
  },

  mathmlBuilder(group, style) {
    var inner = buildExpression(group.body, style); // Wrap with an <mstyle> element.

    var node = new mathMLTree.MathNode("mstyle", inner);
    node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
    return node;
  }

});

var cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  "A": "\\uparrow",
  "V": "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
};

var newCell = () => {
  // Create an empty cell, to be filled below with parse nodes.
  // The parseTree from this module must be constructed like the
  // one created by parseArray(), so an empty CD cell must
  // be a ParseNode<"styling">. And CD is always displaystyle.
  // So these values are fixed and flow can do implicit typing.
  return {
    type: "styling",
    body: [],
    mode: "math",
    style: "display"
  };
};

var isStartOfArrow = node => {
  return node.type === "textord" && node.text === "@";
};

var isLabelEnd = (node, endChar) => {
  return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
};

function cdArrow(arrowChar, labels, parser) {
  // Return a parse tree of an arrow and its labels.
  // This acts in a way similar to a macro expansion.
  var funcName = cdArrowFunctionName[arrowChar];

  switch (funcName) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return parser.callFunction(funcName, [labels[0]], [labels[1]]);

    case "\\uparrow":
    case "\\downarrow":
      {
        var leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
        var bareArrow = {
          type: "atom",
          text: funcName,
          mode: "math",
          family: "rel"
        };
        var sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
        var rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
        var arrowGroup = {
          type: "ordgroup",
          mode: "math",
          body: [leftLabel, sizedArrow, rightLabel]
        };
        return parser.callFunction("\\\\cdparent", [arrowGroup], []);
      }

    case "\\\\cdlongequal":
      return parser.callFunction("\\\\cdlongequal", [], []);

    case "\\Vert":
      {
        var arrow = {
          type: "textord",
          text: "\\Vert",
          mode: "math"
        };
        return parser.callFunction("\\Big", [arrow], []);
      }

    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}

function parseCD(parser) {
  // Get the array's parse nodes with \\ temporarily mapped to \cr.
  var parsedRows = [];
  parser.gullet.beginGroup();
  parser.gullet.macros.set("\\cr", "\\\\\\relax");
  parser.gullet.beginGroup();

  while (true) {
    // eslint-disable-line no-constant-condition
    // Get the parse nodes for the next row.
    parsedRows.push(parser.parseExpression(false, "\\\\"));
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    var next = parser.fetch().text;

    if (next === "&" || next === "\\\\") {
      parser.consume();
    } else if (next === "\\end") {
      if (parsedRows[parsedRows.length - 1].length === 0) {
        parsedRows.pop(); // final row ended in \\
      }

      break;
    } else {
      throw new ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
    }
  }

  var row = [];
  var body = [row]; // Loop thru the parse nodes. Collect them into cells and arrows.

  for (var i = 0; i < parsedRows.length; i++) {
    // Start a new row.
    var rowNodes = parsedRows[i]; // Create the first cell.

    var cell = newCell();

    for (var j = 0; j < rowNodes.length; j++) {
      if (!isStartOfArrow(rowNodes[j])) {
        // If a parseNode is not an arrow, it goes into a cell.
        cell.body.push(rowNodes[j]);
      } else {
        // Parse node j is an "@", the start of an arrow.
        // Before starting on the arrow, push the cell into `row`.
        row.push(cell); // Now collect parseNodes into an arrow.
        // The character after "@" defines the arrow type.

        j += 1;
        var arrowChar = assertSymbolNodeType(rowNodes[j]).text; // Create two empty label nodes. We may or may not use them.

        var labels = new Array(2);
        labels[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        labels[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }; // Process the arrow.

        if ("=|.".indexOf(arrowChar) > -1) ; else if ("<>AV".indexOf(arrowChar) > -1) {
          // Four arrows, `@>>>`, `@<<<`, `@AAA`, and `@VVV`, each take
          // two optional labels. E.g. the right-point arrow syntax is
          // really:  @>{optional label}>{optional label}>
          // Collect parseNodes into labels.
          for (var labelNum = 0; labelNum < 2; labelNum++) {
            var inLabel = true;

            for (var k = j + 1; k < rowNodes.length; k++) {
              if (isLabelEnd(rowNodes[k], arrowChar)) {
                inLabel = false;
                j = k;
                break;
              }

              if (isStartOfArrow(rowNodes[k])) {
                throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
              }

              labels[labelNum].body.push(rowNodes[k]);
            }

            if (inLabel) {
              // isLabelEnd never returned a true.
              throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
            }
          }
        } else {
          throw new ParseError("Expected one of \"<>AV=|.\" after @", rowNodes[j]);
        } // Now join the arrow to its labels.


        var arrow = cdArrow(arrowChar, labels, parser); // Wrap the arrow in  ParseNode<"styling">.
        // This is done to match parseArray() behavior.

        var wrappedArrow = {
          type: "styling",
          body: [arrow],
          mode: "math",
          style: "display" // CD is always displaystyle.

        };
        row.push(wrappedArrow); // In CD's syntax, cells are implicit. That is, everything that
        // is not an arrow gets collected into a cell. So create an empty
        // cell now. It will collect upcoming parseNodes.

        cell = newCell();
      }
    }

    if (i % 2 === 0) {
      // Even-numbered rows consist of: cell, arrow, cell, arrow, ... cell
      // The last cell is not yet pushed into `row`, so:
      row.push(cell);
    } else {
      // Odd-numbered rows consist of: vert arrow, empty cell, ... vert arrow
      // Remove the empty cell that was placed at the beginning of `row`.
      row.shift();
    }

    row = [];
    body.push(row);
  } // End row group


  parser.gullet.endGroup(); // End array group defining \\

  parser.gullet.endGroup(); // define column separation.

  var cols = new Array(body[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25 // So pre and post each get half an \enskip, i.e. 0.25em.

  });
  return {
    type: "array",
    mode: "math",
    body,
    arraystretch: 1,
    addJot: true,
    rowGaps: [null],
    cols,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(body.length + 1).fill([])
  };
} // The functions below are not available for general use.
// They are here only for internal use by the {CD} environment in placing labels
// next to vertical arrows.
// We don't need any such functions for horizontal arrows because we can reuse
// the functionality that already exists for extensible arrows.

defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },

  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "cdlabel",
      mode: parser.mode,
      side: funcName.slice(4),
      label: args[0]
    };
  },

  htmlBuilder(group, options) {
    var newOptions = options.havingStyle(options.style.sup());
    var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options), options);
    label.classes.push("cd-label-" + group.side);
    label.style.bottom = makeEm(0.8 - label.depth); // Zero out label height & depth, so vertical align of arrow is set
    // by the arrow height, not by the label.

    label.height = 0;
    label.depth = 0;
    return label;
  },

  mathmlBuilder(group, options) {
    var label = new mathMLTree.MathNode("mrow", [buildGroup(group.label, options)]);
    label = new mathMLTree.MathNode("mpadded", [label]);
    label.setAttribute("width", "0");

    if (group.side === "left") {
      label.setAttribute("lspace", "-1width");
    } // We have to guess at vertical alignment. We know the arrow is 1.8em tall,
    // But we don't know the height or depth of the label.


    label.setAttribute("voffset", "0.7em");
    label = new mathMLTree.MathNode("mstyle", [label]);
    label.setAttribute("displaystyle", "false");
    label.setAttribute("scriptlevel", "1");
    return label;
  }

});
defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },

  handler(_ref2, args) {
    var {
      parser
    } = _ref2;
    return {
      type: "cdlabelparent",
      mode: parser.mode,
      fragment: args[0]
    };
  },

  htmlBuilder(group, options) {
    // Wrap the vertical arrow and its labels.
    // The parent gets position: relative. The child gets position: absolute.
    // So CSS can locate the label correctly.
    var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options), options);
    parent.classes.push("cd-vert-arrow");
    return parent;
  },

  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mrow", [buildGroup(group.fragment, options)]);
  }

});

// {123} and converts into symbol with code 123.  It is used by the *macro*
// \char defined in macros.js.

defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },

  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var arg = assertNodeType(args[0], "ordgroup");
    var group = arg.body;
    var number = "";

    for (var i = 0; i < group.length; i++) {
      var node = assertNodeType(group[i], "textord");
      number += node.text;
    }

    var code = parseInt(number);
    var text;

    if (isNaN(code)) {
      throw new ParseError("\\@char has non-numeric argument " + number); // If we drop IE support, the following code could be replaced with
      // text = String.fromCodePoint(code)
    } else if (code < 0 || code >= 0x10ffff) {
      throw new ParseError("\\@char with invalid code point " + number);
    } else if (code <= 0xffff) {
      text = String.fromCharCode(code);
    } else {
      // Astral code point; split into surrogate halves
      code -= 0x10000;
      text = String.fromCharCode((code >> 10) + 0xd800, (code & 0x3ff) + 0xdc00);
    }

    return {
      type: "textord",
      mode: parser.mode,
      text: text
    };
  }

});

var htmlBuilder$8 = (group, options) => {
  var elements = buildExpression$1(group.body, options.withColor(group.color), false); // \color isn't supposed to affect the type of the elements it contains.
  // To accomplish this, we wrap the results in a fragment, so the inner
  // elements will be able to directly interact with their neighbors. For
  // example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`

  return buildCommon.makeFragment(elements);
};

var mathmlBuilder$7 = (group, options) => {
  var inner = buildExpression(group.body, options.withColor(group.color));
  var node = new mathMLTree.MathNode("mstyle", inner);
  node.setAttribute("mathcolor", group.color);
  return node;
};

defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "original"]
  },

  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var color = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "color",
      mode: parser.mode,
      color,
      body: ordargument(body)
    };
  },

  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: true,
    argTypes: ["color"]
  },

  handler(_ref2, args) {
    var {
      parser,
      breakOnTokenText
    } = _ref2;
    var color = assertNodeType(args[0], "color-token").color; // Set macro \current@color in current namespace to store the current
    // color, mimicking the behavior of color.sty.
    // This is currently used just to correctly color a \right
    // that follows a \color command.

    parser.gullet.macros.set("\\current@color", color); // Parse out the implicit body that should be colored.

    var body = parser.parseExpression(true, breakOnTokenText);
    return {
      type: "color",
      mode: parser.mode,
      color,
      body
    };
  },

  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});

// Row breaks within tabular environments, and line breaks at top level

defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 1,
    argTypes: ["size"],
    allowedInText: true
  },

  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var size = optArgs[0];
    var newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline " + "does nothing in display mode");
    return {
      type: "cr",
      mode: parser.mode,
      newLine,
      size: size && assertNodeType(size, "size").value
    };
  },

  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(group, options) {
    var span = buildCommon.makeSpan(["mspace"], [], options);

    if (group.newLine) {
      span.classes.push("newline");

      if (group.size) {
        span.style.marginTop = makeEm(calculateSize(group.size, options));
      }
    }

    return span;
  },

  mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mspace");

    if (group.newLine) {
      node.setAttribute("linebreak", "newline");

      if (group.size) {
        node.setAttribute("height", makeEm(calculateSize(group.size, options)));
      }
    }

    return node;
  }

});

var globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
};

var checkControlSequence = tok => {
  var name = tok.text;

  if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
    throw new ParseError("Expected a control sequence", tok);
  }

  return name;
};

var getRHS = parser => {
  var tok = parser.gullet.popToken();

  if (tok.text === "=") {
    // consume optional equals
    tok = parser.gullet.popToken();

    if (tok.text === " ") {
      // consume one optional space
      tok = parser.gullet.popToken();
    }
  }

  return tok;
};

var letCommand = (parser, name, tok, global) => {
  var macro = parser.gullet.macros.get(tok.text);

  if (macro == null) {
    // don't expand it later even if a macro with the same name is defined
    // e.g., \let\foo=\frac \def\frac{\relax} \frac12
    tok.noexpand = true;
    macro = {
      tokens: [tok],
      numArgs: 0,
      // reproduce the same behavior in expansion
      unexpandable: !parser.gullet.isExpandable(tok.text)
    };
  }

  parser.gullet.macros.set(name, macro, global);
}; // <assignment> -> <non-macro assignment>|<macro assignment>
// <non-macro assignment> -> <simple assignment>|\global<non-macro assignment>
// <macro assignment> -> <definition>|<prefix><macro assignment>
// <prefix> -> \global|\long|\outer


defineFunction({
  type: "internal",
  names: ["\\global", "\\long", "\\\\globallong" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },

  handler(_ref) {
    var {
      parser,
      funcName
    } = _ref;
    parser.consumeSpaces();
    var token = parser.fetch();

    if (globalMap[token.text]) {
      // KaTeX doesn't have \par, so ignore \long
      if (funcName === "\\global" || funcName === "\\\\globallong") {
        token.text = globalMap[token.text];
      }

      return assertNodeType(parser.parseFunction(), "internal");
    }

    throw new ParseError("Invalid token after macro prefix", token);
  }

}); // Basic support for macro definitions: \def, \gdef, \edef, \xdef
// <definition> -> <def><control sequence><definition text>
// <def> -> \def|\gdef|\edef|\xdef
// <definition text> -> <parameter text><left brace><balanced text><right brace>

defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },

  handler(_ref2) {
    var {
      parser,
      funcName
    } = _ref2;
    var tok = parser.gullet.popToken();
    var name = tok.text;

    if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
      throw new ParseError("Expected a control sequence", tok);
    }

    var numArgs = 0;
    var insert;
    var delimiters = [[]]; // <parameter text> contains no braces

    while (parser.gullet.future().text !== "{") {
      tok = parser.gullet.popToken();

      if (tok.text === "#") {
        // If the very last character of the <parameter text> is #, so that
        // this # is immediately followed by {, TeX will behave as if the {
        // had been inserted at the right end of both the parameter text
        // and the replacement text.
        if (parser.gullet.future().text === "{") {
          insert = parser.gullet.future();
          delimiters[numArgs].push("{");
          break;
        } // A parameter, the first appearance of # must be followed by 1,
        // the next by 2, and so on; up to nine #’s are allowed


        tok = parser.gullet.popToken();

        if (!/^[1-9]$/.test(tok.text)) {
          throw new ParseError("Invalid argument number \"" + tok.text + "\"");
        }

        if (parseInt(tok.text) !== numArgs + 1) {
          throw new ParseError("Argument number \"" + tok.text + "\" out of order");
        }

        numArgs++;
        delimiters.push([]);
      } else if (tok.text === "EOF") {
        throw new ParseError("Expected a macro definition");
      } else {
        delimiters[numArgs].push(tok.text);
      }
    } // replacement text, enclosed in '{' and '}' and properly nested


    var {
      tokens
    } = parser.gullet.consumeArg();

    if (insert) {
      tokens.unshift(insert);
    }

    if (funcName === "\\edef" || funcName === "\\xdef") {
      tokens = parser.gullet.expandTokens(tokens);
      tokens.reverse(); // to fit in with stack order
    } // Final arg is the expansion of the macro


    parser.gullet.macros.set(name, {
      tokens,
      numArgs,
      delimiters
    }, funcName === globalMap[funcName]);
    return {
      type: "internal",
      mode: parser.mode
    };
  }

}); // <simple assignment> -> <let assignment>
// <let assignment> -> \futurelet<control sequence><token><token>
//     | \let<control sequence><equals><one optional space><token>
// <equals> -> <optional spaces>|<optional spaces>=

defineFunction({
  type: "internal",
  names: ["\\let", "\\\\globallet" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },

  handler(_ref3) {
    var {
      parser,
      funcName
    } = _ref3;
    var name = checkControlSequence(parser.gullet.popToken());
    parser.gullet.consumeSpaces();
    var tok = getRHS(parser);
    letCommand(parser, name, tok, funcName === "\\\\globallet");
    return {
      type: "internal",
      mode: parser.mode
    };
  }

}); // ref: https://www.tug.org/TUGboat/tb09-3/tb22bechtolsheim.pdf

defineFunction({
  type: "internal",
  names: ["\\futurelet", "\\\\globalfuture" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },

  handler(_ref4) {
    var {
      parser,
      funcName
    } = _ref4;
    var name = checkControlSequence(parser.gullet.popToken());
    var middle = parser.gullet.popToken();
    var tok = parser.gullet.popToken();
    letCommand(parser, name, tok, funcName === "\\\\globalfuture");
    parser.gullet.pushToken(tok);
    parser.gullet.pushToken(middle);
    return {
      type: "internal",
      mode: parser.mode
    };
  }

});

/**
 * This file deals with creating delimiters of various sizes. The TeXbook
 * discusses these routines on page 441-442, in the "Another subroutine sets box
 * x to a specified variable delimiter" paragraph.
 *
 * There are three main routines here. `makeSmallDelim` makes a delimiter in the
 * normal font, but in either text, script, or scriptscript style.
 * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,
 * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of
 * smaller pieces that are stacked on top of one another.
 *
 * The functions take a parameter `center`, which determines if the delimiter
 * should be centered around the axis.
 *
 * Then, there are three exposed functions. `sizedDelim` makes a delimiter in
 * one of the given sizes. This is used for things like `\bigl`.
 * `customSizedDelim` makes a delimiter with a given total height+depth. It is
 * called in places like `\sqrt`. `leftRightDelim` makes an appropriate
 * delimiter which surrounds an expression of a given height an depth. It is
 * used in `\left` and `\right`.
 */

/**
 * Get the metrics for a given symbol and font, after transformation (i.e.
 * after following replacement from symbols.js)
 */
var getMetrics = function getMetrics(symbol, font, mode) {
  var replace = symbols.math[symbol] && symbols.math[symbol].replace;
  var metrics = getCharacterMetrics(replace || symbol, font, mode);

  if (!metrics) {
    throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
  }

  return metrics;
};
/**
 * Puts a delimiter span in a given style, and adds appropriate height, depth,
 * and maxFontSizes.
 */


var styleWrap = function styleWrap(delim, toStyle, options, classes) {
  var newOptions = options.havingBaseStyle(toStyle);
  var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
  var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
  span.height *= delimSizeMultiplier;
  span.depth *= delimSizeMultiplier;
  span.maxFontSize = newOptions.sizeMultiplier;
  return span;
};

var centerSpan = function centerSpan(span, options, style) {
  var newOptions = options.havingBaseStyle(style);
  var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
  span.classes.push("delimcenter");
  span.style.top = makeEm(shift);
  span.height -= shift;
  span.depth += shift;
};
/**
 * Makes a small delimiter. This is a delimiter that comes in the Main-Regular
 * font, but is restyled to either be in textstyle, scriptstyle, or
 * scriptscriptstyle.
 */


var makeSmallDelim = function makeSmallDelim(delim, style, center, options, mode, classes) {
  var text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
  var span = styleWrap(text, style, options, classes);

  if (center) {
    centerSpan(span, options, style);
  }

  return span;
};
/**
 * Builds a symbol in the given font size (note size is an integer)
 */


var mathrmSize = function mathrmSize(value, size, mode, options) {
  return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
};
/**
 * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,
 * Size3, or Size4 fonts. It is always rendered in textstyle.
 */


var makeLargeDelim = function makeLargeDelim(delim, size, center, options, mode, classes) {
  var inner = mathrmSize(delim, size, mode, options);
  var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner], options), Style$1.TEXT, options, classes);

  if (center) {
    centerSpan(span, options, Style$1.TEXT);
  }

  return span;
};
/**
 * Make a span from a font glyph with the given offset and in the given font.
 * This is used in makeStackedDelim to make the stacking pieces for the delimiter.
 */


var makeGlyphSpan = function makeGlyphSpan(symbol, font, mode) {
  var sizeClass; // Apply the correct CSS class to choose the right font.

  if (font === "Size1-Regular") {
    sizeClass = "delim-size1";
  } else
    /* if (font === "Size4-Regular") */
    {
      sizeClass = "delim-size4";
    }

  var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]); // Since this will be passed into `makeVList` in the end, wrap the element
  // in the appropriate tag that VList uses.

  return {
    type: "elem",
    elem: corner
  };
};

var makeInner = function makeInner(ch, height, options) {
  // Create a span with inline SVG for the inner part of a tall stacked delimiter.
  var width = fontMetricsData['Size4-Regular'][ch.charCodeAt(0)] ? fontMetricsData['Size4-Regular'][ch.charCodeAt(0)][4] : fontMetricsData['Size1-Regular'][ch.charCodeAt(0)][4];
  var path = new PathNode("inner", innerPath(ch, Math.round(1000 * height)));
  var svgNode = new SvgNode([path], {
    "width": makeEm(width),
    "height": makeEm(height),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1000 * width + " " + Math.round(1000 * height),
    "preserveAspectRatio": "xMinYMin"
  });
  var span = buildCommon.makeSvgSpan([], [svgNode], options);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return {
    type: "elem",
    elem: span
  };
}; // Helpers for makeStackedDelim


var lapInEms = 0.008;
var lap = {
  type: "kern",
  size: -1 * lapInEms
};
var verts = ["|", "\\lvert", "\\rvert", "\\vert"];
var doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
/**
 * Make a stacked delimiter out of a given delimiter, with the total height at
 * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.
 */

var makeStackedDelim = function makeStackedDelim(delim, heightTotal, center, options, mode, classes) {
  // There are four parts, the top, an optional middle, a repeated part, and a
  // bottom.
  var top;
  var middle;
  var repeat;
  var bottom;
  var svgLabel = "";
  var viewBoxWidth = 0;
  top = repeat = bottom = delim;
  middle = null; // Also keep track of what font the delimiters are in

  var font = "Size1-Regular"; // We set the parts and font based on the symbol. Note that we use
  // '\u23d0' instead of '|' and '\u2016' instead of '\\|' for the
  // repeats of the arrows

  if (delim === "\\uparrow") {
    repeat = bottom = "\u23d0";
  } else if (delim === "\\Uparrow") {
    repeat = bottom = "\u2016";
  } else if (delim === "\\downarrow") {
    top = repeat = "\u23d0";
  } else if (delim === "\\Downarrow") {
    top = repeat = "\u2016";
  } else if (delim === "\\updownarrow") {
    top = "\\uparrow";
    repeat = "\u23d0";
    bottom = "\\downarrow";
  } else if (delim === "\\Updownarrow") {
    top = "\\Uparrow";
    repeat = "\u2016";
    bottom = "\\Downarrow";
  } else if (utils.contains(verts, delim)) {
    repeat = "\u2223";
    svgLabel = "vert";
    viewBoxWidth = 333;
  } else if (utils.contains(doubleVerts, delim)) {
    repeat = "\u2225";
    svgLabel = "doublevert";
    viewBoxWidth = 556;
  } else if (delim === "[" || delim === "\\lbrack") {
    top = "\u23a1";
    repeat = "\u23a2";
    bottom = "\u23a3";
    font = "Size4-Regular";
    svgLabel = "lbrack";
    viewBoxWidth = 667;
  } else if (delim === "]" || delim === "\\rbrack") {
    top = "\u23a4";
    repeat = "\u23a5";
    bottom = "\u23a6";
    font = "Size4-Regular";
    svgLabel = "rbrack";
    viewBoxWidth = 667;
  } else if (delim === "\\lfloor" || delim === "\u230a") {
    repeat = top = "\u23a2";
    bottom = "\u23a3";
    font = "Size4-Regular";
    svgLabel = "lfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\lceil" || delim === "\u2308") {
    top = "\u23a1";
    repeat = bottom = "\u23a2";
    font = "Size4-Regular";
    svgLabel = "lceil";
    viewBoxWidth = 667;
  } else if (delim === "\\rfloor" || delim === "\u230b") {
    repeat = top = "\u23a5";
    bottom = "\u23a6";
    font = "Size4-Regular";
    svgLabel = "rfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\rceil" || delim === "\u2309") {
    top = "\u23a4";
    repeat = bottom = "\u23a5";
    font = "Size4-Regular";
    svgLabel = "rceil";
    viewBoxWidth = 667;
  } else if (delim === "(" || delim === "\\lparen") {
    top = "\u239b";
    repeat = "\u239c";
    bottom = "\u239d";
    font = "Size4-Regular";
    svgLabel = "lparen";
    viewBoxWidth = 875;
  } else if (delim === ")" || delim === "\\rparen") {
    top = "\u239e";
    repeat = "\u239f";
    bottom = "\u23a0";
    font = "Size4-Regular";
    svgLabel = "rparen";
    viewBoxWidth = 875;
  } else if (delim === "\\{" || delim === "\\lbrace") {
    top = "\u23a7";
    middle = "\u23a8";
    bottom = "\u23a9";
    repeat = "\u23aa";
    font = "Size4-Regular";
  } else if (delim === "\\}" || delim === "\\rbrace") {
    top = "\u23ab";
    middle = "\u23ac";
    bottom = "\u23ad";
    repeat = "\u23aa";
    font = "Size4-Regular";
  } else if (delim === "\\lgroup" || delim === "\u27ee") {
    top = "\u23a7";
    bottom = "\u23a9";
    repeat = "\u23aa";
    font = "Size4-Regular";
  } else if (delim === "\\rgroup" || delim === "\u27ef") {
    top = "\u23ab";
    bottom = "\u23ad";
    repeat = "\u23aa";
    font = "Size4-Regular";
  } else if (delim === "\\lmoustache" || delim === "\u23b0") {
    top = "\u23a7";
    bottom = "\u23ad";
    repeat = "\u23aa";
    font = "Size4-Regular";
  } else if (delim === "\\rmoustache" || delim === "\u23b1") {
    top = "\u23ab";
    bottom = "\u23a9";
    repeat = "\u23aa";
    font = "Size4-Regular";
  } // Get the metrics of the four sections


  var topMetrics = getMetrics(top, font, mode);
  var topHeightTotal = topMetrics.height + topMetrics.depth;
  var repeatMetrics = getMetrics(repeat, font, mode);
  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
  var bottomMetrics = getMetrics(bottom, font, mode);
  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
  var middleHeightTotal = 0;
  var middleFactor = 1;

  if (middle !== null) {
    var middleMetrics = getMetrics(middle, font, mode);
    middleHeightTotal = middleMetrics.height + middleMetrics.depth;
    middleFactor = 2; // repeat symmetrically above and below middle
  } // Calcuate the minimal height that the delimiter can have.
  // It is at least the size of the top, bottom, and optional middle combined.


  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal; // Compute the number of copies of the repeat symbol we will need

  var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal))); // Compute the total height of the delimiter including all the symbols

  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal; // The center of the delimiter is placed at the center of the axis. Note
  // that in this context, "center" means that the delimiter should be
  // centered around the axis in the current style, while normally it is
  // centered around the axis in textstyle.

  var axisHeight = options.fontMetrics().axisHeight;

  if (center) {
    axisHeight *= options.sizeMultiplier;
  } // Calculate the depth


  var depth = realHeightTotal / 2 - axisHeight; // Now, we start building the pieces that will go into the vlist
  // Keep a list of the pieces of the stacked delimiter

  var stack = [];

  if (svgLabel.length > 0) {
    // Instead of stacking glyphs, create a single SVG.
    // This evades browser problems with imprecise positioning of spans.
    var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
    var viewBoxHeight = Math.round(realHeightTotal * 1000);
    var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1000));
    var path = new PathNode(svgLabel, pathStr);
    var width = (viewBoxWidth / 1000).toFixed(3) + "em";
    var height = (viewBoxHeight / 1000).toFixed(3) + "em";
    var svg = new SvgNode([path], {
      "width": width,
      "height": height,
      "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
    });
    var wrapper = buildCommon.makeSvgSpan([], [svg], options);
    wrapper.height = viewBoxHeight / 1000;
    wrapper.style.width = width;
    wrapper.style.height = height;
    stack.push({
      type: "elem",
      elem: wrapper
    });
  } else {
    // Stack glyphs
    // Start by adding the bottom symbol
    stack.push(makeGlyphSpan(bottom, font, mode));
    stack.push(lap); // overlap

    if (middle === null) {
      // The middle section will be an SVG. Make it an extra 0.016em tall.
      // We'll overlap by 0.008em at top and bottom.
      var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
      stack.push(makeInner(repeat, innerHeight, options));
    } else {
      // When there is a middle bit, we need the middle part and two repeated
      // sections
      var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;

      stack.push(makeInner(repeat, _innerHeight, options)); // Now insert the middle of the brace.

      stack.push(lap);
      stack.push(makeGlyphSpan(middle, font, mode));
      stack.push(lap);
      stack.push(makeInner(repeat, _innerHeight, options));
    } // Add the top symbol


    stack.push(lap);
    stack.push(makeGlyphSpan(top, font, mode));
  } // Finally, build the vlist


  var newOptions = options.havingBaseStyle(Style$1.TEXT);
  var inner = buildCommon.makeVList({
    positionType: "bottom",
    positionData: depth,
    children: stack
  }, newOptions);
  return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner], newOptions), Style$1.TEXT, options, classes);
}; // All surds have 0.08em padding above the viniculum inside the SVG.
// That keeps browser span height rounding error from pinching the line.


var vbPad = 80; // padding above the surd, measured inside the viewBox.

var emPad = 0.08; // padding, in ems, measured in the document.

var sqrtSvg = function sqrtSvg(sqrtName, height, viewBoxHeight, extraViniculum, options) {
  var path = sqrtPath(sqrtName, extraViniculum, viewBoxHeight);
  var pathNode = new PathNode(sqrtName, path);
  var svg = new SvgNode([pathNode], {
    // Note: 1000:1 ratio of viewBox to document em width.
    "width": "400em",
    "height": makeEm(height),
    "viewBox": "0 0 400000 " + viewBoxHeight,
    "preserveAspectRatio": "xMinYMin slice"
  });
  return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
};
/**
 * Make a sqrt image of the given height,
 */


var makeSqrtImage = function makeSqrtImage(height, options) {
  // Define a newOptions that removes the effect of size changes such as \Huge.
  // We don't pick different a height surd for \Huge. For it, we scale up.
  var newOptions = options.havingBaseSizing(); // Pick the desired surd glyph from a sequence of surds.

  var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
  var sizeMultiplier = newOptions.sizeMultiplier; // default
  // The standard sqrt SVGs each have a 0.04em thick viniculum.
  // If Settings.minRuleThickness is larger than that, we add extraViniculum.

  var extraViniculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness); // Create a span containing an SVG image of a sqrt symbol.

  var span;
  var spanHeight = 0;
  var texHeight = 0;
  var viewBoxHeight = 0;
  var advanceWidth; // We create viewBoxes with 80 units of "padding" above each surd.
  // Then browser rounding error on the parent span height will not
  // encroach on the ink of the viniculum. But that padding is not
  // included in the TeX-like `height` used for calculation of
  // vertical alignment. So texHeight = span.height < span.style.height.

  if (delim.type === "small") {
    // Get an SVG that is derived from glyph U+221A in font KaTeX-Main.
    // 1000 unit normal glyph height.
    viewBoxHeight = 1000 + 1000 * extraViniculum + vbPad;

    if (height < 1.0) {
      sizeMultiplier = 1.0; // mimic a \textfont radical
    } else if (height < 1.4) {
      sizeMultiplier = 0.7; // mimic a \scriptfont radical
    }

    spanHeight = (1.0 + extraViniculum + emPad) / sizeMultiplier;
    texHeight = (1.00 + extraViniculum) / sizeMultiplier;
    span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraViniculum, options);
    span.style.minWidth = "0.853em";
    advanceWidth = 0.833 / sizeMultiplier; // from the font.
  } else if (delim.type === "large") {
    // These SVGs come from fonts: KaTeX_Size1, _Size2, etc.
    viewBoxHeight = (1000 + vbPad) * sizeToMaxHeight[delim.size];
    texHeight = (sizeToMaxHeight[delim.size] + extraViniculum) / sizeMultiplier;
    spanHeight = (sizeToMaxHeight[delim.size] + extraViniculum + emPad) / sizeMultiplier;
    span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraViniculum, options);
    span.style.minWidth = "1.02em";
    advanceWidth = 1.0 / sizeMultiplier; // 1.0 from the font.
  } else {
    // Tall sqrt. In TeX, this would be stacked using multiple glyphs.
    // We'll use a single SVG to accomplish the same thing.
    spanHeight = height + extraViniculum + emPad;
    texHeight = height + extraViniculum;
    viewBoxHeight = Math.floor(1000 * height + extraViniculum) + vbPad;
    span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraViniculum, options);
    span.style.minWidth = "0.742em";
    advanceWidth = 1.056;
  }

  span.height = texHeight;
  span.style.height = makeEm(spanHeight);
  return {
    span,
    advanceWidth,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraViniculum) * sizeMultiplier
  };
}; // There are three kinds of delimiters, delimiters that stack when they become
// too large


var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230a", "\u230b", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"]; // delimiters that always stack

var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27ee", "\u27ef", "\\lmoustache", "\\rmoustache", "\u23b0", "\u23b1"]; // and delimiters that never stack

var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"]; // Metrics of the different sizes. Found by looking at TeX's output of
// $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.

var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];
/**
 * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.
 */

var makeSizedDelim = function makeSizedDelim(delim, size, options, mode, classes) {
  // < and > turn into \langle and \rangle in delimiters
  if (delim === "<" || delim === "\\lt" || delim === "\u27e8") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "\u27e9") {
    delim = "\\rangle";
  } // Sized delimiters are never centered.


  if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
    return makeLargeDelim(delim, size, false, options, mode, classes);
  } else if (utils.contains(stackAlwaysDelimiters, delim)) {
    return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
  } else {
    throw new ParseError("Illegal delimiter: '" + delim + "'");
  }
};
/**
 * There are three different sequences of delimiter sizes that the delimiters
 * follow depending on the kind of delimiter. This is used when creating custom
 * sized delimiters to decide whether to create a small, large, or stacked
 * delimiter.
 *
 * In real TeX, these sequences aren't explicitly defined, but are instead
 * defined inside the font metrics. Since there are only three sequences that
 * are possible for the delimiters that TeX defines, it is easier to just encode
 * them explicitly here.
 */


// Delimiters that never stack try small delimiters and large delimiters only
var stackNeverDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}]; // Delimiters that always stack try the small delimiters first, then stack

var stackAlwaysDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "stack"
}]; // Delimiters that stack when large try the small and then large delimiters, and
// stack afterwards

var stackLargeDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}];
/**
 * Get the font used in a delimiter based on what kind of delimiter it is.
 * TODO(#963) Use more specific font family return type once that is introduced.
 */

var delimTypeToFont = function delimTypeToFont(type) {
  if (type.type === "small") {
    return "Main-Regular";
  } else if (type.type === "large") {
    return "Size" + type.size + "-Regular";
  } else if (type.type === "stack") {
    return "Size4-Regular";
  } else {
    throw new Error("Add support for delim type '" + type.type + "' here.");
  }
};
/**
 * Traverse a sequence of types of delimiters to decide what kind of delimiter
 * should be used to create a delimiter of the given height+depth.
 */


var traverseSequence = function traverseSequence(delim, height, sequence, options) {
  // Here, we choose the index we should start at in the sequences. In smaller
  // sizes (which correspond to larger numbers in style.size) we start earlier
  // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts
  // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2
  var start = Math.min(2, 3 - options.style.size);

  for (var i = start; i < sequence.length; i++) {
    if (sequence[i].type === "stack") {
      // This is always the last delimiter, so we just break the loop now.
      break;
    }

    var metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
    var heightDepth = metrics.height + metrics.depth; // Small delimiters are scaled down versions of the same font, so we
    // account for the style change size.

    if (sequence[i].type === "small") {
      var newOptions = options.havingBaseStyle(sequence[i].style);
      heightDepth *= newOptions.sizeMultiplier;
    } // Check if the delimiter at this size works for the given height.


    if (heightDepth > height) {
      return sequence[i];
    }
  } // If we reached the end of the sequence, return the last sequence element.


  return sequence[sequence.length - 1];
};
/**
 * Make a delimiter of a given height+depth, with optional centering. Here, we
 * traverse the sequences, and create a delimiter that the sequence tells us to.
 */


var makeCustomSizedDelim = function makeCustomSizedDelim(delim, height, center, options, mode, classes) {
  if (delim === "<" || delim === "\\lt" || delim === "\u27e8") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "\u27e9") {
    delim = "\\rangle";
  } // Decide what sequence to use


  var sequence;

  if (utils.contains(stackNeverDelimiters, delim)) {
    sequence = stackNeverDelimiterSequence;
  } else if (utils.contains(stackLargeDelimiters, delim)) {
    sequence = stackLargeDelimiterSequence;
  } else {
    sequence = stackAlwaysDelimiterSequence;
  } // Look through the sequence


  var delimType = traverseSequence(delim, height, sequence, options); // Get the delimiter from font glyphs.
  // Depending on the sequence element we decided on, call the
  // appropriate function.

  if (delimType.type === "small") {
    return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
  } else if (delimType.type === "large") {
    return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
  } else
    /* if (delimType.type === "stack") */
    {
      return makeStackedDelim(delim, height, center, options, mode, classes);
    }
};
/**
 * Make a delimiter for use with `\left` and `\right`, given a height and depth
 * of an expression that the delimiters surround.
 */


var makeLeftRightDelim = function makeLeftRightDelim(delim, height, depth, options, mode, classes) {
  // We always center \left/\right delimiters, so the axis is always shifted
  var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier; // Taken from TeX source, tex.web, function make_left_right

  var delimiterFactor = 901;
  var delimiterExtend = 5.0 / options.fontMetrics().ptPerEm;
  var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
  var totalHeight = Math.max( // In real TeX, calculations are done using integral values which are
  // 65536 per pt, or 655360 per em. So, the division here truncates in
  // TeX but doesn't here, producing different results. If we wanted to
  // exactly match TeX's calculation, we could do
  //   Math.floor(655360 * maxDistFromAxis / 500) *
  //    delimiterFactor / 655360
  // (To see the difference, compare
  //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
  // in TeX and KaTeX)
  maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend); // Finally, we defer to `makeCustomSizedDelim` with our calculated total
  // height

  return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
};

var delimiter = {
  sqrtImage: makeSqrtImage,
  sizedDelim: makeSizedDelim,
  sizeToMaxHeight: sizeToMaxHeight,
  customSizedDelim: makeCustomSizedDelim,
  leftRightDelim: makeLeftRightDelim
};

// Extra data needed for the delimiter handler down below
var delimiterSizes = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
};
var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230a", "\u230b", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27e8", "\\rangle", "\u27e9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27ee", "\u27ef", "\\lmoustache", "\\rmoustache", "\u23b0", "\u23b1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];

// Delimiter functions
function checkDelimiter(delim, context) {
  var symDelim = checkSymbolNodeType(delim);

  if (symDelim && utils.contains(delimiters, symDelim.text)) {
    return symDelim;
  } else if (symDelim) {
    throw new ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
  } else {
    throw new ParseError("Invalid delimiter type '" + delim.type + "'", delim);
  }
}

defineFunction({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    return {
      type: "delimsizing",
      mode: context.parser.mode,
      size: delimiterSizes[context.funcName].size,
      mclass: delimiterSizes[context.funcName].mclass,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options) => {
    if (group.delim === ".") {
      // Empty delimiters still count as elements, even though they don't
      // show anything.
      return buildCommon.makeSpan([group.mclass]);
    } // Use delimiter.sizedDelim to generate the delimiter.


    return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
  },
  mathmlBuilder: group => {
    var children = [];

    if (group.delim !== ".") {
      children.push(makeText(group.delim, group.mode));
    }

    var node = new mathMLTree.MathNode("mo", children);

    if (group.mclass === "mopen" || group.mclass === "mclose") {
      // Only some of the delimsizing functions act as fences, and they
      // return "mopen" or "mclose" mclass.
      node.setAttribute("fence", "true");
    } else {
      // Explicitly disable fencing if it's not a fence, to override the
      // defaults.
      node.setAttribute("fence", "false");
    }

    node.setAttribute("stretchy", "true");
    var size = makeEm(delimiter.sizeToMaxHeight[group.size]);
    node.setAttribute("minsize", size);
    node.setAttribute("maxsize", size);
    return node;
  }
});

function assertParsed(group) {
  if (!group.body) {
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
  }
}

defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    // \left case below triggers parsing of \right in
    //   `const right = parser.parseFunction();`
    // uses this return value.
    var color = context.parser.gullet.macros.get("\\current@color");

    if (color && typeof color !== "string") {
      throw new ParseError("\\current@color set to non-string in \\right");
    }

    return {
      type: "leftright-right",
      mode: context.parser.mode,
      delim: checkDelimiter(args[0], context).text,
      color // undefined if not set via \color

    };
  }
});
defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    var parser = context.parser; // Parse out the implicit body

    ++parser.leftrightDepth; // parseExpression stops before '\\right'

    var body = parser.parseExpression(false);
    --parser.leftrightDepth; // Check the next token

    parser.expect("\\right", false);
    var right = assertNodeType(parser.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: parser.mode,
      body,
      left: delim.text,
      right: right.delim,
      rightColor: right.color
    };
  },
  htmlBuilder: (group, options) => {
    assertParsed(group); // Build the inner expression

    var inner = buildExpression$1(group.body, options, true, ["mopen", "mclose"]);
    var innerHeight = 0;
    var innerDepth = 0;
    var hadMiddle = false; // Calculate its height and depth

    for (var i = 0; i < inner.length; i++) {
      // Property `isMiddle` not defined on `span`. See comment in
      // "middle"'s htmlBuilder.
      // $FlowFixMe
      if (inner[i].isMiddle) {
        hadMiddle = true;
      } else {
        innerHeight = Math.max(inner[i].height, innerHeight);
        innerDepth = Math.max(inner[i].depth, innerDepth);
      }
    } // The size of delimiters is the same, regardless of what style we are
    // in. Thus, to correctly calculate the size of delimiter we need around
    // a group, we scale down the inner size based on the size.


    innerHeight *= options.sizeMultiplier;
    innerDepth *= options.sizeMultiplier;
    var leftDelim;

    if (group.left === ".") {
      // Empty delimiters in \left and \right make null delimiter spaces.
      leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
      // Otherwise, use leftRightDelim to generate the correct sized
      // delimiter.
      leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
    } // Add it to the beginning of the expression


    inner.unshift(leftDelim); // Handle middle delimiters

    if (hadMiddle) {
      for (var _i = 1; _i < inner.length; _i++) {
        var middleDelim = inner[_i]; // Property `isMiddle` not defined on `span`. See comment in
        // "middle"'s htmlBuilder.
        // $FlowFixMe

        var isMiddle = middleDelim.isMiddle;

        if (isMiddle) {
          // Apply the options that were active when \middle was called
          inner[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
        }
      }
    }

    var rightDelim; // Same for the right delimiter, but using color specified by \color

    if (group.right === ".") {
      rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
      var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
      rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
    } // Add it to the end of the expression.


    inner.push(rightDelim);
    return buildCommon.makeSpan(["minner"], inner, options);
  },
  mathmlBuilder: (group, options) => {
    assertParsed(group);
    var inner = buildExpression(group.body, options);

    if (group.left !== ".") {
      var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
      leftNode.setAttribute("fence", "true");
      inner.unshift(leftNode);
    }

    if (group.right !== ".") {
      var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
      rightNode.setAttribute("fence", "true");

      if (group.rightColor) {
        rightNode.setAttribute("mathcolor", group.rightColor);
      }

      inner.push(rightNode);
    }

    return makeRow(inner);
  }
});
defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);

    if (!context.parser.leftrightDepth) {
      throw new ParseError("\\middle without preceding \\left", delim);
    }

    return {
      type: "middle",
      mode: context.parser.mode,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options) => {
    var middleDelim;

    if (group.delim === ".") {
      middleDelim = makeNullDelimiter(options, []);
    } else {
      middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
      var isMiddle = {
        delim: group.delim,
        options
      }; // Property `isMiddle` not defined on `span`. It is only used in
      // this file above.
      // TODO: Fix this violation of the `span` type and possibly rename
      // things since `isMiddle` sounds like a boolean, but is a struct.
      // $FlowFixMe

      middleDelim.isMiddle = isMiddle;
    }

    return middleDelim;
  },
  mathmlBuilder: (group, options) => {
    // A Firefox \middle will strech a character vertically only if it
    // is in the fence part of the operator dictionary at:
    // https://www.w3.org/TR/MathML3/appendixc.html.
    // So we need to avoid U+2223 and use plain "|" instead.
    var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
    var middleNode = new mathMLTree.MathNode("mo", [textNode]);
    middleNode.setAttribute("fence", "true"); // MathML gives 5/18em spacing to each <mo> element.
    // \middle should get delimiter spacing instead.

    middleNode.setAttribute("lspace", "0.05em");
    middleNode.setAttribute("rspace", "0.05em");
    return middleNode;
  }
});

var htmlBuilder$7 = (group, options) => {
  // \cancel, \bcancel, \xcancel, \sout, \fbox, \colorbox, \fcolorbox, \phase
  // Some groups can return document fragments.  Handle those by wrapping
  // them in a span.
  var inner = buildCommon.wrapFragment(buildGroup$1(group.body, options), options);
  var label = group.label.slice(1);
  var scale = options.sizeMultiplier;
  var img;
  var imgShift = 0; // In the LaTeX cancel package, line geometry is slightly different
  // depending on whether the subject is wider than it is tall, or vice versa.
  // We don't know the width of a group, so as a proxy, we test if
  // the subject is a single character. This captures most of the
  // subjects that should get the "tall" treatment.

  var isSingleChar = utils.isCharacterBox(group.body);

  if (label === "sout") {
    img = buildCommon.makeSpan(["stretchy", "sout"]);
    img.height = options.fontMetrics().defaultRuleThickness / scale;
    imgShift = -0.5 * options.fontMetrics().xHeight;
  } else if (label === "phase") {
    // Set a couple of dimensions from the steinmetz package.
    var lineWeight = calculateSize({
      number: 0.6,
      unit: "pt"
    }, options);
    var clearance = calculateSize({
      number: 0.35,
      unit: "ex"
    }, options); // Prevent size changes like \Huge from affecting line thickness

    var newOptions = options.havingBaseSizing();
    scale = scale / newOptions.sizeMultiplier;
    var angleHeight = inner.height + inner.depth + lineWeight + clearance; // Reserve a left pad for the angle.

    inner.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight); // Create an SVG

    var viewBoxHeight = Math.floor(1000 * angleHeight * scale);
    var path = phasePath(viewBoxHeight);
    var svgNode = new SvgNode([new PathNode("phase", path)], {
      "width": "400em",
      "height": makeEm(viewBoxHeight / 1000),
      "viewBox": "0 0 400000 " + viewBoxHeight,
      "preserveAspectRatio": "xMinYMin slice"
    }); // Wrap it in a span with overflow: hidden.

    img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
    img.style.height = makeEm(angleHeight);
    imgShift = inner.depth + lineWeight + clearance;
  } else {
    // Add horizontal padding
    if (/cancel/.test(label)) {
      if (!isSingleChar) {
        inner.classes.push("cancel-pad");
      }
    } else if (label === "angl") {
      inner.classes.push("anglpad");
    } else {
      inner.classes.push("boxpad");
    } // Add vertical padding


    var topPad = 0;
    var bottomPad = 0;
    var ruleThickness = 0; // ref: cancel package: \advance\totalheight2\p@ % "+2"

    if (/box/.test(label)) {
      ruleThickness = Math.max(options.fontMetrics().fboxrule, // default
      options.minRuleThickness // User override.
      );
      topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
      bottomPad = topPad;
    } else if (label === "angl") {
      ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
      topPad = 4 * ruleThickness; // gap = 3 × line, plus the line itself.

      bottomPad = Math.max(0, 0.25 - inner.depth);
    } else {
      topPad = isSingleChar ? 0.2 : 0;
      bottomPad = topPad;
    }

    img = stretchy.encloseSpan(inner, label, topPad, bottomPad, options);

    if (/fbox|boxed|fcolorbox/.test(label)) {
      img.style.borderStyle = "solid";
      img.style.borderWidth = makeEm(ruleThickness);
    } else if (label === "angl" && ruleThickness !== 0.049) {
      img.style.borderTopWidth = makeEm(ruleThickness);
      img.style.borderRightWidth = makeEm(ruleThickness);
    }

    imgShift = inner.depth + bottomPad;

    if (group.backgroundColor) {
      img.style.backgroundColor = group.backgroundColor;

      if (group.borderColor) {
        img.style.borderColor = group.borderColor;
      }
    }
  }

  var vlist;

  if (group.backgroundColor) {
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [// Put the color background behind inner;
      {
        type: "elem",
        elem: img,
        shift: imgShift
      }, {
        type: "elem",
        elem: inner,
        shift: 0
      }]
    }, options);
  } else {
    var classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [// Write the \cancel stroke on top of inner.
      {
        type: "elem",
        elem: inner,
        shift: 0
      }, {
        type: "elem",
        elem: img,
        shift: imgShift,
        wrapperClasses: classes
      }]
    }, options);
  }

  if (/cancel/.test(label)) {
    // The cancel package documentation says that cancel lines add their height
    // to the expression, but tests show that isn't how it actually works.
    vlist.height = inner.height;
    vlist.depth = inner.depth;
  }

  if (/cancel/.test(label) && !isSingleChar) {
    // cancel does not create horiz space for its line extension.
    return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
  } else {
    return buildCommon.makeSpan(["mord"], [vlist], options);
  }
};

var mathmlBuilder$6 = (group, options) => {
  var fboxsep = 0;
  var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup(group.body, options)]);

  switch (group.label) {
    case "\\cancel":
      node.setAttribute("notation", "updiagonalstrike");
      break;

    case "\\bcancel":
      node.setAttribute("notation", "downdiagonalstrike");
      break;

    case "\\phase":
      node.setAttribute("notation", "phasorangle");
      break;

    case "\\sout":
      node.setAttribute("notation", "horizontalstrike");
      break;

    case "\\fbox":
      node.setAttribute("notation", "box");
      break;

    case "\\angl":
      node.setAttribute("notation", "actuarial");
      break;

    case "\\fcolorbox":
    case "\\colorbox":
      // <menclose> doesn't have a good notation option. So use <mpadded>
      // instead. Set some attributes that come included with <menclose>.
      fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
      node.setAttribute("width", "+" + 2 * fboxsep + "pt");
      node.setAttribute("height", "+" + 2 * fboxsep + "pt");
      node.setAttribute("lspace", fboxsep + "pt"); //

      node.setAttribute("voffset", fboxsep + "pt");

      if (group.label === "\\fcolorbox") {
        var thk = Math.max(options.fontMetrics().fboxrule, // default
        options.minRuleThickness // user override
        );
        node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
      }

      break;

    case "\\xcancel":
      node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }

  if (group.backgroundColor) {
    node.setAttribute("mathbackground", group.backgroundColor);
  }

  return node;
};

defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "text"]
  },

  handler(_ref, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref;
    var color = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor: color,
      body
    };
  },

  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: true,
    argTypes: ["color", "color", "text"]
  },

  handler(_ref2, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref2;
    var borderColor = assertNodeType(args[0], "color-token").color;
    var backgroundColor = assertNodeType(args[1], "color-token").color;
    var body = args[2];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor,
      borderColor,
      body
    };
  },

  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },

  handler(_ref3, args) {
    var {
      parser
    } = _ref3;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\fbox",
      body: args[0]
    };
  }

});
defineFunction({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },

  handler(_ref4, args) {
    var {
      parser,
      funcName
    } = _ref4;
    var body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },

  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: false
  },

  handler(_ref5, args) {
    var {
      parser
    } = _ref5;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\angl",
      body: args[0]
    };
  }

});

/**
 * All registered environments.
 * `environments.js` exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary via `environments.js`.
 */
var _environments = {};
function defineEnvironment(_ref) {
  var {
    type,
    names,
    props,
    handler,
    htmlBuilder,
    mathmlBuilder
  } = _ref;
  // Set default values of environments.
  var data = {
    type,
    numArgs: props.numArgs || 0,
    allowedInText: false,
    numOptionalArgs: 0,
    handler
  };

  for (var i = 0; i < names.length; ++i) {
    // TODO: The value type of _environments should be a type union of all
    // possible `EnvSpec<>` possibilities instead of `EnvSpec<*>`, which is
    // an existential type.
    _environments[names[i]] = data;
  }

  if (htmlBuilder) {
    _htmlGroupBuilders[type] = htmlBuilder;
  }

  if (mathmlBuilder) {
    _mathmlGroupBuilders[type] = mathmlBuilder;
  }
}

/**
 * All registered global/built-in macros.
 * `macros.js` exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary via `macros.js`.
 */
var _macros = {}; // This function might one day accept an additional argument and do more things.

function defineMacro(name, body) {
  _macros[name] = body;
}

// Helper functions
function getHLines(parser) {
  // Return an array. The array length = number of hlines.
  // Each element in the array tells if the line is dashed.
  var hlineInfo = [];
  parser.consumeSpaces();
  var nxt = parser.fetch().text;

  if (nxt === "\\relax") {
    // \relax is an artifact of the \cr macro below
    parser.consume();
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }

  while (nxt === "\\hline" || nxt === "\\hdashline") {
    parser.consume();
    hlineInfo.push(nxt === "\\hdashline");
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }

  return hlineInfo;
}

var validateAmsEnvironmentContext = context => {
  var settings = context.parser.settings;

  if (!settings.displayMode) {
    throw new ParseError("{" + context.envName + "} can be used only in" + " display mode.");
  }
}; // autoTag (an argument to parseArray) can be one of three values:
// * undefined: Regular (not-top-level) array; no tags on each row
// * true: Automatic equation numbering, overridable by \tag
// * false: Tags allowed on each row, but no automatic numbering
// This function *doesn't* work with the "split" environment name.


function getAutoTag(name) {
  if (name.indexOf("ed") === -1) {
    return name.indexOf("*") === -1;
  } // return undefined;

}
/**
 * Parse the body of the environment, with rows delimited by \\ and
 * columns delimited by &, and create a nested list in row-major order
 * with one group per cell.  If given an optional argument style
 * ("text", "display", etc.), then each cell is cast into that style.
 */


function parseArray(parser, _ref, style) {
  var {
    hskipBeforeAndAfter,
    addJot,
    cols,
    arraystretch,
    colSeparationType,
    autoTag,
    singleRow,
    emptySingleRow,
    maxNumCols,
    leqno
  } = _ref;
  parser.gullet.beginGroup();

  if (!singleRow) {
    // \cr is equivalent to \\ without the optional size argument (see below)
    // TODO: provide helpful error when \cr is used outside array environment
    parser.gullet.macros.set("\\cr", "\\\\\\relax");
  } // Get current arraystretch if it's not set by the environment


  if (!arraystretch) {
    var stretch = parser.gullet.expandMacroAsText("\\arraystretch");

    if (stretch == null) {
      // Default \arraystretch from lttab.dtx
      arraystretch = 1;
    } else {
      arraystretch = parseFloat(stretch);

      if (!arraystretch || arraystretch < 0) {
        throw new ParseError("Invalid \\arraystretch: " + stretch);
      }
    }
  } // Start group for first cell


  parser.gullet.beginGroup();
  var row = [];
  var body = [row];
  var rowGaps = [];
  var hLinesBeforeRow = [];
  var tags = autoTag != null ? [] : undefined; // amsmath uses \global\@eqnswtrue and \global\@eqnswfalse to represent
  // whether this row should have an equation number.  Simulate this with
  // a \@eqnsw macro set to 1 or 0.

  function beginRow() {
    if (autoTag) {
      parser.gullet.macros.set("\\@eqnsw", "1", true);
    }
  }

  function endRow() {
    if (tags) {
      if (parser.gullet.macros.get("\\df@tag")) {
        tags.push(parser.subparse([new Token("\\df@tag")]));
        parser.gullet.macros.set("\\df@tag", undefined, true);
      } else {
        tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
      }
    }
  }

  beginRow(); // Test for \hline at the top of the array.

  hLinesBeforeRow.push(getHLines(parser));

  while (true) {
    // eslint-disable-line no-constant-condition
    // Parse each cell in its own group (namespace)
    var cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    cell = {
      type: "ordgroup",
      mode: parser.mode,
      body: cell
    };

    if (style) {
      cell = {
        type: "styling",
        mode: parser.mode,
        style,
        body: [cell]
      };
    }

    row.push(cell);
    var next = parser.fetch().text;

    if (next === "&") {
      if (maxNumCols && row.length === maxNumCols) {
        if (singleRow || colSeparationType) {
          // {equation} or {split}
          throw new ParseError("Too many tab characters: &", parser.nextToken);
        } else {
          // {array} environment
          parser.settings.reportNonstrict("textEnv", "Too few columns " + "specified in the {array} column argument.");
        }
      }

      parser.consume();
    } else if (next === "\\end") {
      endRow(); // Arrays terminate newlines with `\crcr` which consumes a `\cr` if
      // the last line is empty.  However, AMS environments keep the
      // empty row if it's the only one.
      // NOTE: Currently, `cell` is the last item added into `row`.

      if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
        body.pop();
      }

      if (hLinesBeforeRow.length < body.length + 1) {
        hLinesBeforeRow.push([]);
      }

      break;
    } else if (next === "\\\\") {
      parser.consume();
      var size = void 0; // \def\Let@{\let\\\math@cr}
      // \def\math@cr{...\math@cr@}
      // \def\math@cr@{\new@ifnextchar[\math@cr@@{\math@cr@@[\z@]}}
      // \def\math@cr@@[#1]{...\math@cr@@@...}
      // \def\math@cr@@@{\cr}

      if (parser.gullet.future().text !== " ") {
        size = parser.parseSizeGroup(true);
      }

      rowGaps.push(size ? size.value : null);
      endRow(); // check for \hline(s) following the row separator

      hLinesBeforeRow.push(getHLines(parser));
      row = [];
      body.push(row);
      beginRow();
    } else {
      throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
    }
  } // End cell group


  parser.gullet.endGroup(); // End array group defining \cr

  parser.gullet.endGroup();
  return {
    type: "array",
    mode: parser.mode,
    addJot,
    arraystretch,
    body,
    cols,
    rowGaps,
    hskipBeforeAndAfter,
    hLinesBeforeRow,
    colSeparationType,
    tags,
    leqno
  };
} // Decides on a style for cells in an array according to whether the given
// environment name starts with the letter 'd'.


function dCellStyle(envName) {
  if (envName.slice(0, 1) === "d") {
    return "display";
  } else {
    return "text";
  }
}

var htmlBuilder$6 = function htmlBuilder(group, options) {
  var r;
  var c;
  var nr = group.body.length;
  var hLinesBeforeRow = group.hLinesBeforeRow;
  var nc = 0;
  var body = new Array(nr);
  var hlines = [];
  var ruleThickness = Math.max( // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
  options.fontMetrics().arrayRuleWidth, options.minRuleThickness // User override.
  ); // Horizontal spacing

  var pt = 1 / options.fontMetrics().ptPerEm;
  var arraycolsep = 5 * pt; // default value, i.e. \arraycolsep in article.cls

  if (group.colSeparationType && group.colSeparationType === "small") {
    // We're in a {smallmatrix}. Default column space is \thickspace,
    // i.e. 5/18em = 0.2778em, per amsmath.dtx for {smallmatrix}.
    // But that needs adjustment because LaTeX applies \scriptstyle to the
    // entire array, including the colspace, but this function applies
    // \scriptstyle only inside each element.
    var localMultiplier = options.havingStyle(Style$1.SCRIPT).sizeMultiplier;
    arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
  } // Vertical spacing


  var baselineskip = group.colSeparationType === "CD" ? calculateSize({
    number: 3,
    unit: "ex"
  }, options) : 12 * pt; // see size10.clo
  // Default \jot from ltmath.dtx
  // TODO(edemaine): allow overriding \jot via \setlength (#687)

  var jot = 3 * pt;
  var arrayskip = group.arraystretch * baselineskip;
  var arstrutHeight = 0.7 * arrayskip; // \strutbox in ltfsstrc.dtx and

  var arstrutDepth = 0.3 * arrayskip; // \@arstrutbox in lttab.dtx

  var totalHeight = 0; // Set a position for \hline(s) at the top of the array, if any.

  function setHLinePos(hlinesInGap) {
    for (var i = 0; i < hlinesInGap.length; ++i) {
      if (i > 0) {
        totalHeight += 0.25;
      }

      hlines.push({
        pos: totalHeight,
        isDashed: hlinesInGap[i]
      });
    }
  }

  setHLinePos(hLinesBeforeRow[0]);

  for (r = 0; r < group.body.length; ++r) {
    var inrow = group.body[r];
    var height = arstrutHeight; // \@array adds an \@arstrut

    var depth = arstrutDepth; // to each tow (via the template)

    if (nc < inrow.length) {
      nc = inrow.length;
    }

    var outrow = new Array(inrow.length);

    for (c = 0; c < inrow.length; ++c) {
      var elt = buildGroup$1(inrow[c], options);

      if (depth < elt.depth) {
        depth = elt.depth;
      }

      if (height < elt.height) {
        height = elt.height;
      }

      outrow[c] = elt;
    }

    var rowGap = group.rowGaps[r];
    var gap = 0;

    if (rowGap) {
      gap = calculateSize(rowGap, options);

      if (gap > 0) {
        // \@argarraycr
        gap += arstrutDepth;

        if (depth < gap) {
          depth = gap; // \@xargarraycr
        }

        gap = 0;
      }
    } // In AMS multiline environments such as aligned and gathered, rows
    // correspond to lines that have additional \jot added to the
    // \baselineskip via \openup.


    if (group.addJot) {
      depth += jot;
    }

    outrow.height = height;
    outrow.depth = depth;
    totalHeight += height;
    outrow.pos = totalHeight;
    totalHeight += depth + gap; // \@yargarraycr

    body[r] = outrow; // Set a position for \hline(s), if any.

    setHLinePos(hLinesBeforeRow[r + 1]);
  }

  var offset = totalHeight / 2 + options.fontMetrics().axisHeight;
  var colDescriptions = group.cols || [];
  var cols = [];
  var colSep;
  var colDescrNum;
  var tagSpans = [];

  if (group.tags && group.tags.some(tag => tag)) {
    // An environment with manual tags and/or automatic equation numbers.
    // Create node(s), the latter of which trigger CSS counter increment.
    for (r = 0; r < nr; ++r) {
      var rw = body[r];
      var shift = rw.pos - offset;
      var tag = group.tags[r];
      var tagSpan = void 0;

      if (tag === true) {
        // automatic numbering
        tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
      } else if (tag === false) {
        // \nonumber/\notag or starred environment
        tagSpan = buildCommon.makeSpan([], [], options);
      } else {
        // manual \tag
        tagSpan = buildCommon.makeSpan([], buildExpression$1(tag, options, true), options);
      }

      tagSpan.depth = rw.depth;
      tagSpan.height = rw.height;
      tagSpans.push({
        type: "elem",
        elem: tagSpan,
        shift
      });
    }
  }

  for (c = 0, colDescrNum = 0; // Continue while either there are more columns or more column
  // descriptions, so trailing separators don't get lost.
  c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {
    var colDescr = colDescriptions[colDescrNum] || {};
    var firstSeparator = true;

    while (colDescr.type === "separator") {
      // If there is more than one separator in a row, add a space
      // between them.
      if (!firstSeparator) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
        cols.push(colSep);
      }

      if (colDescr.separator === "|" || colDescr.separator === ":") {
        var lineType = colDescr.separator === "|" ? "solid" : "dashed";
        var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
        separator.style.height = makeEm(totalHeight);
        separator.style.borderRightWidth = makeEm(ruleThickness);
        separator.style.borderRightStyle = lineType;
        separator.style.margin = "0 " + makeEm(-ruleThickness / 2);

        var _shift = totalHeight - offset;

        if (_shift) {
          separator.style.verticalAlign = makeEm(-_shift);
        }

        cols.push(separator);
      } else {
        throw new ParseError("Invalid separator type: " + colDescr.separator);
      }

      colDescrNum++;
      colDescr = colDescriptions[colDescrNum] || {};
      firstSeparator = false;
    }

    if (c >= nc) {
      continue;
    }

    var sepwidth = void 0;

    if (c > 0 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.pregap, arraycolsep);

      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }

    var col = [];

    for (r = 0; r < nr; ++r) {
      var row = body[r];
      var elem = row[c];

      if (!elem) {
        continue;
      }

      var _shift2 = row.pos - offset;

      elem.depth = row.depth;
      elem.height = row.height;
      col.push({
        type: "elem",
        elem: elem,
        shift: _shift2
      });
    }

    col = buildCommon.makeVList({
      positionType: "individualShift",
      children: col
    }, options);
    col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
    cols.push(col);

    if (c < nc - 1 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.postgap, arraycolsep);

      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
  }

  body = buildCommon.makeSpan(["mtable"], cols); // Add \hline(s), if any.

  if (hlines.length > 0) {
    var line = buildCommon.makeLineSpan("hline", options, ruleThickness);
    var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
    var vListElems = [{
      type: "elem",
      elem: body,
      shift: 0
    }];

    while (hlines.length > 0) {
      var hline = hlines.pop();
      var lineShift = hline.pos - offset;

      if (hline.isDashed) {
        vListElems.push({
          type: "elem",
          elem: dashes,
          shift: lineShift
        });
      } else {
        vListElems.push({
          type: "elem",
          elem: line,
          shift: lineShift
        });
      }
    }

    body = buildCommon.makeVList({
      positionType: "individualShift",
      children: vListElems
    }, options);
  }

  if (tagSpans.length === 0) {
    return buildCommon.makeSpan(["mord"], [body], options);
  } else {
    var eqnNumCol = buildCommon.makeVList({
      positionType: "individualShift",
      children: tagSpans
    }, options);
    eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
    return buildCommon.makeFragment([body, eqnNumCol]);
  }
};

var alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
};

var mathmlBuilder$5 = function mathmlBuilder(group, options) {
  var tbl = [];
  var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
  var tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);

  for (var i = 0; i < group.body.length; i++) {
    var rw = group.body[i];
    var row = [];

    for (var j = 0; j < rw.length; j++) {
      row.push(new mathMLTree.MathNode("mtd", [buildGroup(rw[j], options)]));
    }

    if (group.tags && group.tags[i]) {
      row.unshift(glue);
      row.push(glue);

      if (group.leqno) {
        row.unshift(tag);
      } else {
        row.push(tag);
      }
    }

    tbl.push(new mathMLTree.MathNode("mtr", row));
  }

  var table = new mathMLTree.MathNode("mtable", tbl); // Set column alignment, row spacing, column spacing, and
  // array lines by setting attributes on the table element.
  // Set the row spacing. In MathML, we specify a gap distance.
  // We do not use rowGap[] because MathML automatically increases
  // cell height with the height/depth of the element content.
  // LaTeX \arraystretch multiplies the row baseline-to-baseline distance.
  // We simulate this by adding (arraystretch - 1)em to the gap. This
  // does a reasonable job of adjusting arrays containing 1 em tall content.
  // The 0.16 and 0.09 values are found emprically. They produce an array
  // similar to LaTeX and in which content does not interfere with \hines.

  var gap = group.arraystretch === 0.5 ? 0.1 // {smallmatrix}, {subarray}
  : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
  table.setAttribute("rowspacing", makeEm(gap)); // MathML table lines go only between cells.
  // To place a line on an edge we'll use <menclose>, if necessary.

  var menclose = "";
  var align = "";

  if (group.cols && group.cols.length > 0) {
    // Find column alignment, column spacing, and  vertical lines.
    var cols = group.cols;
    var columnLines = "";
    var prevTypeWasAlign = false;
    var iStart = 0;
    var iEnd = cols.length;

    if (cols[0].type === "separator") {
      menclose += "top ";
      iStart = 1;
    }

    if (cols[cols.length - 1].type === "separator") {
      menclose += "bottom ";
      iEnd -= 1;
    }

    for (var _i = iStart; _i < iEnd; _i++) {
      if (cols[_i].type === "align") {
        align += alignMap[cols[_i].align];

        if (prevTypeWasAlign) {
          columnLines += "none ";
        }

        prevTypeWasAlign = true;
      } else if (cols[_i].type === "separator") {
        // MathML accepts only single lines between cells.
        // So we read only the first of consecutive separators.
        if (prevTypeWasAlign) {
          columnLines += cols[_i].separator === "|" ? "solid " : "dashed ";
          prevTypeWasAlign = false;
        }
      }
    }

    table.setAttribute("columnalign", align.trim());

    if (/[sd]/.test(columnLines)) {
      table.setAttribute("columnlines", columnLines.trim());
    }
  } // Set column spacing.


  if (group.colSeparationType === "align") {
    var _cols = group.cols || [];

    var spacing = "";

    for (var _i2 = 1; _i2 < _cols.length; _i2++) {
      spacing += _i2 % 2 ? "0em " : "1em ";
    }

    table.setAttribute("columnspacing", spacing.trim());
  } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
    table.setAttribute("columnspacing", "0em");
  } else if (group.colSeparationType === "small") {
    table.setAttribute("columnspacing", "0.2778em");
  } else if (group.colSeparationType === "CD") {
    table.setAttribute("columnspacing", "0.5em");
  } else {
    table.setAttribute("columnspacing", "1em");
  } // Address \hline and \hdashline


  var rowLines = "";
  var hlines = group.hLinesBeforeRow;
  menclose += hlines[0].length > 0 ? "left " : "";
  menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";

  for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {
    rowLines += hlines[_i3].length === 0 ? "none " // MathML accepts only a single line between rows. Read one element.
    : hlines[_i3][0] ? "dashed " : "solid ";
  }

  if (/[sd]/.test(rowLines)) {
    table.setAttribute("rowlines", rowLines.trim());
  }

  if (menclose !== "") {
    table = new mathMLTree.MathNode("menclose", [table]);
    table.setAttribute("notation", menclose.trim());
  }

  if (group.arraystretch && group.arraystretch < 1) {
    // A small array. Wrap in scriptstyle so row gap is not too large.
    table = new mathMLTree.MathNode("mstyle", [table]);
    table.setAttribute("scriptlevel", "1");
  }

  return table;
}; // Convenience function for align, align*, aligned, alignat, alignat*, alignedat.


var alignedHandler = function alignedHandler(context, args) {
  if (context.envName.indexOf("ed") === -1) {
    validateAmsEnvironmentContext(context);
  }

  var cols = [];
  var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
  var isSplit = context.envName === "split";
  var res = parseArray(context.parser, {
    cols,
    addJot: true,
    autoTag: isSplit ? undefined : getAutoTag(context.envName),
    emptySingleRow: true,
    colSeparationType: separationType,
    maxNumCols: isSplit ? 2 : undefined,
    leqno: context.parser.settings.leqno
  }, "display"); // Determining number of columns.
  // 1. If the first argument is given, we use it as a number of columns,
  //    and makes sure that each row doesn't exceed that number.
  // 2. Otherwise, just count number of columns = maximum number
  //    of cells in each row ("aligned" mode -- isAligned will be true).
  //
  // At the same time, prepend empty group {} at beginning of every second
  // cell in each row (starting with second cell) so that operators become
  // binary.  This behavior is implemented in amsmath's \start@aligned.

  var numMaths;
  var numCols = 0;
  var emptyGroup = {
    type: "ordgroup",
    mode: context.mode,
    body: []
  };

  if (args[0] && args[0].type === "ordgroup") {
    var arg0 = "";

    for (var i = 0; i < args[0].body.length; i++) {
      var textord = assertNodeType(args[0].body[i], "textord");
      arg0 += textord.text;
    }

    numMaths = Number(arg0);
    numCols = numMaths * 2;
  }

  var isAligned = !numCols;
  res.body.forEach(function (row) {
    for (var _i4 = 1; _i4 < row.length; _i4 += 2) {
      // Modify ordgroup node within styling node
      var styling = assertNodeType(row[_i4], "styling");
      var ordgroup = assertNodeType(styling.body[0], "ordgroup");
      ordgroup.body.unshift(emptyGroup);
    }

    if (!isAligned) {
      // Case 1
      var curMaths = row.length / 2;

      if (numMaths < curMaths) {
        throw new ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
      }
    } else if (numCols < row.length) {
      // Case 2
      numCols = row.length;
    }
  }); // Adjusting alignment.
  // In aligned mode, we add one \qquad between columns;
  // otherwise we add nothing.

  for (var _i5 = 0; _i5 < numCols; ++_i5) {
    var align = "r";
    var pregap = 0;

    if (_i5 % 2 === 1) {
      align = "l";
    } else if (_i5 > 0 && isAligned) {
      // "aligned" mode.
      pregap = 1; // add one \quad
    }

    cols[_i5] = {
      type: "align",
      align: align,
      pregap: pregap,
      postgap: 0
    };
  }

  res.colSeparationType = isAligned ? "align" : "alignat";
  return res;
}; // Arrays are part of LaTeX, defined in lttab.dtx so its documentation
// is part of the source2e.pdf file of LaTeX2e source documentation.
// {darray} is an {array} environment where cells are set in \displaystyle,
// as defined in nccmath.sty.


defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },

  handler(context, args) {
    // Since no types are specified above, the two possibilities are
    // - The argument is wrapped in {} or [], in which case Parser's
    //   parseGroup() returns an "ordgroup" wrapping some symbol node.
    // - The argument is a bare symbol node.
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function (nde) {
      var node = assertSymbolNodeType(nde);
      var ca = node.text;

      if ("lcr".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      } else if (ca === "|") {
        return {
          type: "separator",
          separator: "|"
        };
      } else if (ca === ":") {
        return {
          type: "separator",
          separator: ":"
        };
      }

      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    var res = {
      cols,
      hskipBeforeAndAfter: true,
      // \@preamble in lttab.dtx
      maxNumCols: cols.length
    };
    return parseArray(context.parser, res, dCellStyle(context.envName));
  },

  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
}); // The matrix environments of amsmath builds on the array environment
// of LaTeX, which is discussed above.
// The mathtools package adds starred versions of the same environments.
// These have an optional argument to choose left|center|right justification.

defineEnvironment({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },

  handler(context) {
    var delimiters = {
      "matrix": null,
      "pmatrix": ["(", ")"],
      "bmatrix": ["[", "]"],
      "Bmatrix": ["\\{", "\\}"],
      "vmatrix": ["|", "|"],
      "Vmatrix": ["\\Vert", "\\Vert"]
    }[context.envName.replace("*", "")]; // \hskip -\arraycolsep in amsmath

    var colAlign = "c";
    var payload = {
      hskipBeforeAndAfter: false,
      cols: [{
        type: "align",
        align: colAlign
      }]
    };

    if (context.envName.charAt(context.envName.length - 1) === "*") {
      // It's one of the mathtools starred functions.
      // Parse the optional alignment argument.
      var parser = context.parser;
      parser.consumeSpaces();

      if (parser.fetch().text === "[") {
        parser.consume();
        parser.consumeSpaces();
        colAlign = parser.fetch().text;

        if ("lcr".indexOf(colAlign) === -1) {
          throw new ParseError("Expected l or c or r", parser.nextToken);
        }

        parser.consume();
        parser.consumeSpaces();
        parser.expect("]");
        parser.consume();
        payload.cols = [{
          type: "align",
          align: colAlign
        }];
      }
    }

    var res = parseArray(context.parser, payload, dCellStyle(context.envName)); // Populate cols with the correct number of column alignment specs.

    var numCols = Math.max(0, ...res.body.map(row => row.length));
    res.cols = new Array(numCols).fill({
      type: "align",
      align: colAlign
    });
    return delimiters ? {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: delimiters[0],
      right: delimiters[1],
      rightColor: undefined // \right uninfluenced by \color in array

    } : res;
  },

  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },

  handler(context) {
    var payload = {
      arraystretch: 0.5
    };
    var res = parseArray(context.parser, payload, "script");
    res.colSeparationType = "small";
    return res;
  },

  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },

  handler(context, args) {
    // Parsing of {subarray} is similar to {array}
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function (nde) {
      var node = assertSymbolNodeType(nde);
      var ca = node.text; // {subarray} only recognizes "l" & "c"

      if ("lc".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      }

      throw new ParseError("Unknown column alignment: " + ca, nde);
    });

    if (cols.length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }

    var res = {
      cols,
      hskipBeforeAndAfter: false,
      arraystretch: 0.5
    };
    res = parseArray(context.parser, res, "script");

    if (res.body.length > 0 && res.body[0].length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }

    return res;
  },

  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
}); // A cases environment (in amsmath.sty) is almost equivalent to
// \def\arraystretch{1.2}%
// \left\{\begin{array}{@{}l@{\quad}l@{}} … \end{array}\right.
// {dcases} is a {cases} environment where cells are set in \displaystyle,
// as defined in mathtools.sty.
// {rcases} is another mathtools environment. It's brace is on the right side.

defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },

  handler(context) {
    var payload = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1.0
        /* 1em quad */

      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    };
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    return {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: context.envName.indexOf("r") > -1 ? "." : "\\{",
      right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: undefined
    };
  },

  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
}); // In the align environment, one uses ampersands, &, to specify number of
// columns in each row, and to locate spacing between each column.
// align gets automatic numbering. align* and aligned do not.
// The alignedat environment can be used in math mode.
// Note that we assume \nomallineskiplimit to be zero,
// so that \strut@ is the same as \strut.

defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
}); // A gathered environment is like an array environment with one centered
// column, but where rows are considered lines so get \jot line spacing
// and contents are set in \displaystyle.

defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },

  handler(context) {
    if (utils.contains(["gather", "gather*"], context.envName)) {
      validateAmsEnvironmentContext(context);
    }

    var res = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: true,
      colSeparationType: "gather",
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },

  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
}); // alignat environment is like an align environment, but one must explicitly
// specify maximum number of columns in each row, and can adjust spacing between
// each columns.

defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },

  handler(context) {
    validateAmsEnvironmentContext(context);
    var res = {
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      singleRow: true,
      maxNumCols: 1,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },

  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },

  handler(context) {
    validateAmsEnvironmentContext(context);
    return parseCD(context.parser);
  },

  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
defineMacro("\\notag", "\\nonumber"); // Catch \hline outside array environment

defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },

  handler(context, args) {
    throw new ParseError(context.funcName + " valid only within array environment");
  }

});

var environments = _environments;

// defineEnvironment definitions.

defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },

  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var nameGroup = args[0];

    if (nameGroup.type !== "ordgroup") {
      throw new ParseError("Invalid environment name", nameGroup);
    }

    var envName = "";

    for (var i = 0; i < nameGroup.body.length; ++i) {
      envName += assertNodeType(nameGroup.body[i], "textord").text;
    }

    if (funcName === "\\begin") {
      // begin...end is similar to left...right
      if (!environments.hasOwnProperty(envName)) {
        throw new ParseError("No such environment: " + envName, nameGroup);
      } // Build the environment object. Arguments and other information will
      // be made available to the begin and end methods using properties.


      var env = environments[envName];
      var {
        args: _args,
        optArgs
      } = parser.parseArguments("\\begin{" + envName + "}", env);
      var context = {
        mode: parser.mode,
        envName,
        parser
      };
      var result = env.handler(context, _args, optArgs);
      parser.expect("\\end", false);
      var endNameToken = parser.nextToken;
      var end = assertNodeType(parser.parseFunction(), "environment");

      if (end.name !== envName) {
        throw new ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
      } // $FlowFixMe, "environment" handler returns an environment ParseNode


      return result;
    }

    return {
      type: "environment",
      mode: parser.mode,
      name: envName,
      nameGroup
    };
  }

});

// TODO(kevinb): implement \\sl and \\sc

var htmlBuilder$5 = (group, options) => {
  var font = group.font;
  var newOptions = options.withFont(font);
  return buildGroup$1(group.body, newOptions);
};

var mathmlBuilder$4 = (group, options) => {
  var font = group.font;
  var newOptions = options.withFont(font);
  return buildGroup(group.body, newOptions);
};

var fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
defineFunction({
  type: "font",
  names: [// styles, except \boldsymbol defined below
  "\\mathrm", "\\mathit", "\\mathbf", "\\mathnormal", // families
  "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf", "\\mathtt", // aliases, except \bm defined below
  "\\Bbb", "\\bold", "\\frak"],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = normalizeArgument(args[0]);
    var func = funcName;

    if (func in fontAliases) {
      func = fontAliases[func];
    }

    return {
      type: "font",
      mode: parser.mode,
      font: func.slice(1),
      body
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
defineFunction({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    var isCharacterBox = utils.isCharacterBox(body); // amsbsy.sty's \boldsymbol uses \binrel spacing to inherit the
    // argument's bin|rel|ord status

    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(body),
      body: [{
        type: "font",
        mode: parser.mode,
        font: "boldsymbol",
        body
      }],
      isCharacterBox: isCharacterBox
    };
  }
}); // Old font changing functions

defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser,
      funcName,
      breakOnTokenText
    } = _ref3;
    var {
      mode
    } = parser;
    var body = parser.parseExpression(true, breakOnTokenText);
    var style = "math" + funcName.slice(1);
    return {
      type: "font",
      mode: mode,
      font: style,
      body: {
        type: "ordgroup",
        mode: parser.mode,
        body
      }
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});

var adjustStyle = (size, originalStyle) => {
  // Figure out what style this fraction should be in based on the
  // function used
  var style = originalStyle;

  if (size === "display") {
    // Get display style as a default.
    // If incoming style is sub/sup, use style.text() to get correct size.
    style = style.id >= Style$1.SCRIPT.id ? style.text() : Style$1.DISPLAY;
  } else if (size === "text" && style.size === Style$1.DISPLAY.size) {
    // We're in a \tfrac but incoming style is displaystyle, so:
    style = Style$1.TEXT;
  } else if (size === "script") {
    style = Style$1.SCRIPT;
  } else if (size === "scriptscript") {
    style = Style$1.SCRIPTSCRIPT;
  }

  return style;
};

var htmlBuilder$4 = (group, options) => {
  // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).
  var style = adjustStyle(group.size, options.style);
  var nstyle = style.fracNum();
  var dstyle = style.fracDen();
  var newOptions;
  newOptions = options.havingStyle(nstyle);
  var numerm = buildGroup$1(group.numer, newOptions, options);

  if (group.continued) {
    // \cfrac inserts a \strut into the numerator.
    // Get \strut dimensions from TeXbook page 353.
    var hStrut = 8.5 / options.fontMetrics().ptPerEm;
    var dStrut = 3.5 / options.fontMetrics().ptPerEm;
    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
  }

  newOptions = options.havingStyle(dstyle);
  var denomm = buildGroup$1(group.denom, newOptions, options);
  var rule;
  var ruleWidth;
  var ruleSpacing;

  if (group.hasBarLine) {
    if (group.barSize) {
      ruleWidth = calculateSize(group.barSize, options);
      rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
    } else {
      rule = buildCommon.makeLineSpan("frac-line", options);
    }

    ruleWidth = rule.height;
    ruleSpacing = rule.height;
  } else {
    rule = null;
    ruleWidth = 0;
    ruleSpacing = options.fontMetrics().defaultRuleThickness;
  } // Rule 15b


  var numShift;
  var clearance;
  var denomShift;

  if (style.size === Style$1.DISPLAY.size || group.size === "display") {
    numShift = options.fontMetrics().num1;

    if (ruleWidth > 0) {
      clearance = 3 * ruleSpacing;
    } else {
      clearance = 7 * ruleSpacing;
    }

    denomShift = options.fontMetrics().denom1;
  } else {
    if (ruleWidth > 0) {
      numShift = options.fontMetrics().num2;
      clearance = ruleSpacing;
    } else {
      numShift = options.fontMetrics().num3;
      clearance = 3 * ruleSpacing;
    }

    denomShift = options.fontMetrics().denom2;
  }

  var frac;

  if (!rule) {
    // Rule 15c
    var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);

    if (candidateClearance < clearance) {
      numShift += 0.5 * (clearance - candidateClearance);
      denomShift += 0.5 * (clearance - candidateClearance);
    }

    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  } else {
    // Rule 15d
    var axisHeight = options.fontMetrics().axisHeight;

    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
    }

    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
    }

    var midShift = -(axisHeight - 0.5 * ruleWidth);
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: rule,
        shift: midShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  } // Since we manually change the style sometimes (with \dfrac or \tfrac),
  // account for the possible size change here.


  newOptions = options.havingStyle(style);
  frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
  frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier; // Rule 15e

  var delimSize;

  if (style.size === Style$1.DISPLAY.size) {
    delimSize = options.fontMetrics().delim1;
  } else if (style.size === Style$1.SCRIPTSCRIPT.size) {
    delimSize = options.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;
  } else {
    delimSize = options.fontMetrics().delim2;
  }

  var leftDelim;
  var rightDelim;

  if (group.leftDelim == null) {
    leftDelim = makeNullDelimiter(options, ["mopen"]);
  } else {
    leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
  }

  if (group.continued) {
    rightDelim = buildCommon.makeSpan([]); // zero width for \cfrac
  } else if (group.rightDelim == null) {
    rightDelim = makeNullDelimiter(options, ["mclose"]);
  } else {
    rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
  }

  return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
};

var mathmlBuilder$3 = (group, options) => {
  var node = new mathMLTree.MathNode("mfrac", [buildGroup(group.numer, options), buildGroup(group.denom, options)]);

  if (!group.hasBarLine) {
    node.setAttribute("linethickness", "0px");
  } else if (group.barSize) {
    var ruleWidth = calculateSize(group.barSize, options);
    node.setAttribute("linethickness", makeEm(ruleWidth));
  }

  var style = adjustStyle(group.size, options.style);

  if (style.size !== options.style.size) {
    node = new mathMLTree.MathNode("mstyle", [node]);
    var isDisplay = style.size === Style$1.DISPLAY.size ? "true" : "false";
    node.setAttribute("displaystyle", isDisplay);
    node.setAttribute("scriptlevel", "0");
  }

  if (group.leftDelim != null || group.rightDelim != null) {
    var withDelims = [];

    if (group.leftDelim != null) {
      var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
      leftOp.setAttribute("fence", "true");
      withDelims.push(leftOp);
    }

    withDelims.push(node);

    if (group.rightDelim != null) {
      var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
      rightOp.setAttribute("fence", "true");
      withDelims.push(rightOp);
    }

    return makeRow(withDelims);
  }

  return node;
};

defineFunction({
  type: "genfrac",
  names: ["\\dfrac", "\\frac", "\\tfrac", "\\dbinom", "\\binom", "\\tbinom", "\\\\atopfrac", // can’t be entered directly
  "\\\\bracefrac", "\\\\brackfrac" // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var numer = args[0];
    var denom = args[1];
    var hasBarLine;
    var leftDelim = null;
    var rightDelim = null;
    var size = "auto";

    switch (funcName) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        hasBarLine = true;
        break;

      case "\\\\atopfrac":
        hasBarLine = false;
        break;

      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        hasBarLine = false;
        leftDelim = "(";
        rightDelim = ")";
        break;

      case "\\\\bracefrac":
        hasBarLine = false;
        leftDelim = "\\{";
        rightDelim = "\\}";
        break;

      case "\\\\brackfrac":
        hasBarLine = false;
        leftDelim = "[";
        rightDelim = "]";
        break;

      default:
        throw new Error("Unrecognized genfrac command");
    }

    switch (funcName) {
      case "\\dfrac":
      case "\\dbinom":
        size = "display";
        break;

      case "\\tfrac":
      case "\\tbinom":
        size = "text";
        break;
    }

    return {
      type: "genfrac",
      mode: parser.mode,
      continued: false,
      numer,
      denom,
      hasBarLine,
      leftDelim,
      rightDelim,
      size,
      barSize: null
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (_ref2, args) => {
    var {
      parser,
      funcName
    } = _ref2;
    var numer = args[0];
    var denom = args[1];
    return {
      type: "genfrac",
      mode: parser.mode,
      continued: true,
      numer,
      denom,
      hasBarLine: true,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
}); // Infix generalized fractions -- these are not rendered directly, but replaced
// immediately by one of the variants above.

defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },

  handler(_ref3) {
    var {
      parser,
      funcName,
      token
    } = _ref3;
    var replaceWith;

    switch (funcName) {
      case "\\over":
        replaceWith = "\\frac";
        break;

      case "\\choose":
        replaceWith = "\\binom";
        break;

      case "\\atop":
        replaceWith = "\\\\atopfrac";
        break;

      case "\\brace":
        replaceWith = "\\\\bracefrac";
        break;

      case "\\brack":
        replaceWith = "\\\\brackfrac";
        break;

      default:
        throw new Error("Unrecognized infix genfrac command");
    }

    return {
      type: "infix",
      mode: parser.mode,
      replaceWith,
      token
    };
  }

});
var stylArray = ["display", "text", "script", "scriptscript"];

var delimFromValue = function delimFromValue(delimString) {
  var delim = null;

  if (delimString.length > 0) {
    delim = delimString;
    delim = delim === "." ? null : delim;
  }

  return delim;
};

defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: true,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },

  handler(_ref4, args) {
    var {
      parser
    } = _ref4;
    var numer = args[4];
    var denom = args[5]; // Look into the parse nodes to get the desired delimiters.

    var leftNode = normalizeArgument(args[0]);
    var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
    var rightNode = normalizeArgument(args[1]);
    var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
    var barNode = assertNodeType(args[2], "size");
    var hasBarLine;
    var barSize = null;

    if (barNode.isBlank) {
      // \genfrac acts differently than \above.
      // \genfrac treats an empty size group as a signal to use a
      // standard bar size. \above would see size = 0 and omit the bar.
      hasBarLine = true;
    } else {
      barSize = barNode.value;
      hasBarLine = barSize.number > 0;
    } // Find out if we want displaystyle, textstyle, etc.


    var size = "auto";
    var styl = args[3];

    if (styl.type === "ordgroup") {
      if (styl.body.length > 0) {
        var textOrd = assertNodeType(styl.body[0], "textord");
        size = stylArray[Number(textOrd.text)];
      }
    } else {
      styl = assertNodeType(styl, "textord");
      size = stylArray[Number(styl.text)];
    }

    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim,
      rightDelim,
      size
    };
  },

  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
}); // \above is an infix fraction that also defines a fraction bar size.

defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },

  handler(_ref5, args) {
    var {
      parser,
      funcName,
      token
    } = _ref5;
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith: "\\\\abovefrac",
      size: assertNodeType(args[0], "size").value,
      token
    };
  }

});
defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (_ref6, args) => {
    var {
      parser,
      funcName
    } = _ref6;
    var numer = args[0];
    var barSize = assert(assertNodeType(args[1], "infix").size);
    var denom = args[2];
    var hasBarLine = barSize.number > 0;
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});

// NOTE: Unlike most `htmlBuilder`s, this one handles not only "horizBrace", but
// also "supsub" since an over/underbrace can affect super/subscripting.
var htmlBuilder$3 = (grp, options) => {
  var style = options.style; // Pull out the `ParseNode<"horizBrace">` if `grp` is a "supsub" node.

  var supSubGroup;
  var group;

  if (grp.type === "supsub") {
    // Ref: LaTeX source2e: }}}}\limits}
    // i.e. LaTeX treats the brace similar to an op and passes it
    // with \limits, so we need to assign supsub style.
    supSubGroup = grp.sup ? buildGroup$1(grp.sup, options.havingStyle(style.sup()), options) : buildGroup$1(grp.sub, options.havingStyle(style.sub()), options);
    group = assertNodeType(grp.base, "horizBrace");
  } else {
    group = assertNodeType(grp, "horizBrace");
  } // Build the base group


  var body = buildGroup$1(group.base, options.havingBaseStyle(Style$1.DISPLAY)); // Create the stretchy element

  var braceBody = stretchy.svgSpan(group, options); // Generate the vlist, with the appropriate kerns        ┏━━━━━━━━┓
  // This first vlist contains the content and the brace:   equation

  var vlist;

  if (group.isOver) {
    vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: braceBody
      }]
    }, options); // $FlowFixMe: Replace this with passing "svg-align" into makeVList.

    vlist.children[0].children[0].children[1].classes.push("svg-align");
  } else {
    vlist = buildCommon.makeVList({
      positionType: "bottom",
      positionData: body.depth + 0.1 + braceBody.height,
      children: [{
        type: "elem",
        elem: braceBody
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: body
      }]
    }, options); // $FlowFixMe: Replace this with passing "svg-align" into makeVList.

    vlist.children[0].children[0].children[0].classes.push("svg-align");
  }

  if (supSubGroup) {
    // To write the supsub, wrap the first vlist in another vlist:
    // They can't all go in the same vlist, because the note might be
    // wider than the equation. We want the equation to control the
    // brace width.
    //      note          long note           long note
    //   ┏━━━━━━━━┓   or    ┏━━━┓     not    ┏━━━━━━━━━┓
    //    equation           eqn                 eqn
    var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);

    if (group.isOver) {
      vlist = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: vSpan
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: supSubGroup
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "bottom",
        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
        children: [{
          type: "elem",
          elem: supSubGroup
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: vSpan
        }]
      }, options);
    }
  }

  return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
};

var mathmlBuilder$2 = (group, options) => {
  var accentNode = stretchy.mathMLnode(group.label);
  return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup(group.base, options), accentNode]);
}; // Horizontal stretchy braces


defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },

  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "horizBrace",
      mode: parser.mode,
      label: funcName,
      isOver: /^\\over/.test(funcName),
      base: args[0]
    };
  },

  htmlBuilder: htmlBuilder$3,
  mathmlBuilder: mathmlBuilder$2
});

defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    var body = args[1];
    var href = assertNodeType(args[0], "url").url;

    if (!parser.settings.isTrusted({
      command: "\\href",
      url: href
    })) {
      return parser.formatUnsupportedCmd("\\href");
    }

    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options, false);
    return buildCommon.makeAnchor(group.href, [], elements, options);
  },
  mathmlBuilder: (group, options) => {
    var math = buildExpressionRow(group.body, options);

    if (!(math instanceof MathNode)) {
      math = new MathNode("mrow", [math]);
    }

    math.setAttribute("href", group.href);
    return math;
  }
});
defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var href = assertNodeType(args[0], "url").url;

    if (!parser.settings.isTrusted({
      command: "\\url",
      url: href
    })) {
      return parser.formatUnsupportedCmd("\\url");
    }

    var chars = [];

    for (var i = 0; i < href.length; i++) {
      var c = href[i];

      if (c === "~") {
        c = "\\textasciitilde";
      }

      chars.push({
        type: "textord",
        mode: "text",
        text: c
      });
    }

    var body = {
      type: "text",
      mode: parser.mode,
      font: "\\texttt",
      body: chars
    };
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  }
});

// In LaTeX, \vcenter can act only on a box, as in
// \vcenter{\hbox{$\frac{a+b}{\dfrac{c}{d}}$}}
// This function by itself doesn't do anything but prevent a soft line break.

defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: true,
    primitive: true
  },

  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "hbox",
      mode: parser.mode,
      body: ordargument(args[0])
    };
  },

  htmlBuilder(group, options) {
    var elements = buildExpression$1(group.body, options, false);
    return buildCommon.makeFragment(elements);
  },

  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mrow", buildExpression(group.body, options));
  }

});

defineFunction({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName,
      token
    } = _ref;
    var value = assertNodeType(args[0], "raw").string;
    var body = args[1];

    if (parser.settings.strict) {
      parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    }

    var trustContext;
    var attributes = {};

    switch (funcName) {
      case "\\htmlClass":
        attributes.class = value;
        trustContext = {
          command: "\\htmlClass",
          class: value
        };
        break;

      case "\\htmlId":
        attributes.id = value;
        trustContext = {
          command: "\\htmlId",
          id: value
        };
        break;

      case "\\htmlStyle":
        attributes.style = value;
        trustContext = {
          command: "\\htmlStyle",
          style: value
        };
        break;

      case "\\htmlData":
        {
          var data = value.split(",");

          for (var i = 0; i < data.length; i++) {
            var keyVal = data[i].split("=");

            if (keyVal.length !== 2) {
              throw new ParseError("Error parsing key-value for \\htmlData");
            }

            attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
          }

          trustContext = {
            command: "\\htmlData",
            attributes
          };
          break;
        }

      default:
        throw new Error("Unrecognized html command");
    }

    if (!parser.settings.isTrusted(trustContext)) {
      return parser.formatUnsupportedCmd(funcName);
    }

    return {
      type: "html",
      mode: parser.mode,
      attributes,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options, false);
    var classes = ["enclosing"];

    if (group.attributes.class) {
      classes.push(...group.attributes.class.trim().split(/\s+/));
    }

    var span = buildCommon.makeSpan(classes, elements, options);

    for (var attr in group.attributes) {
      if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
        span.setAttribute(attr, group.attributes[attr]);
      }
    }

    return span;
  },
  mathmlBuilder: (group, options) => {
    return buildExpressionRow(group.body, options);
  }
});

defineFunction({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    return {
      type: "htmlmathml",
      mode: parser.mode,
      html: ordargument(args[0]),
      mathml: ordargument(args[1])
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.html, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    return buildExpressionRow(group.mathml, options);
  }
});

var sizeData = function sizeData(str) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
    // str is a number with no unit specified.
    // default unit is bp, per graphix package.
    return {
      number: +str,
      unit: "bp"
    };
  } else {
    var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);

    if (!match) {
      throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
    }

    var data = {
      number: +(match[1] + match[2]),
      // sign + magnitude, cast to number
      unit: match[3]
    };

    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
    }

    return data;
  }
};

defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: false
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser
    } = _ref;
    var width = {
      number: 0,
      unit: "em"
    };
    var height = {
      number: 0.9,
      unit: "em"
    }; // sorta character sized.

    var totalheight = {
      number: 0,
      unit: "em"
    };
    var alt = "";

    if (optArgs[0]) {
      var attributeStr = assertNodeType(optArgs[0], "raw").string; // Parser.js does not parse key/value pairs. We get a string.

      var attributes = attributeStr.split(",");

      for (var i = 0; i < attributes.length; i++) {
        var keyVal = attributes[i].split("=");

        if (keyVal.length === 2) {
          var str = keyVal[1].trim();

          switch (keyVal[0].trim()) {
            case "alt":
              alt = str;
              break;

            case "width":
              width = sizeData(str);
              break;

            case "height":
              height = sizeData(str);
              break;

            case "totalheight":
              totalheight = sizeData(str);
              break;

            default:
              throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
          }
        }
      }
    }

    var src = assertNodeType(args[0], "url").url;

    if (alt === "") {
      // No alt given. Use the file name. Strip away the path.
      alt = src;
      alt = alt.replace(/^.*[\\/]/, '');
      alt = alt.substring(0, alt.lastIndexOf('.'));
    }

    if (!parser.settings.isTrusted({
      command: "\\includegraphics",
      url: src
    })) {
      return parser.formatUnsupportedCmd("\\includegraphics");
    }

    return {
      type: "includegraphics",
      mode: parser.mode,
      alt: alt,
      width: width,
      height: height,
      totalheight: totalheight,
      src: src
    };
  },
  htmlBuilder: (group, options) => {
    var height = calculateSize(group.height, options);
    var depth = 0;

    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options) - height;
    }

    var width = 0;

    if (group.width.number > 0) {
      width = calculateSize(group.width, options);
    }

    var style = {
      height: makeEm(height + depth)
    };

    if (width > 0) {
      style.width = makeEm(width);
    }

    if (depth > 0) {
      style.verticalAlign = makeEm(-depth);
    }

    var node = new Img(group.src, group.alt, style);
    node.height = height;
    node.depth = depth;
    return node;
  },
  mathmlBuilder: (group, options) => {
    var node = new mathMLTree.MathNode("mglyph", []);
    node.setAttribute("alt", group.alt);
    var height = calculateSize(group.height, options);
    var depth = 0;

    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options) - height;
      node.setAttribute("valign", makeEm(-depth));
    }

    node.setAttribute("height", makeEm(height + depth));

    if (group.width.number > 0) {
      var width = calculateSize(group.width, options);
      node.setAttribute("width", makeEm(width));
    }

    node.setAttribute("src", group.src);
    return node;
  }
});

// Horizontal spacing commands

defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: true,
    allowedInText: true
  },

  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var size = assertNodeType(args[0], "size");

    if (parser.settings.strict) {
      var mathFunction = funcName[1] === 'm'; // \mkern, \mskip

      var muUnit = size.value.unit === 'mu';

      if (mathFunction) {
        if (!muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
        }

        if (parser.mode !== "math") {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
        }
      } else {
        // !mathFunction
        if (muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
        }
      }
    }

    return {
      type: "kern",
      mode: parser.mode,
      dimension: size.value
    };
  },

  htmlBuilder(group, options) {
    return buildCommon.makeGlue(group.dimension, options);
  },

  mathmlBuilder(group, options) {
    var dimension = calculateSize(group.dimension, options);
    return new mathMLTree.SpaceNode(dimension);
  }

});

// Horizontal overlap functions
defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "lap",
      mode: parser.mode,
      alignment: funcName.slice(5),
      body
    };
  },
  htmlBuilder: (group, options) => {
    // mathllap, mathrlap, mathclap
    var inner;

    if (group.alignment === "clap") {
      // ref: https://www.math.lsu.edu/~aperlis/publications/mathclap/
      inner = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]); // wrap, since CSS will center a .clap > .inner > span

      inner = buildCommon.makeSpan(["inner"], [inner], options);
    } else {
      inner = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options)]);
    }

    var fix = buildCommon.makeSpan(["fix"], []);
    var node = buildCommon.makeSpan([group.alignment], [inner, fix], options); // At this point, we have correctly set horizontal alignment of the
    // two items involved in the lap.
    // Next, use a strut to set the height of the HTML bounding box.
    // Otherwise, a tall argument may be misplaced.
    // This code resolved issue #1153

    var strut = buildCommon.makeSpan(["strut"]);
    strut.style.height = makeEm(node.height + node.depth);

    if (node.depth) {
      strut.style.verticalAlign = makeEm(-node.depth);
    }

    node.children.unshift(strut); // Next, prevent vertical misplacement when next to something tall.
    // This code resolves issue #1234

    node = buildCommon.makeSpan(["thinbox"], [node], options);
    return buildCommon.makeSpan(["mord", "vbox"], [node], options);
  },
  mathmlBuilder: (group, options) => {
    // mathllap, mathrlap, mathclap
    var node = new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options)]);

    if (group.alignment !== "rlap") {
      var offset = group.alignment === "llap" ? "-1" : "-0.5";
      node.setAttribute("lspace", offset + "width");
    }

    node.setAttribute("width", "0px");
    return node;
  }
});

defineFunction({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },

  handler(_ref, args) {
    var {
      funcName,
      parser
    } = _ref;
    var outerMode = parser.mode;
    parser.switchMode("math");
    var close = funcName === "\\(" ? "\\)" : "$";
    var body = parser.parseExpression(false, close);
    parser.expect(close);
    parser.switchMode(outerMode);
    return {
      type: "styling",
      mode: parser.mode,
      style: "text",
      body
    };
  }

}); // Check for extra closing math delimiters

defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },

  handler(context, args) {
    throw new ParseError("Mismatched " + context.funcName);
  }

});

var chooseMathStyle = (group, options) => {
  switch (options.style.size) {
    case Style$1.DISPLAY.size:
      return group.display;

    case Style$1.TEXT.size:
      return group.text;

    case Style$1.SCRIPT.size:
      return group.script;

    case Style$1.SCRIPTSCRIPT.size:
      return group.scriptscript;

    default:
      return group.text;
  }
};

defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    return {
      type: "mathchoice",
      mode: parser.mode,
      display: ordargument(args[0]),
      text: ordargument(args[1]),
      script: ordargument(args[2]),
      scriptscript: ordargument(args[3])
    };
  },
  htmlBuilder: (group, options) => {
    var body = chooseMathStyle(group, options);
    var elements = buildExpression$1(body, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    var body = chooseMathStyle(group, options);
    return buildExpressionRow(body, options);
  }
});

var assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {
  base = buildCommon.makeSpan([], [base]);
  var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
  var sub;
  var sup; // We manually have to handle the superscripts and subscripts. This,
  // aside from the kern calculations, is copied from supsub.

  if (supGroup) {
    var elem = buildGroup$1(supGroup, options.havingStyle(style.sup()), options);
    sup = {
      elem,
      kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
    };
  }

  if (subGroup) {
    var _elem = buildGroup$1(subGroup, options.havingStyle(style.sub()), options);

    sub = {
      elem: _elem,
      kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
    };
  } // Build the final group as a vlist of the possible subscript, base,
  // and possible superscript.


  var finalGroup;

  if (sup && sub) {
    var bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: bottom,
      children: [{
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub.kern
      }, {
        type: "elem",
        elem: base
      }, {
        type: "kern",
        size: sup.kern
      }, {
        type: "elem",
        elem: sup.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }]
    }, options);
  } else if (sub) {
    var top = base.height - baseShift; // Shift the limits by the slant of the symbol. Note
    // that we are supposed to shift the limits by 1/2 of the slant,
    // but since we are centering the limits adding a full slant of
    // margin will shift by 1/2 that.

    finalGroup = buildCommon.makeVList({
      positionType: "top",
      positionData: top,
      children: [{
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub.kern
      }, {
        type: "elem",
        elem: base
      }]
    }, options);
  } else if (sup) {
    var _bottom = base.depth + baseShift;

    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: _bottom,
      children: [{
        type: "elem",
        elem: base
      }, {
        type: "kern",
        size: sup.kern
      }, {
        type: "elem",
        elem: sup.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }]
    }, options);
  } else {
    // This case probably shouldn't occur (this would mean the
    // supsub was sending us a group with no superscript or
    // subscript) but be safe.
    return base;
  }

  var parts = [finalGroup];

  if (sub && slant !== 0 && !subIsSingleCharacter) {
    // A negative margin-left was applied to the lower limit.
    // Avoid an overlap by placing a spacer on the left on the group.
    var spacer = buildCommon.makeSpan(["mspace"], [], options);
    spacer.style.marginRight = makeEm(slant);
    parts.unshift(spacer);
  }

  return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
};

// Limits, symbols
// Most operators have a large successor symbol, but these don't.
var noSuccessor = ["\\smallint"]; // NOTE: Unlike most `htmlBuilder`s, this one handles not only "op", but also
// "supsub" since some of them (like \int) can affect super/subscripting.

var htmlBuilder$2 = (grp, options) => {
  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;

  if (grp.type === "supsub") {
    // If we have limits, supsub will pass us its group to handle. Pull
    // out the superscript and subscript and set the group to the op in
    // its base.
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "op");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "op");
  }

  var style = options.style;
  var large = false;

  if (style.size === Style$1.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
    // Most symbol operators get larger in displaystyle (rule 13)
    large = true;
  }

  var base;

  if (group.symbol) {
    // If this is a symbol, create the symbol.
    var fontName = large ? "Size2-Regular" : "Size1-Regular";
    var stash = "";

    if (group.name === "\\oiint" || group.name === "\\oiiint") {
      // No font glyphs yet, so use a glyph w/o the oval.
      // TODO: When font glyphs are available, delete this code.
      stash = group.name.slice(1);
      group.name = stash === "oiint" ? "\\iint" : "\\iiint";
    }

    base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);

    if (stash.length > 0) {
      // We're in \oiint or \oiiint. Overlay the oval.
      // TODO: When font glyphs are available, delete this code.
      var italic = base.italic;
      var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
      base = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: base,
          shift: 0
        }, {
          type: "elem",
          elem: oval,
          shift: large ? 0.08 : 0
        }]
      }, options);
      group.name = "\\" + stash;
      base.classes.unshift("mop"); // $FlowFixMe

      base.italic = italic;
    }
  } else if (group.body) {
    // If this is a list, compose that list.
    var inner = buildExpression$1(group.body, options, true);

    if (inner.length === 1 && inner[0] instanceof SymbolNode) {
      base = inner[0];
      base.classes[0] = "mop"; // replace old mclass
    } else {
      base = buildCommon.makeSpan(["mop"], inner, options);
    }
  } else {
    // Otherwise, this is a text operator. Build the text from the
    // operator's name.
    var output = [];

    for (var i = 1; i < group.name.length; i++) {
      output.push(buildCommon.mathsym(group.name[i], group.mode, options));
    }

    base = buildCommon.makeSpan(["mop"], output, options);
  } // If content of op is a single symbol, shift it vertically.


  var baseShift = 0;
  var slant = 0;

  if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
    // We suppress the shift of the base of \overset and \underset. Otherwise,
    // shift the symbol so its center lies on the axis (rule 13). It
    // appears that our fonts have the centers of the symbols already
    // almost on the axis, so these numbers are very small. Note we
    // don't actually apply this here, but instead it is used either in
    // the vlist creation or separately when there are no limits.
    baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight; // The slant of the symbol is just its italic correction.
    // $FlowFixMe

    slant = base.italic;
  }

  if (hasLimits) {
    return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);
  } else {
    if (baseShift) {
      base.style.position = "relative";
      base.style.top = makeEm(baseShift);
    }

    return base;
  }
};

var mathmlBuilder$1 = (group, options) => {
  var node;

  if (group.symbol) {
    // This is a symbol. Just add the symbol.
    node = new MathNode("mo", [makeText(group.name, group.mode)]);

    if (utils.contains(noSuccessor, group.name)) {
      node.setAttribute("largeop", "false");
    }
  } else if (group.body) {
    // This is an operator with children. Add them.
    node = new MathNode("mo", buildExpression(group.body, options));
  } else {
    // This is a text operator. Add all of the characters from the
    // operator's name.
    node = new MathNode("mi", [new TextNode(group.name.slice(1))]); // Append an <mo>&ApplyFunction;</mo>.
    // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4

    var operator = new MathNode("mo", [makeText("\u2061", "text")]);

    if (group.parentIsSupSub) {
      node = new MathNode("mrow", [node, operator]);
    } else {
      node = newDocumentFragment([node, operator]);
    }
  }

  return node;
};

var singleCharBigOps = {
  "\u220F": "\\prod",
  "\u2210": "\\coprod",
  "\u2211": "\\sum",
  "\u22c0": "\\bigwedge",
  "\u22c1": "\\bigvee",
  "\u22c2": "\\bigcap",
  "\u22c3": "\\bigcup",
  "\u2a00": "\\bigodot",
  "\u2a01": "\\bigoplus",
  "\u2a02": "\\bigotimes",
  "\u2a04": "\\biguplus",
  "\u2a06": "\\bigsqcup"
};
defineFunction({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22c0", "\u22c1", "\u22c2", "\u22c3", "\u2a00", "\u2a01", "\u2a02", "\u2a04", "\u2a06"],
  props: {
    numArgs: 0
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var fName = funcName;

    if (fName.length === 1) {
      fName = singleCharBigOps[fName];
    }

    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
}); // Note: calling defineFunction with a type that's already been defined only
// works because the same htmlBuilder and mathmlBuilder are being used.

defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
}); // There are 2 flags for operators; whether they produce limits in
// displaystyle, and whether they are symbols and should grow in
// displaystyle. These four groups cover the four possible choices.

var singleCharIntegrals = {
  "\u222b": "\\int",
  "\u222c": "\\iint",
  "\u222d": "\\iiint",
  "\u222e": "\\oint",
  "\u222f": "\\oiint",
  "\u2230": "\\oiiint"
}; // No limits, not symbols

defineFunction({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },

  handler(_ref3) {
    var {
      parser,
      funcName
    } = _ref3;
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },

  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
}); // Limits, not symbols

defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },

  handler(_ref4) {
    var {
      parser,
      funcName
    } = _ref4;
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },

  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
}); // No limits, symbols

defineFunction({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222b", "\u222c", "\u222d", "\u222e", "\u222f", "\u2230"],
  props: {
    numArgs: 0
  },

  handler(_ref5) {
    var {
      parser,
      funcName
    } = _ref5;
    var fName = funcName;

    if (fName.length === 1) {
      fName = singleCharIntegrals[fName];
    }

    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },

  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});

// NOTE: Unlike most `htmlBuilder`s, this one handles not only
// "operatorname", but also  "supsub" since \operatorname* can
// affect super/subscripting.
var htmlBuilder$1 = (grp, options) => {
  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;

  if (grp.type === "supsub") {
    // If we have limits, supsub will pass us its group to handle. Pull
    // out the superscript and subscript and set the group to the op in
    // its base.
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "operatorname");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "operatorname");
  }

  var base;

  if (group.body.length > 0) {
    var body = group.body.map(child => {
      // $FlowFixMe: Check if the node has a string `text` property.
      var childText = child.text;

      if (typeof childText === "string") {
        return {
          type: "textord",
          mode: child.mode,
          text: childText
        };
      } else {
        return child;
      }
    }); // Consolidate function names into symbol characters.

    var expression = buildExpression$1(body, options.withFont("mathrm"), true);

    for (var i = 0; i < expression.length; i++) {
      var child = expression[i];

      if (child instanceof SymbolNode) {
        // Per amsopn package,
        // change minus to hyphen and \ast to asterisk
        child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
      }
    }

    base = buildCommon.makeSpan(["mop"], expression, options);
  } else {
    base = buildCommon.makeSpan(["mop"], [], options);
  }

  if (hasLimits) {
    return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
  } else {
    return base;
  }
};

var mathmlBuilder = (group, options) => {
  // The steps taken here are similar to the html version.
  var expression = buildExpression(group.body, options.withFont("mathrm")); // Is expression a string or has it something like a fraction?

  var isAllString = true; // default

  for (var i = 0; i < expression.length; i++) {
    var node = expression[i];

    if (node instanceof mathMLTree.SpaceNode) ; else if (node instanceof mathMLTree.MathNode) {
      switch (node.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        // Do nothing yet.

        case "mo":
          {
            var child = node.children[0];

            if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
              child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
            } else {
              isAllString = false;
            }

            break;
          }

        default:
          isAllString = false;
      }
    } else {
      isAllString = false;
    }
  }

  if (isAllString) {
    // Write a single TextNode instead of multiple nested tags.
    var word = expression.map(node => node.toText()).join("");
    expression = [new mathMLTree.TextNode(word)];
  }

  var identifier = new mathMLTree.MathNode("mi", expression);
  identifier.setAttribute("mathvariant", "normal"); // \u2061 is the same as &ApplyFunction;
  // ref: https://www.w3schools.com/charsets/ref_html_entities_a.asp

  var operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);

  if (group.parentIsSupSub) {
    return new mathMLTree.MathNode("mrow", [identifier, operator]);
  } else {
    return mathMLTree.newDocumentFragment([identifier, operator]);
  }
}; // \operatorname
// amsopn.dtx: \mathop{#1\kern\z@\operator@font#3}\newmcodes@


defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "operatorname",
      mode: parser.mode,
      body: ordargument(body),
      alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
      limits: false,
      parentIsSupSub: false
    };
  },
  htmlBuilder: htmlBuilder$1,
  mathmlBuilder
});
defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");

defineFunctionBuilders({
  type: "ordgroup",

  htmlBuilder(group, options) {
    if (group.semisimple) {
      return buildCommon.makeFragment(buildExpression$1(group.body, options, false));
    }

    return buildCommon.makeSpan(["mord"], buildExpression$1(group.body, options, true), options);
  },

  mathmlBuilder(group, options) {
    return buildExpressionRow(group.body, options, true);
  }

});

defineFunction({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },

  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var body = args[0];
    return {
      type: "overline",
      mode: parser.mode,
      body
    };
  },

  htmlBuilder(group, options) {
    // Overlines are handled in the TeXbook pg 443, Rule 9.
    // Build the inner group in the cramped style.
    var innerGroup = buildGroup$1(group.body, options.havingCrampedStyle()); // Create the line above the body

    var line = buildCommon.makeLineSpan("overline-line", options); // Generate the vlist, with the appropriate kerns

    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: innerGroup
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: defaultRuleThickness
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
  },

  mathmlBuilder(group, options) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203e")]);
    operator.setAttribute("stretchy", "true");
    var node = new mathMLTree.MathNode("mover", [buildGroup(group.body, options), operator]);
    node.setAttribute("accent", "true");
    return node;
  }

});

defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    var body = args[0];
    return {
      type: "phantom",
      mode: parser.mode,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options.withPhantom(), false); // \phantom isn't supposed to affect the elements it contains.
    // See "color" for more details.

    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    var inner = buildExpression(group.body, options);
    return new mathMLTree.MathNode("mphantom", inner);
  }
});
defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    return {
      type: "hphantom",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder: (group, options) => {
    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options.withPhantom())]);
    node.height = 0;
    node.depth = 0;

    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        node.children[i].height = 0;
        node.children[i].depth = 0;
      }
    } // See smash for comment re: use of makeVList


    node = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options); // For spacing, TeX treats \smash as a math group (same spacing as ord).

    return buildCommon.makeSpan(["mord"], [node], options);
  },
  mathmlBuilder: (group, options) => {
    var inner = buildExpression(ordargument(group.body), options);
    var phantom = new mathMLTree.MathNode("mphantom", inner);
    var node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("height", "0px");
    node.setAttribute("depth", "0px");
    return node;
  }
});
defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser
    } = _ref3;
    var body = args[0];
    return {
      type: "vphantom",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder: (group, options) => {
    var inner = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options.withPhantom())]);
    var fix = buildCommon.makeSpan(["fix"], []);
    return buildCommon.makeSpan(["mord", "rlap"], [inner, fix], options);
  },
  mathmlBuilder: (group, options) => {
    var inner = buildExpression(ordargument(group.body), options);
    var phantom = new mathMLTree.MathNode("mphantom", inner);
    var node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("width", "0px");
    return node;
  }
});

defineFunction({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },

  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var amount = assertNodeType(args[0], "size").value;
    var body = args[1];
    return {
      type: "raisebox",
      mode: parser.mode,
      dy: amount,
      body
    };
  },

  htmlBuilder(group, options) {
    var body = buildGroup$1(group.body, options);
    var dy = calculateSize(group.dy, options);
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: -dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },

  mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options)]);
    var dy = group.dy.number + group.dy.unit;
    node.setAttribute("voffset", dy);
    return node;
  }

});

defineFunction({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: true
  },

  handler(_ref) {
    var {
      parser
    } = _ref;
    return {
      type: "internal",
      mode: parser.mode
    };
  }

});

defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
  },

  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var shift = optArgs[0];
    var width = assertNodeType(args[0], "size");
    var height = assertNodeType(args[1], "size");
    return {
      type: "rule",
      mode: parser.mode,
      shift: shift && assertNodeType(shift, "size").value,
      width: width.value,
      height: height.value
    };
  },

  htmlBuilder(group, options) {
    // Make an empty span for the rule
    var rule = buildCommon.makeSpan(["mord", "rule"], [], options); // Calculate the shift, width, and height of the rule, and account for units

    var width = calculateSize(group.width, options);
    var height = calculateSize(group.height, options);
    var shift = group.shift ? calculateSize(group.shift, options) : 0; // Style the rule to the right size

    rule.style.borderRightWidth = makeEm(width);
    rule.style.borderTopWidth = makeEm(height);
    rule.style.bottom = makeEm(shift); // Record the height and width

    rule.width = width;
    rule.height = height + shift;
    rule.depth = -shift; // Font size is the number large enough that the browser will
    // reserve at least `absHeight` space above the baseline.
    // The 1.125 factor was empirically determined

    rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
    return rule;
  },

  mathmlBuilder(group, options) {
    var width = calculateSize(group.width, options);
    var height = calculateSize(group.height, options);
    var shift = group.shift ? calculateSize(group.shift, options) : 0;
    var color = options.color && options.getColor() || "black";
    var rule = new mathMLTree.MathNode("mspace");
    rule.setAttribute("mathbackground", color);
    rule.setAttribute("width", makeEm(width));
    rule.setAttribute("height", makeEm(height));
    var wrapper = new mathMLTree.MathNode("mpadded", [rule]);

    if (shift >= 0) {
      wrapper.setAttribute("height", makeEm(shift));
    } else {
      wrapper.setAttribute("height", makeEm(shift));
      wrapper.setAttribute("depth", makeEm(-shift));
    }

    wrapper.setAttribute("voffset", makeEm(shift));
    return wrapper;
  }

});

function sizingGroup(value, options, baseOptions) {
  var inner = buildExpression$1(value, options, false);
  var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier; // Add size-resetting classes to the inner list and set maxFontSize
  // manually. Handle nested size changes.

  for (var i = 0; i < inner.length; i++) {
    var pos = inner[i].classes.indexOf("sizing");

    if (pos < 0) {
      Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));
    } else if (inner[i].classes[pos + 1] === "reset-size" + options.size) {
      // This is a nested size change: e.g., inner[i] is the "b" in
      // `\Huge a \small b`. Override the old size (the `reset-` class)
      // but not the new size.
      inner[i].classes[pos + 1] = "reset-size" + baseOptions.size;
    }

    inner[i].height *= multiplier;
    inner[i].depth *= multiplier;
  }

  return buildCommon.makeFragment(inner);
}
var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
var htmlBuilder = (group, options) => {
  // Handle sizing operators like \Huge. Real TeX doesn't actually allow
  // these functions inside of math expressions, so we do some special
  // handling.
  var newOptions = options.havingSize(group.size);
  return sizingGroup(group.body, newOptions, options);
};
defineFunction({
  type: "sizing",
  names: sizeFuncs,
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      breakOnTokenText,
      funcName,
      parser
    } = _ref;
    var body = parser.parseExpression(false, breakOnTokenText);
    return {
      type: "sizing",
      mode: parser.mode,
      // Figure out what size to use based on the list of functions above
      size: sizeFuncs.indexOf(funcName) + 1,
      body
    };
  },
  htmlBuilder,
  mathmlBuilder: (group, options) => {
    var newOptions = options.havingSize(group.size);
    var inner = buildExpression(group.body, newOptions);
    var node = new mathMLTree.MathNode("mstyle", inner); // TODO(emily): This doesn't produce the correct size for nested size
    // changes, because we don't keep state of what style we're currently
    // in, so we can't reset the size to normal before changing it.  Now
    // that we're passing an options parameter we should be able to fix
    // this.

    node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
    return node;
  }
});

// smash, with optional [tb], as in AMS
defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser
    } = _ref;
    var smashHeight = false;
    var smashDepth = false;
    var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");

    if (tbArg) {
      // Optional [tb] argument is engaged.
      // ref: amsmath: \renewcommand{\smash}[1][tb]{%
      //               def\mb@t{\ht}\def\mb@b{\dp}\def\mb@tb{\ht\z@\z@\dp}%
      var letter = "";

      for (var i = 0; i < tbArg.body.length; ++i) {
        var node = tbArg.body[i]; // $FlowFixMe: Not every node type has a `text` property.

        letter = node.text;

        if (letter === "t") {
          smashHeight = true;
        } else if (letter === "b") {
          smashDepth = true;
        } else {
          smashHeight = false;
          smashDepth = false;
          break;
        }
      }
    } else {
      smashHeight = true;
      smashDepth = true;
    }

    var body = args[0];
    return {
      type: "smash",
      mode: parser.mode,
      body,
      smashHeight,
      smashDepth
    };
  },
  htmlBuilder: (group, options) => {
    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);

    if (!group.smashHeight && !group.smashDepth) {
      return node;
    }

    if (group.smashHeight) {
      node.height = 0; // In order to influence makeVList, we have to reset the children.

      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          node.children[i].height = 0;
        }
      }
    }

    if (group.smashDepth) {
      node.depth = 0;

      if (node.children) {
        for (var _i = 0; _i < node.children.length; _i++) {
          node.children[_i].depth = 0;
        }
      }
    } // At this point, we've reset the TeX-like height and depth values.
    // But the span still has an HTML line height.
    // makeVList applies "display: table-cell", which prevents the browser
    // from acting on that line height. So we'll call makeVList now.


    var smashedNode = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options); // For spacing, TeX treats \hphantom as a math group (same spacing as ord).

    return buildCommon.makeSpan(["mord"], [smashedNode], options);
  },
  mathmlBuilder: (group, options) => {
    var node = new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options)]);

    if (group.smashHeight) {
      node.setAttribute("height", "0px");
    }

    if (group.smashDepth) {
      node.setAttribute("depth", "0px");
    }

    return node;
  }
});

defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },

  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var index = optArgs[0];
    var body = args[0];
    return {
      type: "sqrt",
      mode: parser.mode,
      body,
      index
    };
  },

  htmlBuilder(group, options) {
    // Square roots are handled in the TeXbook pg. 443, Rule 11.
    // First, we do the same steps as in overline to build the inner group
    // and line
    var inner = buildGroup$1(group.body, options.havingCrampedStyle());

    if (inner.height === 0) {
      // Render a small surd.
      inner.height = options.fontMetrics().xHeight;
    } // Some groups can return document fragments.  Handle those by wrapping
    // them in a span.


    inner = buildCommon.wrapFragment(inner, options); // Calculate the minimum size for the \surd delimiter

    var metrics = options.fontMetrics();
    var theta = metrics.defaultRuleThickness;
    var phi = theta;

    if (options.style.id < Style$1.TEXT.id) {
      phi = options.fontMetrics().xHeight;
    } // Calculate the clearance between the body and line


    var lineClearance = theta + phi / 4;
    var minDelimiterHeight = inner.height + inner.depth + lineClearance + theta; // Create a sqrt SVG of the required minimum size

    var {
      span: img,
      ruleWidth,
      advanceWidth
    } = delimiter.sqrtImage(minDelimiterHeight, options);
    var delimDepth = img.height - ruleWidth; // Adjust the clearance based on the delimiter size

    if (delimDepth > inner.height + inner.depth + lineClearance) {
      lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;
    } // Shift the sqrt image


    var imgShift = img.height - inner.height - lineClearance - ruleWidth;
    inner.style.paddingLeft = makeEm(advanceWidth); // Overlay the image and the argument.

    var body = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: inner,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(inner.height + imgShift)
      }, {
        type: "elem",
        elem: img
      }, {
        type: "kern",
        size: ruleWidth
      }]
    }, options);

    if (!group.index) {
      return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
    } else {
      // Handle the optional root index
      // The index is always in scriptscript style
      var newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);
      var rootm = buildGroup$1(group.index, newOptions, options); // The amount the index is shifted by. This is taken from the TeX
      // source, in the definition of `\r@@t`.

      var toShift = 0.6 * (body.height - body.depth); // Build a VList with the superscript shifted up correctly

      var rootVList = buildCommon.makeVList({
        positionType: "shift",
        positionData: -toShift,
        children: [{
          type: "elem",
          elem: rootm
        }]
      }, options); // Add a class surrounding it so we can add on the appropriate
      // kerning

      var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
      return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
    }
  },

  mathmlBuilder(group, options) {
    var {
      body,
      index
    } = group;
    return index ? new mathMLTree.MathNode("mroot", [buildGroup(body, options), buildGroup(index, options)]) : new mathMLTree.MathNode("msqrt", [buildGroup(body, options)]);
  }

});

var styleMap = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },

  handler(_ref, args) {
    var {
      breakOnTokenText,
      funcName,
      parser
    } = _ref;
    // parse out the implicit body
    var body = parser.parseExpression(true, breakOnTokenText); // TODO: Refactor to avoid duplicating styleMap in multiple places (e.g.
    // here and in buildHTML and de-dupe the enumeration of all the styles).
    // $FlowFixMe: The names above exactly match the styles.

    var style = funcName.slice(1, funcName.length - 5);
    return {
      type: "styling",
      mode: parser.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style,
      body
    };
  },

  htmlBuilder(group, options) {
    // Style changes are handled in the TeXbook on pg. 442, Rule 3.
    var newStyle = styleMap[group.style];
    var newOptions = options.havingStyle(newStyle).withFont('');
    return sizingGroup(group.body, newOptions, options);
  },

  mathmlBuilder(group, options) {
    // Figure out what style we're changing to.
    var newStyle = styleMap[group.style];
    var newOptions = options.havingStyle(newStyle);
    var inner = buildExpression(group.body, newOptions);
    var node = new mathMLTree.MathNode("mstyle", inner);
    var styleAttributes = {
      "display": ["0", "true"],
      "text": ["0", "false"],
      "script": ["1", "false"],
      "scriptscript": ["2", "false"]
    };
    var attr = styleAttributes[group.style];
    node.setAttribute("scriptlevel", attr[0]);
    node.setAttribute("displaystyle", attr[1]);
    return node;
  }

});

/**
 * Sometimes, groups perform special rules when they have superscripts or
 * subscripts attached to them. This function lets the `supsub` group know that
 * Sometimes, groups perform special rules when they have superscripts or
 * its inner element should handle the superscripts and subscripts instead of
 * handling them itself.
 */
var htmlBuilderDelegate = function htmlBuilderDelegate(group, options) {
  var base = group.base;

  if (!base) {
    return null;
  } else if (base.type === "op") {
    // Operators handle supsubs differently when they have limits
    // (e.g. `\displaystyle\sum_2^3`)
    var delegate = base.limits && (options.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);
    return delegate ? htmlBuilder$2 : null;
  } else if (base.type === "operatorname") {
    var _delegate = base.alwaysHandleSupSub && (options.style.size === Style$1.DISPLAY.size || base.limits);

    return _delegate ? htmlBuilder$1 : null;
  } else if (base.type === "accent") {
    return utils.isCharacterBox(base.base) ? htmlBuilder$a : null;
  } else if (base.type === "horizBrace") {
    var isSup = !group.sub;
    return isSup === base.isOver ? htmlBuilder$3 : null;
  } else {
    return null;
  }
}; // Super scripts and subscripts, whose precise placement can depend on other
// functions that precede them.


defineFunctionBuilders({
  type: "supsub",

  htmlBuilder(group, options) {
    // Superscript and subscripts are handled in the TeXbook on page
    // 445-446, rules 18(a-f).
    // Here is where we defer to the inner group if it should handle
    // superscripts and subscripts itself.
    var builderDelegate = htmlBuilderDelegate(group, options);

    if (builderDelegate) {
      return builderDelegate(group, options);
    }

    var {
      base: valueBase,
      sup: valueSup,
      sub: valueSub
    } = group;
    var base = buildGroup$1(valueBase, options);
    var supm;
    var subm;
    var metrics = options.fontMetrics(); // Rule 18a

    var supShift = 0;
    var subShift = 0;
    var isCharacterBox = valueBase && utils.isCharacterBox(valueBase);

    if (valueSup) {
      var newOptions = options.havingStyle(options.style.sup());
      supm = buildGroup$1(valueSup, newOptions, options);

      if (!isCharacterBox) {
        supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    }

    if (valueSub) {
      var _newOptions = options.havingStyle(options.style.sub());

      subm = buildGroup$1(valueSub, _newOptions, options);

      if (!isCharacterBox) {
        subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    } // Rule 18c


    var minSupShift;

    if (options.style === Style$1.DISPLAY) {
      minSupShift = metrics.sup1;
    } else if (options.style.cramped) {
      minSupShift = metrics.sup3;
    } else {
      minSupShift = metrics.sup2;
    } // scriptspace is a font-size-independent size, so scale it
    // appropriately for use as the marginRight.


    var multiplier = options.sizeMultiplier;
    var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
    var marginLeft = null;

    if (subm) {
      // Subscripts shouldn't be shifted by the base's italic correction.
      // Account for that by shifting the subscript back the appropriate
      // amount. Note we only do this when the base is a single symbol.
      var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");

      if (base instanceof SymbolNode || isOiint) {
        // $FlowFixMe
        marginLeft = makeEm(-base.italic);
      }
    }

    var supsub;

    if (supm && subm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      subShift = Math.max(subShift, metrics.sub2);
      var ruleWidth = metrics.defaultRuleThickness; // Rule 18e

      var maxWidth = 4 * ruleWidth;

      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
        subShift = maxWidth - (supShift - supm.depth) + subm.height;
        var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);

        if (psi > 0) {
          supShift += psi;
          subShift -= psi;
        }
      }

      var vlistElem = [{
        type: "elem",
        elem: subm,
        shift: subShift,
        marginRight,
        marginLeft
      }, {
        type: "elem",
        elem: supm,
        shift: -supShift,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "individualShift",
        children: vlistElem
      }, options);
    } else if (subm) {
      // Rule 18b
      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
      var _vlistElem = [{
        type: "elem",
        elem: subm,
        marginLeft,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: subShift,
        children: _vlistElem
      }, options);
    } else if (supm) {
      // Rule 18c, d
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: -supShift,
        children: [{
          type: "elem",
          elem: supm,
          marginRight
        }]
      }, options);
    } else {
      throw new Error("supsub must have either sup or sub.");
    } // Wrap the supsub vlist in a span.msupsub to reset text-align.


    var mclass = getTypeOfDomTree(base, "right") || "mord";
    return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
  },

  mathmlBuilder(group, options) {
    // Is the inner group a relevant horizonal brace?
    var isBrace = false;
    var isOver;
    var isSup;

    if (group.base && group.base.type === "horizBrace") {
      isSup = !!group.sup;

      if (isSup === group.base.isOver) {
        isBrace = true;
        isOver = group.base.isOver;
      }
    }

    if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
      group.base.parentIsSupSub = true;
    }

    var children = [buildGroup(group.base, options)];

    if (group.sub) {
      children.push(buildGroup(group.sub, options));
    }

    if (group.sup) {
      children.push(buildGroup(group.sup, options));
    }

    var nodeType;

    if (isBrace) {
      nodeType = isOver ? "mover" : "munder";
    } else if (!group.sub) {
      var base = group.base;

      if (base && base.type === "op" && base.limits && (options.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {
        nodeType = "mover";
      } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === Style$1.DISPLAY)) {
        nodeType = "mover";
      } else {
        nodeType = "msup";
      }
    } else if (!group.sup) {
      var _base = group.base;

      if (_base && _base.type === "op" && _base.limits && (options.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {
        nodeType = "munder";
      } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === Style$1.DISPLAY)) {
        nodeType = "munder";
      } else {
        nodeType = "msub";
      }
    } else {
      var _base2 = group.base;

      if (_base2 && _base2.type === "op" && _base2.limits && options.style === Style$1.DISPLAY) {
        nodeType = "munderover";
      } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === Style$1.DISPLAY || _base2.limits)) {
        nodeType = "munderover";
      } else {
        nodeType = "msubsup";
      }
    }

    return new mathMLTree.MathNode(nodeType, children);
  }

});

defineFunctionBuilders({
  type: "atom",

  htmlBuilder(group, options) {
    return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
  },

  mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);

    if (group.family === "bin") {
      var variant = getVariant(group, options);

      if (variant === "bold-italic") {
        node.setAttribute("mathvariant", variant);
      }
    } else if (group.family === "punct") {
      node.setAttribute("separator", "true");
    } else if (group.family === "open" || group.family === "close") {
      // Delims built here should not stretch vertically.
      // See delimsizing.js for stretchy delims.
      node.setAttribute("stretchy", "false");
    }

    return node;
  }

});

// "mathord" and "textord" ParseNodes created in Parser.js from symbol Groups in
// src/symbols.js.
var defaultVariant = {
  "mi": "italic",
  "mn": "normal",
  "mtext": "normal"
};
defineFunctionBuilders({
  type: "mathord",

  htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "mathord");
  },

  mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
    var variant = getVariant(group, options) || "italic";

    if (variant !== defaultVariant[node.type]) {
      node.setAttribute("mathvariant", variant);
    }

    return node;
  }

});
defineFunctionBuilders({
  type: "textord",

  htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "textord");
  },

  mathmlBuilder(group, options) {
    var text = makeText(group.text, group.mode, options);
    var variant = getVariant(group, options) || "normal";
    var node;

    if (group.mode === 'text') {
      node = new mathMLTree.MathNode("mtext", [text]);
    } else if (/[0-9]/.test(group.text)) {
      node = new mathMLTree.MathNode("mn", [text]);
    } else if (group.text === "\\prime") {
      node = new mathMLTree.MathNode("mo", [text]);
    } else {
      node = new mathMLTree.MathNode("mi", [text]);
    }

    if (variant !== defaultVariant[node.type]) {
      node.setAttribute("mathvariant", variant);
    }

    return node;
  }

});

var cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}; // A lookup table to determine whether a spacing function/symbol should be
// treated like a regular space character.  If a symbol or command is a key
// in this table, then it should be a regular space character.  Furthermore,
// the associated value may have a `className` specifying an extra CSS class
// to add to the created `span`.

var regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
}; // ParseNode<"spacing"> created in Parser.js from the "spacing" symbol Groups in
// src/symbols.js.

defineFunctionBuilders({
  type: "spacing",

  htmlBuilder(group, options) {
    if (regularSpace.hasOwnProperty(group.text)) {
      var className = regularSpace[group.text].className || ""; // Spaces are generated by adding an actual space. Each of these
      // things has an entry in the symbols table, so these will be turned
      // into appropriate outputs.

      if (group.mode === "text") {
        var ord = buildCommon.makeOrd(group, options, "textord");
        ord.classes.push(className);
        return ord;
      } else {
        return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
      }
    } else if (cssSpace.hasOwnProperty(group.text)) {
      // Spaces based on just a CSS class.
      return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
    } else {
      throw new ParseError("Unknown type of space \"" + group.text + "\"");
    }
  },

  mathmlBuilder(group, options) {
    var node;

    if (regularSpace.hasOwnProperty(group.text)) {
      node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\u00a0")]);
    } else if (cssSpace.hasOwnProperty(group.text)) {
      // CSS-based MathML spaces (\nobreak, \allowbreak) are ignored
      return new mathMLTree.MathNode("mspace");
    } else {
      throw new ParseError("Unknown type of space \"" + group.text + "\"");
    }

    return node;
  }

});

var pad = () => {
  var padNode = new mathMLTree.MathNode("mtd", []);
  padNode.setAttribute("width", "50%");
  return padNode;
};

defineFunctionBuilders({
  type: "tag",

  mathmlBuilder(group, options) {
    var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
    table.setAttribute("width", "100%");
    return table; // TODO: Left-aligned tags.
    // Currently, the group and options passed here do not contain
    // enough info to set tag alignment. `leqno` is in Settings but it is
    // not passed to Options. On the HTML side, leqno is
    // set by a CSS class applied in buildTree.js. That would have worked
    // in MathML if browsers supported <mlabeledtr>. Since they don't, we
    // need to rewrite the way this function is called.
  }

});

var textFontFamilies = {
  "\\text": undefined,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
};
var textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};
var textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
};

var optionsWithFont = (group, options) => {
  var font = group.font; // Checks if the argument is a font family or a font style.

  if (!font) {
    return options;
  } else if (textFontFamilies[font]) {
    return options.withTextFontFamily(textFontFamilies[font]);
  } else if (textFontWeights[font]) {
    return options.withTextFontWeight(textFontWeights[font]);
  } else {
    return options.withTextFontShape(textFontShapes[font]);
  }
};

defineFunction({
  type: "text",
  names: [// Font families
  "\\text", "\\textrm", "\\textsf", "\\texttt", "\\textnormal", // Font weights
  "\\textbf", "\\textmd", // Font Shapes
  "\\textit", "\\textup"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },

  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "text",
      mode: parser.mode,
      body: ordargument(body),
      font: funcName
    };
  },

  htmlBuilder(group, options) {
    var newOptions = optionsWithFont(group, options);
    var inner = buildExpression$1(group.body, newOptions, true);
    return buildCommon.makeSpan(["mord", "text"], inner, newOptions);
  },

  mathmlBuilder(group, options) {
    var newOptions = optionsWithFont(group, options);
    return buildExpressionRow(group.body, newOptions);
  }

});

defineFunction({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },

  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "underline",
      mode: parser.mode,
      body: args[0]
    };
  },

  htmlBuilder(group, options) {
    // Underlines are handled in the TeXbook pg 443, Rule 10.
    // Build the inner group.
    var innerGroup = buildGroup$1(group.body, options); // Create the line to go below the body

    var line = buildCommon.makeLineSpan("underline-line", options); // Generate the vlist, with the appropriate kerns

    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "kern",
        size: defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
  },

  mathmlBuilder(group, options) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203e")]);
    operator.setAttribute("stretchy", "true");
    var node = new mathMLTree.MathNode("munder", [buildGroup(group.body, options), operator]);
    node.setAttribute("accentunder", "true");
    return node;
  }

});

defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: false
  },

  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "vcenter",
      mode: parser.mode,
      body: args[0]
    };
  },

  htmlBuilder(group, options) {
    var body = buildGroup$1(group.body, options);
    var axisHeight = options.fontMetrics().axisHeight;
    var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },

  mathmlBuilder(group, options) {
    // There is no way to do this in MathML.
    // Write a class as a breadcrumb in case some post-processor wants
    // to perform a vcenter adjustment.
    return new mathMLTree.MathNode("mpadded", [buildGroup(group.body, options)], ["vcenter"]);
  }

});

defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },

  handler(context, args, optArgs) {
    // \verb and \verb* are dealt with directly in Parser.js.
    // If we end up here, it's because of a failure to match the two delimiters
    // in the regex in Lexer.js.  LaTeX raises the following error when \verb is
    // terminated by end of line (or file).
    throw new ParseError("\\verb ended by end of line instead of matching delimiter");
  },

  htmlBuilder(group, options) {
    var text = makeVerb(group);
    var body = []; // \verb enters text mode and therefore is sized like \textstyle

    var newOptions = options.havingStyle(options.style.text());

    for (var i = 0; i < text.length; i++) {
      var c = text[i];

      if (c === '~') {
        c = '\\textasciitilde';
      }

      body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
    }

    return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
  },

  mathmlBuilder(group, options) {
    var text = new mathMLTree.TextNode(makeVerb(group));
    var node = new mathMLTree.MathNode("mtext", [text]);
    node.setAttribute("mathvariant", "monospace");
    return node;
  }

});
/**
 * Converts verb group into body string.
 *
 * \verb* replaces each space with an open box \u2423
 * \verb replaces each space with a no-break space \xA0
 */

var makeVerb = group => group.body.replace(/ /g, group.star ? '\u2423' : '\xA0');

/** Include this to ensure that all functions are defined. */
var functions = _functions;

/**
 * The Lexer class handles tokenizing the input in various ways. Since our
 * parser expects us to be able to backtrack, the lexer allows lexing from any
 * given starting point.
 *
 * Its main exposed function is the `lex` function, which takes a position to
 * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
 * function.
 *
 * The various `_innerLex` functions perform the actual lexing of different
 * kinds.
 */

/* The following tokenRegex
 * - matches typical whitespace (but not NBSP etc.) using its first group
 * - does not match any control character \x00-\x1f except whitespace
 * - does not match a bare backslash
 * - matches any ASCII character except those just mentioned
 * - does not match the BMP private use area \uE000-\uF8FF
 * - does not match bare surrogate code units
 * - matches any BMP character except for those just described
 * - matches any valid Unicode surrogate pair
 * - matches a backslash followed by one or more whitespace characters
 * - matches a backslash followed by one or more letters then whitespace
 * - matches a backslash followed by any BMP character
 * Capturing groups:
 *   [1] regular whitespace
 *   [2] backslash followed by whitespace
 *   [3] anything else, which may include:
 *     [4] left character of \verb*
 *     [5] left character of \verb
 *     [6] backslash followed by word, excluding any trailing whitespace
 * Just because the Lexer matches something doesn't mean it's valid input:
 * If there is no matching function or symbol definition, the Parser will
 * still reject the input.
 */
var spaceRegexString = "[ \r\n\t]";
var controlWordRegexString = "\\\\[a-zA-Z@]+";
var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
var controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
var controlSpaceRegexString = "\\\\(\n|[ \r\t]+\n?)[ \r\t]*";
var combiningDiacriticalMarkString = "[\u0300-\u036f]";
var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
var tokenRegexString = "(" + spaceRegexString + "+)|" + ( // whitespace
controlSpaceRegexString + "|") + // \whitespace
"([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + ( // single codepoint
combiningDiacriticalMarkString + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + ( // surrogate pair
combiningDiacriticalMarkString + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4" + // \verb*
"|\\\\verb([^*a-zA-Z]).*?\\5" + ( // \verb unstarred
"|" + controlWordWhitespaceRegexString) + ( // \macroName + spaces
"|" + controlSymbolRegexString + ")"); // \\, \', etc.

/** Main Lexer class */

class Lexer {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(input, settings) {
    this.input = void 0;
    this.settings = void 0;
    this.tokenRegex = void 0;
    this.catcodes = void 0;
    // Separate accents from characters
    this.input = input;
    this.settings = settings;
    this.tokenRegex = new RegExp(tokenRegexString, 'g');
    this.catcodes = {
      "%": 14,
      // comment character
      "~": 13 // active character

    };
  }

  setCatcode(char, code) {
    this.catcodes[char] = code;
  }
  /**
   * This function lexes a single token.
   */


  lex() {
    var input = this.input;
    var pos = this.tokenRegex.lastIndex;

    if (pos === input.length) {
      return new Token("EOF", new SourceLocation(this, pos, pos));
    }

    var match = this.tokenRegex.exec(input);

    if (match === null || match.index !== pos) {
      throw new ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
    }

    var text = match[6] || match[3] || (match[2] ? "\\ " : " ");

    if (this.catcodes[text] === 14) {
      // comment character
      var nlIndex = input.indexOf('\n', this.tokenRegex.lastIndex);

      if (nlIndex === -1) {
        this.tokenRegex.lastIndex = input.length; // EOF

        this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would " + "fail because of commenting the end of math mode (e.g. $)");
      } else {
        this.tokenRegex.lastIndex = nlIndex + 1;
      }

      return this.lex();
    }

    return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
  }

}

/**
 * A `Namespace` refers to a space of nameable things like macros or lengths,
 * which can be `set` either globally or local to a nested group, using an
 * undo stack similar to how TeX implements this functionality.
 * Performance-wise, `get` and local `set` take constant time, while global
 * `set` takes time proportional to the depth of group nesting.
 */
class Namespace {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(builtins, globalMacros) {
    if (builtins === void 0) {
      builtins = {};
    }

    if (globalMacros === void 0) {
      globalMacros = {};
    }

    this.current = void 0;
    this.builtins = void 0;
    this.undefStack = void 0;
    this.current = globalMacros;
    this.builtins = builtins;
    this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */


  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */


  endGroup() {
    if (this.undefStack.length === 0) {
      throw new ParseError("Unbalanced namespace destruction: attempt " + "to pop global namespace; please report this as a bug");
    }

    var undefs = this.undefStack.pop();

    for (var undef in undefs) {
      if (undefs.hasOwnProperty(undef)) {
        if (undefs[undef] == null) {
          delete this.current[undef];
        } else {
          this.current[undef] = undefs[undef];
        }
      }
    }
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */


  endGroups() {
    while (this.undefStack.length > 0) {
      this.endGroup();
    }
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */


  has(name) {
    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */


  get(name) {
    if (this.current.hasOwnProperty(name)) {
      return this.current[name];
    } else {
      return this.builtins[name];
    }
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */


  set(name, value, global) {
    if (global === void 0) {
      global = false;
    }

    if (global) {
      // Global set is equivalent to setting in all groups.  Simulate this
      // by destroying any undos currently scheduled for this name,
      // and adding an undo with the *new* value (in case it later gets
      // locally reset within this environment).
      for (var i = 0; i < this.undefStack.length; i++) {
        delete this.undefStack[i][name];
      }

      if (this.undefStack.length > 0) {
        this.undefStack[this.undefStack.length - 1][name] = value;
      }
    } else {
      // Undo this set at end of this group (possibly to `undefined`),
      // unless an undo is already in place, in which case that older
      // value is the correct one.
      var top = this.undefStack[this.undefStack.length - 1];

      if (top && !top.hasOwnProperty(name)) {
        top[name] = this.current[name];
      }
    }

    if (value == null) {
      delete this.current[name];
    } else {
      this.current[name] = value;
    }
  }

}

/**
 * Predefined macros for KaTeX.
 * This can be used to define some commands in terms of others.
 */
var macros = _macros;
// macro tools

defineMacro("\\noexpand", function (context) {
  // The expansion is the token itself; but that token is interpreted
  // as if its meaning were ‘\relax’ if it is a control sequence that
  // would ordinarily be expanded by TeX’s expansion rules.
  var t = context.popToken();

  if (context.isExpandable(t.text)) {
    t.noexpand = true;
    t.treatAsRelax = true;
  }

  return {
    tokens: [t],
    numArgs: 0
  };
});
defineMacro("\\expandafter", function (context) {
  // TeX first reads the token that comes immediately after \expandafter,
  // without expanding it; let’s call this token t. Then TeX reads the
  // token that comes after t (and possibly more tokens, if that token
  // has an argument), replacing it by its expansion. Finally TeX puts
  // t back in front of that expansion.
  var t = context.popToken();
  context.expandOnce(true); // expand only an expandable token

  return {
    tokens: [t],
    numArgs: 0
  };
}); // LaTeX's \@firstoftwo{#1}{#2} expands to #1, skipping #2
// TeX source: \long\def\@firstoftwo#1#2{#1}

defineMacro("\\@firstoftwo", function (context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[0],
    numArgs: 0
  };
}); // LaTeX's \@secondoftwo{#1}{#2} expands to #2, skipping #1
// TeX source: \long\def\@secondoftwo#1#2{#2}

defineMacro("\\@secondoftwo", function (context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[1],
    numArgs: 0
  };
}); // LaTeX's \@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)
// symbol that isn't a space, consuming any spaces but not consuming the
// first nonspace character.  If that nonspace character matches #1, then
// the macro expands to #2; otherwise, it expands to #3.

defineMacro("\\@ifnextchar", function (context) {
  var args = context.consumeArgs(3); // symbol, if, else

  context.consumeSpaces();
  var nextToken = context.future();

  if (args[0].length === 1 && args[0][0].text === nextToken.text) {
    return {
      tokens: args[1],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[2],
      numArgs: 0
    };
  }
}); // LaTeX's \@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.
// If it is `*`, then it consumes the symbol, and the macro expands to #1;
// otherwise, the macro expands to #2 (without consuming the symbol).
// TeX source: \def\@ifstar#1{\@ifnextchar *{\@firstoftwo{#1}}}

defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}"); // LaTeX's \TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode

defineMacro("\\TextOrMath", function (context) {
  var args = context.consumeArgs(2);

  if (context.mode === 'text') {
    return {
      tokens: args[0],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[1],
      numArgs: 0
    };
  }
}); // Lookup table for parsing numbers in base 8 through 16

var digitToNumber = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  "a": 10,
  "A": 10,
  "b": 11,
  "B": 11,
  "c": 12,
  "C": 12,
  "d": 13,
  "D": 13,
  "e": 14,
  "E": 14,
  "f": 15,
  "F": 15
}; // TeX \char makes a literal character (catcode 12) using the following forms:
// (see The TeXBook, p. 43)
//   \char123  -- decimal
//   \char'123 -- octal
//   \char"123 -- hex
//   \char`x   -- character that can be written (i.e. isn't active)
//   \char`\x  -- character that cannot be written (e.g. %)
// These all refer to characters from the font, so we turn them into special
// calls to a function \@char dealt with in the Parser.

defineMacro("\\char", function (context) {
  var token = context.popToken();
  var base;
  var number = '';

  if (token.text === "'") {
    base = 8;
    token = context.popToken();
  } else if (token.text === '"') {
    base = 16;
    token = context.popToken();
  } else if (token.text === "`") {
    token = context.popToken();

    if (token.text[0] === "\\") {
      number = token.text.charCodeAt(1);
    } else if (token.text === "EOF") {
      throw new ParseError("\\char` missing argument");
    } else {
      number = token.text.charCodeAt(0);
    }
  } else {
    base = 10;
  }

  if (base) {
    // Parse a number in the given base, starting with first `token`.
    number = digitToNumber[token.text];

    if (number == null || number >= base) {
      throw new ParseError("Invalid base-" + base + " digit " + token.text);
    }

    var digit;

    while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
      number *= base;
      number += digit;
      context.popToken();
    }
  }

  return "\\@char{" + number + "}";
}); // \newcommand{\macro}[args]{definition}
// \renewcommand{\macro}[args]{definition}
// TODO: Optional arguments: \newcommand{\macro}[args][default]{definition}

var newcommand = (context, existsOK, nonexistsOK) => {
  var arg = context.consumeArg().tokens;

  if (arg.length !== 1) {
    throw new ParseError("\\newcommand's first argument must be a macro name");
  }

  var name = arg[0].text;
  var exists = context.isDefined(name);

  if (exists && !existsOK) {
    throw new ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
  }

  if (!exists && !nonexistsOK) {
    throw new ParseError("\\renewcommand{" + name + "} when command " + name + " " + "does not yet exist; use \\newcommand");
  }

  var numArgs = 0;
  arg = context.consumeArg().tokens;

  if (arg.length === 1 && arg[0].text === "[") {
    var argText = '';
    var token = context.expandNextToken();

    while (token.text !== "]" && token.text !== "EOF") {
      // TODO: Should properly expand arg, e.g., ignore {}s
      argText += token.text;
      token = context.expandNextToken();
    }

    if (!argText.match(/^\s*[0-9]+\s*$/)) {
      throw new ParseError("Invalid number of arguments: " + argText);
    }

    numArgs = parseInt(argText);
    arg = context.consumeArg().tokens;
  } // Final arg is the expansion of the macro


  context.macros.set(name, {
    tokens: arg,
    numArgs
  });
  return '';
};

defineMacro("\\newcommand", context => newcommand(context, false, true));
defineMacro("\\renewcommand", context => newcommand(context, true, false));
defineMacro("\\providecommand", context => newcommand(context, true, true)); // terminal (console) tools

defineMacro("\\message", context => {
  var arg = context.consumeArgs(1)[0]; // eslint-disable-next-line no-console

  console.log(arg.reverse().map(token => token.text).join(""));
  return '';
});
defineMacro("\\errmessage", context => {
  var arg = context.consumeArgs(1)[0]; // eslint-disable-next-line no-console

  console.error(arg.reverse().map(token => token.text).join(""));
  return '';
});
defineMacro("\\show", context => {
  var tok = context.popToken();
  var name = tok.text; // eslint-disable-next-line no-console

  console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);
  return '';
}); //////////////////////////////////////////////////////////////////////
// Grouping
// \let\bgroup={ \let\egroup=}

defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}"); // Symbols from latex.ltx:
// \def~{\nobreakspace{}}
// \def\lq{`}
// \def\rq{'}
// \def \aa {\r a}
// \def \AA {\r A}

defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");
defineMacro("\\AA", "\\r A"); // Copyright (C) and registered (R) symbols. Use raw symbol in MathML.
// \DeclareTextCommandDefault{\textcopyright}{\textcircled{c}}
// \DeclareTextCommandDefault{\textregistered}{\textcircled{%
//      \check@mathfonts\fontsize\sf@size\z@\math@fontsfalse\selectfont R}}
// \DeclareRobustCommand{\copyright}{%
//    \ifmmode{\nfss@text{\textcopyright}}\else\textcopyright\fi}

defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}"); // Characters omitted from Unicode range 1D400–1D7FF

defineMacro("\u212C", "\\mathscr{B}"); // script

defineMacro("\u2130", "\\mathscr{E}");
defineMacro("\u2131", "\\mathscr{F}");
defineMacro("\u210B", "\\mathscr{H}");
defineMacro("\u2110", "\\mathscr{I}");
defineMacro("\u2112", "\\mathscr{L}");
defineMacro("\u2133", "\\mathscr{M}");
defineMacro("\u211B", "\\mathscr{R}");
defineMacro("\u212D", "\\mathfrak{C}"); // Fraktur

defineMacro("\u210C", "\\mathfrak{H}");
defineMacro("\u2128", "\\mathfrak{Z}"); // Define \Bbbk with a macro that works in both HTML and MathML.

defineMacro("\\Bbbk", "\\Bbb{k}"); // Unicode middle dot
// The KaTeX fonts do not contain U+00B7. Instead, \cdotp displays
// the dot at U+22C5 and gives it punct spacing.

defineMacro("\u00b7", "\\cdotp"); // \llap and \rlap render their contents in text mode

defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
defineMacro("\\clap", "\\mathclap{\\textrm{#1}}"); // \mathstrut from the TeXbook, p 360

defineMacro("\\mathstrut", "\\vphantom{(}"); // \underbar from TeXbook p 353

defineMacro("\\underbar", "\\underline{\\text{#1}}"); // \not is defined by base/fontmath.ltx via
// \DeclareMathSymbol{\not}{\mathrel}{symbols}{"36}
// It's thus treated like a \mathrel, but defined by a symbol that has zero
// width but extends to the right.  We use \rlap to get that spacing.
// For MathML we write U+0338 here. buildMathML.js will then do the overlay.

defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}'); // Negated symbols from base/fontmath.ltx:
// \def\neq{\not=} \let\ne=\neq
// \DeclareRobustCommand
//   \notin{\mathrel{\m@th\mathpalette\c@ncel\in}}
// \def\c@ncel#1#2{\m@th\ooalign{$\hfil#1\mkern1mu/\hfil$\crcr$#1#2$}}

defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
defineMacro("\\ne", "\\neq");
defineMacro("\u2260", "\\neq");
defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}" + "{\\mathrel{\\char`∉}}");
defineMacro("\u2209", "\\notin"); // Unicode stacked relations

defineMacro("\u2258", "\\html@mathml{" + "\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}" + "}{\\mathrel{\\char`\u2258}}");
defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}" + "{\\mathrel{\\char`\u225B}}");
defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}" + "{\\mathrel{\\char`\u225D}}");
defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}" + "{\\mathrel{\\char`\u225E}}");
defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}"); // Misc Unicode

defineMacro("\u27C2", "\\perp");
defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
defineMacro("\u220C", "\\notni");
defineMacro("\u231C", "\\ulcorner");
defineMacro("\u231D", "\\urcorner");
defineMacro("\u231E", "\\llcorner");
defineMacro("\u231F", "\\lrcorner");
defineMacro("\u00A9", "\\copyright");
defineMacro("\u00AE", "\\textregistered");
defineMacro("\uFE0F", "\\textregistered"); // The KaTeX fonts have corners at codepoints that don't match Unicode.
// For MathML purposes, use the Unicode code point.

defineMacro("\\ulcorner", "\\html@mathml{\\@ulcorner}{\\mathop{\\char\"231c}}");
defineMacro("\\urcorner", "\\html@mathml{\\@urcorner}{\\mathop{\\char\"231d}}");
defineMacro("\\llcorner", "\\html@mathml{\\@llcorner}{\\mathop{\\char\"231e}}");
defineMacro("\\lrcorner", "\\html@mathml{\\@lrcorner}{\\mathop{\\char\"231f}}"); //////////////////////////////////////////////////////////////////////
// LaTeX_2ε
// \vdots{\vbox{\baselineskip4\p@  \lineskiplimit\z@
// \kern6\p@\hbox{.}\hbox{.}\hbox{.}}}
// We'll call \varvdots, which gets a glyph from symbols.js.
// The zero-width rule gets us an equivalent to the vertical 6pt kern.

defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("\u22ee", "\\vdots"); //////////////////////////////////////////////////////////////////////
// amsmath.sty
// http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf
// Italic Greek capital letters.  AMS defines these with \DeclareMathSymbol,
// but they are equivalent to \mathit{\Letter}.

defineMacro("\\varGamma", "\\mathit{\\Gamma}");
defineMacro("\\varDelta", "\\mathit{\\Delta}");
defineMacro("\\varTheta", "\\mathit{\\Theta}");
defineMacro("\\varLambda", "\\mathit{\\Lambda}");
defineMacro("\\varXi", "\\mathit{\\Xi}");
defineMacro("\\varPi", "\\mathit{\\Pi}");
defineMacro("\\varSigma", "\\mathit{\\Sigma}");
defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
defineMacro("\\varPhi", "\\mathit{\\Phi}");
defineMacro("\\varPsi", "\\mathit{\\Psi}");
defineMacro("\\varOmega", "\\mathit{\\Omega}"); //\newcommand{\substack}[1]{\subarray{c}#1\endsubarray}

defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}"); // \renewcommand{\colon}{\nobreak\mskip2mu\mathpunct{}\nonscript
// \mkern-\thinmuskip{:}\mskip6muplus1mu\relax}

defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}" + "\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax"); // \newcommand{\boxed}[1]{\fbox{\m@th$\displaystyle#1$}}

defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}"); // \def\iff{\DOTSB\;\Longleftrightarrow\;}
// \def\implies{\DOTSB\;\Longrightarrow\;}
// \def\impliedby{\DOTSB\;\Longleftarrow\;}

defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;"); // AMSMath's automatic \dots, based on \mdots@@ macro.

var dotsByToken = {
  ',': '\\dotsc',
  '\\not': '\\dotsb',
  // \keybin@ checks for the following:
  '+': '\\dotsb',
  '=': '\\dotsb',
  '<': '\\dotsb',
  '>': '\\dotsb',
  '-': '\\dotsb',
  '*': '\\dotsb',
  ':': '\\dotsb',
  // Symbols whose definition starts with \DOTSB:
  '\\DOTSB': '\\dotsb',
  '\\coprod': '\\dotsb',
  '\\bigvee': '\\dotsb',
  '\\bigwedge': '\\dotsb',
  '\\biguplus': '\\dotsb',
  '\\bigcap': '\\dotsb',
  '\\bigcup': '\\dotsb',
  '\\prod': '\\dotsb',
  '\\sum': '\\dotsb',
  '\\bigotimes': '\\dotsb',
  '\\bigoplus': '\\dotsb',
  '\\bigodot': '\\dotsb',
  '\\bigsqcup': '\\dotsb',
  '\\And': '\\dotsb',
  '\\longrightarrow': '\\dotsb',
  '\\Longrightarrow': '\\dotsb',
  '\\longleftarrow': '\\dotsb',
  '\\Longleftarrow': '\\dotsb',
  '\\longleftrightarrow': '\\dotsb',
  '\\Longleftrightarrow': '\\dotsb',
  '\\mapsto': '\\dotsb',
  '\\longmapsto': '\\dotsb',
  '\\hookrightarrow': '\\dotsb',
  '\\doteq': '\\dotsb',
  // Symbols whose definition starts with \mathbin:
  '\\mathbin': '\\dotsb',
  // Symbols whose definition starts with \mathrel:
  '\\mathrel': '\\dotsb',
  '\\relbar': '\\dotsb',
  '\\Relbar': '\\dotsb',
  '\\xrightarrow': '\\dotsb',
  '\\xleftarrow': '\\dotsb',
  // Symbols whose definition starts with \DOTSI:
  '\\DOTSI': '\\dotsi',
  '\\int': '\\dotsi',
  '\\oint': '\\dotsi',
  '\\iint': '\\dotsi',
  '\\iiint': '\\dotsi',
  '\\iiiint': '\\dotsi',
  '\\idotsint': '\\dotsi',
  // Symbols whose definition starts with \DOTSX:
  '\\DOTSX': '\\dotsx'
};
defineMacro("\\dots", function (context) {
  // TODO: If used in text mode, should expand to \textellipsis.
  // However, in KaTeX, \textellipsis and \ldots behave the same
  // (in text mode), and it's unlikely we'd see any of the math commands
  // that affect the behavior of \dots when in text mode.  So fine for now
  // (until we support \ifmmode ... \else ... \fi).
  var thedots = '\\dotso';
  var next = context.expandAfterFuture().text;

  if (next in dotsByToken) {
    thedots = dotsByToken[next];
  } else if (next.slice(0, 4) === '\\not') {
    thedots = '\\dotsb';
  } else if (next in symbols.math) {
    if (utils.contains(['bin', 'rel'], symbols.math[next].group)) {
      thedots = '\\dotsb';
    }
  }

  return thedots;
});
var spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ')': true,
  ']': true,
  '\\rbrack': true,
  '\\}': true,
  '\\rbrace': true,
  '\\rangle': true,
  '\\rceil': true,
  '\\rfloor': true,
  '\\rgroup': true,
  '\\rmoustache': true,
  '\\right': true,
  '\\bigr': true,
  '\\biggr': true,
  '\\Bigr': true,
  '\\Biggr': true,
  // \extra@ also tests for the following:
  '$': true,
  // \extrap@ checks for the following:
  ';': true,
  '.': true,
  ',': true
};
defineMacro("\\dotso", function (context) {
  var next = context.future().text;

  if (next in spaceAfterDots) {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\dotsc", function (context) {
  var next = context.future().text; // \dotsc uses \extra@ but not \extrap@, instead specially checking for
  // ';' and '.', but doesn't check for ','.

  if (next in spaceAfterDots && next !== ',') {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\cdots", function (context) {
  var next = context.future().text;

  if (next in spaceAfterDots) {
    return "\\@cdots\\,";
  } else {
    return "\\@cdots";
  }
});
defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots"); // amsmath doesn't actually define \dotsx, but \dots followed by a macro
// starting with \DOTSX implies \dotso, and then \extra@ detects this case
// and forces the added `\,`.

defineMacro("\\dotsx", "\\ldots\\,"); // \let\DOTSI\relax
// \let\DOTSB\relax
// \let\DOTSX\relax

defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax"); // Spacing, based on amsmath.sty's override of LaTeX defaults
// \DeclareRobustCommand{\tmspace}[3]{%
//   \ifmmode\mskip#1#2\else\kern#1#3\fi\relax}

defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax"); // \renewcommand{\,}{\tmspace+\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip

defineMacro("\\,", "\\tmspace+{3mu}{.1667em}"); // \let\thinspace\,

defineMacro("\\thinspace", "\\,"); // \def\>{\mskip\medmuskip}
// \renewcommand{\:}{\tmspace+\medmuskip{.2222em}}
// TODO: \> and math mode of \: should use \medmuskip = 4mu plus 2mu minus 4mu

defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "\\tmspace+{4mu}{.2222em}"); // \let\medspace\:

defineMacro("\\medspace", "\\:"); // \renewcommand{\;}{\tmspace+\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip = 5mu plus 5mu

defineMacro("\\;", "\\tmspace+{5mu}{.2777em}"); // \let\thickspace\;

defineMacro("\\thickspace", "\\;"); // \renewcommand{\!}{\tmspace-\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip

defineMacro("\\!", "\\tmspace-{3mu}{.1667em}"); // \let\negthinspace\!

defineMacro("\\negthinspace", "\\!"); // \newcommand{\negmedspace}{\tmspace-\medmuskip{.2222em}}
// TODO: math mode should use \medmuskip

defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}"); // \newcommand{\negthickspace}{\tmspace-\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip

defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}"); // \def\enspace{\kern.5em }

defineMacro("\\enspace", "\\kern.5em "); // \def\enskip{\hskip.5em\relax}

defineMacro("\\enskip", "\\hskip.5em\\relax"); // \def\quad{\hskip1em\relax}

defineMacro("\\quad", "\\hskip1em\\relax"); // \def\qquad{\hskip2em\relax}

defineMacro("\\qquad", "\\hskip2em\\relax"); // \tag@in@display form of \tag

defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", context => {
  if (context.macros.get("\\df@tag")) {
    throw new ParseError("Multiple \\tag");
  }

  return "\\gdef\\df@tag{\\text{#1}}";
}); // \renewcommand{\bmod}{\nonscript\mskip-\medmuskip\mkern5mu\mathbin
//   {\operator@font mod}\penalty900
//   \mkern5mu\nonscript\mskip-\medmuskip}
// \newcommand{\pod}[1]{\allowbreak
//   \if@display\mkern18mu\else\mkern8mu\fi(#1)}
// \renewcommand{\pmod}[1]{\pod{{\operator@font mod}\mkern6mu#1}}
// \newcommand{\mod}[1]{\allowbreak\if@display\mkern18mu
//   \else\mkern12mu\fi{\operator@font mod}\,\,#1}
// TODO: math mode should use \medmuskip = 4mu plus 2mu minus 4mu

defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}" + "\\mathbin{\\rm mod}" + "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
defineMacro("\\pod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro("\\mod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}" + "{\\rm mod}\\,\\,#1"); //////////////////////////////////////////////////////////////////////
// LaTeX source2e
// \expandafter\let\expandafter\@normalcr
//     \csname\expandafter\@gobble\string\\ \endcsname
// \DeclareRobustCommand\newline{\@normalcr\relax}

defineMacro("\\newline", "\\\\\\relax"); // \def\TeX{T\kern-.1667em\lower.5ex\hbox{E}\kern-.125emX\@}
// TODO: Doesn't normally work in math mode because \@ fails.  KaTeX doesn't
// support \@ yet, so that's omitted, and we add \text so that the result
// doesn't look funny in math mode.

defineMacro("\\TeX", "\\textrm{\\html@mathml{" + "T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX" + "}{TeX}}"); // \DeclareRobustCommand{\LaTeX}{L\kern-.36em%
//         {\sbox\z@ T%
//          \vbox to\ht\z@{\hbox{\check@mathfonts
//                               \fontsize\sf@size\z@
//                               \math@fontsfalse\selectfont
//                               A}%
//                         \vss}%
//         }%
//         \kern-.15em%
//         \TeX}
// This code aligns the top of the A with the T (from the perspective of TeX's
// boxes, though visually the A appears to extend above slightly).
// We compute the corresponding \raisebox when A is rendered in \normalsize
// \scriptstyle, which has a scale factor of 0.7 (see Options.js).

var latexRaiseA = makeEm(fontMetricsData['Main-Regular']["T".charCodeAt(0)][1] - 0.7 * fontMetricsData['Main-Regular']["A".charCodeAt(0)][1]);
defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}"); // New KaTeX logo based on tweaking LaTeX logo

defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}"); // \DeclareRobustCommand\hspace{\@ifstar\@hspacer\@hspace}
// \def\@hspace#1{\hskip  #1\relax}
// \def\@hspacer#1{\vrule \@width\z@\nobreak
//                 \hskip #1\hskip \z@skip}

defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax"); //////////////////////////////////////////////////////////////////////
// mathtools.sty
//\providecommand\ordinarycolon{:}

defineMacro("\\ordinarycolon", ":"); //\def\vcentcolon{\mathrel{\mathop\ordinarycolon}}
//TODO(edemaine): Not yet centered. Fix via \raisebox or #726

defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}"); // \providecommand*\dblcolon{\vcentcolon\mathrel{\mkern-.9mu}\vcentcolon}

defineMacro("\\dblcolon", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}" + "{\\mathop{\\char\"2237}}"); // \providecommand*\coloneqq{\vcentcolon\mathrel{\mkern-1.2mu}=}

defineMacro("\\coloneqq", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}" + "{\\mathop{\\char\"2254}}"); // ≔
// \providecommand*\Coloneqq{\dblcolon\mathrel{\mkern-1.2mu}=}

defineMacro("\\Coloneqq", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}" + "{\\mathop{\\char\"2237\\char\"3d}}"); // \providecommand*\coloneq{\vcentcolon\mathrel{\mkern-1.2mu}\mathrel{-}}

defineMacro("\\coloneq", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}" + "{\\mathop{\\char\"3a\\char\"2212}}"); // \providecommand*\Coloneq{\dblcolon\mathrel{\mkern-1.2mu}\mathrel{-}}

defineMacro("\\Coloneq", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}" + "{\\mathop{\\char\"2237\\char\"2212}}"); // \providecommand*\eqqcolon{=\mathrel{\mkern-1.2mu}\vcentcolon}

defineMacro("\\eqqcolon", "\\html@mathml{" + "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}" + "{\\mathop{\\char\"2255}}"); // ≕
// \providecommand*\Eqqcolon{=\mathrel{\mkern-1.2mu}\dblcolon}

defineMacro("\\Eqqcolon", "\\html@mathml{" + "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}" + "{\\mathop{\\char\"3d\\char\"2237}}"); // \providecommand*\eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\vcentcolon}

defineMacro("\\eqcolon", "\\html@mathml{" + "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}" + "{\\mathop{\\char\"2239}}"); // \providecommand*\Eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\dblcolon}

defineMacro("\\Eqcolon", "\\html@mathml{" + "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}" + "{\\mathop{\\char\"2212\\char\"2237}}"); // \providecommand*\colonapprox{\vcentcolon\mathrel{\mkern-1.2mu}\approx}

defineMacro("\\colonapprox", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}" + "{\\mathop{\\char\"3a\\char\"2248}}"); // \providecommand*\Colonapprox{\dblcolon\mathrel{\mkern-1.2mu}\approx}

defineMacro("\\Colonapprox", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}" + "{\\mathop{\\char\"2237\\char\"2248}}"); // \providecommand*\colonsim{\vcentcolon\mathrel{\mkern-1.2mu}\sim}

defineMacro("\\colonsim", "\\html@mathml{" + "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}" + "{\\mathop{\\char\"3a\\char\"223c}}"); // \providecommand*\Colonsim{\dblcolon\mathrel{\mkern-1.2mu}\sim}

defineMacro("\\Colonsim", "\\html@mathml{" + "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}" + "{\\mathop{\\char\"2237\\char\"223c}}"); // Some Unicode characters are implemented with macros to mathtools functions.

defineMacro("\u2237", "\\dblcolon"); // ::

defineMacro("\u2239", "\\eqcolon"); // -:

defineMacro("\u2254", "\\coloneqq"); // :=

defineMacro("\u2255", "\\eqqcolon"); // =:

defineMacro("\u2A74", "\\Coloneqq"); // ::=
//////////////////////////////////////////////////////////////////////
// colonequals.sty
// Alternate names for mathtools's macros:

defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon"); // \colonapprox name is same in mathtools and colonequals.

defineMacro("\\coloncolonapprox", "\\Colonapprox"); // \colonsim name is same in mathtools and colonequals.

defineMacro("\\coloncolonsim", "\\Colonsim"); // Additional macros, implemented by analogy with mathtools definitions:

defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}"); // Present in newtxmath, pxfonts and txfonts

defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}"); //////////////////////////////////////////////////////////////////////
// From amsopn.sty

defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}"); //////////////////////////////////////////////////////////////////////
// MathML alternates for KaTeX glyphs in the Unicode private area

defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}");
defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}");
defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}");
defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}");
defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}");
defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}");
defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}"); //////////////////////////////////////////////////////////////////////
// stmaryrd and semantic
// The stmaryrd and semantic packages render the next four items by calling a
// glyph. Those glyphs do not exist in the KaTeX fonts. Hence the macros.

defineMacro("\\llbracket", "\\html@mathml{" + "\\mathopen{[\\mkern-3.2mu[}}" + "{\\mathopen{\\char`\u27e6}}");
defineMacro("\\rrbracket", "\\html@mathml{" + "\\mathclose{]\\mkern-3.2mu]}}" + "{\\mathclose{\\char`\u27e7}}");
defineMacro("\u27e6", "\\llbracket"); // blackboard bold [

defineMacro("\u27e7", "\\rrbracket"); // blackboard bold ]

defineMacro("\\lBrace", "\\html@mathml{" + "\\mathopen{\\{\\mkern-3.2mu[}}" + "{\\mathopen{\\char`\u2983}}");
defineMacro("\\rBrace", "\\html@mathml{" + "\\mathclose{]\\mkern-3.2mu\\}}}" + "{\\mathclose{\\char`\u2984}}");
defineMacro("\u2983", "\\lBrace"); // blackboard bold {

defineMacro("\u2984", "\\rBrace"); // blackboard bold }
// TODO: Create variable sized versions of the last two items. I believe that
// will require new font glyphs.
// The stmaryrd function `\minuso` provides a "Plimsoll" symbol that
// superimposes the characters \circ and \mathminus. Used in chemistry.

defineMacro("\\minuso", "\\mathbin{\\html@mathml{" + "{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}" + "{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}" + "{\\char`⦵}}");
defineMacro("⦵", "\\minuso"); //////////////////////////////////////////////////////////////////////
// texvc.sty
// The texvc package contains macros available in mediawiki pages.
// We omit the functions deprecated at
// https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax
// We also omit texvc's \O, which conflicts with \text{\O}

defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\Alpha", "\\mathrm{A}");
defineMacro("\\Beta", "\\mathrm{B}");
defineMacro("\\bull", "\\bullet");
defineMacro("\\Chi", "\\mathrm{X}");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\Epsilon", "\\mathrm{E}");
defineMacro("\\Eta", "\\mathrm{H}");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\Iota", "\\mathrm{I}");
defineMacro("\\isin", "\\in");
defineMacro("\\Kappa", "\\mathrm{K}");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\Mu", "\\mathrm{M}");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\Nu", "\\mathrm{N}");
defineMacro("\\Omicron", "\\mathrm{O}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\Rho", "\\mathrm{P}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\Tau", "\\mathrm{T}");
defineMacro("\\thetasym", "\\vartheta"); // TODO: defineMacro("\\varcoppa", "\\\mbox{\\coppa}");

defineMacro("\\weierp", "\\wp");
defineMacro("\\Zeta", "\\mathrm{Z}"); //////////////////////////////////////////////////////////////////////
// statmath.sty
// https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf

defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits"); //////////////////////////////////////////////////////////////////////
// braket.sty
// http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/braket/braket.pdf

defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");

var braketHelper = one => context => {
  var left = context.consumeArg().tokens;
  var middle = context.consumeArg().tokens;
  var middleDouble = context.consumeArg().tokens;
  var right = context.consumeArg().tokens;
  var oldMiddle = context.macros.get("|");
  var oldMiddleDouble = context.macros.get("\\|");
  context.macros.beginGroup();

  var midMacro = double => context => {
    if (one) {
      // Only modify the first instance of | or \|
      context.macros.set("|", oldMiddle);

      if (middleDouble.length) {
        context.macros.set("\\|", oldMiddleDouble);
      }
    }

    var doubled = double;

    if (!double && middleDouble.length) {
      // Mimic \@ifnextchar
      var nextToken = context.future();

      if (nextToken.text === "|") {
        context.popToken();
        doubled = true;
      }
    }

    return {
      tokens: doubled ? middleDouble : middle,
      numArgs: 0
    };
  };

  context.macros.set("|", midMacro(false));

  if (middleDouble.length) {
    context.macros.set("\\|", midMacro(true));
  }

  var arg = context.consumeArg().tokens;
  var expanded = context.expandTokens([...right, ...arg, ...left // reversed
  ]);
  context.macros.endGroup();
  return {
    tokens: expanded.reverse(),
    numArgs: 0
  };
};

defineMacro("\\bra@ket", braketHelper(false));
defineMacro("\\bra@set", braketHelper(true));
defineMacro("\\Braket", "\\bra@ket{\\left\\langle}" + "{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
defineMacro("\\Set", "\\bra@set{\\left\\{\\:}" + "{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}"); // has no support for special || or \|
//////////////////////////////////////////////////////////////////////
// actuarialangle.dtx

defineMacro("\\angln", "{\\angl n}"); // Custom Khan Academy colors, should be moved to an optional package

defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
defineMacro("\\red", "\\textcolor{##df0030}{#1}");
defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
defineMacro("\\gray", "\\textcolor{gray}{#1}");
defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");

/**
 * This file contains the “gullet” where macros are expanded
 * until only non-macro tokens remain.
 */
// List of commands that act like macros but aren't defined as a macro,
// function, or symbol.  Used in `isDefined`.
var implicitCommands = {
  "^": true,
  // Parser.js
  "_": true,
  // Parser.js
  "\\limits": true,
  // Parser.js
  "\\nolimits": true // Parser.js

};
class MacroExpander {
  constructor(input, settings, mode) {
    this.settings = void 0;
    this.expansionCount = void 0;
    this.lexer = void 0;
    this.macros = void 0;
    this.stack = void 0;
    this.mode = void 0;
    this.settings = settings;
    this.expansionCount = 0;
    this.feed(input); // Make new global namespace

    this.macros = new Namespace(macros, settings.macros);
    this.mode = mode;
    this.stack = []; // contains tokens in REVERSE order
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */


  feed(input) {
    this.lexer = new Lexer(input, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */


  switchMode(newMode) {
    this.mode = newMode;
  }
  /**
   * Start a new group nesting within all namespaces.
   */


  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */


  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */


  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */


  future() {
    if (this.stack.length === 0) {
      this.pushToken(this.lexer.lex());
    }

    return this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */


  popToken() {
    this.future(); // ensure non-empty stack

    return this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */


  pushToken(token) {
    this.stack.push(token);
  }
  /**
   * Append an array of tokens to the token stack.
   */


  pushTokens(tokens) {
    this.stack.push(...tokens);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */


  scanArgument(isOptional) {
    var start;
    var end;
    var tokens;

    if (isOptional) {
      this.consumeSpaces(); // \@ifnextchar gobbles any space following it

      if (this.future().text !== "[") {
        return null;
      }

      start = this.popToken(); // don't include [ in tokens

      ({
        tokens,
        end
      } = this.consumeArg(["]"]));
    } else {
      ({
        tokens,
        start,
        end
      } = this.consumeArg());
    } // indicate the end of an argument


    this.pushToken(new Token("EOF", end.loc));
    this.pushTokens(tokens);
    return start.range(end, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */


  consumeSpaces() {
    for (;;) {
      var token = this.future();

      if (token.text === " ") {
        this.stack.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */


  consumeArg(delims) {
    // The argument for a delimited parameter is the shortest (possibly
    // empty) sequence of tokens with properly nested {...} groups that is
    // followed ... by this particular list of non-parameter tokens.
    // The argument for an undelimited parameter is the next nonblank
    // token, unless that token is ‘{’, when the argument will be the
    // entire {...} group that follows.
    var tokens = [];
    var isDelimited = delims && delims.length > 0;

    if (!isDelimited) {
      // Ignore spaces between arguments.  As the TeXbook says:
      // "After you have said ‘\def\row#1#2{...}’, you are allowed to
      //  put spaces between the arguments (e.g., ‘\row x n’), because
      //  TeX doesn’t use single spaces as undelimited arguments."
      this.consumeSpaces();
    }

    var start = this.future();
    var tok;
    var depth = 0;
    var match = 0;

    do {
      tok = this.popToken();
      tokens.push(tok);

      if (tok.text === "{") {
        ++depth;
      } else if (tok.text === "}") {
        --depth;

        if (depth === -1) {
          throw new ParseError("Extra }", tok);
        }
      } else if (tok.text === "EOF") {
        throw new ParseError("Unexpected end of input in a macro argument" + ", expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
      }

      if (delims && isDelimited) {
        if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
          ++match;

          if (match === delims.length) {
            // don't include delims in tokens
            tokens.splice(-match, match);
            break;
          }
        } else {
          match = 0;
        }
      }
    } while (depth !== 0 || isDelimited); // If the argument found ... has the form ‘{<nested tokens>}’,
    // ... the outermost braces enclosing the argument are removed


    if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
      tokens.pop();
      tokens.shift();
    }

    tokens.reverse(); // to fit in with stack order

    return {
      tokens,
      start,
      end: tok
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */


  consumeArgs(numArgs, delimiters) {
    if (delimiters) {
      if (delimiters.length !== numArgs + 1) {
        throw new ParseError("The length of delimiters doesn't match the number of args!");
      }

      var delims = delimiters[0];

      for (var i = 0; i < delims.length; i++) {
        var tok = this.popToken();

        if (delims[i] !== tok.text) {
          throw new ParseError("Use of the macro doesn't match its definition", tok);
        }
      }
    }

    var args = [];

    for (var _i = 0; _i < numArgs; _i++) {
      args.push(this.consumeArg(delimiters && delimiters[_i + 1]).tokens);
    }

    return args;
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order and will be returned as an array,
   * also in reverse order.
   *
   * If not, the next token will be returned without removing it
   * from the stack.  This case can be detected by a `Token` return value
   * instead of an `Array` return value.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty.
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */


  expandOnce(expandableOnly) {
    var topToken = this.popToken();
    var name = topToken.text;
    var expansion = !topToken.noexpand ? this._getExpansion(name) : null;

    if (expansion == null || expandableOnly && expansion.unexpandable) {
      if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
        throw new ParseError("Undefined control sequence: " + name);
      }

      this.pushToken(topToken);
      return topToken;
    }

    this.expansionCount++;

    if (this.expansionCount > this.settings.maxExpand) {
      throw new ParseError("Too many expansions: infinite loop or " + "need to increase maxExpand setting");
    }

    var tokens = expansion.tokens;
    var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);

    if (expansion.numArgs) {
      // paste arguments in place of the placeholders
      tokens = tokens.slice(); // make a shallow copy

      for (var i = tokens.length - 1; i >= 0; --i) {
        var tok = tokens[i];

        if (tok.text === "#") {
          if (i === 0) {
            throw new ParseError("Incomplete placeholder at end of macro body", tok);
          }

          tok = tokens[--i]; // next token on stack

          if (tok.text === "#") {
            // ## → #
            tokens.splice(i + 1, 1); // drop first #
          } else if (/^[1-9]$/.test(tok.text)) {
            // replace the placeholder with the indicated argument
            tokens.splice(i, 2, ...args[+tok.text - 1]);
          } else {
            throw new ParseError("Not a valid argument number", tok);
          }
        }
      }
    } // Concatenate expansion onto top of stack.


    this.pushTokens(tokens);
    return tokens;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */


  expandAfterFuture() {
    this.expandOnce();
    return this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */


  expandNextToken() {
    for (;;) {
      var expanded = this.expandOnce(); // expandOnce returns Token if and only if it's fully expanded.

      if (expanded instanceof Token) {
        // the token after \noexpand is interpreted as if its meaning
        // were ‘\relax’
        if (expanded.treatAsRelax) {
          expanded.text = "\\relax";
        }

        return this.stack.pop(); // === expanded
      }
    } // Flow unable to figure out that this pathway is impossible.
    // https://github.com/facebook/flow/issues/4808


    throw new Error(); // eslint-disable-line no-unreachable
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */


  expandMacro(name) {
    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : undefined;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */


  expandTokens(tokens) {
    var output = [];
    var oldStackLength = this.stack.length;
    this.pushTokens(tokens);

    while (this.stack.length > oldStackLength) {
      var expanded = this.expandOnce(true); // expand only expandable tokens
      // expandOnce returns Token if and only if it's fully expanded.

      if (expanded instanceof Token) {
        if (expanded.treatAsRelax) {
          // the expansion of \noexpand is the token itself
          expanded.noexpand = false;
          expanded.treatAsRelax = false;
        }

        output.push(this.stack.pop());
      }
    }

    return output;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */


  expandMacroAsText(name) {
    var tokens = this.expandMacro(name);

    if (tokens) {
      return tokens.map(token => token.text).join("");
    } else {
      return tokens;
    }
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */


  _getExpansion(name) {
    var definition = this.macros.get(name);

    if (definition == null) {
      // mainly checking for undefined here
      return definition;
    } // If a single character has an associated catcode other than 13
    // (active character), then don't expand it.


    if (name.length === 1) {
      var catcode = this.lexer.catcodes[name];

      if (catcode != null && catcode !== 13) {
        return;
      }
    }

    var expansion = typeof definition === "function" ? definition(this) : definition;

    if (typeof expansion === "string") {
      var numArgs = 0;

      if (expansion.indexOf("#") !== -1) {
        var stripped = expansion.replace(/##/g, "");

        while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
          ++numArgs;
        }
      }

      var bodyLexer = new Lexer(expansion, this.settings);
      var tokens = [];
      var tok = bodyLexer.lex();

      while (tok.text !== "EOF") {
        tokens.push(tok);
        tok = bodyLexer.lex();
      }

      tokens.reverse(); // to fit in with stack using push and pop

      var expanded = {
        tokens,
        numArgs
      };
      return expanded;
    }

    return expansion;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */


  isDefined(name) {
    return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
  }
  /**
   * Determine whether a command is expandable.
   */


  isExpandable(name) {
    var macro = this.macros.get(name);
    return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;
  }

}

// Helpers for Parser.js handling of Unicode (sub|super)script characters.
var unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;
var uSubsAndSups = Object.freeze({
  '₊': '+',
  '₋': '-',
  '₌': '=',
  '₍': '(',
  '₎': ')',
  '₀': '0',
  '₁': '1',
  '₂': '2',
  '₃': '3',
  '₄': '4',
  '₅': '5',
  '₆': '6',
  '₇': '7',
  '₈': '8',
  '₉': '9',
  '\u2090': 'a',
  '\u2091': 'e',
  '\u2095': 'h',
  '\u1D62': 'i',
  '\u2C7C': 'j',
  '\u2096': 'k',
  '\u2097': 'l',
  '\u2098': 'm',
  '\u2099': 'n',
  '\u2092': 'o',
  '\u209A': 'p',
  '\u1D63': 'r',
  '\u209B': 's',
  '\u209C': 't',
  '\u1D64': 'u',
  '\u1D65': 'v',
  '\u2093': 'x',
  '\u1D66': 'β',
  '\u1D67': 'γ',
  '\u1D68': 'ρ',
  '\u1D69': '\u03d5',
  '\u1D6A': 'χ',
  '⁺': '+',
  '⁻': '-',
  '⁼': '=',
  '⁽': '(',
  '⁾': ')',
  '⁰': '0',
  '¹': '1',
  '²': '2',
  '³': '3',
  '⁴': '4',
  '⁵': '5',
  '⁶': '6',
  '⁷': '7',
  '⁸': '8',
  '⁹': '9',
  '\u1D2C': 'A',
  '\u1D2E': 'B',
  '\u1D30': 'D',
  '\u1D31': 'E',
  '\u1D33': 'G',
  '\u1D34': 'H',
  '\u1D35': 'I',
  '\u1D36': 'J',
  '\u1D37': 'K',
  '\u1D38': 'L',
  '\u1D39': 'M',
  '\u1D3A': 'N',
  '\u1D3C': 'O',
  '\u1D3E': 'P',
  '\u1D3F': 'R',
  '\u1D40': 'T',
  '\u1D41': 'U',
  '\u2C7D': 'V',
  '\u1D42': 'W',
  '\u1D43': 'a',
  '\u1D47': 'b',
  '\u1D9C': 'c',
  '\u1D48': 'd',
  '\u1D49': 'e',
  '\u1DA0': 'f',
  '\u1D4D': 'g',
  '\u02B0': 'h',
  '\u2071': 'i',
  '\u02B2': 'j',
  '\u1D4F': 'k',
  '\u02E1': 'l',
  '\u1D50': 'm',
  '\u207F': 'n',
  '\u1D52': 'o',
  '\u1D56': 'p',
  '\u02B3': 'r',
  '\u02E2': 's',
  '\u1D57': 't',
  '\u1D58': 'u',
  '\u1D5B': 'v',
  '\u02B7': 'w',
  '\u02E3': 'x',
  '\u02B8': 'y',
  '\u1DBB': 'z',
  '\u1D5D': 'β',
  '\u1D5E': 'γ',
  '\u1D5F': 'δ',
  '\u1D60': '\u03d5',
  '\u1D61': 'χ',
  '\u1DBF': 'θ'
});

/* eslint no-constant-condition:0 */

var unicodeAccents = {
  "́": {
    "text": "\\'",
    "math": "\\acute"
  },
  "̀": {
    "text": "\\`",
    "math": "\\grave"
  },
  "̈": {
    "text": "\\\"",
    "math": "\\ddot"
  },
  "̃": {
    "text": "\\~",
    "math": "\\tilde"
  },
  "̄": {
    "text": "\\=",
    "math": "\\bar"
  },
  "̆": {
    "text": "\\u",
    "math": "\\breve"
  },
  "̌": {
    "text": "\\v",
    "math": "\\check"
  },
  "̂": {
    "text": "\\^",
    "math": "\\hat"
  },
  "̇": {
    "text": "\\.",
    "math": "\\dot"
  },
  "̊": {
    "text": "\\r",
    "math": "\\mathring"
  },
  "̋": {
    "text": "\\H"
  },
  "̧": {
    "text": "\\c"
  }
};
var unicodeSymbols = {
  "á": "á",
  "à": "à",
  "ä": "ä",
  "ǟ": "ǟ",
  "ã": "ã",
  "ā": "ā",
  "ă": "ă",
  "ắ": "ắ",
  "ằ": "ằ",
  "ẵ": "ẵ",
  "ǎ": "ǎ",
  "â": "â",
  "ấ": "ấ",
  "ầ": "ầ",
  "ẫ": "ẫ",
  "ȧ": "ȧ",
  "ǡ": "ǡ",
  "å": "å",
  "ǻ": "ǻ",
  "ḃ": "ḃ",
  "ć": "ć",
  "ḉ": "ḉ",
  "č": "č",
  "ĉ": "ĉ",
  "ċ": "ċ",
  "ç": "ç",
  "ď": "ď",
  "ḋ": "ḋ",
  "ḑ": "ḑ",
  "é": "é",
  "è": "è",
  "ë": "ë",
  "ẽ": "ẽ",
  "ē": "ē",
  "ḗ": "ḗ",
  "ḕ": "ḕ",
  "ĕ": "ĕ",
  "ḝ": "ḝ",
  "ě": "ě",
  "ê": "ê",
  "ế": "ế",
  "ề": "ề",
  "ễ": "ễ",
  "ė": "ė",
  "ȩ": "ȩ",
  "ḟ": "ḟ",
  "ǵ": "ǵ",
  "ḡ": "ḡ",
  "ğ": "ğ",
  "ǧ": "ǧ",
  "ĝ": "ĝ",
  "ġ": "ġ",
  "ģ": "ģ",
  "ḧ": "ḧ",
  "ȟ": "ȟ",
  "ĥ": "ĥ",
  "ḣ": "ḣ",
  "ḩ": "ḩ",
  "í": "í",
  "ì": "ì",
  "ï": "ï",
  "ḯ": "ḯ",
  "ĩ": "ĩ",
  "ī": "ī",
  "ĭ": "ĭ",
  "ǐ": "ǐ",
  "î": "î",
  "ǰ": "ǰ",
  "ĵ": "ĵ",
  "ḱ": "ḱ",
  "ǩ": "ǩ",
  "ķ": "ķ",
  "ĺ": "ĺ",
  "ľ": "ľ",
  "ļ": "ļ",
  "ḿ": "ḿ",
  "ṁ": "ṁ",
  "ń": "ń",
  "ǹ": "ǹ",
  "ñ": "ñ",
  "ň": "ň",
  "ṅ": "ṅ",
  "ņ": "ņ",
  "ó": "ó",
  "ò": "ò",
  "ö": "ö",
  "ȫ": "ȫ",
  "õ": "õ",
  "ṍ": "ṍ",
  "ṏ": "ṏ",
  "ȭ": "ȭ",
  "ō": "ō",
  "ṓ": "ṓ",
  "ṑ": "ṑ",
  "ŏ": "ŏ",
  "ǒ": "ǒ",
  "ô": "ô",
  "ố": "ố",
  "ồ": "ồ",
  "ỗ": "ỗ",
  "ȯ": "ȯ",
  "ȱ": "ȱ",
  "ő": "ő",
  "ṕ": "ṕ",
  "ṗ": "ṗ",
  "ŕ": "ŕ",
  "ř": "ř",
  "ṙ": "ṙ",
  "ŗ": "ŗ",
  "ś": "ś",
  "ṥ": "ṥ",
  "š": "š",
  "ṧ": "ṧ",
  "ŝ": "ŝ",
  "ṡ": "ṡ",
  "ş": "ş",
  "ẗ": "ẗ",
  "ť": "ť",
  "ṫ": "ṫ",
  "ţ": "ţ",
  "ú": "ú",
  "ù": "ù",
  "ü": "ü",
  "ǘ": "ǘ",
  "ǜ": "ǜ",
  "ǖ": "ǖ",
  "ǚ": "ǚ",
  "ũ": "ũ",
  "ṹ": "ṹ",
  "ū": "ū",
  "ṻ": "ṻ",
  "ŭ": "ŭ",
  "ǔ": "ǔ",
  "û": "û",
  "ů": "ů",
  "ű": "ű",
  "ṽ": "ṽ",
  "ẃ": "ẃ",
  "ẁ": "ẁ",
  "ẅ": "ẅ",
  "ŵ": "ŵ",
  "ẇ": "ẇ",
  "ẘ": "ẘ",
  "ẍ": "ẍ",
  "ẋ": "ẋ",
  "ý": "ý",
  "ỳ": "ỳ",
  "ÿ": "ÿ",
  "ỹ": "ỹ",
  "ȳ": "ȳ",
  "ŷ": "ŷ",
  "ẏ": "ẏ",
  "ẙ": "ẙ",
  "ź": "ź",
  "ž": "ž",
  "ẑ": "ẑ",
  "ż": "ż",
  "Á": "Á",
  "À": "À",
  "Ä": "Ä",
  "Ǟ": "Ǟ",
  "Ã": "Ã",
  "Ā": "Ā",
  "Ă": "Ă",
  "Ắ": "Ắ",
  "Ằ": "Ằ",
  "Ẵ": "Ẵ",
  "Ǎ": "Ǎ",
  "Â": "Â",
  "Ấ": "Ấ",
  "Ầ": "Ầ",
  "Ẫ": "Ẫ",
  "Ȧ": "Ȧ",
  "Ǡ": "Ǡ",
  "Å": "Å",
  "Ǻ": "Ǻ",
  "Ḃ": "Ḃ",
  "Ć": "Ć",
  "Ḉ": "Ḉ",
  "Č": "Č",
  "Ĉ": "Ĉ",
  "Ċ": "Ċ",
  "Ç": "Ç",
  "Ď": "Ď",
  "Ḋ": "Ḋ",
  "Ḑ": "Ḑ",
  "É": "É",
  "È": "È",
  "Ë": "Ë",
  "Ẽ": "Ẽ",
  "Ē": "Ē",
  "Ḗ": "Ḗ",
  "Ḕ": "Ḕ",
  "Ĕ": "Ĕ",
  "Ḝ": "Ḝ",
  "Ě": "Ě",
  "Ê": "Ê",
  "Ế": "Ế",
  "Ề": "Ề",
  "Ễ": "Ễ",
  "Ė": "Ė",
  "Ȩ": "Ȩ",
  "Ḟ": "Ḟ",
  "Ǵ": "Ǵ",
  "Ḡ": "Ḡ",
  "Ğ": "Ğ",
  "Ǧ": "Ǧ",
  "Ĝ": "Ĝ",
  "Ġ": "Ġ",
  "Ģ": "Ģ",
  "Ḧ": "Ḧ",
  "Ȟ": "Ȟ",
  "Ĥ": "Ĥ",
  "Ḣ": "Ḣ",
  "Ḩ": "Ḩ",
  "Í": "Í",
  "Ì": "Ì",
  "Ï": "Ï",
  "Ḯ": "Ḯ",
  "Ĩ": "Ĩ",
  "Ī": "Ī",
  "Ĭ": "Ĭ",
  "Ǐ": "Ǐ",
  "Î": "Î",
  "İ": "İ",
  "Ĵ": "Ĵ",
  "Ḱ": "Ḱ",
  "Ǩ": "Ǩ",
  "Ķ": "Ķ",
  "Ĺ": "Ĺ",
  "Ľ": "Ľ",
  "Ļ": "Ļ",
  "Ḿ": "Ḿ",
  "Ṁ": "Ṁ",
  "Ń": "Ń",
  "Ǹ": "Ǹ",
  "Ñ": "Ñ",
  "Ň": "Ň",
  "Ṅ": "Ṅ",
  "Ņ": "Ņ",
  "Ó": "Ó",
  "Ò": "Ò",
  "Ö": "Ö",
  "Ȫ": "Ȫ",
  "Õ": "Õ",
  "Ṍ": "Ṍ",
  "Ṏ": "Ṏ",
  "Ȭ": "Ȭ",
  "Ō": "Ō",
  "Ṓ": "Ṓ",
  "Ṑ": "Ṑ",
  "Ŏ": "Ŏ",
  "Ǒ": "Ǒ",
  "Ô": "Ô",
  "Ố": "Ố",
  "Ồ": "Ồ",
  "Ỗ": "Ỗ",
  "Ȯ": "Ȯ",
  "Ȱ": "Ȱ",
  "Ő": "Ő",
  "Ṕ": "Ṕ",
  "Ṗ": "Ṗ",
  "Ŕ": "Ŕ",
  "Ř": "Ř",
  "Ṙ": "Ṙ",
  "Ŗ": "Ŗ",
  "Ś": "Ś",
  "Ṥ": "Ṥ",
  "Š": "Š",
  "Ṧ": "Ṧ",
  "Ŝ": "Ŝ",
  "Ṡ": "Ṡ",
  "Ş": "Ş",
  "Ť": "Ť",
  "Ṫ": "Ṫ",
  "Ţ": "Ţ",
  "Ú": "Ú",
  "Ù": "Ù",
  "Ü": "Ü",
  "Ǘ": "Ǘ",
  "Ǜ": "Ǜ",
  "Ǖ": "Ǖ",
  "Ǚ": "Ǚ",
  "Ũ": "Ũ",
  "Ṹ": "Ṹ",
  "Ū": "Ū",
  "Ṻ": "Ṻ",
  "Ŭ": "Ŭ",
  "Ǔ": "Ǔ",
  "Û": "Û",
  "Ů": "Ů",
  "Ű": "Ű",
  "Ṽ": "Ṽ",
  "Ẃ": "Ẃ",
  "Ẁ": "Ẁ",
  "Ẅ": "Ẅ",
  "Ŵ": "Ŵ",
  "Ẇ": "Ẇ",
  "Ẍ": "Ẍ",
  "Ẋ": "Ẋ",
  "Ý": "Ý",
  "Ỳ": "Ỳ",
  "Ÿ": "Ÿ",
  "Ỹ": "Ỹ",
  "Ȳ": "Ȳ",
  "Ŷ": "Ŷ",
  "Ẏ": "Ẏ",
  "Ź": "Ź",
  "Ž": "Ž",
  "Ẑ": "Ẑ",
  "Ż": "Ż",
  "ά": "ά",
  "ὰ": "ὰ",
  "ᾱ": "ᾱ",
  "ᾰ": "ᾰ",
  "έ": "έ",
  "ὲ": "ὲ",
  "ή": "ή",
  "ὴ": "ὴ",
  "ί": "ί",
  "ὶ": "ὶ",
  "ϊ": "ϊ",
  "ΐ": "ΐ",
  "ῒ": "ῒ",
  "ῑ": "ῑ",
  "ῐ": "ῐ",
  "ό": "ό",
  "ὸ": "ὸ",
  "ύ": "ύ",
  "ὺ": "ὺ",
  "ϋ": "ϋ",
  "ΰ": "ΰ",
  "ῢ": "ῢ",
  "ῡ": "ῡ",
  "ῠ": "ῠ",
  "ώ": "ώ",
  "ὼ": "ὼ",
  "Ύ": "Ύ",
  "Ὺ": "Ὺ",
  "Ϋ": "Ϋ",
  "Ῡ": "Ῡ",
  "Ῠ": "Ῠ",
  "Ώ": "Ώ",
  "Ὼ": "Ὼ"
};

/**
 * This file contains the parser used to parse out a TeX expression from the
 * input. Since TeX isn't context-free, standard parsers don't work particularly
 * well.
 *
 * The strategy of this parser is as such:
 *
 * The main functions (the `.parse...` ones) take a position in the current
 * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
 * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When
 * individual tokens are needed at a position, the lexer is called to pull out a
 * token, which is then used.
 *
 * The parser has a property called "mode" indicating the mode that
 * the parser is currently in. Currently it has to be one of "math" or
 * "text", which denotes whether the current environment is a math-y
 * one or a text-y one (e.g. inside \text). Currently, this serves to
 * limit the functions which can be used in text mode.
 *
 * The main functions then return an object which contains the useful data that
 * was parsed at its given point, and a new position at the end of the parsed
 * data. The main functions can call each other and continue the parsing by
 * using the returned position as a new starting point.
 *
 * There are also extra `.handle...` functions, which pull out some reused
 * functionality into self-contained functions.
 *
 * The functions return ParseNodes.
 */
class Parser {
  constructor(input, settings) {
    this.mode = void 0;
    this.gullet = void 0;
    this.settings = void 0;
    this.leftrightDepth = void 0;
    this.nextToken = void 0;
    // Start in math mode
    this.mode = "math"; // Create a new macro expander (gullet) and (indirectly via that) also a
    // new lexer (mouth) for this parser (stomach, in the language of TeX)

    this.gullet = new MacroExpander(input, settings, this.mode); // Store the settings for use in parsing

    this.settings = settings; // Count leftright depth (for \middle errors)

    this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */


  expect(text, consume) {
    if (consume === void 0) {
      consume = true;
    }

    if (this.fetch().text !== text) {
      throw new ParseError("Expected '" + text + "', got '" + this.fetch().text + "'", this.fetch());
    }

    if (consume) {
      this.consume();
    }
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */


  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */


  fetch() {
    if (this.nextToken == null) {
      this.nextToken = this.gullet.expandNextToken();
    }

    return this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */


  switchMode(newMode) {
    this.mode = newMode;
    this.gullet.switchMode(newMode);
  }
  /**
   * Main parsing function, which parses an entire input.
   */


  parse() {
    if (!this.settings.globalGroup) {
      // Create a group namespace for the math expression.
      // (LaTeX creates a new group for every $...$, $$...$$, \[...\].)
      this.gullet.beginGroup();
    } // Use old \color behavior (same as LaTeX's \textcolor) if requested.
    // We do this within the group for the math expression, so it doesn't
    // pollute settings.macros.


    if (this.settings.colorIsTextColor) {
      this.gullet.macros.set("\\color", "\\textcolor");
    }

    try {
      // Try to parse the input
      var parse = this.parseExpression(false); // If we succeeded, make sure there's an EOF at the end

      this.expect("EOF"); // End the group namespace for the expression

      if (!this.settings.globalGroup) {
        this.gullet.endGroup();
      }

      return parse; // Close any leftover groups in case of a parse error.
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */


  subparse(tokens) {
    // Save the next token from the current job.
    var oldToken = this.nextToken;
    this.consume(); // Run the new job, terminating it with an excess '}'

    this.gullet.pushToken(new Token("}"));
    this.gullet.pushTokens(tokens);
    var parse = this.parseExpression(false);
    this.expect("}"); // Restore the next token from the current job.

    this.nextToken = oldToken;
    return parse;
  }

  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precendence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(breakOnInfix, breakOnTokenText) {
    var body = []; // Keep adding atoms to the body until we can't parse any more atoms (either
    // we reached the end, a }, or a \right)

    while (true) {
      // Ignore spaces in math mode
      if (this.mode === "math") {
        this.consumeSpaces();
      }

      var lex = this.fetch();

      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
        break;
      }

      if (breakOnTokenText && lex.text === breakOnTokenText) {
        break;
      }

      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
        break;
      }

      var atom = this.parseAtom(breakOnTokenText);

      if (!atom) {
        break;
      } else if (atom.type === "internal") {
        continue;
      }

      body.push(atom);
    }

    if (this.mode === "text") {
      this.formLigatures(body);
    }

    return this.handleInfixNodes(body);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */


  handleInfixNodes(body) {
    var overIndex = -1;
    var funcName;

    for (var i = 0; i < body.length; i++) {
      if (body[i].type === "infix") {
        if (overIndex !== -1) {
          throw new ParseError("only one infix operator per group", body[i].token);
        }

        overIndex = i;
        funcName = body[i].replaceWith;
      }
    }

    if (overIndex !== -1 && funcName) {
      var numerNode;
      var denomNode;
      var numerBody = body.slice(0, overIndex);
      var denomBody = body.slice(overIndex + 1);

      if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
        numerNode = numerBody[0];
      } else {
        numerNode = {
          type: "ordgroup",
          mode: this.mode,
          body: numerBody
        };
      }

      if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
        denomNode = denomBody[0];
      } else {
        denomNode = {
          type: "ordgroup",
          mode: this.mode,
          body: denomBody
        };
      }

      var node;

      if (funcName === "\\\\abovefrac") {
        node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
      } else {
        node = this.callFunction(funcName, [numerNode, denomNode], []);
      }

      return [node];
    } else {
      return body;
    }
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */


  handleSupSubscript(name // For error reporting.
  ) {
    var symbolToken = this.fetch();
    var symbol = symbolToken.text;
    this.consume();
    this.consumeSpaces(); // ignore spaces before sup/subscript argument

    var group = this.parseGroup(name);

    if (!group) {
      throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
    }

    return group;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */


  formatUnsupportedCmd(text) {
    var textordArray = [];

    for (var i = 0; i < text.length; i++) {
      textordArray.push({
        type: "textord",
        mode: "text",
        text: text[i]
      });
    }

    var textNode = {
      type: "text",
      mode: this.mode,
      body: textordArray
    };
    var colorNode = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [textNode]
    };
    return colorNode;
  }
  /**
   * Parses a group with optional super/subscripts.
   */


  parseAtom(breakOnTokenText) {
    // The body of an atom is an implicit group, so that things like
    // \left(x\right)^2 work correctly.
    var base = this.parseGroup("atom", breakOnTokenText); // In text mode, we don't have superscripts or subscripts

    if (this.mode === "text") {
      return base;
    } // Note that base may be empty (i.e. null) at this point.


    var superscript;
    var subscript;

    while (true) {
      // Guaranteed in math mode, so eat any spaces first.
      this.consumeSpaces(); // Lex the first token

      var lex = this.fetch();

      if (lex.text === "\\limits" || lex.text === "\\nolimits") {
        // We got a limit control
        if (base && base.type === "op") {
          var limits = lex.text === "\\limits";
          base.limits = limits;
          base.alwaysHandleSupSub = true;
        } else if (base && base.type === "operatorname") {
          if (base.alwaysHandleSupSub) {
            base.limits = lex.text === "\\limits";
          }
        } else {
          throw new ParseError("Limit controls must follow a math operator", lex);
        }

        this.consume();
      } else if (lex.text === "^") {
        // We got a superscript start
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }

        superscript = this.handleSupSubscript("superscript");
      } else if (lex.text === "_") {
        // We got a subscript start
        if (subscript) {
          throw new ParseError("Double subscript", lex);
        }

        subscript = this.handleSupSubscript("subscript");
      } else if (lex.text === "'") {
        // We got a prime
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }

        var prime = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }; // Many primes can be grouped together, so we handle this here

        var primes = [prime];
        this.consume(); // Keep lexing tokens until we get something that's not a prime

        while (this.fetch().text === "'") {
          // For each one, add another prime to the list
          primes.push(prime);
          this.consume();
        } // If there's a superscript following the primes, combine that
        // superscript in with the primes.


        if (this.fetch().text === "^") {
          primes.push(this.handleSupSubscript("superscript"));
        } // Put everything into an ordgroup as the superscript


        superscript = {
          type: "ordgroup",
          mode: this.mode,
          body: primes
        };
      } else if (uSubsAndSups[lex.text]) {
        // A Unicode subscript or superscript character.
        // We treat these similarly to the unicode-math package.
        // So we render a string of Unicode (sub|super)scripts the
        // same as a (sub|super)script of regular characters.
        var str = uSubsAndSups[lex.text];
        var isSub = unicodeSubRegEx.test(lex.text);
        this.consume(); // Continue fetching tokens to fill out the string.

        while (true) {
          var token = this.fetch().text;

          if (!uSubsAndSups[token]) {
            break;
          }

          if (unicodeSubRegEx.test(token) !== isSub) {
            break;
          }

          this.consume();
          str += uSubsAndSups[token];
        } // Now create a (sub|super)script.


        var body = new Parser(str, this.settings).parse();

        if (isSub) {
          subscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        } else {
          superscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        }
      } else {
        // If it wasn't ^, _, or ', stop parsing super/subscripts
        break;
      }
    } // Base must be set if superscript or subscript are set per logic above,
    // but need to check here for type check to pass.


    if (superscript || subscript) {
      // If we got either a superscript or subscript, create a supsub
      return {
        type: "supsub",
        mode: this.mode,
        base: base,
        sup: superscript,
        sub: subscript
      };
    } else {
      // Otherwise return the original body
      return base;
    }
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */


  parseFunction(breakOnTokenText, name // For determining its context
  ) {
    var token = this.fetch();
    var func = token.text;
    var funcData = functions[func];

    if (!funcData) {
      return null;
    }

    this.consume(); // consume command token

    if (name && name !== "atom" && !funcData.allowedInArgument) {
      throw new ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
    } else if (this.mode === "text" && !funcData.allowedInText) {
      throw new ParseError("Can't use function '" + func + "' in text mode", token);
    } else if (this.mode === "math" && funcData.allowedInMath === false) {
      throw new ParseError("Can't use function '" + func + "' in math mode", token);
    }

    var {
      args,
      optArgs
    } = this.parseArguments(func, funcData);
    return this.callFunction(func, args, optArgs, token, breakOnTokenText);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */


  callFunction(name, args, optArgs, token, breakOnTokenText) {
    var context = {
      funcName: name,
      parser: this,
      token,
      breakOnTokenText
    };
    var func = functions[name];

    if (func && func.handler) {
      return func.handler(context, args, optArgs);
    } else {
      throw new ParseError("No function handler for " + name);
    }
  }
  /**
   * Parses the arguments of a function or environment
   */


  parseArguments(func, // Should look like "\name" or "\begin{name}".
  funcData) {
    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;

    if (totalArgs === 0) {
      return {
        args: [],
        optArgs: []
      };
    }

    var args = [];
    var optArgs = [];

    for (var i = 0; i < totalArgs; i++) {
      var argType = funcData.argTypes && funcData.argTypes[i];
      var isOptional = i < funcData.numOptionalArgs;

      if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
      funcData.type === "sqrt" && i === 1 && optArgs[0] == null) {
        argType = "primitive";
      }

      var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);

      if (isOptional) {
        optArgs.push(arg);
      } else if (arg != null) {
        args.push(arg);
      } else {
        // should be unreachable
        throw new ParseError("Null argument, please report this as a bug");
      }
    }

    return {
      args,
      optArgs
    };
  }
  /**
   * Parses a group when the mode is changing.
   */


  parseGroupOfType(name, type, optional) {
    switch (type) {
      case "color":
        return this.parseColorGroup(optional);

      case "size":
        return this.parseSizeGroup(optional);

      case "url":
        return this.parseUrlGroup(optional);

      case "math":
      case "text":
        return this.parseArgumentGroup(optional, type);

      case "hbox":
        {
          // hbox argument type wraps the argument in the equivalent of
          // \hbox, which is like \text but switching to \textstyle size.
          var group = this.parseArgumentGroup(optional, "text");
          return group != null ? {
            type: "styling",
            mode: group.mode,
            body: [group],
            style: "text" // simulate \textstyle

          } : null;
        }

      case "raw":
        {
          var token = this.parseStringGroup("raw", optional);
          return token != null ? {
            type: "raw",
            mode: "text",
            string: token.text
          } : null;
        }

      case "primitive":
        {
          if (optional) {
            throw new ParseError("A primitive argument cannot be optional");
          }

          var _group = this.parseGroup(name);

          if (_group == null) {
            throw new ParseError("Expected group as " + name, this.fetch());
          }

          return _group;
        }

      case "original":
      case null:
      case undefined:
        return this.parseArgumentGroup(optional);

      default:
        throw new ParseError("Unknown group type as " + name, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */


  consumeSpaces() {
    while (this.fetch().text === " ") {
      this.consume();
    }
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */


  parseStringGroup(modeName, // Used to describe the mode in error messages.
  optional) {
    var argToken = this.gullet.scanArgument(optional);

    if (argToken == null) {
      return null;
    }

    var str = "";
    var nextToken;

    while ((nextToken = this.fetch()).text !== "EOF") {
      str += nextToken.text;
      this.consume();
    }

    this.consume(); // consume the end of the argument

    argToken.text = str;
    return argToken;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */


  parseRegexGroup(regex, modeName // Used to describe the mode in error messages.
  ) {
    var firstToken = this.fetch();
    var lastToken = firstToken;
    var str = "";
    var nextToken;

    while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
      lastToken = nextToken;
      str += lastToken.text;
      this.consume();
    }

    if (str === "") {
      throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
    }

    return firstToken.range(lastToken, str);
  }
  /**
   * Parses a color description.
   */


  parseColorGroup(optional) {
    var res = this.parseStringGroup("color", optional);

    if (res == null) {
      return null;
    }

    var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);

    if (!match) {
      throw new ParseError("Invalid color: '" + res.text + "'", res);
    }

    var color = match[0];

    if (/^[0-9a-f]{6}$/i.test(color)) {
      // We allow a 6-digit HTML color spec without a leading "#".
      // This follows the xcolor package's HTML color model.
      // Predefined color names are all missed by this RegEx pattern.
      color = "#" + color;
    }

    return {
      type: "color-token",
      mode: this.mode,
      color
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */


  parseSizeGroup(optional) {
    var res;
    var isBlank = false; // don't expand before parseStringGroup

    this.gullet.consumeSpaces();

    if (!optional && this.gullet.future().text !== "{") {
      res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
    } else {
      res = this.parseStringGroup("size", optional);
    }

    if (!res) {
      return null;
    }

    if (!optional && res.text.length === 0) {
      // Because we've tested for what is !optional, this block won't
      // affect \kern, \hspace, etc. It will capture the mandatory arguments
      // to \genfrac and \above.
      res.text = "0pt"; // Enable \above{}

      isBlank = true; // This is here specifically for \genfrac
    }

    var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);

    if (!match) {
      throw new ParseError("Invalid size: '" + res.text + "'", res);
    }

    var data = {
      number: +(match[1] + match[2]),
      // sign + magnitude, cast to number
      unit: match[3]
    };

    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "'", res);
    }

    return {
      type: "size",
      mode: this.mode,
      value: data,
      isBlank
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */


  parseUrlGroup(optional) {
    this.gullet.lexer.setCatcode("%", 13); // active character

    this.gullet.lexer.setCatcode("~", 12); // other character

    var res = this.parseStringGroup("url", optional);
    this.gullet.lexer.setCatcode("%", 14); // comment character

    this.gullet.lexer.setCatcode("~", 13); // active character

    if (res == null) {
      return null;
    } // hyperref package allows backslashes alone in href, but doesn't
    // generate valid links in such cases; we interpret this as
    // "undefined" behaviour, and keep them as-is. Some browser will
    // replace backslashes with forward slashes.


    var url = res.text.replace(/\\([#$%&~_^{}])/g, '$1');
    return {
      type: "url",
      mode: this.mode,
      url
    };
  }
  /**
   * Parses an argument with the mode specified.
   */


  parseArgumentGroup(optional, mode) {
    var argToken = this.gullet.scanArgument(optional);

    if (argToken == null) {
      return null;
    }

    var outerMode = this.mode;

    if (mode) {
      // Switch to specified mode
      this.switchMode(mode);
    }

    this.gullet.beginGroup();
    var expression = this.parseExpression(false, "EOF"); // TODO: find an alternative way to denote the end

    this.expect("EOF"); // expect the end of the argument

    this.gullet.endGroup();
    var result = {
      type: "ordgroup",
      mode: this.mode,
      loc: argToken.loc,
      body: expression
    };

    if (mode) {
      // Switch mode back
      this.switchMode(outerMode);
    }

    return result;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */


  parseGroup(name, // For error reporting.
  breakOnTokenText) {
    var firstToken = this.fetch();
    var text = firstToken.text;
    var result; // Try to parse an open brace or \begingroup

    if (text === "{" || text === "\\begingroup") {
      this.consume();
      var groupEnd = text === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup(); // If we get a brace, parse an expression

      var expression = this.parseExpression(false, groupEnd);
      var lastToken = this.fetch();
      this.expect(groupEnd); // Check that we got a matching closing brace

      this.gullet.endGroup();
      result = {
        type: "ordgroup",
        mode: this.mode,
        loc: SourceLocation.range(firstToken, lastToken),
        body: expression,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: text === "\\begingroup" || undefined
      };
    } else {
      // If there exists a function with this name, parse the function.
      // Otherwise, just return a nucleus
      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();

      if (result == null && text[0] === "\\" && !implicitCommands.hasOwnProperty(text)) {
        if (this.settings.throwOnError) {
          throw new ParseError("Undefined control sequence: " + text, firstToken);
        }

        result = this.formatUnsupportedCmd(text);
        this.consume();
      }
    }

    return result;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */


  formLigatures(group) {
    var n = group.length - 1;

    for (var i = 0; i < n; ++i) {
      var a = group[i]; // $FlowFixMe: Not every node type has a `text` property.

      var v = a.text;

      if (v === "-" && group[i + 1].text === "-") {
        if (i + 1 < n && group[i + 2].text === "-") {
          group.splice(i, 3, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 2]),
            text: "---"
          });
          n -= 2;
        } else {
          group.splice(i, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 1]),
            text: "--"
          });
          n -= 1;
        }
      }

      if ((v === "'" || v === "`") && group[i + 1].text === v) {
        group.splice(i, 2, {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(a, group[i + 1]),
          text: v + v
        });
        n -= 1;
      }
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */


  parseSymbol() {
    var nucleus = this.fetch();
    var text = nucleus.text;

    if (/^\\verb[^a-zA-Z]/.test(text)) {
      this.consume();
      var arg = text.slice(5);
      var star = arg.charAt(0) === "*";

      if (star) {
        arg = arg.slice(1);
      } // Lexer's tokenRegex is constructed to always have matching
      // first/last characters.


      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
        throw new ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
      }

      arg = arg.slice(1, -1); // remove first and last char

      return {
        type: "verb",
        mode: "text",
        body: arg,
        star
      };
    } // At this point, we should have a symbol, possibly with accents.
    // First expand any accented base symbol according to unicodeSymbols.


    if (unicodeSymbols.hasOwnProperty(text[0]) && !symbols[this.mode][text[0]]) {
      // This behavior is not strict (XeTeX-compatible) in math mode.
      if (this.settings.strict && this.mode === "math") {
        this.settings.reportNonstrict("unicodeTextInMathMode", "Accented Unicode text character \"" + text[0] + "\" used in " + "math mode", nucleus);
      }

      text = unicodeSymbols[text[0]] + text.slice(1);
    } // Strip off any combining characters


    var match = combiningDiacriticalMarksEndRegex.exec(text);

    if (match) {
      text = text.substring(0, match.index);

      if (text === 'i') {
        text = '\u0131'; // dotless i, in math and text mode
      } else if (text === 'j') {
        text = '\u0237'; // dotless j, in math and text mode
      }
    } // Recognize base symbol


    var symbol;

    if (symbols[this.mode][text]) {
      if (this.settings.strict && this.mode === 'math' && extraLatin.indexOf(text) >= 0) {
        this.settings.reportNonstrict("unicodeTextInMathMode", "Latin-1/Unicode text character \"" + text[0] + "\" used in " + "math mode", nucleus);
      }

      var group = symbols[this.mode][text].group;
      var loc = SourceLocation.range(nucleus);
      var s;

      if (ATOMS.hasOwnProperty(group)) {
        // $FlowFixMe
        var family = group;
        s = {
          type: "atom",
          mode: this.mode,
          family,
          loc,
          text
        };
      } else {
        // $FlowFixMe
        s = {
          type: group,
          mode: this.mode,
          loc,
          text
        };
      } // $FlowFixMe


      symbol = s;
    } else if (text.charCodeAt(0) >= 0x80) {
      // no symbol for e.g. ^
      if (this.settings.strict) {
        if (!supportedCodepoint(text.charCodeAt(0))) {
          this.settings.reportNonstrict("unknownSymbol", "Unrecognized Unicode character \"" + text[0] + "\"" + (" (" + text.charCodeAt(0) + ")"), nucleus);
        } else if (this.mode === "math") {
          this.settings.reportNonstrict("unicodeTextInMathMode", "Unicode text character \"" + text[0] + "\" used in math mode", nucleus);
        }
      } // All nonmathematical Unicode characters are rendered as if they
      // are in text mode (wrapped in \text) because that's what it
      // takes to render them in LaTeX.  Setting `mode: this.mode` is
      // another natural choice (the user requested math mode), but
      // this makes it more difficult for getCharacterMetrics() to
      // distinguish Unicode characters without metrics and those for
      // which we want to simulate the letter M.


      symbol = {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(nucleus),
        text
      };
    } else {
      return null; // EOF, ^, _, {, }, etc.
    }

    this.consume(); // Transform combining characters into accents

    if (match) {
      for (var i = 0; i < match[0].length; i++) {
        var accent = match[0][i];

        if (!unicodeAccents[accent]) {
          throw new ParseError("Unknown accent ' " + accent + "'", nucleus);
        }

        var command = unicodeAccents[accent][this.mode] || unicodeAccents[accent].text;

        if (!command) {
          throw new ParseError("Accent " + accent + " unsupported in " + this.mode + " mode", nucleus);
        }

        symbol = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(nucleus),
          label: command,
          isStretchy: false,
          isShifty: true,
          // $FlowFixMe
          base: symbol
        };
      }
    } // $FlowFixMe


    return symbol;
  }

}
Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];

/**
 * Provides a single function for parsing an expression using a Parser
 * TODO(emily): Remove this
 */

/**
 * Parses an expression using a Parser, then returns the parsed result.
 */
var parseTree = function parseTree(toParse, settings) {
  if (!(typeof toParse === 'string' || toParse instanceof String)) {
    throw new TypeError('KaTeX can only parse string typed expression');
  }

  var parser = new Parser(toParse, settings); // Blank out any \df@tag to avoid spurious "Duplicate \tag" errors

  delete parser.gullet.macros.current["\\df@tag"];
  var tree = parser.parse(); // Prevent a color definition from persisting between calls to katex.render().

  delete parser.gullet.macros.current["\\current@color"];
  delete parser.gullet.macros.current["\\color"]; // If the input used \tag, it will set the \df@tag macro to the tag.
  // In this case, we separately parse the tag and wrap the tree.

  if (parser.gullet.macros.get("\\df@tag")) {
    if (!settings.displayMode) {
      throw new ParseError("\\tag works only in display equations");
    }

    tree = [{
      type: "tag",
      mode: "text",
      body: tree,
      tag: parser.subparse([new Token("\\df@tag")])
    }];
  }

  return tree;
};

/* eslint no-console:0 */

/**
 * Parse and build an expression, and place that expression in the DOM node
 * given.
 */
var render = function render(expression, baseNode, options) {
  baseNode.textContent = "";
  var node = renderToDomTree(expression, options).toNode();
  baseNode.appendChild(node);
}; // KaTeX's styles don't work properly in quirks mode. Print out an error, and
// disable rendering.


if (typeof document !== "undefined") {
  if (document.compatMode !== "CSS1Compat") {
    typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your " + "website has a suitable doctype.");

    render = function render() {
      throw new ParseError("KaTeX doesn't work in quirks mode.");
    };
  }
}
/**
 * Parse and build an expression, and return the markup for that.
 */


var renderToString = function renderToString(expression, options) {
  var markup = renderToDomTree(expression, options).toMarkup();
  return markup;
};
/**
 * Parse an expression and return the parse tree.
 */


var generateParseTree = function generateParseTree(expression, options) {
  var settings = new Settings(options);
  return parseTree(expression, settings);
};
/**
 * If the given error is a KaTeX ParseError and options.throwOnError is false,
 * renders the invalid LaTeX as a span with hover title giving the KaTeX
 * error message.  Otherwise, simply throws the error.
 */


var renderError = function renderError(error, expression, options) {
  if (options.throwOnError || !(error instanceof ParseError)) {
    throw error;
  }

  var node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
  node.setAttribute("title", error.toString());
  node.setAttribute("style", "color:" + options.errorColor);
  return node;
};
/**
 * Generates and returns the katex build tree. This is used for advanced
 * use cases (like rendering to custom output).
 */


var renderToDomTree = function renderToDomTree(expression, options) {
  var settings = new Settings(options);

  try {
    var tree = parseTree(expression, settings);
    return buildTree(tree, expression, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};
/**
 * Generates and returns the katex build tree, with just HTML (no MathML).
 * This is used for advanced use cases (like rendering to custom output).
 */


var renderToHTMLTree = function renderToHTMLTree(expression, options) {
  var settings = new Settings(options);

  try {
    var tree = parseTree(expression, settings);
    return buildHTMLTree(tree, expression, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};

var katex = {
  /**
   * Current KaTeX version
   */
  version: "0.16.3",

  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render,

  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString,

  /**
   * KaTeX error, usually during parsing.
   */
  ParseError,

  /**
   * The shema of Settings
   */
  SETTINGS_SCHEMA,

  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: generateParseTree,

  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: renderToDomTree,

  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: renderToHTMLTree,

  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: setFontMetrics,

  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: defineSymbol,

  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: defineMacro,

  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: {
    Span,
    Anchor,
    SymbolNode,
    SvgNode,
    PathNode,
    LineNode
  }
};

var showdown$1 = {exports: {}};

(function (module) {
	;/*! showdown v 2.1.0 - 21-04-2022 */
	(function(){
	/**
	 * Created by Tivie on 13-07-2015.
	 */

	function getDefaultOpts (simple) {
	  'use strict';

	  var defaultOptions = {
	    omitExtraWLInCodeBlocks: {
	      defaultValue: false,
	      describe: 'Omit the default extra whiteline added to code blocks',
	      type: 'boolean'
	    },
	    noHeaderId: {
	      defaultValue: false,
	      describe: 'Turn on/off generated header id',
	      type: 'boolean'
	    },
	    prefixHeaderId: {
	      defaultValue: false,
	      describe: 'Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic \'section-\' prefix',
	      type: 'string'
	    },
	    rawPrefixHeaderId: {
	      defaultValue: false,
	      describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
	      type: 'boolean'
	    },
	    ghCompatibleHeaderId: {
	      defaultValue: false,
	      describe: 'Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)',
	      type: 'boolean'
	    },
	    rawHeaderId: {
	      defaultValue: false,
	      describe: 'Remove only spaces, \' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids',
	      type: 'boolean'
	    },
	    headerLevelStart: {
	      defaultValue: false,
	      describe: 'The header blocks level start',
	      type: 'integer'
	    },
	    parseImgDimensions: {
	      defaultValue: false,
	      describe: 'Turn on/off image dimension parsing',
	      type: 'boolean'
	    },
	    simplifiedAutoLink: {
	      defaultValue: false,
	      describe: 'Turn on/off GFM autolink style',
	      type: 'boolean'
	    },
	    excludeTrailingPunctuationFromURLs: {
	      defaultValue: false,
	      describe: 'Excludes trailing punctuation from links generated with autoLinking',
	      type: 'boolean'
	    },
	    literalMidWordUnderscores: {
	      defaultValue: false,
	      describe: 'Parse midword underscores as literal underscores',
	      type: 'boolean'
	    },
	    literalMidWordAsterisks: {
	      defaultValue: false,
	      describe: 'Parse midword asterisks as literal asterisks',
	      type: 'boolean'
	    },
	    strikethrough: {
	      defaultValue: false,
	      describe: 'Turn on/off strikethrough support',
	      type: 'boolean'
	    },
	    tables: {
	      defaultValue: false,
	      describe: 'Turn on/off tables support',
	      type: 'boolean'
	    },
	    tablesHeaderId: {
	      defaultValue: false,
	      describe: 'Add an id to table headers',
	      type: 'boolean'
	    },
	    ghCodeBlocks: {
	      defaultValue: true,
	      describe: 'Turn on/off GFM fenced code blocks support',
	      type: 'boolean'
	    },
	    tasklists: {
	      defaultValue: false,
	      describe: 'Turn on/off GFM tasklist support',
	      type: 'boolean'
	    },
	    smoothLivePreview: {
	      defaultValue: false,
	      describe: 'Prevents weird effects in live previews due to incomplete input',
	      type: 'boolean'
	    },
	    smartIndentationFix: {
	      defaultValue: false,
	      describe: 'Tries to smartly fix indentation in es6 strings',
	      type: 'boolean'
	    },
	    disableForced4SpacesIndentedSublists: {
	      defaultValue: false,
	      describe: 'Disables the requirement of indenting nested sublists by 4 spaces',
	      type: 'boolean'
	    },
	    simpleLineBreaks: {
	      defaultValue: false,
	      describe: 'Parses simple line breaks as <br> (GFM Style)',
	      type: 'boolean'
	    },
	    requireSpaceBeforeHeadingText: {
	      defaultValue: false,
	      describe: 'Makes adding a space between `#` and the header text mandatory (GFM Style)',
	      type: 'boolean'
	    },
	    ghMentions: {
	      defaultValue: false,
	      describe: 'Enables github @mentions',
	      type: 'boolean'
	    },
	    ghMentionsLink: {
	      defaultValue: 'https://github.com/{u}',
	      describe: 'Changes the link generated by @mentions. Only applies if ghMentions option is enabled.',
	      type: 'string'
	    },
	    encodeEmails: {
	      defaultValue: true,
	      describe: 'Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities',
	      type: 'boolean'
	    },
	    openLinksInNewWindow: {
	      defaultValue: false,
	      describe: 'Open all links in new windows',
	      type: 'boolean'
	    },
	    backslashEscapesHTMLTags: {
	      defaultValue: false,
	      describe: 'Support for HTML Tag escaping. ex: \<div>foo\</div>',
	      type: 'boolean'
	    },
	    emoji: {
	      defaultValue: false,
	      describe: 'Enable emoji support. Ex: `this is a :smile: emoji`',
	      type: 'boolean'
	    },
	    underline: {
	      defaultValue: false,
	      describe: 'Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`',
	      type: 'boolean'
	    },
	    ellipsis: {
	      defaultValue: true,
	      describe: 'Replaces three dots with the ellipsis unicode character',
	      type: 'boolean'
	    },
	    completeHTMLDocument: {
	      defaultValue: false,
	      describe: 'Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags',
	      type: 'boolean'
	    },
	    metadata: {
	      defaultValue: false,
	      describe: 'Enable support for document metadata (defined at the top of the document between `«««` and `»»»` or between `---` and `---`).',
	      type: 'boolean'
	    },
	    splitAdjacentBlockquotes: {
	      defaultValue: false,
	      describe: 'Split adjacent blockquote blocks',
	      type: 'boolean'
	    }
	  };
	  if (simple === false) {
	    return JSON.parse(JSON.stringify(defaultOptions));
	  }
	  var ret = {};
	  for (var opt in defaultOptions) {
	    if (defaultOptions.hasOwnProperty(opt)) {
	      ret[opt] = defaultOptions[opt].defaultValue;
	    }
	  }
	  return ret;
	}

	function allOptionsOn () {
	  'use strict';
	  var options = getDefaultOpts(true),
	      ret = {};
	  for (var opt in options) {
	    if (options.hasOwnProperty(opt)) {
	      ret[opt] = true;
	    }
	  }
	  return ret;
	}

	/**
	 * Created by Tivie on 06-01-2015.
	 */

	// Private properties
	var showdown = {},
	    parsers = {},
	    extensions = {},
	    globalOptions = getDefaultOpts(true),
	    setFlavor = 'vanilla',
	    flavor = {
	      github: {
	        omitExtraWLInCodeBlocks:              true,
	        simplifiedAutoLink:                   true,
	        excludeTrailingPunctuationFromURLs:   true,
	        literalMidWordUnderscores:            true,
	        strikethrough:                        true,
	        tables:                               true,
	        tablesHeaderId:                       true,
	        ghCodeBlocks:                         true,
	        tasklists:                            true,
	        disableForced4SpacesIndentedSublists: true,
	        simpleLineBreaks:                     true,
	        requireSpaceBeforeHeadingText:        true,
	        ghCompatibleHeaderId:                 true,
	        ghMentions:                           true,
	        backslashEscapesHTMLTags:             true,
	        emoji:                                true,
	        splitAdjacentBlockquotes:             true
	      },
	      original: {
	        noHeaderId:                           true,
	        ghCodeBlocks:                         false
	      },
	      ghost: {
	        omitExtraWLInCodeBlocks:              true,
	        parseImgDimensions:                   true,
	        simplifiedAutoLink:                   true,
	        excludeTrailingPunctuationFromURLs:   true,
	        literalMidWordUnderscores:            true,
	        strikethrough:                        true,
	        tables:                               true,
	        tablesHeaderId:                       true,
	        ghCodeBlocks:                         true,
	        tasklists:                            true,
	        smoothLivePreview:                    true,
	        simpleLineBreaks:                     true,
	        requireSpaceBeforeHeadingText:        true,
	        ghMentions:                           false,
	        encodeEmails:                         true
	      },
	      vanilla: getDefaultOpts(true),
	      allOn: allOptionsOn()
	    };

	/**
	 * helper namespace
	 * @type {{}}
	 */
	showdown.helper = {};

	/**
	 * TODO LEGACY SUPPORT CODE
	 * @type {{}}
	 */
	showdown.extensions = {};

	/**
	 * Set a global option
	 * @static
	 * @param {string} key
	 * @param {*} value
	 * @returns {showdown}
	 */
	showdown.setOption = function (key, value) {
	  'use strict';
	  globalOptions[key] = value;
	  return this;
	};

	/**
	 * Get a global option
	 * @static
	 * @param {string} key
	 * @returns {*}
	 */
	showdown.getOption = function (key) {
	  'use strict';
	  return globalOptions[key];
	};

	/**
	 * Get the global options
	 * @static
	 * @returns {{}}
	 */
	showdown.getOptions = function () {
	  'use strict';
	  return globalOptions;
	};

	/**
	 * Reset global options to the default values
	 * @static
	 */
	showdown.resetOptions = function () {
	  'use strict';
	  globalOptions = getDefaultOpts(true);
	};

	/**
	 * Set the flavor showdown should use as default
	 * @param {string} name
	 */
	showdown.setFlavor = function (name) {
	  'use strict';
	  if (!flavor.hasOwnProperty(name)) {
	    throw Error(name + ' flavor was not found');
	  }
	  showdown.resetOptions();
	  var preset = flavor[name];
	  setFlavor = name;
	  for (var option in preset) {
	    if (preset.hasOwnProperty(option)) {
	      globalOptions[option] = preset[option];
	    }
	  }
	};

	/**
	 * Get the currently set flavor
	 * @returns {string}
	 */
	showdown.getFlavor = function () {
	  'use strict';
	  return setFlavor;
	};

	/**
	 * Get the options of a specified flavor. Returns undefined if the flavor was not found
	 * @param {string} name Name of the flavor
	 * @returns {{}|undefined}
	 */
	showdown.getFlavorOptions = function (name) {
	  'use strict';
	  if (flavor.hasOwnProperty(name)) {
	    return flavor[name];
	  }
	};

	/**
	 * Get the default options
	 * @static
	 * @param {boolean} [simple=true]
	 * @returns {{}}
	 */
	showdown.getDefaultOptions = function (simple) {
	  'use strict';
	  return getDefaultOpts(simple);
	};

	/**
	 * Get or set a subParser
	 *
	 * subParser(name)       - Get a registered subParser
	 * subParser(name, func) - Register a subParser
	 * @static
	 * @param {string} name
	 * @param {function} [func]
	 * @returns {*}
	 */
	showdown.subParser = function (name, func) {
	  'use strict';
	  if (showdown.helper.isString(name)) {
	    if (typeof func !== 'undefined') {
	      parsers[name] = func;
	    } else {
	      if (parsers.hasOwnProperty(name)) {
	        return parsers[name];
	      } else {
	        throw Error('SubParser named ' + name + ' not registered!');
	      }
	    }
	  }
	};

	/**
	 * Gets or registers an extension
	 * @static
	 * @param {string} name
	 * @param {object|object[]|function=} ext
	 * @returns {*}
	 */
	showdown.extension = function (name, ext) {
	  'use strict';

	  if (!showdown.helper.isString(name)) {
	    throw Error('Extension \'name\' must be a string');
	  }

	  name = showdown.helper.stdExtName(name);

	  // Getter
	  if (showdown.helper.isUndefined(ext)) {
	    if (!extensions.hasOwnProperty(name)) {
	      throw Error('Extension named ' + name + ' is not registered!');
	    }
	    return extensions[name];

	    // Setter
	  } else {
	    // Expand extension if it's wrapped in a function
	    if (typeof ext === 'function') {
	      ext = ext();
	    }

	    // Ensure extension is an array
	    if (!showdown.helper.isArray(ext)) {
	      ext = [ext];
	    }

	    var validExtension = validate(ext, name);

	    if (validExtension.valid) {
	      extensions[name] = ext;
	    } else {
	      throw Error(validExtension.error);
	    }
	  }
	};

	/**
	 * Gets all extensions registered
	 * @returns {{}}
	 */
	showdown.getAllExtensions = function () {
	  'use strict';
	  return extensions;
	};

	/**
	 * Remove an extension
	 * @param {string} name
	 */
	showdown.removeExtension = function (name) {
	  'use strict';
	  delete extensions[name];
	};

	/**
	 * Removes all extensions
	 */
	showdown.resetExtensions = function () {
	  'use strict';
	  extensions = {};
	};

	/**
	 * Validate extension
	 * @param {array} extension
	 * @param {string} name
	 * @returns {{valid: boolean, error: string}}
	 */
	function validate (extension, name) {
	  'use strict';

	  var errMsg = (name) ? 'Error in ' + name + ' extension->' : 'Error in unnamed extension',
	      ret = {
	        valid: true,
	        error: ''
	      };

	  if (!showdown.helper.isArray(extension)) {
	    extension = [extension];
	  }

	  for (var i = 0; i < extension.length; ++i) {
	    var baseMsg = errMsg + ' sub-extension ' + i + ': ',
	        ext = extension[i];
	    if (typeof ext !== 'object') {
	      ret.valid = false;
	      ret.error = baseMsg + 'must be an object, but ' + typeof ext + ' given';
	      return ret;
	    }

	    if (!showdown.helper.isString(ext.type)) {
	      ret.valid = false;
	      ret.error = baseMsg + 'property "type" must be a string, but ' + typeof ext.type + ' given';
	      return ret;
	    }

	    var type = ext.type = ext.type.toLowerCase();

	    // normalize extension type
	    if (type === 'language') {
	      type = ext.type = 'lang';
	    }

	    if (type === 'html') {
	      type = ext.type = 'output';
	    }

	    if (type !== 'lang' && type !== 'output' && type !== 'listener') {
	      ret.valid = false;
	      ret.error = baseMsg + 'type ' + type + ' is not recognized. Valid values: "lang/language", "output/html" or "listener"';
	      return ret;
	    }

	    if (type === 'listener') {
	      if (showdown.helper.isUndefined(ext.listeners)) {
	        ret.valid = false;
	        ret.error = baseMsg + '. Extensions of type "listener" must have a property called "listeners"';
	        return ret;
	      }
	    } else {
	      if (showdown.helper.isUndefined(ext.filter) && showdown.helper.isUndefined(ext.regex)) {
	        ret.valid = false;
	        ret.error = baseMsg + type + ' extensions must define either a "regex" property or a "filter" method';
	        return ret;
	      }
	    }

	    if (ext.listeners) {
	      if (typeof ext.listeners !== 'object') {
	        ret.valid = false;
	        ret.error = baseMsg + '"listeners" property must be an object but ' + typeof ext.listeners + ' given';
	        return ret;
	      }
	      for (var ln in ext.listeners) {
	        if (ext.listeners.hasOwnProperty(ln)) {
	          if (typeof ext.listeners[ln] !== 'function') {
	            ret.valid = false;
	            ret.error = baseMsg + '"listeners" property must be an hash of [event name]: [callback]. listeners.' + ln +
	              ' must be a function but ' + typeof ext.listeners[ln] + ' given';
	            return ret;
	          }
	        }
	      }
	    }

	    if (ext.filter) {
	      if (typeof ext.filter !== 'function') {
	        ret.valid = false;
	        ret.error = baseMsg + '"filter" must be a function, but ' + typeof ext.filter + ' given';
	        return ret;
	      }
	    } else if (ext.regex) {
	      if (showdown.helper.isString(ext.regex)) {
	        ext.regex = new RegExp(ext.regex, 'g');
	      }
	      if (!(ext.regex instanceof RegExp)) {
	        ret.valid = false;
	        ret.error = baseMsg + '"regex" property must either be a string or a RegExp object, but ' + typeof ext.regex + ' given';
	        return ret;
	      }
	      if (showdown.helper.isUndefined(ext.replace)) {
	        ret.valid = false;
	        ret.error = baseMsg + '"regex" extensions must implement a replace string or function';
	        return ret;
	      }
	    }
	  }
	  return ret;
	}

	/**
	 * Validate extension
	 * @param {object} ext
	 * @returns {boolean}
	 */
	showdown.validateExtension = function (ext) {
	  'use strict';

	  var validateExtension = validate(ext, null);
	  if (!validateExtension.valid) {
	    console.warn(validateExtension.error);
	    return false;
	  }
	  return true;
	};

	/**
	 * showdownjs helper functions
	 */

	if (!showdown.hasOwnProperty('helper')) {
	  showdown.helper = {};
	}

	/**
	 * Check if var is string
	 * @static
	 * @param {string} a
	 * @returns {boolean}
	 */
	showdown.helper.isString = function (a) {
	  'use strict';
	  return (typeof a === 'string' || a instanceof String);
	};

	/**
	 * Check if var is a function
	 * @static
	 * @param {*} a
	 * @returns {boolean}
	 */
	showdown.helper.isFunction = function (a) {
	  'use strict';
	  var getType = {};
	  return a && getType.toString.call(a) === '[object Function]';
	};

	/**
	 * isArray helper function
	 * @static
	 * @param {*} a
	 * @returns {boolean}
	 */
	showdown.helper.isArray = function (a) {
	  'use strict';
	  return Array.isArray(a);
	};

	/**
	 * Check if value is undefined
	 * @static
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	 */
	showdown.helper.isUndefined = function (value) {
	  'use strict';
	  return typeof value === 'undefined';
	};

	/**
	 * ForEach helper function
	 * Iterates over Arrays and Objects (own properties only)
	 * @static
	 * @param {*} obj
	 * @param {function} callback Accepts 3 params: 1. value, 2. key, 3. the original array/object
	 */
	showdown.helper.forEach = function (obj, callback) {
	  'use strict';
	  // check if obj is defined
	  if (showdown.helper.isUndefined(obj)) {
	    throw new Error('obj param is required');
	  }

	  if (showdown.helper.isUndefined(callback)) {
	    throw new Error('callback param is required');
	  }

	  if (!showdown.helper.isFunction(callback)) {
	    throw new Error('callback param must be a function/closure');
	  }

	  if (typeof obj.forEach === 'function') {
	    obj.forEach(callback);
	  } else if (showdown.helper.isArray(obj)) {
	    for (var i = 0; i < obj.length; i++) {
	      callback(obj[i], i, obj);
	    }
	  } else if (typeof (obj) === 'object') {
	    for (var prop in obj) {
	      if (obj.hasOwnProperty(prop)) {
	        callback(obj[prop], prop, obj);
	      }
	    }
	  } else {
	    throw new Error('obj does not seem to be an array or an iterable object');
	  }
	};

	/**
	 * Standardidize extension name
	 * @static
	 * @param {string} s extension name
	 * @returns {string}
	 */
	showdown.helper.stdExtName = function (s) {
	  'use strict';
	  return s.replace(/[_?*+\/\\.^-]/g, '').replace(/\s/g, '').toLowerCase();
	};

	function escapeCharactersCallback (wholeMatch, m1) {
	  'use strict';
	  var charCodeToEscape = m1.charCodeAt(0);
	  return '¨E' + charCodeToEscape + 'E';
	}

	/**
	 * Callback used to escape characters when passing through String.replace
	 * @static
	 * @param {string} wholeMatch
	 * @param {string} m1
	 * @returns {string}
	 */
	showdown.helper.escapeCharactersCallback = escapeCharactersCallback;

	/**
	 * Escape characters in a string
	 * @static
	 * @param {string} text
	 * @param {string} charsToEscape
	 * @param {boolean} afterBackslash
	 * @returns {XML|string|void|*}
	 */
	showdown.helper.escapeCharacters = function (text, charsToEscape, afterBackslash) {
	  'use strict';
	  // First we have to escape the escape characters so that
	  // we can build a character class out of them
	  var regexString = '([' + charsToEscape.replace(/([\[\]\\])/g, '\\$1') + '])';

	  if (afterBackslash) {
	    regexString = '\\\\' + regexString;
	  }

	  var regex = new RegExp(regexString, 'g');
	  text = text.replace(regex, escapeCharactersCallback);

	  return text;
	};

	/**
	 * Unescape HTML entities
	 * @param txt
	 * @returns {string}
	 */
	showdown.helper.unescapeHTMLEntities = function (txt) {
	  'use strict';

	  return txt
	    .replace(/&quot;/g, '"')
	    .replace(/&lt;/g, '<')
	    .replace(/&gt;/g, '>')
	    .replace(/&amp;/g, '&');
	};

	var rgxFindMatchPos = function (str, left, right, flags) {
	  'use strict';
	  var f = flags || '',
	      g = f.indexOf('g') > -1,
	      x = new RegExp(left + '|' + right, 'g' + f.replace(/g/g, '')),
	      l = new RegExp(left, f.replace(/g/g, '')),
	      pos = [],
	      t, s, m, start, end;

	  do {
	    t = 0;
	    while ((m = x.exec(str))) {
	      if (l.test(m[0])) {
	        if (!(t++)) {
	          s = x.lastIndex;
	          start = s - m[0].length;
	        }
	      } else if (t) {
	        if (!--t) {
	          end = m.index + m[0].length;
	          var obj = {
	            left: {start: start, end: s},
	            match: {start: s, end: m.index},
	            right: {start: m.index, end: end},
	            wholeMatch: {start: start, end: end}
	          };
	          pos.push(obj);
	          if (!g) {
	            return pos;
	          }
	        }
	      }
	    }
	  } while (t && (x.lastIndex = s));

	  return pos;
	};

	/**
	 * matchRecursiveRegExp
	 *
	 * (c) 2007 Steven Levithan <stevenlevithan.com>
	 * MIT License
	 *
	 * Accepts a string to search, a left and right format delimiter
	 * as regex patterns, and optional regex flags. Returns an array
	 * of matches, allowing nested instances of left/right delimiters.
	 * Use the "g" flag to return all matches, otherwise only the
	 * first is returned. Be careful to ensure that the left and
	 * right format delimiters produce mutually exclusive matches.
	 * Backreferences are not supported within the right delimiter
	 * due to how it is internally combined with the left delimiter.
	 * When matching strings whose format delimiters are unbalanced
	 * to the left or right, the output is intentionally as a
	 * conventional regex library with recursion support would
	 * produce, e.g. "<<x>" and "<x>>" both produce ["x"] when using
	 * "<" and ">" as the delimiters (both strings contain a single,
	 * balanced instance of "<x>").
	 *
	 * examples:
	 * matchRecursiveRegExp("test", "\\(", "\\)")
	 * returns: []
	 * matchRecursiveRegExp("<t<<e>><s>>t<>", "<", ">", "g")
	 * returns: ["t<<e>><s>", ""]
	 * matchRecursiveRegExp("<div id=\"x\">test</div>", "<div\\b[^>]*>", "</div>", "gi")
	 * returns: ["test"]
	 */
	showdown.helper.matchRecursiveRegExp = function (str, left, right, flags) {
	  'use strict';

	  var matchPos = rgxFindMatchPos (str, left, right, flags),
	      results = [];

	  for (var i = 0; i < matchPos.length; ++i) {
	    results.push([
	      str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
	      str.slice(matchPos[i].match.start, matchPos[i].match.end),
	      str.slice(matchPos[i].left.start, matchPos[i].left.end),
	      str.slice(matchPos[i].right.start, matchPos[i].right.end)
	    ]);
	  }
	  return results;
	};

	/**
	 *
	 * @param {string} str
	 * @param {string|function} replacement
	 * @param {string} left
	 * @param {string} right
	 * @param {string} flags
	 * @returns {string}
	 */
	showdown.helper.replaceRecursiveRegExp = function (str, replacement, left, right, flags) {
	  'use strict';

	  if (!showdown.helper.isFunction(replacement)) {
	    var repStr = replacement;
	    replacement = function () {
	      return repStr;
	    };
	  }

	  var matchPos = rgxFindMatchPos(str, left, right, flags),
	      finalStr = str,
	      lng = matchPos.length;

	  if (lng > 0) {
	    var bits = [];
	    if (matchPos[0].wholeMatch.start !== 0) {
	      bits.push(str.slice(0, matchPos[0].wholeMatch.start));
	    }
	    for (var i = 0; i < lng; ++i) {
	      bits.push(
	        replacement(
	          str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
	          str.slice(matchPos[i].match.start, matchPos[i].match.end),
	          str.slice(matchPos[i].left.start, matchPos[i].left.end),
	          str.slice(matchPos[i].right.start, matchPos[i].right.end)
	        )
	      );
	      if (i < lng - 1) {
	        bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));
	      }
	    }
	    if (matchPos[lng - 1].wholeMatch.end < str.length) {
	      bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));
	    }
	    finalStr = bits.join('');
	  }
	  return finalStr;
	};

	/**
	 * Returns the index within the passed String object of the first occurrence of the specified regex,
	 * starting the search at fromIndex. Returns -1 if the value is not found.
	 *
	 * @param {string} str string to search
	 * @param {RegExp} regex Regular expression to search
	 * @param {int} [fromIndex = 0] Index to start the search
	 * @returns {Number}
	 * @throws InvalidArgumentError
	 */
	showdown.helper.regexIndexOf = function (str, regex, fromIndex) {
	  'use strict';
	  if (!showdown.helper.isString(str)) {
	    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
	  }
	  if (regex instanceof RegExp === false) {
	    throw 'InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp';
	  }
	  var indexOf = str.substring(fromIndex || 0).search(regex);
	  return (indexOf >= 0) ? (indexOf + (fromIndex || 0)) : indexOf;
	};

	/**
	 * Splits the passed string object at the defined index, and returns an array composed of the two substrings
	 * @param {string} str string to split
	 * @param {int} index index to split string at
	 * @returns {[string,string]}
	 * @throws InvalidArgumentError
	 */
	showdown.helper.splitAtIndex = function (str, index) {
	  'use strict';
	  if (!showdown.helper.isString(str)) {
	    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
	  }
	  return [str.substring(0, index), str.substring(index)];
	};

	/**
	 * Obfuscate an e-mail address through the use of Character Entities,
	 * transforming ASCII characters into their equivalent decimal or hex entities.
	 *
	 * Since it has a random component, subsequent calls to this function produce different results
	 *
	 * @param {string} mail
	 * @returns {string}
	 */
	showdown.helper.encodeEmailAddress = function (mail) {
	  'use strict';
	  var encode = [
	    function (ch) {
	      return '&#' + ch.charCodeAt(0) + ';';
	    },
	    function (ch) {
	      return '&#x' + ch.charCodeAt(0).toString(16) + ';';
	    },
	    function (ch) {
	      return ch;
	    }
	  ];

	  mail = mail.replace(/./g, function (ch) {
	    if (ch === '@') {
	      // this *must* be encoded. I insist.
	      ch = encode[Math.floor(Math.random() * 2)](ch);
	    } else {
	      var r = Math.random();
	      // roughly 10% raw, 45% hex, 45% dec
	      ch = (
	        r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch)
	      );
	    }
	    return ch;
	  });

	  return mail;
	};

	/**
	 *
	 * @param str
	 * @param targetLength
	 * @param padString
	 * @returns {string}
	 */
	showdown.helper.padEnd = function padEnd (str, targetLength, padString) {
	  'use strict';
	  /*jshint bitwise: false*/
	  // eslint-disable-next-line space-infix-ops
	  targetLength = targetLength>>0; //floor if number or convert non-number to 0;
	  /*jshint bitwise: true*/
	  padString = String(padString || ' ');
	  if (str.length > targetLength) {
	    return String(str);
	  } else {
	    targetLength = targetLength - str.length;
	    if (targetLength > padString.length) {
	      padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
	    }
	    return String(str) + padString.slice(0,targetLength);
	  }
	};

	/**
	 * POLYFILLS
	 */
	// use this instead of builtin is undefined for IE8 compatibility
	if (typeof (console) === 'undefined') {
	  console = {
	    warn: function (msg) {
	      'use strict';
	      alert(msg);
	    },
	    log: function (msg) {
	      'use strict';
	      alert(msg);
	    },
	    error: function (msg) {
	      'use strict';
	      throw msg;
	    }
	  };
	}

	/**
	 * Common regexes.
	 * We declare some common regexes to improve performance
	 */
	showdown.helper.regexes = {
	  asteriskDashAndColon: /([*_:~])/g
	};

	/**
	 * EMOJIS LIST
	 */
	showdown.helper.emojis = {
	  '+1':'\ud83d\udc4d',
	  '-1':'\ud83d\udc4e',
	  '100':'\ud83d\udcaf',
	  '1234':'\ud83d\udd22',
	  '1st_place_medal':'\ud83e\udd47',
	  '2nd_place_medal':'\ud83e\udd48',
	  '3rd_place_medal':'\ud83e\udd49',
	  '8ball':'\ud83c\udfb1',
	  'a':'\ud83c\udd70\ufe0f',
	  'ab':'\ud83c\udd8e',
	  'abc':'\ud83d\udd24',
	  'abcd':'\ud83d\udd21',
	  'accept':'\ud83c\ude51',
	  'aerial_tramway':'\ud83d\udea1',
	  'airplane':'\u2708\ufe0f',
	  'alarm_clock':'\u23f0',
	  'alembic':'\u2697\ufe0f',
	  'alien':'\ud83d\udc7d',
	  'ambulance':'\ud83d\ude91',
	  'amphora':'\ud83c\udffa',
	  'anchor':'\u2693\ufe0f',
	  'angel':'\ud83d\udc7c',
	  'anger':'\ud83d\udca2',
	  'angry':'\ud83d\ude20',
	  'anguished':'\ud83d\ude27',
	  'ant':'\ud83d\udc1c',
	  'apple':'\ud83c\udf4e',
	  'aquarius':'\u2652\ufe0f',
	  'aries':'\u2648\ufe0f',
	  'arrow_backward':'\u25c0\ufe0f',
	  'arrow_double_down':'\u23ec',
	  'arrow_double_up':'\u23eb',
	  'arrow_down':'\u2b07\ufe0f',
	  'arrow_down_small':'\ud83d\udd3d',
	  'arrow_forward':'\u25b6\ufe0f',
	  'arrow_heading_down':'\u2935\ufe0f',
	  'arrow_heading_up':'\u2934\ufe0f',
	  'arrow_left':'\u2b05\ufe0f',
	  'arrow_lower_left':'\u2199\ufe0f',
	  'arrow_lower_right':'\u2198\ufe0f',
	  'arrow_right':'\u27a1\ufe0f',
	  'arrow_right_hook':'\u21aa\ufe0f',
	  'arrow_up':'\u2b06\ufe0f',
	  'arrow_up_down':'\u2195\ufe0f',
	  'arrow_up_small':'\ud83d\udd3c',
	  'arrow_upper_left':'\u2196\ufe0f',
	  'arrow_upper_right':'\u2197\ufe0f',
	  'arrows_clockwise':'\ud83d\udd03',
	  'arrows_counterclockwise':'\ud83d\udd04',
	  'art':'\ud83c\udfa8',
	  'articulated_lorry':'\ud83d\ude9b',
	  'artificial_satellite':'\ud83d\udef0',
	  'astonished':'\ud83d\ude32',
	  'athletic_shoe':'\ud83d\udc5f',
	  'atm':'\ud83c\udfe7',
	  'atom_symbol':'\u269b\ufe0f',
	  'avocado':'\ud83e\udd51',
	  'b':'\ud83c\udd71\ufe0f',
	  'baby':'\ud83d\udc76',
	  'baby_bottle':'\ud83c\udf7c',
	  'baby_chick':'\ud83d\udc24',
	  'baby_symbol':'\ud83d\udebc',
	  'back':'\ud83d\udd19',
	  'bacon':'\ud83e\udd53',
	  'badminton':'\ud83c\udff8',
	  'baggage_claim':'\ud83d\udec4',
	  'baguette_bread':'\ud83e\udd56',
	  'balance_scale':'\u2696\ufe0f',
	  'balloon':'\ud83c\udf88',
	  'ballot_box':'\ud83d\uddf3',
	  'ballot_box_with_check':'\u2611\ufe0f',
	  'bamboo':'\ud83c\udf8d',
	  'banana':'\ud83c\udf4c',
	  'bangbang':'\u203c\ufe0f',
	  'bank':'\ud83c\udfe6',
	  'bar_chart':'\ud83d\udcca',
	  'barber':'\ud83d\udc88',
	  'baseball':'\u26be\ufe0f',
	  'basketball':'\ud83c\udfc0',
	  'basketball_man':'\u26f9\ufe0f',
	  'basketball_woman':'\u26f9\ufe0f&zwj;\u2640\ufe0f',
	  'bat':'\ud83e\udd87',
	  'bath':'\ud83d\udec0',
	  'bathtub':'\ud83d\udec1',
	  'battery':'\ud83d\udd0b',
	  'beach_umbrella':'\ud83c\udfd6',
	  'bear':'\ud83d\udc3b',
	  'bed':'\ud83d\udecf',
	  'bee':'\ud83d\udc1d',
	  'beer':'\ud83c\udf7a',
	  'beers':'\ud83c\udf7b',
	  'beetle':'\ud83d\udc1e',
	  'beginner':'\ud83d\udd30',
	  'bell':'\ud83d\udd14',
	  'bellhop_bell':'\ud83d\udece',
	  'bento':'\ud83c\udf71',
	  'biking_man':'\ud83d\udeb4',
	  'bike':'\ud83d\udeb2',
	  'biking_woman':'\ud83d\udeb4&zwj;\u2640\ufe0f',
	  'bikini':'\ud83d\udc59',
	  'biohazard':'\u2623\ufe0f',
	  'bird':'\ud83d\udc26',
	  'birthday':'\ud83c\udf82',
	  'black_circle':'\u26ab\ufe0f',
	  'black_flag':'\ud83c\udff4',
	  'black_heart':'\ud83d\udda4',
	  'black_joker':'\ud83c\udccf',
	  'black_large_square':'\u2b1b\ufe0f',
	  'black_medium_small_square':'\u25fe\ufe0f',
	  'black_medium_square':'\u25fc\ufe0f',
	  'black_nib':'\u2712\ufe0f',
	  'black_small_square':'\u25aa\ufe0f',
	  'black_square_button':'\ud83d\udd32',
	  'blonde_man':'\ud83d\udc71',
	  'blonde_woman':'\ud83d\udc71&zwj;\u2640\ufe0f',
	  'blossom':'\ud83c\udf3c',
	  'blowfish':'\ud83d\udc21',
	  'blue_book':'\ud83d\udcd8',
	  'blue_car':'\ud83d\ude99',
	  'blue_heart':'\ud83d\udc99',
	  'blush':'\ud83d\ude0a',
	  'boar':'\ud83d\udc17',
	  'boat':'\u26f5\ufe0f',
	  'bomb':'\ud83d\udca3',
	  'book':'\ud83d\udcd6',
	  'bookmark':'\ud83d\udd16',
	  'bookmark_tabs':'\ud83d\udcd1',
	  'books':'\ud83d\udcda',
	  'boom':'\ud83d\udca5',
	  'boot':'\ud83d\udc62',
	  'bouquet':'\ud83d\udc90',
	  'bowing_man':'\ud83d\ude47',
	  'bow_and_arrow':'\ud83c\udff9',
	  'bowing_woman':'\ud83d\ude47&zwj;\u2640\ufe0f',
	  'bowling':'\ud83c\udfb3',
	  'boxing_glove':'\ud83e\udd4a',
	  'boy':'\ud83d\udc66',
	  'bread':'\ud83c\udf5e',
	  'bride_with_veil':'\ud83d\udc70',
	  'bridge_at_night':'\ud83c\udf09',
	  'briefcase':'\ud83d\udcbc',
	  'broken_heart':'\ud83d\udc94',
	  'bug':'\ud83d\udc1b',
	  'building_construction':'\ud83c\udfd7',
	  'bulb':'\ud83d\udca1',
	  'bullettrain_front':'\ud83d\ude85',
	  'bullettrain_side':'\ud83d\ude84',
	  'burrito':'\ud83c\udf2f',
	  'bus':'\ud83d\ude8c',
	  'business_suit_levitating':'\ud83d\udd74',
	  'busstop':'\ud83d\ude8f',
	  'bust_in_silhouette':'\ud83d\udc64',
	  'busts_in_silhouette':'\ud83d\udc65',
	  'butterfly':'\ud83e\udd8b',
	  'cactus':'\ud83c\udf35',
	  'cake':'\ud83c\udf70',
	  'calendar':'\ud83d\udcc6',
	  'call_me_hand':'\ud83e\udd19',
	  'calling':'\ud83d\udcf2',
	  'camel':'\ud83d\udc2b',
	  'camera':'\ud83d\udcf7',
	  'camera_flash':'\ud83d\udcf8',
	  'camping':'\ud83c\udfd5',
	  'cancer':'\u264b\ufe0f',
	  'candle':'\ud83d\udd6f',
	  'candy':'\ud83c\udf6c',
	  'canoe':'\ud83d\udef6',
	  'capital_abcd':'\ud83d\udd20',
	  'capricorn':'\u2651\ufe0f',
	  'car':'\ud83d\ude97',
	  'card_file_box':'\ud83d\uddc3',
	  'card_index':'\ud83d\udcc7',
	  'card_index_dividers':'\ud83d\uddc2',
	  'carousel_horse':'\ud83c\udfa0',
	  'carrot':'\ud83e\udd55',
	  'cat':'\ud83d\udc31',
	  'cat2':'\ud83d\udc08',
	  'cd':'\ud83d\udcbf',
	  'chains':'\u26d3',
	  'champagne':'\ud83c\udf7e',
	  'chart':'\ud83d\udcb9',
	  'chart_with_downwards_trend':'\ud83d\udcc9',
	  'chart_with_upwards_trend':'\ud83d\udcc8',
	  'checkered_flag':'\ud83c\udfc1',
	  'cheese':'\ud83e\uddc0',
	  'cherries':'\ud83c\udf52',
	  'cherry_blossom':'\ud83c\udf38',
	  'chestnut':'\ud83c\udf30',
	  'chicken':'\ud83d\udc14',
	  'children_crossing':'\ud83d\udeb8',
	  'chipmunk':'\ud83d\udc3f',
	  'chocolate_bar':'\ud83c\udf6b',
	  'christmas_tree':'\ud83c\udf84',
	  'church':'\u26ea\ufe0f',
	  'cinema':'\ud83c\udfa6',
	  'circus_tent':'\ud83c\udfaa',
	  'city_sunrise':'\ud83c\udf07',
	  'city_sunset':'\ud83c\udf06',
	  'cityscape':'\ud83c\udfd9',
	  'cl':'\ud83c\udd91',
	  'clamp':'\ud83d\udddc',
	  'clap':'\ud83d\udc4f',
	  'clapper':'\ud83c\udfac',
	  'classical_building':'\ud83c\udfdb',
	  'clinking_glasses':'\ud83e\udd42',
	  'clipboard':'\ud83d\udccb',
	  'clock1':'\ud83d\udd50',
	  'clock10':'\ud83d\udd59',
	  'clock1030':'\ud83d\udd65',
	  'clock11':'\ud83d\udd5a',
	  'clock1130':'\ud83d\udd66',
	  'clock12':'\ud83d\udd5b',
	  'clock1230':'\ud83d\udd67',
	  'clock130':'\ud83d\udd5c',
	  'clock2':'\ud83d\udd51',
	  'clock230':'\ud83d\udd5d',
	  'clock3':'\ud83d\udd52',
	  'clock330':'\ud83d\udd5e',
	  'clock4':'\ud83d\udd53',
	  'clock430':'\ud83d\udd5f',
	  'clock5':'\ud83d\udd54',
	  'clock530':'\ud83d\udd60',
	  'clock6':'\ud83d\udd55',
	  'clock630':'\ud83d\udd61',
	  'clock7':'\ud83d\udd56',
	  'clock730':'\ud83d\udd62',
	  'clock8':'\ud83d\udd57',
	  'clock830':'\ud83d\udd63',
	  'clock9':'\ud83d\udd58',
	  'clock930':'\ud83d\udd64',
	  'closed_book':'\ud83d\udcd5',
	  'closed_lock_with_key':'\ud83d\udd10',
	  'closed_umbrella':'\ud83c\udf02',
	  'cloud':'\u2601\ufe0f',
	  'cloud_with_lightning':'\ud83c\udf29',
	  'cloud_with_lightning_and_rain':'\u26c8',
	  'cloud_with_rain':'\ud83c\udf27',
	  'cloud_with_snow':'\ud83c\udf28',
	  'clown_face':'\ud83e\udd21',
	  'clubs':'\u2663\ufe0f',
	  'cocktail':'\ud83c\udf78',
	  'coffee':'\u2615\ufe0f',
	  'coffin':'\u26b0\ufe0f',
	  'cold_sweat':'\ud83d\ude30',
	  'comet':'\u2604\ufe0f',
	  'computer':'\ud83d\udcbb',
	  'computer_mouse':'\ud83d\uddb1',
	  'confetti_ball':'\ud83c\udf8a',
	  'confounded':'\ud83d\ude16',
	  'confused':'\ud83d\ude15',
	  'congratulations':'\u3297\ufe0f',
	  'construction':'\ud83d\udea7',
	  'construction_worker_man':'\ud83d\udc77',
	  'construction_worker_woman':'\ud83d\udc77&zwj;\u2640\ufe0f',
	  'control_knobs':'\ud83c\udf9b',
	  'convenience_store':'\ud83c\udfea',
	  'cookie':'\ud83c\udf6a',
	  'cool':'\ud83c\udd92',
	  'policeman':'\ud83d\udc6e',
	  'copyright':'\u00a9\ufe0f',
	  'corn':'\ud83c\udf3d',
	  'couch_and_lamp':'\ud83d\udecb',
	  'couple':'\ud83d\udc6b',
	  'couple_with_heart_woman_man':'\ud83d\udc91',
	  'couple_with_heart_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc68',
	  'couple_with_heart_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc69',
	  'couplekiss_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc68',
	  'couplekiss_man_woman':'\ud83d\udc8f',
	  'couplekiss_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc69',
	  'cow':'\ud83d\udc2e',
	  'cow2':'\ud83d\udc04',
	  'cowboy_hat_face':'\ud83e\udd20',
	  'crab':'\ud83e\udd80',
	  'crayon':'\ud83d\udd8d',
	  'credit_card':'\ud83d\udcb3',
	  'crescent_moon':'\ud83c\udf19',
	  'cricket':'\ud83c\udfcf',
	  'crocodile':'\ud83d\udc0a',
	  'croissant':'\ud83e\udd50',
	  'crossed_fingers':'\ud83e\udd1e',
	  'crossed_flags':'\ud83c\udf8c',
	  'crossed_swords':'\u2694\ufe0f',
	  'crown':'\ud83d\udc51',
	  'cry':'\ud83d\ude22',
	  'crying_cat_face':'\ud83d\ude3f',
	  'crystal_ball':'\ud83d\udd2e',
	  'cucumber':'\ud83e\udd52',
	  'cupid':'\ud83d\udc98',
	  'curly_loop':'\u27b0',
	  'currency_exchange':'\ud83d\udcb1',
	  'curry':'\ud83c\udf5b',
	  'custard':'\ud83c\udf6e',
	  'customs':'\ud83d\udec3',
	  'cyclone':'\ud83c\udf00',
	  'dagger':'\ud83d\udde1',
	  'dancer':'\ud83d\udc83',
	  'dancing_women':'\ud83d\udc6f',
	  'dancing_men':'\ud83d\udc6f&zwj;\u2642\ufe0f',
	  'dango':'\ud83c\udf61',
	  'dark_sunglasses':'\ud83d\udd76',
	  'dart':'\ud83c\udfaf',
	  'dash':'\ud83d\udca8',
	  'date':'\ud83d\udcc5',
	  'deciduous_tree':'\ud83c\udf33',
	  'deer':'\ud83e\udd8c',
	  'department_store':'\ud83c\udfec',
	  'derelict_house':'\ud83c\udfda',
	  'desert':'\ud83c\udfdc',
	  'desert_island':'\ud83c\udfdd',
	  'desktop_computer':'\ud83d\udda5',
	  'male_detective':'\ud83d\udd75\ufe0f',
	  'diamond_shape_with_a_dot_inside':'\ud83d\udca0',
	  'diamonds':'\u2666\ufe0f',
	  'disappointed':'\ud83d\ude1e',
	  'disappointed_relieved':'\ud83d\ude25',
	  'dizzy':'\ud83d\udcab',
	  'dizzy_face':'\ud83d\ude35',
	  'do_not_litter':'\ud83d\udeaf',
	  'dog':'\ud83d\udc36',
	  'dog2':'\ud83d\udc15',
	  'dollar':'\ud83d\udcb5',
	  'dolls':'\ud83c\udf8e',
	  'dolphin':'\ud83d\udc2c',
	  'door':'\ud83d\udeaa',
	  'doughnut':'\ud83c\udf69',
	  'dove':'\ud83d\udd4a',
	  'dragon':'\ud83d\udc09',
	  'dragon_face':'\ud83d\udc32',
	  'dress':'\ud83d\udc57',
	  'dromedary_camel':'\ud83d\udc2a',
	  'drooling_face':'\ud83e\udd24',
	  'droplet':'\ud83d\udca7',
	  'drum':'\ud83e\udd41',
	  'duck':'\ud83e\udd86',
	  'dvd':'\ud83d\udcc0',
	  'e-mail':'\ud83d\udce7',
	  'eagle':'\ud83e\udd85',
	  'ear':'\ud83d\udc42',
	  'ear_of_rice':'\ud83c\udf3e',
	  'earth_africa':'\ud83c\udf0d',
	  'earth_americas':'\ud83c\udf0e',
	  'earth_asia':'\ud83c\udf0f',
	  'egg':'\ud83e\udd5a',
	  'eggplant':'\ud83c\udf46',
	  'eight_pointed_black_star':'\u2734\ufe0f',
	  'eight_spoked_asterisk':'\u2733\ufe0f',
	  'electric_plug':'\ud83d\udd0c',
	  'elephant':'\ud83d\udc18',
	  'email':'\u2709\ufe0f',
	  'end':'\ud83d\udd1a',
	  'envelope_with_arrow':'\ud83d\udce9',
	  'euro':'\ud83d\udcb6',
	  'european_castle':'\ud83c\udff0',
	  'european_post_office':'\ud83c\udfe4',
	  'evergreen_tree':'\ud83c\udf32',
	  'exclamation':'\u2757\ufe0f',
	  'expressionless':'\ud83d\ude11',
	  'eye':'\ud83d\udc41',
	  'eye_speech_bubble':'\ud83d\udc41&zwj;\ud83d\udde8',
	  'eyeglasses':'\ud83d\udc53',
	  'eyes':'\ud83d\udc40',
	  'face_with_head_bandage':'\ud83e\udd15',
	  'face_with_thermometer':'\ud83e\udd12',
	  'fist_oncoming':'\ud83d\udc4a',
	  'factory':'\ud83c\udfed',
	  'fallen_leaf':'\ud83c\udf42',
	  'family_man_woman_boy':'\ud83d\udc6a',
	  'family_man_boy':'\ud83d\udc68&zwj;\ud83d\udc66',
	  'family_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_man_girl':'\ud83d\udc68&zwj;\ud83d\udc67',
	  'family_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_man_man_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66',
	  'family_man_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_man_man_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67',
	  'family_man_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_man_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_man_woman_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_man_woman_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
	  'family_man_woman_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_man_woman_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc66',
	  'family_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc67',
	  'family_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_woman_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66',
	  'family_woman_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_woman_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
	  'family_woman_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_woman_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'fast_forward':'\u23e9',
	  'fax':'\ud83d\udce0',
	  'fearful':'\ud83d\ude28',
	  'feet':'\ud83d\udc3e',
	  'female_detective':'\ud83d\udd75\ufe0f&zwj;\u2640\ufe0f',
	  'ferris_wheel':'\ud83c\udfa1',
	  'ferry':'\u26f4',
	  'field_hockey':'\ud83c\udfd1',
	  'file_cabinet':'\ud83d\uddc4',
	  'file_folder':'\ud83d\udcc1',
	  'film_projector':'\ud83d\udcfd',
	  'film_strip':'\ud83c\udf9e',
	  'fire':'\ud83d\udd25',
	  'fire_engine':'\ud83d\ude92',
	  'fireworks':'\ud83c\udf86',
	  'first_quarter_moon':'\ud83c\udf13',
	  'first_quarter_moon_with_face':'\ud83c\udf1b',
	  'fish':'\ud83d\udc1f',
	  'fish_cake':'\ud83c\udf65',
	  'fishing_pole_and_fish':'\ud83c\udfa3',
	  'fist_raised':'\u270a',
	  'fist_left':'\ud83e\udd1b',
	  'fist_right':'\ud83e\udd1c',
	  'flags':'\ud83c\udf8f',
	  'flashlight':'\ud83d\udd26',
	  'fleur_de_lis':'\u269c\ufe0f',
	  'flight_arrival':'\ud83d\udeec',
	  'flight_departure':'\ud83d\udeeb',
	  'floppy_disk':'\ud83d\udcbe',
	  'flower_playing_cards':'\ud83c\udfb4',
	  'flushed':'\ud83d\ude33',
	  'fog':'\ud83c\udf2b',
	  'foggy':'\ud83c\udf01',
	  'football':'\ud83c\udfc8',
	  'footprints':'\ud83d\udc63',
	  'fork_and_knife':'\ud83c\udf74',
	  'fountain':'\u26f2\ufe0f',
	  'fountain_pen':'\ud83d\udd8b',
	  'four_leaf_clover':'\ud83c\udf40',
	  'fox_face':'\ud83e\udd8a',
	  'framed_picture':'\ud83d\uddbc',
	  'free':'\ud83c\udd93',
	  'fried_egg':'\ud83c\udf73',
	  'fried_shrimp':'\ud83c\udf64',
	  'fries':'\ud83c\udf5f',
	  'frog':'\ud83d\udc38',
	  'frowning':'\ud83d\ude26',
	  'frowning_face':'\u2639\ufe0f',
	  'frowning_man':'\ud83d\ude4d&zwj;\u2642\ufe0f',
	  'frowning_woman':'\ud83d\ude4d',
	  'middle_finger':'\ud83d\udd95',
	  'fuelpump':'\u26fd\ufe0f',
	  'full_moon':'\ud83c\udf15',
	  'full_moon_with_face':'\ud83c\udf1d',
	  'funeral_urn':'\u26b1\ufe0f',
	  'game_die':'\ud83c\udfb2',
	  'gear':'\u2699\ufe0f',
	  'gem':'\ud83d\udc8e',
	  'gemini':'\u264a\ufe0f',
	  'ghost':'\ud83d\udc7b',
	  'gift':'\ud83c\udf81',
	  'gift_heart':'\ud83d\udc9d',
	  'girl':'\ud83d\udc67',
	  'globe_with_meridians':'\ud83c\udf10',
	  'goal_net':'\ud83e\udd45',
	  'goat':'\ud83d\udc10',
	  'golf':'\u26f3\ufe0f',
	  'golfing_man':'\ud83c\udfcc\ufe0f',
	  'golfing_woman':'\ud83c\udfcc\ufe0f&zwj;\u2640\ufe0f',
	  'gorilla':'\ud83e\udd8d',
	  'grapes':'\ud83c\udf47',
	  'green_apple':'\ud83c\udf4f',
	  'green_book':'\ud83d\udcd7',
	  'green_heart':'\ud83d\udc9a',
	  'green_salad':'\ud83e\udd57',
	  'grey_exclamation':'\u2755',
	  'grey_question':'\u2754',
	  'grimacing':'\ud83d\ude2c',
	  'grin':'\ud83d\ude01',
	  'grinning':'\ud83d\ude00',
	  'guardsman':'\ud83d\udc82',
	  'guardswoman':'\ud83d\udc82&zwj;\u2640\ufe0f',
	  'guitar':'\ud83c\udfb8',
	  'gun':'\ud83d\udd2b',
	  'haircut_woman':'\ud83d\udc87',
	  'haircut_man':'\ud83d\udc87&zwj;\u2642\ufe0f',
	  'hamburger':'\ud83c\udf54',
	  'hammer':'\ud83d\udd28',
	  'hammer_and_pick':'\u2692',
	  'hammer_and_wrench':'\ud83d\udee0',
	  'hamster':'\ud83d\udc39',
	  'hand':'\u270b',
	  'handbag':'\ud83d\udc5c',
	  'handshake':'\ud83e\udd1d',
	  'hankey':'\ud83d\udca9',
	  'hatched_chick':'\ud83d\udc25',
	  'hatching_chick':'\ud83d\udc23',
	  'headphones':'\ud83c\udfa7',
	  'hear_no_evil':'\ud83d\ude49',
	  'heart':'\u2764\ufe0f',
	  'heart_decoration':'\ud83d\udc9f',
	  'heart_eyes':'\ud83d\ude0d',
	  'heart_eyes_cat':'\ud83d\ude3b',
	  'heartbeat':'\ud83d\udc93',
	  'heartpulse':'\ud83d\udc97',
	  'hearts':'\u2665\ufe0f',
	  'heavy_check_mark':'\u2714\ufe0f',
	  'heavy_division_sign':'\u2797',
	  'heavy_dollar_sign':'\ud83d\udcb2',
	  'heavy_heart_exclamation':'\u2763\ufe0f',
	  'heavy_minus_sign':'\u2796',
	  'heavy_multiplication_x':'\u2716\ufe0f',
	  'heavy_plus_sign':'\u2795',
	  'helicopter':'\ud83d\ude81',
	  'herb':'\ud83c\udf3f',
	  'hibiscus':'\ud83c\udf3a',
	  'high_brightness':'\ud83d\udd06',
	  'high_heel':'\ud83d\udc60',
	  'hocho':'\ud83d\udd2a',
	  'hole':'\ud83d\udd73',
	  'honey_pot':'\ud83c\udf6f',
	  'horse':'\ud83d\udc34',
	  'horse_racing':'\ud83c\udfc7',
	  'hospital':'\ud83c\udfe5',
	  'hot_pepper':'\ud83c\udf36',
	  'hotdog':'\ud83c\udf2d',
	  'hotel':'\ud83c\udfe8',
	  'hotsprings':'\u2668\ufe0f',
	  'hourglass':'\u231b\ufe0f',
	  'hourglass_flowing_sand':'\u23f3',
	  'house':'\ud83c\udfe0',
	  'house_with_garden':'\ud83c\udfe1',
	  'houses':'\ud83c\udfd8',
	  'hugs':'\ud83e\udd17',
	  'hushed':'\ud83d\ude2f',
	  'ice_cream':'\ud83c\udf68',
	  'ice_hockey':'\ud83c\udfd2',
	  'ice_skate':'\u26f8',
	  'icecream':'\ud83c\udf66',
	  'id':'\ud83c\udd94',
	  'ideograph_advantage':'\ud83c\ude50',
	  'imp':'\ud83d\udc7f',
	  'inbox_tray':'\ud83d\udce5',
	  'incoming_envelope':'\ud83d\udce8',
	  'tipping_hand_woman':'\ud83d\udc81',
	  'information_source':'\u2139\ufe0f',
	  'innocent':'\ud83d\ude07',
	  'interrobang':'\u2049\ufe0f',
	  'iphone':'\ud83d\udcf1',
	  'izakaya_lantern':'\ud83c\udfee',
	  'jack_o_lantern':'\ud83c\udf83',
	  'japan':'\ud83d\uddfe',
	  'japanese_castle':'\ud83c\udfef',
	  'japanese_goblin':'\ud83d\udc7a',
	  'japanese_ogre':'\ud83d\udc79',
	  'jeans':'\ud83d\udc56',
	  'joy':'\ud83d\ude02',
	  'joy_cat':'\ud83d\ude39',
	  'joystick':'\ud83d\udd79',
	  'kaaba':'\ud83d\udd4b',
	  'key':'\ud83d\udd11',
	  'keyboard':'\u2328\ufe0f',
	  'keycap_ten':'\ud83d\udd1f',
	  'kick_scooter':'\ud83d\udef4',
	  'kimono':'\ud83d\udc58',
	  'kiss':'\ud83d\udc8b',
	  'kissing':'\ud83d\ude17',
	  'kissing_cat':'\ud83d\ude3d',
	  'kissing_closed_eyes':'\ud83d\ude1a',
	  'kissing_heart':'\ud83d\ude18',
	  'kissing_smiling_eyes':'\ud83d\ude19',
	  'kiwi_fruit':'\ud83e\udd5d',
	  'koala':'\ud83d\udc28',
	  'koko':'\ud83c\ude01',
	  'label':'\ud83c\udff7',
	  'large_blue_circle':'\ud83d\udd35',
	  'large_blue_diamond':'\ud83d\udd37',
	  'large_orange_diamond':'\ud83d\udd36',
	  'last_quarter_moon':'\ud83c\udf17',
	  'last_quarter_moon_with_face':'\ud83c\udf1c',
	  'latin_cross':'\u271d\ufe0f',
	  'laughing':'\ud83d\ude06',
	  'leaves':'\ud83c\udf43',
	  'ledger':'\ud83d\udcd2',
	  'left_luggage':'\ud83d\udec5',
	  'left_right_arrow':'\u2194\ufe0f',
	  'leftwards_arrow_with_hook':'\u21a9\ufe0f',
	  'lemon':'\ud83c\udf4b',
	  'leo':'\u264c\ufe0f',
	  'leopard':'\ud83d\udc06',
	  'level_slider':'\ud83c\udf9a',
	  'libra':'\u264e\ufe0f',
	  'light_rail':'\ud83d\ude88',
	  'link':'\ud83d\udd17',
	  'lion':'\ud83e\udd81',
	  'lips':'\ud83d\udc44',
	  'lipstick':'\ud83d\udc84',
	  'lizard':'\ud83e\udd8e',
	  'lock':'\ud83d\udd12',
	  'lock_with_ink_pen':'\ud83d\udd0f',
	  'lollipop':'\ud83c\udf6d',
	  'loop':'\u27bf',
	  'loud_sound':'\ud83d\udd0a',
	  'loudspeaker':'\ud83d\udce2',
	  'love_hotel':'\ud83c\udfe9',
	  'love_letter':'\ud83d\udc8c',
	  'low_brightness':'\ud83d\udd05',
	  'lying_face':'\ud83e\udd25',
	  'm':'\u24c2\ufe0f',
	  'mag':'\ud83d\udd0d',
	  'mag_right':'\ud83d\udd0e',
	  'mahjong':'\ud83c\udc04\ufe0f',
	  'mailbox':'\ud83d\udceb',
	  'mailbox_closed':'\ud83d\udcea',
	  'mailbox_with_mail':'\ud83d\udcec',
	  'mailbox_with_no_mail':'\ud83d\udced',
	  'man':'\ud83d\udc68',
	  'man_artist':'\ud83d\udc68&zwj;\ud83c\udfa8',
	  'man_astronaut':'\ud83d\udc68&zwj;\ud83d\ude80',
	  'man_cartwheeling':'\ud83e\udd38&zwj;\u2642\ufe0f',
	  'man_cook':'\ud83d\udc68&zwj;\ud83c\udf73',
	  'man_dancing':'\ud83d\udd7a',
	  'man_facepalming':'\ud83e\udd26&zwj;\u2642\ufe0f',
	  'man_factory_worker':'\ud83d\udc68&zwj;\ud83c\udfed',
	  'man_farmer':'\ud83d\udc68&zwj;\ud83c\udf3e',
	  'man_firefighter':'\ud83d\udc68&zwj;\ud83d\ude92',
	  'man_health_worker':'\ud83d\udc68&zwj;\u2695\ufe0f',
	  'man_in_tuxedo':'\ud83e\udd35',
	  'man_judge':'\ud83d\udc68&zwj;\u2696\ufe0f',
	  'man_juggling':'\ud83e\udd39&zwj;\u2642\ufe0f',
	  'man_mechanic':'\ud83d\udc68&zwj;\ud83d\udd27',
	  'man_office_worker':'\ud83d\udc68&zwj;\ud83d\udcbc',
	  'man_pilot':'\ud83d\udc68&zwj;\u2708\ufe0f',
	  'man_playing_handball':'\ud83e\udd3e&zwj;\u2642\ufe0f',
	  'man_playing_water_polo':'\ud83e\udd3d&zwj;\u2642\ufe0f',
	  'man_scientist':'\ud83d\udc68&zwj;\ud83d\udd2c',
	  'man_shrugging':'\ud83e\udd37&zwj;\u2642\ufe0f',
	  'man_singer':'\ud83d\udc68&zwj;\ud83c\udfa4',
	  'man_student':'\ud83d\udc68&zwj;\ud83c\udf93',
	  'man_teacher':'\ud83d\udc68&zwj;\ud83c\udfeb',
	  'man_technologist':'\ud83d\udc68&zwj;\ud83d\udcbb',
	  'man_with_gua_pi_mao':'\ud83d\udc72',
	  'man_with_turban':'\ud83d\udc73',
	  'tangerine':'\ud83c\udf4a',
	  'mans_shoe':'\ud83d\udc5e',
	  'mantelpiece_clock':'\ud83d\udd70',
	  'maple_leaf':'\ud83c\udf41',
	  'martial_arts_uniform':'\ud83e\udd4b',
	  'mask':'\ud83d\ude37',
	  'massage_woman':'\ud83d\udc86',
	  'massage_man':'\ud83d\udc86&zwj;\u2642\ufe0f',
	  'meat_on_bone':'\ud83c\udf56',
	  'medal_military':'\ud83c\udf96',
	  'medal_sports':'\ud83c\udfc5',
	  'mega':'\ud83d\udce3',
	  'melon':'\ud83c\udf48',
	  'memo':'\ud83d\udcdd',
	  'men_wrestling':'\ud83e\udd3c&zwj;\u2642\ufe0f',
	  'menorah':'\ud83d\udd4e',
	  'mens':'\ud83d\udeb9',
	  'metal':'\ud83e\udd18',
	  'metro':'\ud83d\ude87',
	  'microphone':'\ud83c\udfa4',
	  'microscope':'\ud83d\udd2c',
	  'milk_glass':'\ud83e\udd5b',
	  'milky_way':'\ud83c\udf0c',
	  'minibus':'\ud83d\ude90',
	  'minidisc':'\ud83d\udcbd',
	  'mobile_phone_off':'\ud83d\udcf4',
	  'money_mouth_face':'\ud83e\udd11',
	  'money_with_wings':'\ud83d\udcb8',
	  'moneybag':'\ud83d\udcb0',
	  'monkey':'\ud83d\udc12',
	  'monkey_face':'\ud83d\udc35',
	  'monorail':'\ud83d\ude9d',
	  'moon':'\ud83c\udf14',
	  'mortar_board':'\ud83c\udf93',
	  'mosque':'\ud83d\udd4c',
	  'motor_boat':'\ud83d\udee5',
	  'motor_scooter':'\ud83d\udef5',
	  'motorcycle':'\ud83c\udfcd',
	  'motorway':'\ud83d\udee3',
	  'mount_fuji':'\ud83d\uddfb',
	  'mountain':'\u26f0',
	  'mountain_biking_man':'\ud83d\udeb5',
	  'mountain_biking_woman':'\ud83d\udeb5&zwj;\u2640\ufe0f',
	  'mountain_cableway':'\ud83d\udea0',
	  'mountain_railway':'\ud83d\ude9e',
	  'mountain_snow':'\ud83c\udfd4',
	  'mouse':'\ud83d\udc2d',
	  'mouse2':'\ud83d\udc01',
	  'movie_camera':'\ud83c\udfa5',
	  'moyai':'\ud83d\uddff',
	  'mrs_claus':'\ud83e\udd36',
	  'muscle':'\ud83d\udcaa',
	  'mushroom':'\ud83c\udf44',
	  'musical_keyboard':'\ud83c\udfb9',
	  'musical_note':'\ud83c\udfb5',
	  'musical_score':'\ud83c\udfbc',
	  'mute':'\ud83d\udd07',
	  'nail_care':'\ud83d\udc85',
	  'name_badge':'\ud83d\udcdb',
	  'national_park':'\ud83c\udfde',
	  'nauseated_face':'\ud83e\udd22',
	  'necktie':'\ud83d\udc54',
	  'negative_squared_cross_mark':'\u274e',
	  'nerd_face':'\ud83e\udd13',
	  'neutral_face':'\ud83d\ude10',
	  'new':'\ud83c\udd95',
	  'new_moon':'\ud83c\udf11',
	  'new_moon_with_face':'\ud83c\udf1a',
	  'newspaper':'\ud83d\udcf0',
	  'newspaper_roll':'\ud83d\uddde',
	  'next_track_button':'\u23ed',
	  'ng':'\ud83c\udd96',
	  'no_good_man':'\ud83d\ude45&zwj;\u2642\ufe0f',
	  'no_good_woman':'\ud83d\ude45',
	  'night_with_stars':'\ud83c\udf03',
	  'no_bell':'\ud83d\udd15',
	  'no_bicycles':'\ud83d\udeb3',
	  'no_entry':'\u26d4\ufe0f',
	  'no_entry_sign':'\ud83d\udeab',
	  'no_mobile_phones':'\ud83d\udcf5',
	  'no_mouth':'\ud83d\ude36',
	  'no_pedestrians':'\ud83d\udeb7',
	  'no_smoking':'\ud83d\udead',
	  'non-potable_water':'\ud83d\udeb1',
	  'nose':'\ud83d\udc43',
	  'notebook':'\ud83d\udcd3',
	  'notebook_with_decorative_cover':'\ud83d\udcd4',
	  'notes':'\ud83c\udfb6',
	  'nut_and_bolt':'\ud83d\udd29',
	  'o':'\u2b55\ufe0f',
	  'o2':'\ud83c\udd7e\ufe0f',
	  'ocean':'\ud83c\udf0a',
	  'octopus':'\ud83d\udc19',
	  'oden':'\ud83c\udf62',
	  'office':'\ud83c\udfe2',
	  'oil_drum':'\ud83d\udee2',
	  'ok':'\ud83c\udd97',
	  'ok_hand':'\ud83d\udc4c',
	  'ok_man':'\ud83d\ude46&zwj;\u2642\ufe0f',
	  'ok_woman':'\ud83d\ude46',
	  'old_key':'\ud83d\udddd',
	  'older_man':'\ud83d\udc74',
	  'older_woman':'\ud83d\udc75',
	  'om':'\ud83d\udd49',
	  'on':'\ud83d\udd1b',
	  'oncoming_automobile':'\ud83d\ude98',
	  'oncoming_bus':'\ud83d\ude8d',
	  'oncoming_police_car':'\ud83d\ude94',
	  'oncoming_taxi':'\ud83d\ude96',
	  'open_file_folder':'\ud83d\udcc2',
	  'open_hands':'\ud83d\udc50',
	  'open_mouth':'\ud83d\ude2e',
	  'open_umbrella':'\u2602\ufe0f',
	  'ophiuchus':'\u26ce',
	  'orange_book':'\ud83d\udcd9',
	  'orthodox_cross':'\u2626\ufe0f',
	  'outbox_tray':'\ud83d\udce4',
	  'owl':'\ud83e\udd89',
	  'ox':'\ud83d\udc02',
	  'package':'\ud83d\udce6',
	  'page_facing_up':'\ud83d\udcc4',
	  'page_with_curl':'\ud83d\udcc3',
	  'pager':'\ud83d\udcdf',
	  'paintbrush':'\ud83d\udd8c',
	  'palm_tree':'\ud83c\udf34',
	  'pancakes':'\ud83e\udd5e',
	  'panda_face':'\ud83d\udc3c',
	  'paperclip':'\ud83d\udcce',
	  'paperclips':'\ud83d\udd87',
	  'parasol_on_ground':'\u26f1',
	  'parking':'\ud83c\udd7f\ufe0f',
	  'part_alternation_mark':'\u303d\ufe0f',
	  'partly_sunny':'\u26c5\ufe0f',
	  'passenger_ship':'\ud83d\udef3',
	  'passport_control':'\ud83d\udec2',
	  'pause_button':'\u23f8',
	  'peace_symbol':'\u262e\ufe0f',
	  'peach':'\ud83c\udf51',
	  'peanuts':'\ud83e\udd5c',
	  'pear':'\ud83c\udf50',
	  'pen':'\ud83d\udd8a',
	  'pencil2':'\u270f\ufe0f',
	  'penguin':'\ud83d\udc27',
	  'pensive':'\ud83d\ude14',
	  'performing_arts':'\ud83c\udfad',
	  'persevere':'\ud83d\ude23',
	  'person_fencing':'\ud83e\udd3a',
	  'pouting_woman':'\ud83d\ude4e',
	  'phone':'\u260e\ufe0f',
	  'pick':'\u26cf',
	  'pig':'\ud83d\udc37',
	  'pig2':'\ud83d\udc16',
	  'pig_nose':'\ud83d\udc3d',
	  'pill':'\ud83d\udc8a',
	  'pineapple':'\ud83c\udf4d',
	  'ping_pong':'\ud83c\udfd3',
	  'pisces':'\u2653\ufe0f',
	  'pizza':'\ud83c\udf55',
	  'place_of_worship':'\ud83d\uded0',
	  'plate_with_cutlery':'\ud83c\udf7d',
	  'play_or_pause_button':'\u23ef',
	  'point_down':'\ud83d\udc47',
	  'point_left':'\ud83d\udc48',
	  'point_right':'\ud83d\udc49',
	  'point_up':'\u261d\ufe0f',
	  'point_up_2':'\ud83d\udc46',
	  'police_car':'\ud83d\ude93',
	  'policewoman':'\ud83d\udc6e&zwj;\u2640\ufe0f',
	  'poodle':'\ud83d\udc29',
	  'popcorn':'\ud83c\udf7f',
	  'post_office':'\ud83c\udfe3',
	  'postal_horn':'\ud83d\udcef',
	  'postbox':'\ud83d\udcee',
	  'potable_water':'\ud83d\udeb0',
	  'potato':'\ud83e\udd54',
	  'pouch':'\ud83d\udc5d',
	  'poultry_leg':'\ud83c\udf57',
	  'pound':'\ud83d\udcb7',
	  'rage':'\ud83d\ude21',
	  'pouting_cat':'\ud83d\ude3e',
	  'pouting_man':'\ud83d\ude4e&zwj;\u2642\ufe0f',
	  'pray':'\ud83d\ude4f',
	  'prayer_beads':'\ud83d\udcff',
	  'pregnant_woman':'\ud83e\udd30',
	  'previous_track_button':'\u23ee',
	  'prince':'\ud83e\udd34',
	  'princess':'\ud83d\udc78',
	  'printer':'\ud83d\udda8',
	  'purple_heart':'\ud83d\udc9c',
	  'purse':'\ud83d\udc5b',
	  'pushpin':'\ud83d\udccc',
	  'put_litter_in_its_place':'\ud83d\udeae',
	  'question':'\u2753',
	  'rabbit':'\ud83d\udc30',
	  'rabbit2':'\ud83d\udc07',
	  'racehorse':'\ud83d\udc0e',
	  'racing_car':'\ud83c\udfce',
	  'radio':'\ud83d\udcfb',
	  'radio_button':'\ud83d\udd18',
	  'radioactive':'\u2622\ufe0f',
	  'railway_car':'\ud83d\ude83',
	  'railway_track':'\ud83d\udee4',
	  'rainbow':'\ud83c\udf08',
	  'rainbow_flag':'\ud83c\udff3\ufe0f&zwj;\ud83c\udf08',
	  'raised_back_of_hand':'\ud83e\udd1a',
	  'raised_hand_with_fingers_splayed':'\ud83d\udd90',
	  'raised_hands':'\ud83d\ude4c',
	  'raising_hand_woman':'\ud83d\ude4b',
	  'raising_hand_man':'\ud83d\ude4b&zwj;\u2642\ufe0f',
	  'ram':'\ud83d\udc0f',
	  'ramen':'\ud83c\udf5c',
	  'rat':'\ud83d\udc00',
	  'record_button':'\u23fa',
	  'recycle':'\u267b\ufe0f',
	  'red_circle':'\ud83d\udd34',
	  'registered':'\u00ae\ufe0f',
	  'relaxed':'\u263a\ufe0f',
	  'relieved':'\ud83d\ude0c',
	  'reminder_ribbon':'\ud83c\udf97',
	  'repeat':'\ud83d\udd01',
	  'repeat_one':'\ud83d\udd02',
	  'rescue_worker_helmet':'\u26d1',
	  'restroom':'\ud83d\udebb',
	  'revolving_hearts':'\ud83d\udc9e',
	  'rewind':'\u23ea',
	  'rhinoceros':'\ud83e\udd8f',
	  'ribbon':'\ud83c\udf80',
	  'rice':'\ud83c\udf5a',
	  'rice_ball':'\ud83c\udf59',
	  'rice_cracker':'\ud83c\udf58',
	  'rice_scene':'\ud83c\udf91',
	  'right_anger_bubble':'\ud83d\uddef',
	  'ring':'\ud83d\udc8d',
	  'robot':'\ud83e\udd16',
	  'rocket':'\ud83d\ude80',
	  'rofl':'\ud83e\udd23',
	  'roll_eyes':'\ud83d\ude44',
	  'roller_coaster':'\ud83c\udfa2',
	  'rooster':'\ud83d\udc13',
	  'rose':'\ud83c\udf39',
	  'rosette':'\ud83c\udff5',
	  'rotating_light':'\ud83d\udea8',
	  'round_pushpin':'\ud83d\udccd',
	  'rowing_man':'\ud83d\udea3',
	  'rowing_woman':'\ud83d\udea3&zwj;\u2640\ufe0f',
	  'rugby_football':'\ud83c\udfc9',
	  'running_man':'\ud83c\udfc3',
	  'running_shirt_with_sash':'\ud83c\udfbd',
	  'running_woman':'\ud83c\udfc3&zwj;\u2640\ufe0f',
	  'sa':'\ud83c\ude02\ufe0f',
	  'sagittarius':'\u2650\ufe0f',
	  'sake':'\ud83c\udf76',
	  'sandal':'\ud83d\udc61',
	  'santa':'\ud83c\udf85',
	  'satellite':'\ud83d\udce1',
	  'saxophone':'\ud83c\udfb7',
	  'school':'\ud83c\udfeb',
	  'school_satchel':'\ud83c\udf92',
	  'scissors':'\u2702\ufe0f',
	  'scorpion':'\ud83e\udd82',
	  'scorpius':'\u264f\ufe0f',
	  'scream':'\ud83d\ude31',
	  'scream_cat':'\ud83d\ude40',
	  'scroll':'\ud83d\udcdc',
	  'seat':'\ud83d\udcba',
	  'secret':'\u3299\ufe0f',
	  'see_no_evil':'\ud83d\ude48',
	  'seedling':'\ud83c\udf31',
	  'selfie':'\ud83e\udd33',
	  'shallow_pan_of_food':'\ud83e\udd58',
	  'shamrock':'\u2618\ufe0f',
	  'shark':'\ud83e\udd88',
	  'shaved_ice':'\ud83c\udf67',
	  'sheep':'\ud83d\udc11',
	  'shell':'\ud83d\udc1a',
	  'shield':'\ud83d\udee1',
	  'shinto_shrine':'\u26e9',
	  'ship':'\ud83d\udea2',
	  'shirt':'\ud83d\udc55',
	  'shopping':'\ud83d\udecd',
	  'shopping_cart':'\ud83d\uded2',
	  'shower':'\ud83d\udebf',
	  'shrimp':'\ud83e\udd90',
	  'signal_strength':'\ud83d\udcf6',
	  'six_pointed_star':'\ud83d\udd2f',
	  'ski':'\ud83c\udfbf',
	  'skier':'\u26f7',
	  'skull':'\ud83d\udc80',
	  'skull_and_crossbones':'\u2620\ufe0f',
	  'sleeping':'\ud83d\ude34',
	  'sleeping_bed':'\ud83d\udecc',
	  'sleepy':'\ud83d\ude2a',
	  'slightly_frowning_face':'\ud83d\ude41',
	  'slightly_smiling_face':'\ud83d\ude42',
	  'slot_machine':'\ud83c\udfb0',
	  'small_airplane':'\ud83d\udee9',
	  'small_blue_diamond':'\ud83d\udd39',
	  'small_orange_diamond':'\ud83d\udd38',
	  'small_red_triangle':'\ud83d\udd3a',
	  'small_red_triangle_down':'\ud83d\udd3b',
	  'smile':'\ud83d\ude04',
	  'smile_cat':'\ud83d\ude38',
	  'smiley':'\ud83d\ude03',
	  'smiley_cat':'\ud83d\ude3a',
	  'smiling_imp':'\ud83d\ude08',
	  'smirk':'\ud83d\ude0f',
	  'smirk_cat':'\ud83d\ude3c',
	  'smoking':'\ud83d\udeac',
	  'snail':'\ud83d\udc0c',
	  'snake':'\ud83d\udc0d',
	  'sneezing_face':'\ud83e\udd27',
	  'snowboarder':'\ud83c\udfc2',
	  'snowflake':'\u2744\ufe0f',
	  'snowman':'\u26c4\ufe0f',
	  'snowman_with_snow':'\u2603\ufe0f',
	  'sob':'\ud83d\ude2d',
	  'soccer':'\u26bd\ufe0f',
	  'soon':'\ud83d\udd1c',
	  'sos':'\ud83c\udd98',
	  'sound':'\ud83d\udd09',
	  'space_invader':'\ud83d\udc7e',
	  'spades':'\u2660\ufe0f',
	  'spaghetti':'\ud83c\udf5d',
	  'sparkle':'\u2747\ufe0f',
	  'sparkler':'\ud83c\udf87',
	  'sparkles':'\u2728',
	  'sparkling_heart':'\ud83d\udc96',
	  'speak_no_evil':'\ud83d\ude4a',
	  'speaker':'\ud83d\udd08',
	  'speaking_head':'\ud83d\udde3',
	  'speech_balloon':'\ud83d\udcac',
	  'speedboat':'\ud83d\udea4',
	  'spider':'\ud83d\udd77',
	  'spider_web':'\ud83d\udd78',
	  'spiral_calendar':'\ud83d\uddd3',
	  'spiral_notepad':'\ud83d\uddd2',
	  'spoon':'\ud83e\udd44',
	  'squid':'\ud83e\udd91',
	  'stadium':'\ud83c\udfdf',
	  'star':'\u2b50\ufe0f',
	  'star2':'\ud83c\udf1f',
	  'star_and_crescent':'\u262a\ufe0f',
	  'star_of_david':'\u2721\ufe0f',
	  'stars':'\ud83c\udf20',
	  'station':'\ud83d\ude89',
	  'statue_of_liberty':'\ud83d\uddfd',
	  'steam_locomotive':'\ud83d\ude82',
	  'stew':'\ud83c\udf72',
	  'stop_button':'\u23f9',
	  'stop_sign':'\ud83d\uded1',
	  'stopwatch':'\u23f1',
	  'straight_ruler':'\ud83d\udccf',
	  'strawberry':'\ud83c\udf53',
	  'stuck_out_tongue':'\ud83d\ude1b',
	  'stuck_out_tongue_closed_eyes':'\ud83d\ude1d',
	  'stuck_out_tongue_winking_eye':'\ud83d\ude1c',
	  'studio_microphone':'\ud83c\udf99',
	  'stuffed_flatbread':'\ud83e\udd59',
	  'sun_behind_large_cloud':'\ud83c\udf25',
	  'sun_behind_rain_cloud':'\ud83c\udf26',
	  'sun_behind_small_cloud':'\ud83c\udf24',
	  'sun_with_face':'\ud83c\udf1e',
	  'sunflower':'\ud83c\udf3b',
	  'sunglasses':'\ud83d\ude0e',
	  'sunny':'\u2600\ufe0f',
	  'sunrise':'\ud83c\udf05',
	  'sunrise_over_mountains':'\ud83c\udf04',
	  'surfing_man':'\ud83c\udfc4',
	  'surfing_woman':'\ud83c\udfc4&zwj;\u2640\ufe0f',
	  'sushi':'\ud83c\udf63',
	  'suspension_railway':'\ud83d\ude9f',
	  'sweat':'\ud83d\ude13',
	  'sweat_drops':'\ud83d\udca6',
	  'sweat_smile':'\ud83d\ude05',
	  'sweet_potato':'\ud83c\udf60',
	  'swimming_man':'\ud83c\udfca',
	  'swimming_woman':'\ud83c\udfca&zwj;\u2640\ufe0f',
	  'symbols':'\ud83d\udd23',
	  'synagogue':'\ud83d\udd4d',
	  'syringe':'\ud83d\udc89',
	  'taco':'\ud83c\udf2e',
	  'tada':'\ud83c\udf89',
	  'tanabata_tree':'\ud83c\udf8b',
	  'taurus':'\u2649\ufe0f',
	  'taxi':'\ud83d\ude95',
	  'tea':'\ud83c\udf75',
	  'telephone_receiver':'\ud83d\udcde',
	  'telescope':'\ud83d\udd2d',
	  'tennis':'\ud83c\udfbe',
	  'tent':'\u26fa\ufe0f',
	  'thermometer':'\ud83c\udf21',
	  'thinking':'\ud83e\udd14',
	  'thought_balloon':'\ud83d\udcad',
	  'ticket':'\ud83c\udfab',
	  'tickets':'\ud83c\udf9f',
	  'tiger':'\ud83d\udc2f',
	  'tiger2':'\ud83d\udc05',
	  'timer_clock':'\u23f2',
	  'tipping_hand_man':'\ud83d\udc81&zwj;\u2642\ufe0f',
	  'tired_face':'\ud83d\ude2b',
	  'tm':'\u2122\ufe0f',
	  'toilet':'\ud83d\udebd',
	  'tokyo_tower':'\ud83d\uddfc',
	  'tomato':'\ud83c\udf45',
	  'tongue':'\ud83d\udc45',
	  'top':'\ud83d\udd1d',
	  'tophat':'\ud83c\udfa9',
	  'tornado':'\ud83c\udf2a',
	  'trackball':'\ud83d\uddb2',
	  'tractor':'\ud83d\ude9c',
	  'traffic_light':'\ud83d\udea5',
	  'train':'\ud83d\ude8b',
	  'train2':'\ud83d\ude86',
	  'tram':'\ud83d\ude8a',
	  'triangular_flag_on_post':'\ud83d\udea9',
	  'triangular_ruler':'\ud83d\udcd0',
	  'trident':'\ud83d\udd31',
	  'triumph':'\ud83d\ude24',
	  'trolleybus':'\ud83d\ude8e',
	  'trophy':'\ud83c\udfc6',
	  'tropical_drink':'\ud83c\udf79',
	  'tropical_fish':'\ud83d\udc20',
	  'truck':'\ud83d\ude9a',
	  'trumpet':'\ud83c\udfba',
	  'tulip':'\ud83c\udf37',
	  'tumbler_glass':'\ud83e\udd43',
	  'turkey':'\ud83e\udd83',
	  'turtle':'\ud83d\udc22',
	  'tv':'\ud83d\udcfa',
	  'twisted_rightwards_arrows':'\ud83d\udd00',
	  'two_hearts':'\ud83d\udc95',
	  'two_men_holding_hands':'\ud83d\udc6c',
	  'two_women_holding_hands':'\ud83d\udc6d',
	  'u5272':'\ud83c\ude39',
	  'u5408':'\ud83c\ude34',
	  'u55b6':'\ud83c\ude3a',
	  'u6307':'\ud83c\ude2f\ufe0f',
	  'u6708':'\ud83c\ude37\ufe0f',
	  'u6709':'\ud83c\ude36',
	  'u6e80':'\ud83c\ude35',
	  'u7121':'\ud83c\ude1a\ufe0f',
	  'u7533':'\ud83c\ude38',
	  'u7981':'\ud83c\ude32',
	  'u7a7a':'\ud83c\ude33',
	  'umbrella':'\u2614\ufe0f',
	  'unamused':'\ud83d\ude12',
	  'underage':'\ud83d\udd1e',
	  'unicorn':'\ud83e\udd84',
	  'unlock':'\ud83d\udd13',
	  'up':'\ud83c\udd99',
	  'upside_down_face':'\ud83d\ude43',
	  'v':'\u270c\ufe0f',
	  'vertical_traffic_light':'\ud83d\udea6',
	  'vhs':'\ud83d\udcfc',
	  'vibration_mode':'\ud83d\udcf3',
	  'video_camera':'\ud83d\udcf9',
	  'video_game':'\ud83c\udfae',
	  'violin':'\ud83c\udfbb',
	  'virgo':'\u264d\ufe0f',
	  'volcano':'\ud83c\udf0b',
	  'volleyball':'\ud83c\udfd0',
	  'vs':'\ud83c\udd9a',
	  'vulcan_salute':'\ud83d\udd96',
	  'walking_man':'\ud83d\udeb6',
	  'walking_woman':'\ud83d\udeb6&zwj;\u2640\ufe0f',
	  'waning_crescent_moon':'\ud83c\udf18',
	  'waning_gibbous_moon':'\ud83c\udf16',
	  'warning':'\u26a0\ufe0f',
	  'wastebasket':'\ud83d\uddd1',
	  'watch':'\u231a\ufe0f',
	  'water_buffalo':'\ud83d\udc03',
	  'watermelon':'\ud83c\udf49',
	  'wave':'\ud83d\udc4b',
	  'wavy_dash':'\u3030\ufe0f',
	  'waxing_crescent_moon':'\ud83c\udf12',
	  'wc':'\ud83d\udebe',
	  'weary':'\ud83d\ude29',
	  'wedding':'\ud83d\udc92',
	  'weight_lifting_man':'\ud83c\udfcb\ufe0f',
	  'weight_lifting_woman':'\ud83c\udfcb\ufe0f&zwj;\u2640\ufe0f',
	  'whale':'\ud83d\udc33',
	  'whale2':'\ud83d\udc0b',
	  'wheel_of_dharma':'\u2638\ufe0f',
	  'wheelchair':'\u267f\ufe0f',
	  'white_check_mark':'\u2705',
	  'white_circle':'\u26aa\ufe0f',
	  'white_flag':'\ud83c\udff3\ufe0f',
	  'white_flower':'\ud83d\udcae',
	  'white_large_square':'\u2b1c\ufe0f',
	  'white_medium_small_square':'\u25fd\ufe0f',
	  'white_medium_square':'\u25fb\ufe0f',
	  'white_small_square':'\u25ab\ufe0f',
	  'white_square_button':'\ud83d\udd33',
	  'wilted_flower':'\ud83e\udd40',
	  'wind_chime':'\ud83c\udf90',
	  'wind_face':'\ud83c\udf2c',
	  'wine_glass':'\ud83c\udf77',
	  'wink':'\ud83d\ude09',
	  'wolf':'\ud83d\udc3a',
	  'woman':'\ud83d\udc69',
	  'woman_artist':'\ud83d\udc69&zwj;\ud83c\udfa8',
	  'woman_astronaut':'\ud83d\udc69&zwj;\ud83d\ude80',
	  'woman_cartwheeling':'\ud83e\udd38&zwj;\u2640\ufe0f',
	  'woman_cook':'\ud83d\udc69&zwj;\ud83c\udf73',
	  'woman_facepalming':'\ud83e\udd26&zwj;\u2640\ufe0f',
	  'woman_factory_worker':'\ud83d\udc69&zwj;\ud83c\udfed',
	  'woman_farmer':'\ud83d\udc69&zwj;\ud83c\udf3e',
	  'woman_firefighter':'\ud83d\udc69&zwj;\ud83d\ude92',
	  'woman_health_worker':'\ud83d\udc69&zwj;\u2695\ufe0f',
	  'woman_judge':'\ud83d\udc69&zwj;\u2696\ufe0f',
	  'woman_juggling':'\ud83e\udd39&zwj;\u2640\ufe0f',
	  'woman_mechanic':'\ud83d\udc69&zwj;\ud83d\udd27',
	  'woman_office_worker':'\ud83d\udc69&zwj;\ud83d\udcbc',
	  'woman_pilot':'\ud83d\udc69&zwj;\u2708\ufe0f',
	  'woman_playing_handball':'\ud83e\udd3e&zwj;\u2640\ufe0f',
	  'woman_playing_water_polo':'\ud83e\udd3d&zwj;\u2640\ufe0f',
	  'woman_scientist':'\ud83d\udc69&zwj;\ud83d\udd2c',
	  'woman_shrugging':'\ud83e\udd37&zwj;\u2640\ufe0f',
	  'woman_singer':'\ud83d\udc69&zwj;\ud83c\udfa4',
	  'woman_student':'\ud83d\udc69&zwj;\ud83c\udf93',
	  'woman_teacher':'\ud83d\udc69&zwj;\ud83c\udfeb',
	  'woman_technologist':'\ud83d\udc69&zwj;\ud83d\udcbb',
	  'woman_with_turban':'\ud83d\udc73&zwj;\u2640\ufe0f',
	  'womans_clothes':'\ud83d\udc5a',
	  'womans_hat':'\ud83d\udc52',
	  'women_wrestling':'\ud83e\udd3c&zwj;\u2640\ufe0f',
	  'womens':'\ud83d\udeba',
	  'world_map':'\ud83d\uddfa',
	  'worried':'\ud83d\ude1f',
	  'wrench':'\ud83d\udd27',
	  'writing_hand':'\u270d\ufe0f',
	  'x':'\u274c',
	  'yellow_heart':'\ud83d\udc9b',
	  'yen':'\ud83d\udcb4',
	  'yin_yang':'\u262f\ufe0f',
	  'yum':'\ud83d\ude0b',
	  'zap':'\u26a1\ufe0f',
	  'zipper_mouth_face':'\ud83e\udd10',
	  'zzz':'\ud83d\udca4',

	  /* special emojis :P */
	  'octocat':  '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
	  'showdown': '<span style="font-family: \'Anonymous Pro\', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>'
	};

	/**
	 * Created by Estevao on 31-05-2015.
	 */

	/**
	 * Showdown Converter class
	 * @class
	 * @param {object} [converterOptions]
	 * @returns {Converter}
	 */
	showdown.Converter = function (converterOptions) {
	  'use strict';

	  var
	      /**
	       * Options used by this converter
	       * @private
	       * @type {{}}
	       */
	      options = {},

	      /**
	       * Language extensions used by this converter
	       * @private
	       * @type {Array}
	       */
	      langExtensions = [],

	      /**
	       * Output modifiers extensions used by this converter
	       * @private
	       * @type {Array}
	       */
	      outputModifiers = [],

	      /**
	       * Event listeners
	       * @private
	       * @type {{}}
	       */
	      listeners = {},

	      /**
	       * The flavor set in this converter
	       */
	      setConvFlavor = setFlavor,

	      /**
	       * Metadata of the document
	       * @type {{parsed: {}, raw: string, format: string}}
	       */
	      metadata = {
	        parsed: {},
	        raw: '',
	        format: ''
	      };

	  _constructor();

	  /**
	   * Converter constructor
	   * @private
	   */
	  function _constructor () {
	    converterOptions = converterOptions || {};

	    for (var gOpt in globalOptions) {
	      if (globalOptions.hasOwnProperty(gOpt)) {
	        options[gOpt] = globalOptions[gOpt];
	      }
	    }

	    // Merge options
	    if (typeof converterOptions === 'object') {
	      for (var opt in converterOptions) {
	        if (converterOptions.hasOwnProperty(opt)) {
	          options[opt] = converterOptions[opt];
	        }
	      }
	    } else {
	      throw Error('Converter expects the passed parameter to be an object, but ' + typeof converterOptions +
	      ' was passed instead.');
	    }

	    if (options.extensions) {
	      showdown.helper.forEach(options.extensions, _parseExtension);
	    }
	  }

	  /**
	   * Parse extension
	   * @param {*} ext
	   * @param {string} [name='']
	   * @private
	   */
	  function _parseExtension (ext, name) {

	    name = name || null;
	    // If it's a string, the extension was previously loaded
	    if (showdown.helper.isString(ext)) {
	      ext = showdown.helper.stdExtName(ext);
	      name = ext;

	      // LEGACY_SUPPORT CODE
	      if (showdown.extensions[ext]) {
	        console.warn('DEPRECATION WARNING: ' + ext + ' is an old extension that uses a deprecated loading method.' +
	          'Please inform the developer that the extension should be updated!');
	        legacyExtensionLoading(showdown.extensions[ext], ext);
	        return;
	        // END LEGACY SUPPORT CODE

	      } else if (!showdown.helper.isUndefined(extensions[ext])) {
	        ext = extensions[ext];

	      } else {
	        throw Error('Extension "' + ext + '" could not be loaded. It was either not found or is not a valid extension.');
	      }
	    }

	    if (typeof ext === 'function') {
	      ext = ext();
	    }

	    if (!showdown.helper.isArray(ext)) {
	      ext = [ext];
	    }

	    var validExt = validate(ext, name);
	    if (!validExt.valid) {
	      throw Error(validExt.error);
	    }

	    for (var i = 0; i < ext.length; ++i) {
	      switch (ext[i].type) {

	        case 'lang':
	          langExtensions.push(ext[i]);
	          break;

	        case 'output':
	          outputModifiers.push(ext[i]);
	          break;
	      }
	      if (ext[i].hasOwnProperty('listeners')) {
	        for (var ln in ext[i].listeners) {
	          if (ext[i].listeners.hasOwnProperty(ln)) {
	            listen(ln, ext[i].listeners[ln]);
	          }
	        }
	      }
	    }

	  }

	  /**
	   * LEGACY_SUPPORT
	   * @param {*} ext
	   * @param {string} name
	   */
	  function legacyExtensionLoading (ext, name) {
	    if (typeof ext === 'function') {
	      ext = ext(new showdown.Converter());
	    }
	    if (!showdown.helper.isArray(ext)) {
	      ext = [ext];
	    }
	    var valid = validate(ext, name);

	    if (!valid.valid) {
	      throw Error(valid.error);
	    }

	    for (var i = 0; i < ext.length; ++i) {
	      switch (ext[i].type) {
	        case 'lang':
	          langExtensions.push(ext[i]);
	          break;
	        case 'output':
	          outputModifiers.push(ext[i]);
	          break;
	        default:// should never reach here
	          throw Error('Extension loader error: Type unrecognized!!!');
	      }
	    }
	  }

	  /**
	   * Listen to an event
	   * @param {string} name
	   * @param {function} callback
	   */
	  function listen (name, callback) {
	    if (!showdown.helper.isString(name)) {
	      throw Error('Invalid argument in converter.listen() method: name must be a string, but ' + typeof name + ' given');
	    }

	    if (typeof callback !== 'function') {
	      throw Error('Invalid argument in converter.listen() method: callback must be a function, but ' + typeof callback + ' given');
	    }

	    if (!listeners.hasOwnProperty(name)) {
	      listeners[name] = [];
	    }
	    listeners[name].push(callback);
	  }

	  function rTrimInputText (text) {
	    var rsp = text.match(/^\s*/)[0].length,
	        rgx = new RegExp('^\\s{0,' + rsp + '}', 'gm');
	    return text.replace(rgx, '');
	  }

	  /**
	   * Dispatch an event
	   * @private
	   * @param {string} evtName Event name
	   * @param {string} text Text
	   * @param {{}} options Converter Options
	   * @param {{}} globals
	   * @returns {string}
	   */
	  this._dispatch = function dispatch (evtName, text, options, globals) {
	    if (listeners.hasOwnProperty(evtName)) {
	      for (var ei = 0; ei < listeners[evtName].length; ++ei) {
	        var nText = listeners[evtName][ei](evtName, text, this, options, globals);
	        if (nText && typeof nText !== 'undefined') {
	          text = nText;
	        }
	      }
	    }
	    return text;
	  };

	  /**
	   * Listen to an event
	   * @param {string} name
	   * @param {function} callback
	   * @returns {showdown.Converter}
	   */
	  this.listen = function (name, callback) {
	    listen(name, callback);
	    return this;
	  };

	  /**
	   * Converts a markdown string into HTML
	   * @param {string} text
	   * @returns {*}
	   */
	  this.makeHtml = function (text) {
	    //check if text is not falsy
	    if (!text) {
	      return text;
	    }

	    var globals = {
	      gHtmlBlocks:     [],
	      gHtmlMdBlocks:   [],
	      gHtmlSpans:      [],
	      gUrls:           {},
	      gTitles:         {},
	      gDimensions:     {},
	      gListLevel:      0,
	      hashLinkCounts:  {},
	      langExtensions:  langExtensions,
	      outputModifiers: outputModifiers,
	      converter:       this,
	      ghCodeBlocks:    [],
	      metadata: {
	        parsed: {},
	        raw: '',
	        format: ''
	      }
	    };

	    // This lets us use ¨ trema as an escape char to avoid md5 hashes
	    // The choice of character is arbitrary; anything that isn't
	    // magic in Markdown will work.
	    text = text.replace(/¨/g, '¨T');

	    // Replace $ with ¨D
	    // RegExp interprets $ as a special character
	    // when it's in a replacement string
	    text = text.replace(/\$/g, '¨D');

	    // Standardize line endings
	    text = text.replace(/\r\n/g, '\n'); // DOS to Unix
	    text = text.replace(/\r/g, '\n'); // Mac to Unix

	    // Stardardize line spaces
	    text = text.replace(/\u00A0/g, '&nbsp;');

	    if (options.smartIndentationFix) {
	      text = rTrimInputText(text);
	    }

	    // Make sure text begins and ends with a couple of newlines:
	    text = '\n\n' + text + '\n\n';

	    // detab
	    text = showdown.subParser('detab')(text, options, globals);

	    /**
	     * Strip any lines consisting only of spaces and tabs.
	     * This makes subsequent regexs easier to write, because we can
	     * match consecutive blank lines with /\n+/ instead of something
	     * contorted like /[ \t]*\n+/
	     */
	    text = text.replace(/^[ \t]+$/mg, '');

	    //run languageExtensions
	    showdown.helper.forEach(langExtensions, function (ext) {
	      text = showdown.subParser('runExtension')(ext, text, options, globals);
	    });

	    // run the sub parsers
	    text = showdown.subParser('metadata')(text, options, globals);
	    text = showdown.subParser('hashPreCodeTags')(text, options, globals);
	    text = showdown.subParser('githubCodeBlocks')(text, options, globals);
	    text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
	    text = showdown.subParser('hashCodeTags')(text, options, globals);
	    text = showdown.subParser('stripLinkDefinitions')(text, options, globals);
	    text = showdown.subParser('blockGamut')(text, options, globals);
	    text = showdown.subParser('unhashHTMLSpans')(text, options, globals);
	    text = showdown.subParser('unescapeSpecialChars')(text, options, globals);

	    // attacklab: Restore dollar signs
	    text = text.replace(/¨D/g, '$$');

	    // attacklab: Restore tremas
	    text = text.replace(/¨T/g, '¨');

	    // render a complete html document instead of a partial if the option is enabled
	    text = showdown.subParser('completeHTMLDocument')(text, options, globals);

	    // Run output modifiers
	    showdown.helper.forEach(outputModifiers, function (ext) {
	      text = showdown.subParser('runExtension')(ext, text, options, globals);
	    });

	    // update metadata
	    metadata = globals.metadata;
	    return text;
	  };

	  /**
	   * Converts an HTML string into a markdown string
	   * @param src
	   * @param [HTMLParser] A WHATWG DOM and HTML parser, such as JSDOM. If none is supplied, window.document will be used.
	   * @returns {string}
	   */
	  this.makeMarkdown = this.makeMd = function (src, HTMLParser) {

	    // replace \r\n with \n
	    src = src.replace(/\r\n/g, '\n');
	    src = src.replace(/\r/g, '\n'); // old macs

	    // due to an edge case, we need to find this: > <
	    // to prevent removing of non silent white spaces
	    // ex: <em>this is</em> <strong>sparta</strong>
	    src = src.replace(/>[ \t]+</, '>¨NBSP;<');

	    if (!HTMLParser) {
	      if (window && window.document) {
	        HTMLParser = window.document;
	      } else {
	        throw new Error('HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM');
	      }
	    }

	    var doc = HTMLParser.createElement('div');
	    doc.innerHTML = src;

	    var globals = {
	      preList: substitutePreCodeTags(doc)
	    };

	    // remove all newlines and collapse spaces
	    clean(doc);

	    // some stuff, like accidental reference links must now be escaped
	    // TODO
	    // doc.innerHTML = doc.innerHTML.replace(/\[[\S\t ]]/);

	    var nodes = doc.childNodes,
	        mdDoc = '';

	    for (var i = 0; i < nodes.length; i++) {
	      mdDoc += showdown.subParser('makeMarkdown.node')(nodes[i], globals);
	    }

	    function clean (node) {
	      for (var n = 0; n < node.childNodes.length; ++n) {
	        var child = node.childNodes[n];
	        if (child.nodeType === 3) {
	          if (!/\S/.test(child.nodeValue) && !/^[ ]+$/.test(child.nodeValue)) {
	            node.removeChild(child);
	            --n;
	          } else {
	            child.nodeValue = child.nodeValue.split('\n').join(' ');
	            child.nodeValue = child.nodeValue.replace(/(\s)+/g, '$1');
	          }
	        } else if (child.nodeType === 1) {
	          clean(child);
	        }
	      }
	    }

	    // find all pre tags and replace contents with placeholder
	    // we need this so that we can remove all indentation from html
	    // to ease up parsing
	    function substitutePreCodeTags (doc) {

	      var pres = doc.querySelectorAll('pre'),
	          presPH = [];

	      for (var i = 0; i < pres.length; ++i) {

	        if (pres[i].childElementCount === 1 && pres[i].firstChild.tagName.toLowerCase() === 'code') {
	          var content = pres[i].firstChild.innerHTML.trim(),
	              language = pres[i].firstChild.getAttribute('data-language') || '';

	          // if data-language attribute is not defined, then we look for class language-*
	          if (language === '') {
	            var classes = pres[i].firstChild.className.split(' ');
	            for (var c = 0; c < classes.length; ++c) {
	              var matches = classes[c].match(/^language-(.+)$/);
	              if (matches !== null) {
	                language = matches[1];
	                break;
	              }
	            }
	          }

	          // unescape html entities in content
	          content = showdown.helper.unescapeHTMLEntities(content);

	          presPH.push(content);
	          pres[i].outerHTML = '<precode language="' + language + '" precodenum="' + i.toString() + '"></precode>';
	        } else {
	          presPH.push(pres[i].innerHTML);
	          pres[i].innerHTML = '';
	          pres[i].setAttribute('prenum', i.toString());
	        }
	      }
	      return presPH;
	    }

	    return mdDoc;
	  };

	  /**
	   * Set an option of this Converter instance
	   * @param {string} key
	   * @param {*} value
	   */
	  this.setOption = function (key, value) {
	    options[key] = value;
	  };

	  /**
	   * Get the option of this Converter instance
	   * @param {string} key
	   * @returns {*}
	   */
	  this.getOption = function (key) {
	    return options[key];
	  };

	  /**
	   * Get the options of this Converter instance
	   * @returns {{}}
	   */
	  this.getOptions = function () {
	    return options;
	  };

	  /**
	   * Add extension to THIS converter
	   * @param {{}} extension
	   * @param {string} [name=null]
	   */
	  this.addExtension = function (extension, name) {
	    name = name || null;
	    _parseExtension(extension, name);
	  };

	  /**
	   * Use a global registered extension with THIS converter
	   * @param {string} extensionName Name of the previously registered extension
	   */
	  this.useExtension = function (extensionName) {
	    _parseExtension(extensionName);
	  };

	  /**
	   * Set the flavor THIS converter should use
	   * @param {string} name
	   */
	  this.setFlavor = function (name) {
	    if (!flavor.hasOwnProperty(name)) {
	      throw Error(name + ' flavor was not found');
	    }
	    var preset = flavor[name];
	    setConvFlavor = name;
	    for (var option in preset) {
	      if (preset.hasOwnProperty(option)) {
	        options[option] = preset[option];
	      }
	    }
	  };

	  /**
	   * Get the currently set flavor of this converter
	   * @returns {string}
	   */
	  this.getFlavor = function () {
	    return setConvFlavor;
	  };

	  /**
	   * Remove an extension from THIS converter.
	   * Note: This is a costly operation. It's better to initialize a new converter
	   * and specify the extensions you wish to use
	   * @param {Array} extension
	   */
	  this.removeExtension = function (extension) {
	    if (!showdown.helper.isArray(extension)) {
	      extension = [extension];
	    }
	    for (var a = 0; a < extension.length; ++a) {
	      var ext = extension[a];
	      for (var i = 0; i < langExtensions.length; ++i) {
	        if (langExtensions[i] === ext) {
	          langExtensions.splice(i, 1);
	        }
	      }
	      for (var ii = 0; ii < outputModifiers.length; ++ii) {
	        if (outputModifiers[ii] === ext) {
	          outputModifiers.splice(ii, 1);
	        }
	      }
	    }
	  };

	  /**
	   * Get all extension of THIS converter
	   * @returns {{language: Array, output: Array}}
	   */
	  this.getAllExtensions = function () {
	    return {
	      language: langExtensions,
	      output: outputModifiers
	    };
	  };

	  /**
	   * Get the metadata of the previously parsed document
	   * @param raw
	   * @returns {string|{}}
	   */
	  this.getMetadata = function (raw) {
	    if (raw) {
	      return metadata.raw;
	    } else {
	      return metadata.parsed;
	    }
	  };

	  /**
	   * Get the metadata format of the previously parsed document
	   * @returns {string}
	   */
	  this.getMetadataFormat = function () {
	    return metadata.format;
	  };

	  /**
	   * Private: set a single key, value metadata pair
	   * @param {string} key
	   * @param {string} value
	   */
	  this._setMetadataPair = function (key, value) {
	    metadata.parsed[key] = value;
	  };

	  /**
	   * Private: set metadata format
	   * @param {string} format
	   */
	  this._setMetadataFormat = function (format) {
	    metadata.format = format;
	  };

	  /**
	   * Private: set metadata raw text
	   * @param {string} raw
	   */
	  this._setMetadataRaw = function (raw) {
	    metadata.raw = raw;
	  };
	};

	/**
	 * Turn Markdown link shortcuts into XHTML <a> tags.
	 */
	showdown.subParser('anchors', function (text, options, globals) {
	  'use strict';

	  text = globals.converter._dispatch('anchors.before', text, options, globals);

	  var writeAnchorTag = function (wholeMatch, linkText, linkId, url, m5, m6, title) {
	    if (showdown.helper.isUndefined(title)) {
	      title = '';
	    }
	    linkId = linkId.toLowerCase();

	    // Special case for explicit empty url
	    if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
	      url = '';
	    } else if (!url) {
	      if (!linkId) {
	        // lower-case and turn embedded newlines into spaces
	        linkId = linkText.toLowerCase().replace(/ ?\n/g, ' ');
	      }
	      url = '#' + linkId;

	      if (!showdown.helper.isUndefined(globals.gUrls[linkId])) {
	        url = globals.gUrls[linkId];
	        if (!showdown.helper.isUndefined(globals.gTitles[linkId])) {
	          title = globals.gTitles[linkId];
	        }
	      } else {
	        return wholeMatch;
	      }
	    }

	    //url = showdown.helper.escapeCharacters(url, '*_', false); // replaced line to improve performance
	    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);

	    var result = '<a href="' + url + '"';

	    if (title !== '' && title !== null) {
	      title = title.replace(/"/g, '&quot;');
	      //title = showdown.helper.escapeCharacters(title, '*_', false); // replaced line to improve performance
	      title = title.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	      result += ' title="' + title + '"';
	    }

	    // optionLinksInNewWindow only applies
	    // to external links. Hash links (#) open in same page
	    if (options.openLinksInNewWindow && !/^#/.test(url)) {
	      // escaped _
	      result += ' rel="noopener noreferrer" target="¨E95Eblank"';
	    }

	    result += '>' + linkText + '</a>';

	    return result;
	  };

	  // First, handle reference-style links: [link text] [id]
	  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, writeAnchorTag);

	  // Next, inline-style links: [link text](url "optional title")
	  // cases with crazy urls like ./image/cat1).png
	  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
	    writeAnchorTag);

	  // normal cases
	  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
	    writeAnchorTag);

	  // handle reference-style shortcuts: [link text]
	  // These must come last in case you've also got [link test][1]
	  // or [link test](/foo)
	  text = text.replace(/\[([^\[\]]+)]()()()()()/g, writeAnchorTag);

	  // Lastly handle GithubMentions if option is enabled
	  if (options.ghMentions) {
	    text = text.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gmi, function (wm, st, escape, mentions, username) {
	      if (escape === '\\') {
	        return st + mentions;
	      }

	      //check if options.ghMentionsLink is a string
	      if (!showdown.helper.isString(options.ghMentionsLink)) {
	        throw new Error('ghMentionsLink option must be a string');
	      }
	      var lnk = options.ghMentionsLink.replace(/\{u}/g, username),
	          target = '';
	      if (options.openLinksInNewWindow) {
	        target = ' rel="noopener noreferrer" target="¨E95Eblank"';
	      }
	      return st + '<a href="' + lnk + '"' + target + '>' + mentions + '</a>';
	    });
	  }

	  text = globals.converter._dispatch('anchors.after', text, options, globals);
	  return text;
	});

	// url allowed chars [a-z\d_.~:/?#[]@!$&'()*+,;=-]

	var simpleURLRegex  = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi,
	    simpleURLRegex2 = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi,
	    delimUrlRegex   = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi,
	    simpleMailRegex = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gmi,
	    delimMailRegex  = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,

	    replaceLink = function (options) {
	      'use strict';
	      return function (wm, leadingMagicChars, link, m2, m3, trailingPunctuation, trailingMagicChars) {
	        link = link.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	        var lnkTxt = link,
	            append = '',
	            target = '',
	            lmc    = leadingMagicChars || '',
	            tmc    = trailingMagicChars || '';
	        if (/^www\./i.test(link)) {
	          link = link.replace(/^www\./i, 'http://www.');
	        }
	        if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {
	          append = trailingPunctuation;
	        }
	        if (options.openLinksInNewWindow) {
	          target = ' rel="noopener noreferrer" target="¨E95Eblank"';
	        }
	        return lmc + '<a href="' + link + '"' + target + '>' + lnkTxt + '</a>' + append + tmc;
	      };
	    },

	    replaceMail = function (options, globals) {
	      'use strict';
	      return function (wholeMatch, b, mail) {
	        var href = 'mailto:';
	        b = b || '';
	        mail = showdown.subParser('unescapeSpecialChars')(mail, options, globals);
	        if (options.encodeEmails) {
	          href = showdown.helper.encodeEmailAddress(href + mail);
	          mail = showdown.helper.encodeEmailAddress(mail);
	        } else {
	          href = href + mail;
	        }
	        return b + '<a href="' + href + '">' + mail + '</a>';
	      };
	    };

	showdown.subParser('autoLinks', function (text, options, globals) {
	  'use strict';

	  text = globals.converter._dispatch('autoLinks.before', text, options, globals);

	  text = text.replace(delimUrlRegex, replaceLink(options));
	  text = text.replace(delimMailRegex, replaceMail(options, globals));

	  text = globals.converter._dispatch('autoLinks.after', text, options, globals);

	  return text;
	});

	showdown.subParser('simplifiedAutoLinks', function (text, options, globals) {
	  'use strict';

	  if (!options.simplifiedAutoLink) {
	    return text;
	  }

	  text = globals.converter._dispatch('simplifiedAutoLinks.before', text, options, globals);

	  if (options.excludeTrailingPunctuationFromURLs) {
	    text = text.replace(simpleURLRegex2, replaceLink(options));
	  } else {
	    text = text.replace(simpleURLRegex, replaceLink(options));
	  }
	  text = text.replace(simpleMailRegex, replaceMail(options, globals));

	  text = globals.converter._dispatch('simplifiedAutoLinks.after', text, options, globals);

	  return text;
	});

	/**
	 * These are all the transformations that form block-level
	 * tags like paragraphs, headers, and list items.
	 */
	showdown.subParser('blockGamut', function (text, options, globals) {
	  'use strict';

	  text = globals.converter._dispatch('blockGamut.before', text, options, globals);

	  // we parse blockquotes first so that we can have headings and hrs
	  // inside blockquotes
	  text = showdown.subParser('blockQuotes')(text, options, globals);
	  text = showdown.subParser('headers')(text, options, globals);

	  // Do Horizontal Rules:
	  text = showdown.subParser('horizontalRule')(text, options, globals);

	  text = showdown.subParser('lists')(text, options, globals);
	  text = showdown.subParser('codeBlocks')(text, options, globals);
	  text = showdown.subParser('tables')(text, options, globals);

	  // We already ran _HashHTMLBlocks() before, in Markdown(), but that
	  // was to escape raw HTML in the original Markdown source. This time,
	  // we're escaping the markup we've just created, so that we don't wrap
	  // <p> tags around block-level tags.
	  text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
	  text = showdown.subParser('paragraphs')(text, options, globals);

	  text = globals.converter._dispatch('blockGamut.after', text, options, globals);

	  return text;
	});

	showdown.subParser('blockQuotes', function (text, options, globals) {
	  'use strict';

	  text = globals.converter._dispatch('blockQuotes.before', text, options, globals);

	  // add a couple extra lines after the text and endtext mark
	  text = text + '\n\n';

	  var rgx = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;

	  if (options.splitAdjacentBlockquotes) {
	    rgx = /^ {0,3}>[\s\S]*?(?:\n\n)/gm;
	  }

	  text = text.replace(rgx, function (bq) {
	    // attacklab: hack around Konqueror 3.5.4 bug:
	    // "----------bug".replace(/^-/g,"") == "bug"
	    bq = bq.replace(/^[ \t]*>[ \t]?/gm, ''); // trim one level of quoting

	    // attacklab: clean up hack
	    bq = bq.replace(/¨0/g, '');

	    bq = bq.replace(/^[ \t]+$/gm, ''); // trim whitespace-only lines
	    bq = showdown.subParser('githubCodeBlocks')(bq, options, globals);
	    bq = showdown.subParser('blockGamut')(bq, options, globals); // recurse

	    bq = bq.replace(/(^|\n)/g, '$1  ');
	    // These leading spaces screw with <pre> content, so we need to fix that:
	    bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function (wholeMatch, m1) {
	      var pre = m1;
	      // attacklab: hack around Konqueror 3.5.4 bug:
	      pre = pre.replace(/^  /mg, '¨0');
	      pre = pre.replace(/¨0/g, '');
	      return pre;
	    });

	    return showdown.subParser('hashBlock')('<blockquote>\n' + bq + '\n</blockquote>', options, globals);
	  });

	  text = globals.converter._dispatch('blockQuotes.after', text, options, globals);
	  return text;
	});

	/**
	 * Process Markdown `<pre><code>` blocks.
	 */
	showdown.subParser('codeBlocks', function (text, options, globals) {
	  'use strict';

	  text = globals.converter._dispatch('codeBlocks.before', text, options, globals);

	  // sentinel workarounds for lack of \A and \Z, safari\khtml bug
	  text += '¨0';

	  var pattern = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=¨0))/g;
	  text = text.replace(pattern, function (wholeMatch, m1, m2) {
	    var codeblock = m1,
	        nextChar = m2,
	        end = '\n';

	    codeblock = showdown.subParser('outdent')(codeblock, options, globals);
	    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
	    codeblock = showdown.subParser('detab')(codeblock, options, globals);
	    codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
	    codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing newlines

	    if (options.omitExtraWLInCodeBlocks) {
	      end = '';
	    }

	    codeblock = '<pre><code>' + codeblock + end + '</code></pre>';

	    return showdown.subParser('hashBlock')(codeblock, options, globals) + nextChar;
	  });

	  // strip sentinel
	  text = text.replace(/¨0/, '');

	  text = globals.converter._dispatch('codeBlocks.after', text, options, globals);
	  return text;
	});

	/**
	 *
	 *   *  Backtick quotes are used for <code></code> spans.
	 *
	 *   *  You can use multiple backticks as the delimiters if you want to
	 *     include literal backticks in the code span. So, this input:
	 *
	 *         Just type ``foo `bar` baz`` at the prompt.
	 *
	 *       Will translate to:
	 *
	 *         <p>Just type <code>foo `bar` baz</code> at the prompt.</p>
	 *
	 *    There's no arbitrary limit to the number of backticks you
	 *    can use as delimters. If you need three consecutive backticks
	 *    in your code, use four for delimiters, etc.
	 *
	 *  *  You can use spaces to get literal backticks at the edges:
	 *
	 *         ... type `` `bar` `` ...
	 *
	 *       Turns to:
	 *
	 *         ... type <code>`bar`</code> ...
	 */
	showdown.subParser('codeSpans', function (text, options, globals) {
	  'use strict';

	  text = globals.converter._dispatch('codeSpans.before', text, options, globals);

	  if (typeof (text) === 'undefined') {
	    text = '';
	  }
	  text = text.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
	    function (wholeMatch, m1, m2, m3) {
	      var c = m3;
	      c = c.replace(/^([ \t]*)/g, '');	// leading whitespace
	      c = c.replace(/[ \t]*$/g, '');	// trailing whitespace
	      c = showdown.subParser('encodeCode')(c, options, globals);
	      c = m1 + '<code>' + c + '</code>';
	      c = showdown.subParser('hashHTMLSpans')(c, options, globals);
	      return c;
	    }
	  );

	  text = globals.converter._dispatch('codeSpans.after', text, options, globals);
	  return text;
	});

	/**
	 * Create a full HTML document from the processed markdown
	 */
	showdown.subParser('completeHTMLDocument', function (text, options, globals) {
	  'use strict';

	  if (!options.completeHTMLDocument) {
	    return text;
	  }

	  text = globals.converter._dispatch('completeHTMLDocument.before', text, options, globals);

	  var doctype = 'html',
	      doctypeParsed = '<!DOCTYPE HTML>\n',
	      title = '',
	      charset = '<meta charset="utf-8">\n',
	      lang = '',
	      metadata = '';

	  if (typeof globals.metadata.parsed.doctype !== 'undefined') {
	    doctypeParsed = '<!DOCTYPE ' +  globals.metadata.parsed.doctype + '>\n';
	    doctype = globals.metadata.parsed.doctype.toString().toLowerCase();
	    if (doctype === 'html' || doctype === 'html5') {
	      charset = '<meta charset="utf-8">';
	    }
	  }

	  for (var meta in globals.metadata.parsed) {
	    if (globals.metadata.parsed.hasOwnProperty(meta)) {
	      switch (meta.toLowerCase()) {
	        case 'doctype':
	          break;

	        case 'title':
	          title = '<title>' +  globals.metadata.parsed.title + '</title>\n';
	          break;

	        case 'charset':
	          if (doctype === 'html' || doctype === 'html5') {
	            charset = '<meta charset="' + globals.metadata.parsed.charset + '">\n';
	          } else {
	            charset = '<meta name="charset" content="' + globals.metadata.parsed.charset + '">\n';
	          }
	          break;

	        case 'language':
	        case 'lang':
	          lang = ' lang="' + globals.metadata.parsed[meta] + '"';
	          metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
	          break;

	        default:
	          metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
	      }
	    }
	  }

	  text = doctypeParsed + '<html' + lang + '>\n<head>\n' + title + charset + metadata + '</head>\n<body>\n' + text.trim() + '\n</body>\n</html>';

	  text = globals.converter._dispatch('completeHTMLDocument.after', text, options, globals);
	  return text;
	});

	/**
	 * Convert all tabs to spaces
	 */
	showdown.subParser('detab', function (text, options, globals) {
	  'use strict';
	  text = globals.converter._dispatch('detab.before', text, options, globals);

	  // expand first n-1 tabs
	  text = text.replace(/\t(?=\t)/g, '    '); // g_tab_width

	  // replace the nth with two sentinels
	  text = text.replace(/\t/g, '¨A¨B');

	  // use the sentinel to anchor our regex so it doesn't explode
	  text = text.replace(/¨B(.+?)¨A/g, function (wholeMatch, m1) {
	    var leadingText = m1,
	        numSpaces = 4 - leadingText.length % 4;  // g_tab_width

	    // there *must* be a better way to do this:
	    for (var i = 0; i < numSpaces; i++) {
	      leadingText += ' ';
	    }

	    return leadingText;
	  });

	  // clean up sentinels
	  text = text.replace(/¨A/g, '    ');  // g_tab_width
	  text = text.replace(/¨B/g, '');

	  text = globals.converter._dispatch('detab.after', text, options, globals);
	  return text;
	});

	showdown.subParser('ellipsis', function (text, options, globals) {
	  'use strict';

	  if (!options.ellipsis) {
	    return text;
	  }

	  text = globals.converter._dispatch('ellipsis.before', text, options, globals);

	  text = text.replace(/\.\.\./g, '…');

	  text = globals.converter._dispatch('ellipsis.after', text, options, globals);

	  return text;
	});

	/**
	 * Turn emoji codes into emojis
	 *
	 * List of supported emojis: https://github.com/showdownjs/showdown/wiki/Emojis
	 */
	showdown.subParser('emoji', function (text, options, globals) {
	  'use strict';

	  if (!options.emoji) {
	    return text;
	  }

	  text = globals.converter._dispatch('emoji.before', text, options, globals);

	  var emojiRgx = /:([\S]+?):/g;

	  text = text.replace(emojiRgx, function (wm, emojiCode) {
	    if (showdown.helper.emojis.hasOwnProperty(emojiCode)) {
	      return showdown.helper.emojis[emojiCode];
	    }
	    return wm;
	  });

	  text = globals.converter._dispatch('emoji.after', text, options, globals);

	  return text;
	});

	/**
	 * Smart processing for ampersands and angle brackets that need to be encoded.
	 */
	showdown.subParser('encodeAmpsAndAngles', function (text, options, globals) {
	  'use strict';
	  text = globals.converter._dispatch('encodeAmpsAndAngles.before', text, options, globals);

	  // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:
	  // http://bumppo.net/projects/amputator/
	  text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, '&amp;');

	  // Encode naked <'s
	  text = text.replace(/<(?![a-z\/?$!])/gi, '&lt;');

	  // Encode <
	  text = text.replace(/</g, '&lt;');

	  // Encode >
	  text = text.replace(/>/g, '&gt;');

	  text = globals.converter._dispatch('encodeAmpsAndAngles.after', text, options, globals);
	  return text;
	});

	/**
	 * Returns the string, with after processing the following backslash escape sequences.
	 *
	 * attacklab: The polite way to do this is with the new escapeCharacters() function:
	 *
	 *    text = escapeCharacters(text,"\\",true);
	 *    text = escapeCharacters(text,"`*_{}[]()>#+-.!",true);
	 *
	 * ...but we're sidestepping its use of the (slow) RegExp constructor
	 * as an optimization for Firefox.  This function gets called a LOT.
	 */
	showdown.subParser('encodeBackslashEscapes', function (text, options, globals) {
	  'use strict';
	  text = globals.converter._dispatch('encodeBackslashEscapes.before', text, options, globals);

	  text = text.replace(/\\(\\)/g, showdown.helper.escapeCharactersCallback);
	  text = text.replace(/\\([`*_{}\[\]()>#+.!~=|:-])/g, showdown.helper.escapeCharactersCallback);

	  text = globals.converter._dispatch('encodeBackslashEscapes.after', text, options, globals);
	  return text;
	});

	/**
	 * Encode/escape certain characters inside Markdown code runs.
	 * The point is that in code, these characters are literals,
	 * and lose their special Markdown meanings.
	 */
	showdown.subParser('encodeCode', function (text, options, globals) {
	  'use strict';

	  text = globals.converter._dispatch('encodeCode.before', text, options, globals);

	  // Encode all ampersands; HTML entities are not
	  // entities within a Markdown code span.
	  text = text
	    .replace(/&/g, '&amp;')
	  // Do the angle bracket song and dance:
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	  // Now, escape characters that are magic in Markdown:
	    .replace(/([*_{}\[\]\\=~-])/g, showdown.helper.escapeCharactersCallback);

	  text = globals.converter._dispatch('encodeCode.after', text, options, globals);
	  return text;
	});

	/**
	 * Within tags -- meaning between < and > -- encode [\ ` * _ ~ =] so they
	 * don't conflict with their use in Markdown for code, italics and strong.
	 */
	showdown.subParser('escapeSpecialCharsWithinTagAttributes', function (text, options, globals) {
	  'use strict';
	  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.before', text, options, globals);

	  // Build a regex to find HTML tags.
	  var tags     = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi,
	      comments = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;

	  text = text.replace(tags, function (wholeMatch) {
	    return wholeMatch
	      .replace(/(.)<\/?code>(?=.)/g, '$1`')
	      .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
	  });

	  text = text.replace(comments, function (wholeMatch) {
	    return wholeMatch
	      .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
	  });

	  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.after', text, options, globals);
	  return text;
	});

	/**
	 * Handle github codeblocks prior to running HashHTML so that
	 * HTML contained within the codeblock gets escaped properly
	 * Example:
	 * ```ruby
	 *     def hello_world(x)
	 *       puts "Hello, #{x}"
	 *     end
	 * ```
	 */
	showdown.subParser('githubCodeBlocks', function (text, options, globals) {
	  'use strict';

	  // early exit if option is not enabled
	  if (!options.ghCodeBlocks) {
	    return text;
	  }

	  text = globals.converter._dispatch('githubCodeBlocks.before', text, options, globals);

	  text += '¨0';

	  text = text.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, function (wholeMatch, delim, language, codeblock) {
	    var end = (options.omitExtraWLInCodeBlocks) ? '' : '\n';

	    // First parse the github code block
	    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
	    codeblock = showdown.subParser('detab')(codeblock, options, globals);
	    codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
	    codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing whitespace

	    codeblock = '<pre><code' + (language ? ' class="' + language + ' language-' + language + '"' : '') + '>' + codeblock + end + '</code></pre>';

	    codeblock = showdown.subParser('hashBlock')(codeblock, options, globals);

	    // Since GHCodeblocks can be false positives, we need to
	    // store the primitive text and the parsed text in a global var,
	    // and then return a token
	    return '\n\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
	  });

	  // attacklab: strip sentinel
	  text = text.replace(/¨0/, '');

	  return globals.converter._dispatch('githubCodeBlocks.after', text, options, globals);
	});

	showdown.subParser('hashBlock', function (text, options, globals) {
	  'use strict';
	  text = globals.converter._dispatch('hashBlock.before', text, options, globals);
	  text = text.replace(/(^\n+|\n+$)/g, '');
	  text = '\n\n¨K' + (globals.gHtmlBlocks.push(text) - 1) + 'K\n\n';
	  text = globals.converter._dispatch('hashBlock.after', text, options, globals);
	  return text;
	});

	/**
	 * Hash and escape <code> elements that should not be parsed as markdown
	 */
	showdown.subParser('hashCodeTags', function (text, options, globals) {
	  'use strict';
	  text = globals.converter._dispatch('hashCodeTags.before', text, options, globals);

	  var repFunc = function (wholeMatch, match, left, right) {
	    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
	    return '¨C' + (globals.gHtmlSpans.push(codeblock) - 1) + 'C';
	  };

	  // Hash naked <code>
	  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '<code\\b[^>]*>', '</code>', 'gim');

	  text = globals.converter._dispatch('hashCodeTags.after', text, options, globals);
	  return text;
	});

	showdown.subParser('hashElement', function (text, options, globals) {
	  'use strict';

	  return function (wholeMatch, m1) {
	    var blockText = m1;

	    // Undo double lines
	    blockText = blockText.replace(/\n\n/g, '\n');
	    blockText = blockText.replace(/^\n/, '');

	    // strip trailing blank lines
	    blockText = blockText.replace(/\n+$/g, '');

	    // Replace the element text with a marker ("¨KxK" where x is its key)
	    blockText = '\n\n¨K' + (globals.gHtmlBlocks.push(blockText) - 1) + 'K\n\n';

	    return blockText;
	  };
	});

	showdown.subParser('hashHTMLBlocks', function (text, options, globals) {
	  'use strict';
	  text = globals.converter._dispatch('hashHTMLBlocks.before', text, options, globals);

	  var blockTags = [
	        'pre',
	        'div',
	        'h1',
	        'h2',
	        'h3',
	        'h4',
	        'h5',
	        'h6',
	        'blockquote',
	        'table',
	        'dl',
	        'ol',
	        'ul',
	        'script',
	        'noscript',
	        'form',
	        'fieldset',
	        'iframe',
	        'math',
	        'style',
	        'section',
	        'header',
	        'footer',
	        'nav',
	        'article',
	        'aside',
	        'address',
	        'audio',
	        'canvas',
	        'figure',
	        'hgroup',
	        'output',
	        'video',
	        'p'
	      ],
	      repFunc = function (wholeMatch, match, left, right) {
	        var txt = wholeMatch;
	        // check if this html element is marked as markdown
	        // if so, it's contents should be parsed as markdown
	        if (left.search(/\bmarkdown\b/) !== -1) {
	          txt = left + globals.converter.makeHtml(match) + right;
	        }
	        return '\n\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
	      };

	  if (options.backslashEscapesHTMLTags) {
	    // encode backslash escaped HTML tags
	    text = text.replace(/\\<(\/?[^>]+?)>/g, function (wm, inside) {
	      return '&lt;' + inside + '&gt;';
	    });
	  }

	  // hash HTML Blocks
	  for (var i = 0; i < blockTags.length; ++i) {

	    var opTagPos,
	        rgx1     = new RegExp('^ {0,3}(<' + blockTags[i] + '\\b[^>]*>)', 'im'),
	        patLeft  = '<' + blockTags[i] + '\\b[^>]*>',
	        patRight = '</' + blockTags[i] + '>';
	    // 1. Look for the first position of the first opening HTML tag in the text
	    while ((opTagPos = showdown.helper.regexIndexOf(text, rgx1)) !== -1) {

	      // if the HTML tag is \ escaped, we need to escape it and break


	      //2. Split the text in that position
	      var subTexts = showdown.helper.splitAtIndex(text, opTagPos),
	          //3. Match recursively
	          newSubText1 = showdown.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, 'im');

	      // prevent an infinite loop
	      if (newSubText1 === subTexts[1]) {
	        break;
	      }
	      text = subTexts[0].concat(newSubText1);
	    }
	  }
	  // HR SPECIAL CASE
	  text = text.replace(/(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
	    showdown.subParser('hashElement')(text, options, globals));

	  // Special case for standalone HTML comments
	  text = showdown.helper.replaceRecursiveRegExp(text, function (txt) {
	    return '\n\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
	  }, '^ {0,3}<!--', '-->', 'gm');

	  // PHP and ASP-style processor instructions (<?...?> and <%...%>)
	  text = text.replace(/(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
	    showdown.subParser('hashElement')(text, options, globals));

	  text = globals.converter._dispatch('hashHTMLBlocks.after', text, options, globals);
	  return text;
	});

	/**
	 * Hash span elements that should not be parsed as markdown
	 */
	showdown.subParser('hashHTMLSpans', function (text, options, globals) {
	  'use strict';
	  text = globals.converter._dispatch('hashHTMLSpans.before', text, options, globals);

	  function hashHTMLSpan (html) {
	    return '¨C' + (globals.gHtmlSpans.push(html) - 1) + 'C';
	  }

	  // Hash Self Closing tags
	  text = text.replace(/<[^>]+?\/>/gi, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  // Hash tags without properties
	  text = text.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  // Hash tags with properties
	  text = text.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  // Hash self closing tags without />
	  text = text.replace(/<[^>]+?>/gi, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  /*showdown.helper.matchRecursiveRegExp(text, '<code\\b[^>]*>', '</code>', 'gi');*/

	  text = globals.converter._dispatch('hashHTMLSpans.after', text, options, globals);
	  return text;
	});

	/**
	 * Unhash HTML spans
	 */
	showdown.subParser('unhashHTMLSpans', function (text, options, globals) {
	  'use strict';
	  text = globals.converter._dispatch('unhashHTMLSpans.before', text, options, globals);

	  for (var i = 0; i < globals.gHtmlSpans.length; ++i) {
	    var repText = globals.gHtmlSpans[i],
	        // limiter to prevent infinite loop (assume 10 as limit for recurse)
	        limit = 0;

	    while (/¨C(\d+)C/.test(repText)) {
	      var num = RegExp.$1;
	      repText = repText.replace('¨C' + num + 'C', globals.gHtmlSpans[num]);
	      if (limit === 10) {
	        console.error('maximum nesting of 10 spans reached!!!');
	        break;
	      }
	      ++limit;
	    }
	    text = text.replace('¨C' + i + 'C', repText);
	  }

	  text = globals.converter._dispatch('unhashHTMLSpans.after', text, options, globals);
	  return text;
	});

	/**
	 * Hash and escape <pre><code> elements that should not be parsed as markdown
	 */
	showdown.subParser('hashPreCodeTags', function (text, options, globals) {
	  'use strict';
	  text = globals.converter._dispatch('hashPreCodeTags.before', text, options, globals);

	  var repFunc = function (wholeMatch, match, left, right) {
	    // encode html entities
	    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
	    return '\n\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
	  };

	  // Hash <pre><code>
	  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>', '^ {0,3}</code>\\s*</pre>', 'gim');

	  text = globals.converter._dispatch('hashPreCodeTags.after', text, options, globals);
	  return text;
	});

	showdown.subParser('headers', function (text, options, globals) {
	  'use strict';

	  text = globals.converter._dispatch('headers.before', text, options, globals);

	  var headerLevelStart = (isNaN(parseInt(options.headerLevelStart))) ? 1 : parseInt(options.headerLevelStart),

	      // Set text-style headers:
	      //	Header 1
	      //	========
	      //
	      //	Header 2
	      //	--------
	      //
	      setextRegexH1 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm,
	      setextRegexH2 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm;

	  text = text.replace(setextRegexH1, function (wholeMatch, m1) {

	    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
	        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
	        hLevel = headerLevelStart,
	        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
	    return showdown.subParser('hashBlock')(hashBlock, options, globals);
	  });

	  text = text.replace(setextRegexH2, function (matchFound, m1) {
	    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
	        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
	        hLevel = headerLevelStart + 1,
	        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
	    return showdown.subParser('hashBlock')(hashBlock, options, globals);
	  });

	  // atx-style headers:
	  //  # Header 1
	  //  ## Header 2
	  //  ## Header 2 with closing hashes ##
	  //  ...
	  //  ###### Header 6
	  //
	  var atxStyle = (options.requireSpaceBeforeHeadingText) ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;

	  text = text.replace(atxStyle, function (wholeMatch, m1, m2) {
	    var hText = m2;
	    if (options.customizedHeaderId) {
	      hText = m2.replace(/\s?\{([^{]+?)}\s*$/, '');
	    }

	    var span = showdown.subParser('spanGamut')(hText, options, globals),
	        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m2) + '"',
	        hLevel = headerLevelStart - 1 + m1.length,
	        header = '<h' + hLevel + hID + '>' + span + '</h' + hLevel + '>';

	    return showdown.subParser('hashBlock')(header, options, globals);
	  });

	  function headerId (m) {
	    var title,
	        prefix;

	    // It is separate from other options to allow combining prefix and customized
	    if (options.customizedHeaderId) {
	      var match = m.match(/\{([^{]+?)}\s*$/);
	      if (match && match[1]) {
	        m = match[1];
	      }
	    }

	    title = m;

	    // Prefix id to prevent causing inadvertent pre-existing style matches.
	    if (showdown.helper.isString(options.prefixHeaderId)) {
	      prefix = options.prefixHeaderId;
	    } else if (options.prefixHeaderId === true) {
	      prefix = 'section-';
	    } else {
	      prefix = '';
	    }

	    if (!options.rawPrefixHeaderId) {
	      title = prefix + title;
	    }

	    if (options.ghCompatibleHeaderId) {
	      title = title
	        .replace(/ /g, '-')
	        // replace previously escaped chars (&, ¨ and $)
	        .replace(/&amp;/g, '')
	        .replace(/¨T/g, '')
	        .replace(/¨D/g, '')
	        // replace rest of the chars (&~$ are repeated as they might have been escaped)
	        // borrowed from github's redcarpet (some they should produce similar results)
	        .replace(/[&+$,\/:;=?@"#{}|^¨~\[\]`\\*)(%.!'<>]/g, '')
	        .toLowerCase();
	    } else if (options.rawHeaderId) {
	      title = title
	        .replace(/ /g, '-')
	        // replace previously escaped chars (&, ¨ and $)
	        .replace(/&amp;/g, '&')
	        .replace(/¨T/g, '¨')
	        .replace(/¨D/g, '$')
	        // replace " and '
	        .replace(/["']/g, '-')
	        .toLowerCase();
	    } else {
	      title = title
	        .replace(/[^\w]/g, '')
	        .toLowerCase();
	    }

	    if (options.rawPrefixHeaderId) {
	      title = prefix + title;
	    }

	    if (globals.hashLinkCounts[title]) {
	      title = title + '-' + (globals.hashLinkCounts[title]++);
	    } else {
	      globals.hashLinkCounts[title] = 1;
	    }
	    return title;
	  }

	  text = globals.converter._dispatch('headers.after', text, options, globals);
	  return text;
	});

	/**
	 * Turn Markdown link shortcuts into XHTML <a> tags.
	 */
	showdown.subParser('horizontalRule', function (text, options, globals) {
	  'use strict';
	  text = globals.converter._dispatch('horizontalRule.before', text, options, globals);

	  var key = showdown.subParser('hashBlock')('<hr />', options, globals);
	  text = text.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, key);
	  text = text.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, key);
	  text = text.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, key);

	  text = globals.converter._dispatch('horizontalRule.after', text, options, globals);
	  return text;
	});

	/**
	 * Turn Markdown image shortcuts into <img> tags.
	 */
	showdown.subParser('images', function (text, options, globals) {
	  'use strict';

	  text = globals.converter._dispatch('images.before', text, options, globals);

	  var inlineRegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
	      crazyRegExp       = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g,
	      base64RegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
	      referenceRegExp   = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g,
	      refShortcutRegExp = /!\[([^\[\]]+)]()()()()()/g;

	  function writeImageTagBase64 (wholeMatch, altText, linkId, url, width, height, m5, title) {
	    url = url.replace(/\s/g, '');
	    return writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title);
	  }

	  function writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title) {

	    var gUrls   = globals.gUrls,
	        gTitles = globals.gTitles,
	        gDims   = globals.gDimensions;

	    linkId = linkId.toLowerCase();

	    if (!title) {
	      title = '';
	    }
	    // Special case for explicit empty url
	    if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
	      url = '';

	    } else if (url === '' || url === null) {
	      if (linkId === '' || linkId === null) {
	        // lower-case and turn embedded newlines into spaces
	        linkId = altText.toLowerCase().replace(/ ?\n/g, ' ');
	      }
	      url = '#' + linkId;

	      if (!showdown.helper.isUndefined(gUrls[linkId])) {
	        url = gUrls[linkId];
	        if (!showdown.helper.isUndefined(gTitles[linkId])) {
	          title = gTitles[linkId];
	        }
	        if (!showdown.helper.isUndefined(gDims[linkId])) {
	          width = gDims[linkId].width;
	          height = gDims[linkId].height;
	        }
	      } else {
	        return wholeMatch;
	      }
	    }

	    altText = altText
	      .replace(/"/g, '&quot;')
	    //altText = showdown.helper.escapeCharacters(altText, '*_', false);
	      .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	    //url = showdown.helper.escapeCharacters(url, '*_', false);
	    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	    var result = '<img src="' + url + '" alt="' + altText + '"';

	    if (title && showdown.helper.isString(title)) {
	      title = title
	        .replace(/"/g, '&quot;')
	      //title = showdown.helper.escapeCharacters(title, '*_', false);
	        .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	      result += ' title="' + title + '"';
	    }

	    if (width && height) {
	      width  = (width === '*') ? 'auto' : width;
	      height = (height === '*') ? 'auto' : height;

	      result += ' width="' + width + '"';
	      result += ' height="' + height + '"';
	    }

	    result += ' />';

	    return result;
	  }

	  // First, handle reference-style labeled images: ![alt text][id]
	  text = text.replace(referenceRegExp, writeImageTag);

	  // Next, handle inline images:  ![alt text](url =<width>x<height> "optional title")

	  // base64 encoded images
	  text = text.replace(base64RegExp, writeImageTagBase64);

	  // cases with crazy urls like ./image/cat1).png
	  text = text.replace(crazyRegExp, writeImageTag);

	  // normal cases
	  text = text.replace(inlineRegExp, writeImageTag);

	  // handle reference-style shortcuts: ![img text]
	  text = text.replace(refShortcutRegExp, writeImageTag);

	  text = globals.converter._dispatch('images.after', text, options, globals);
	  return text;
	});

	showdown.subParser('italicsAndBold', function (text, options, globals) {
	  'use strict';

	  text = globals.converter._dispatch('italicsAndBold.before', text, options, globals);

	  // it's faster to have 3 separate regexes for each case than have just one
	  // because of backtracing, in some cases, it could lead to an exponential effect
	  // called "catastrophic backtrace". Ominous!

	  function parseInside (txt, left, right) {
	    /*
	    if (options.simplifiedAutoLink) {
	      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
	    }
	    */
	    return left + txt + right;
	  }

	  // Parse underscores
	  if (options.literalMidWordUnderscores) {
	    text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
	      return parseInside (txt, '<strong><em>', '</em></strong>');
	    });
	    text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
	      return parseInside (txt, '<strong>', '</strong>');
	    });
	    text = text.replace(/\b_(\S[\s\S]*?)_\b/g, function (wm, txt) {
	      return parseInside (txt, '<em>', '</em>');
	    });
	  } else {
	    text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
	    });
	    text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
	    });
	    text = text.replace(/_([^\s_][\s\S]*?)_/g, function (wm, m) {
	      // !/^_[^_]/.test(m) - test if it doesn't start with __ (since it seems redundant, we removed it)
	      return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
	    });
	  }

	  // Now parse asterisks
	  if (options.literalMidWordAsterisks) {
	    text = text.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, function (wm, lead, txt) {
	      return parseInside (txt, lead + '<strong><em>', '</em></strong>');
	    });
	    text = text.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, function (wm, lead, txt) {
	      return parseInside (txt, lead + '<strong>', '</strong>');
	    });
	    text = text.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, function (wm, lead, txt) {
	      return parseInside (txt, lead + '<em>', '</em>');
	    });
	  } else {
	    text = text.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
	    });
	    text = text.replace(/\*\*(\S[\s\S]*?)\*\*/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
	    });
	    text = text.replace(/\*([^\s*][\s\S]*?)\*/g, function (wm, m) {
	      // !/^\*[^*]/.test(m) - test if it doesn't start with ** (since it seems redundant, we removed it)
	      return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
	    });
	  }


	  text = globals.converter._dispatch('italicsAndBold.after', text, options, globals);
	  return text;
	});

	/**
	 * Form HTML ordered (numbered) and unordered (bulleted) lists.
	 */
	showdown.subParser('lists', function (text, options, globals) {
	  'use strict';

	  /**
	   * Process the contents of a single ordered or unordered list, splitting it
	   * into individual list items.
	   * @param {string} listStr
	   * @param {boolean} trimTrailing
	   * @returns {string}
	   */
	  function processListItems (listStr, trimTrailing) {
	    // The $g_list_level global keeps track of when we're inside a list.
	    // Each time we enter a list, we increment it; when we leave a list,
	    // we decrement. If it's zero, we're not in a list anymore.
	    //
	    // We do this because when we're not inside a list, we want to treat
	    // something like this:
	    //
	    //    I recommend upgrading to version
	    //    8. Oops, now this line is treated
	    //    as a sub-list.
	    //
	    // As a single paragraph, despite the fact that the second line starts
	    // with a digit-period-space sequence.
	    //
	    // Whereas when we're inside a list (or sub-list), that line will be
	    // treated as the start of a sub-list. What a kludge, huh? This is
	    // an aspect of Markdown's syntax that's hard to parse perfectly
	    // without resorting to mind-reading. Perhaps the solution is to
	    // change the syntax rules such that sub-lists must start with a
	    // starting cardinal number; e.g. "1." or "a.".
	    globals.gListLevel++;

	    // trim trailing blank lines:
	    listStr = listStr.replace(/\n{2,}$/, '\n');

	    // attacklab: add sentinel to emulate \z
	    listStr += '¨0';

	    var rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0| {0,3}([*+-]|\d+[.])[ \t]+))/gm,
	        isParagraphed = (/\n[ \t]*\n(?!¨0)/.test(listStr));

	    // Since version 1.5, nesting sublists requires 4 spaces (or 1 tab) indentation,
	    // which is a syntax breaking change
	    // activating this option reverts to old behavior
	    if (options.disableForced4SpacesIndentedSublists) {
	      rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0|\2([*+-]|\d+[.])[ \t]+))/gm;
	    }

	    listStr = listStr.replace(rgx, function (wholeMatch, m1, m2, m3, m4, taskbtn, checked) {
	      checked = (checked && checked.trim() !== '');

	      var item = showdown.subParser('outdent')(m4, options, globals),
	          bulletStyle = '';

	      // Support for github tasklists
	      if (taskbtn && options.tasklists) {
	        bulletStyle = ' class="task-list-item" style="list-style-type: none;"';
	        item = item.replace(/^[ \t]*\[(x|X| )?]/m, function () {
	          var otp = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
	          if (checked) {
	            otp += ' checked';
	          }
	          otp += '>';
	          return otp;
	        });
	      }

	      // ISSUE #312
	      // This input: - - - a
	      // causes trouble to the parser, since it interprets it as:
	      // <ul><li><li><li>a</li></li></li></ul>
	      // instead of:
	      // <ul><li>- - a</li></ul>
	      // So, to prevent it, we will put a marker (¨A)in the beginning of the line
	      // Kind of hackish/monkey patching, but seems more effective than overcomplicating the list parser
	      item = item.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function (wm2) {
	        return '¨A' + wm2;
	      });

	      // m1 - Leading line or
	      // Has a double return (multi paragraph) or
	      // Has sublist
	      if (m1 || (item.search(/\n{2,}/) > -1)) {
	        item = showdown.subParser('githubCodeBlocks')(item, options, globals);
	        item = showdown.subParser('blockGamut')(item, options, globals);
	      } else {
	        // Recursion for sub-lists:
	        item = showdown.subParser('lists')(item, options, globals);
	        item = item.replace(/\n$/, ''); // chomp(item)
	        item = showdown.subParser('hashHTMLBlocks')(item, options, globals);

	        // Colapse double linebreaks
	        item = item.replace(/\n\n+/g, '\n\n');
	        if (isParagraphed) {
	          item = showdown.subParser('paragraphs')(item, options, globals);
	        } else {
	          item = showdown.subParser('spanGamut')(item, options, globals);
	        }
	      }

	      // now we need to remove the marker (¨A)
	      item = item.replace('¨A', '');
	      // we can finally wrap the line in list item tags
	      item =  '<li' + bulletStyle + '>' + item + '</li>\n';

	      return item;
	    });

	    // attacklab: strip sentinel
	    listStr = listStr.replace(/¨0/g, '');

	    globals.gListLevel--;

	    if (trimTrailing) {
	      listStr = listStr.replace(/\s+$/, '');
	    }

	    return listStr;
	  }

	  function styleStartNumber (list, listType) {
	    // check if ol and starts by a number different than 1
	    if (listType === 'ol') {
	      var res = list.match(/^ *(\d+)\./);
	      if (res && res[1] !== '1') {
	        return ' start="' + res[1] + '"';
	      }
	    }
	    return '';
	  }

	  /**
	   * Check and parse consecutive lists (better fix for issue #142)
	   * @param {string} list
	   * @param {string} listType
	   * @param {boolean} trimTrailing
	   * @returns {string}
	   */
	  function parseConsecutiveLists (list, listType, trimTrailing) {
	    // check if we caught 2 or more consecutive lists by mistake
	    // we use the counterRgx, meaning if listType is UL we look for OL and vice versa
	    var olRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm,
	        ulRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm,
	        counterRxg = (listType === 'ul') ? olRgx : ulRgx,
	        result = '';

	    if (list.search(counterRxg) !== -1) {
	      (function parseCL (txt) {
	        var pos = txt.search(counterRxg),
	            style = styleStartNumber(list, listType);
	        if (pos !== -1) {
	          // slice
	          result += '\n\n<' + listType + style + '>\n' + processListItems(txt.slice(0, pos), !!trimTrailing) + '</' + listType + '>\n';

	          // invert counterType and listType
	          listType = (listType === 'ul') ? 'ol' : 'ul';
	          counterRxg = (listType === 'ul') ? olRgx : ulRgx;

	          //recurse
	          parseCL(txt.slice(pos));
	        } else {
	          result += '\n\n<' + listType + style + '>\n' + processListItems(txt, !!trimTrailing) + '</' + listType + '>\n';
	        }
	      })(list);
	    } else {
	      var style = styleStartNumber(list, listType);
	      result = '\n\n<' + listType + style + '>\n' + processListItems(list, !!trimTrailing) + '</' + listType + '>\n';
	    }

	    return result;
	  }

	  /** Start of list parsing **/
	  text = globals.converter._dispatch('lists.before', text, options, globals);
	  // add sentinel to hack around khtml/safari bug:
	  // http://bugs.webkit.org/show_bug.cgi?id=11231
	  text += '¨0';

	  if (globals.gListLevel) {
	    text = text.replace(/^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
	      function (wholeMatch, list, m2) {
	        var listType = (m2.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
	        return parseConsecutiveLists(list, listType, true);
	      }
	    );
	  } else {
	    text = text.replace(/(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
	      function (wholeMatch, m1, list, m3) {
	        var listType = (m3.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
	        return parseConsecutiveLists(list, listType, false);
	      }
	    );
	  }

	  // strip sentinel
	  text = text.replace(/¨0/, '');
	  text = globals.converter._dispatch('lists.after', text, options, globals);
	  return text;
	});

	/**
	 * Parse metadata at the top of the document
	 */
	showdown.subParser('metadata', function (text, options, globals) {
	  'use strict';

	  if (!options.metadata) {
	    return text;
	  }

	  text = globals.converter._dispatch('metadata.before', text, options, globals);

	  function parseMetadataContents (content) {
	    // raw is raw so it's not changed in any way
	    globals.metadata.raw = content;

	    // escape chars forbidden in html attributes
	    // double quotes
	    content = content
	      // ampersand first
	      .replace(/&/g, '&amp;')
	      // double quotes
	      .replace(/"/g, '&quot;');

	    content = content.replace(/\n {4}/g, ' ');
	    content.replace(/^([\S ]+): +([\s\S]+?)$/gm, function (wm, key, value) {
	      globals.metadata.parsed[key] = value;
	      return '';
	    });
	  }

	  text = text.replace(/^\s*«««+(\S*?)\n([\s\S]+?)\n»»»+\n/, function (wholematch, format, content) {
	    parseMetadataContents(content);
	    return '¨M';
	  });

	  text = text.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function (wholematch, format, content) {
	    if (format) {
	      globals.metadata.format = format;
	    }
	    parseMetadataContents(content);
	    return '¨M';
	  });

	  text = text.replace(/¨M/g, '');

	  text = globals.converter._dispatch('metadata.after', text, options, globals);
	  return text;
	});

	/**
	 * Remove one level of line-leading tabs or spaces
	 */
	showdown.subParser('outdent', function (text, options, globals) {
	  'use strict';
	  text = globals.converter._dispatch('outdent.before', text, options, globals);

	  // attacklab: hack around Konqueror 3.5.4 bug:
	  // "----------bug".replace(/^-/g,"") == "bug"
	  text = text.replace(/^(\t|[ ]{1,4})/gm, '¨0'); // attacklab: g_tab_width

	  // attacklab: clean up hack
	  text = text.replace(/¨0/g, '');

	  text = globals.converter._dispatch('outdent.after', text, options, globals);
	  return text;
	});

	/**
	 *
	 */
	showdown.subParser('paragraphs', function (text, options, globals) {
	  'use strict';

	  text = globals.converter._dispatch('paragraphs.before', text, options, globals);
	  // Strip leading and trailing lines:
	  text = text.replace(/^\n+/g, '');
	  text = text.replace(/\n+$/g, '');

	  var grafs = text.split(/\n{2,}/g),
	      grafsOut = [],
	      end = grafs.length; // Wrap <p> tags

	  for (var i = 0; i < end; i++) {
	    var str = grafs[i];
	    // if this is an HTML marker, copy it
	    if (str.search(/¨(K|G)(\d+)\1/g) >= 0) {
	      grafsOut.push(str);

	    // test for presence of characters to prevent empty lines being parsed
	    // as paragraphs (resulting in undesired extra empty paragraphs)
	    } else if (str.search(/\S/) >= 0) {
	      str = showdown.subParser('spanGamut')(str, options, globals);
	      str = str.replace(/^([ \t]*)/g, '<p>');
	      str += '</p>';
	      grafsOut.push(str);
	    }
	  }

	  /** Unhashify HTML blocks */
	  end = grafsOut.length;
	  for (i = 0; i < end; i++) {
	    var blockText = '',
	        grafsOutIt = grafsOut[i],
	        codeFlag = false;
	    // if this is a marker for an html block...
	    // use RegExp.test instead of string.search because of QML bug
	    while (/¨(K|G)(\d+)\1/.test(grafsOutIt)) {
	      var delim = RegExp.$1,
	          num   = RegExp.$2;

	      if (delim === 'K') {
	        blockText = globals.gHtmlBlocks[num];
	      } else {
	        // we need to check if ghBlock is a false positive
	        if (codeFlag) {
	          // use encoded version of all text
	          blockText = showdown.subParser('encodeCode')(globals.ghCodeBlocks[num].text, options, globals);
	        } else {
	          blockText = globals.ghCodeBlocks[num].codeblock;
	        }
	      }
	      blockText = blockText.replace(/\$/g, '$$$$'); // Escape any dollar signs

	      grafsOutIt = grafsOutIt.replace(/(\n\n)?¨(K|G)\d+\2(\n\n)?/, blockText);
	      // Check if grafsOutIt is a pre->code
	      if (/^<pre\b[^>]*>\s*<code\b[^>]*>/.test(grafsOutIt)) {
	        codeFlag = true;
	      }
	    }
	    grafsOut[i] = grafsOutIt;
	  }
	  text = grafsOut.join('\n');
	  // Strip leading and trailing lines:
	  text = text.replace(/^\n+/g, '');
	  text = text.replace(/\n+$/g, '');
	  return globals.converter._dispatch('paragraphs.after', text, options, globals);
	});

	/**
	 * Run extension
	 */
	showdown.subParser('runExtension', function (ext, text, options, globals) {
	  'use strict';

	  if (ext.filter) {
	    text = ext.filter(text, globals.converter, options);

	  } else if (ext.regex) {
	    // TODO remove this when old extension loading mechanism is deprecated
	    var re = ext.regex;
	    if (!(re instanceof RegExp)) {
	      re = new RegExp(re, 'g');
	    }
	    text = text.replace(re, ext.replace);
	  }

	  return text;
	});

	/**
	 * These are all the transformations that occur *within* block-level
	 * tags like paragraphs, headers, and list items.
	 */
	showdown.subParser('spanGamut', function (text, options, globals) {
	  'use strict';

	  text = globals.converter._dispatch('spanGamut.before', text, options, globals);
	  text = showdown.subParser('codeSpans')(text, options, globals);
	  text = showdown.subParser('escapeSpecialCharsWithinTagAttributes')(text, options, globals);
	  text = showdown.subParser('encodeBackslashEscapes')(text, options, globals);

	  // Process anchor and image tags. Images must come first,
	  // because ![foo][f] looks like an anchor.
	  text = showdown.subParser('images')(text, options, globals);
	  text = showdown.subParser('anchors')(text, options, globals);

	  // Make links out of things like `<http://example.com/>`
	  // Must come after anchors, because you can use < and >
	  // delimiters in inline links like [this](<url>).
	  text = showdown.subParser('autoLinks')(text, options, globals);
	  text = showdown.subParser('simplifiedAutoLinks')(text, options, globals);
	  text = showdown.subParser('emoji')(text, options, globals);
	  text = showdown.subParser('underline')(text, options, globals);
	  text = showdown.subParser('italicsAndBold')(text, options, globals);
	  text = showdown.subParser('strikethrough')(text, options, globals);
	  text = showdown.subParser('ellipsis')(text, options, globals);

	  // we need to hash HTML tags inside spans
	  text = showdown.subParser('hashHTMLSpans')(text, options, globals);

	  // now we encode amps and angles
	  text = showdown.subParser('encodeAmpsAndAngles')(text, options, globals);

	  // Do hard breaks
	  if (options.simpleLineBreaks) {
	    // GFM style hard breaks
	    // only add line breaks if the text does not contain a block (special case for lists)
	    if (!/\n\n¨K/.test(text)) {
	      text = text.replace(/\n+/g, '<br />\n');
	    }
	  } else {
	    // Vanilla hard breaks
	    text = text.replace(/  +\n/g, '<br />\n');
	  }

	  text = globals.converter._dispatch('spanGamut.after', text, options, globals);
	  return text;
	});

	showdown.subParser('strikethrough', function (text, options, globals) {
	  'use strict';

	  function parseInside (txt) {
	    if (options.simplifiedAutoLink) {
	      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
	    }
	    return '<del>' + txt + '</del>';
	  }

	  if (options.strikethrough) {
	    text = globals.converter._dispatch('strikethrough.before', text, options, globals);
	    text = text.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function (wm, txt) { return parseInside(txt); });
	    text = globals.converter._dispatch('strikethrough.after', text, options, globals);
	  }

	  return text;
	});

	/**
	 * Strips link definitions from text, stores the URLs and titles in
	 * hash references.
	 * Link defs are in the form: ^[id]: url "optional title"
	 */
	showdown.subParser('stripLinkDefinitions', function (text, options, globals) {
	  'use strict';

	  var regex       = /^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=¨0))/gm,
	      base64Regex = /^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=¨0)|(?=\n\[))/gm;

	  // attacklab: sentinel workarounds for lack of \A and \Z, safari\khtml bug
	  text += '¨0';

	  var replaceFunc = function (wholeMatch, linkId, url, width, height, blankLines, title) {

	    // if there aren't two instances of linkId it must not be a reference link so back out
	    linkId = linkId.toLowerCase();
	    if (text.toLowerCase().split(linkId).length - 1 < 2) {
	      return wholeMatch;
	    }
	    if (url.match(/^data:.+?\/.+?;base64,/)) {
	      // remove newlines
	      globals.gUrls[linkId] = url.replace(/\s/g, '');
	    } else {
	      globals.gUrls[linkId] = showdown.subParser('encodeAmpsAndAngles')(url, options, globals);  // Link IDs are case-insensitive
	    }

	    if (blankLines) {
	      // Oops, found blank lines, so it's not a title.
	      // Put back the parenthetical statement we stole.
	      return blankLines + title;

	    } else {
	      if (title) {
	        globals.gTitles[linkId] = title.replace(/"|'/g, '&quot;');
	      }
	      if (options.parseImgDimensions && width && height) {
	        globals.gDimensions[linkId] = {
	          width:  width,
	          height: height
	        };
	      }
	    }
	    // Completely remove the definition from the text
	    return '';
	  };

	  // first we try to find base64 link references
	  text = text.replace(base64Regex, replaceFunc);

	  text = text.replace(regex, replaceFunc);

	  // attacklab: strip sentinel
	  text = text.replace(/¨0/, '');

	  return text;
	});

	showdown.subParser('tables', function (text, options, globals) {
	  'use strict';

	  if (!options.tables) {
	    return text;
	  }

	  var tableRgx       = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|¨0)/gm,
	      //singeColTblRgx = /^ {0,3}\|.+\|\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n(?: {0,3}\|.+\|\n)+(?:\n\n|¨0)/gm;
	      singeColTblRgx = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|¨0)/gm;

	  function parseStyles (sLine) {
	    if (/^:[ \t]*--*$/.test(sLine)) {
	      return ' style="text-align:left;"';
	    } else if (/^--*[ \t]*:[ \t]*$/.test(sLine)) {
	      return ' style="text-align:right;"';
	    } else if (/^:[ \t]*--*[ \t]*:$/.test(sLine)) {
	      return ' style="text-align:center;"';
	    } else {
	      return '';
	    }
	  }

	  function parseHeaders (header, style) {
	    var id = '';
	    header = header.trim();
	    // support both tablesHeaderId and tableHeaderId due to error in documentation so we don't break backwards compatibility
	    if (options.tablesHeaderId || options.tableHeaderId) {
	      id = ' id="' + header.replace(/ /g, '_').toLowerCase() + '"';
	    }
	    header = showdown.subParser('spanGamut')(header, options, globals);

	    return '<th' + id + style + '>' + header + '</th>\n';
	  }

	  function parseCells (cell, style) {
	    var subText = showdown.subParser('spanGamut')(cell, options, globals);
	    return '<td' + style + '>' + subText + '</td>\n';
	  }

	  function buildTable (headers, cells) {
	    var tb = '<table>\n<thead>\n<tr>\n',
	        tblLgn = headers.length;

	    for (var i = 0; i < tblLgn; ++i) {
	      tb += headers[i];
	    }
	    tb += '</tr>\n</thead>\n<tbody>\n';

	    for (i = 0; i < cells.length; ++i) {
	      tb += '<tr>\n';
	      for (var ii = 0; ii < tblLgn; ++ii) {
	        tb += cells[i][ii];
	      }
	      tb += '</tr>\n';
	    }
	    tb += '</tbody>\n</table>\n';
	    return tb;
	  }

	  function parseTable (rawTable) {
	    var i, tableLines = rawTable.split('\n');

	    for (i = 0; i < tableLines.length; ++i) {
	      // strip wrong first and last column if wrapped tables are used
	      if (/^ {0,3}\|/.test(tableLines[i])) {
	        tableLines[i] = tableLines[i].replace(/^ {0,3}\|/, '');
	      }
	      if (/\|[ \t]*$/.test(tableLines[i])) {
	        tableLines[i] = tableLines[i].replace(/\|[ \t]*$/, '');
	      }
	      // parse code spans first, but we only support one line code spans
	      tableLines[i] = showdown.subParser('codeSpans')(tableLines[i], options, globals);
	    }

	    var rawHeaders = tableLines[0].split('|').map(function (s) { return s.trim();}),
	        rawStyles = tableLines[1].split('|').map(function (s) { return s.trim();}),
	        rawCells = [],
	        headers = [],
	        styles = [],
	        cells = [];

	    tableLines.shift();
	    tableLines.shift();

	    for (i = 0; i < tableLines.length; ++i) {
	      if (tableLines[i].trim() === '') {
	        continue;
	      }
	      rawCells.push(
	        tableLines[i]
	          .split('|')
	          .map(function (s) {
	            return s.trim();
	          })
	      );
	    }

	    if (rawHeaders.length < rawStyles.length) {
	      return rawTable;
	    }

	    for (i = 0; i < rawStyles.length; ++i) {
	      styles.push(parseStyles(rawStyles[i]));
	    }

	    for (i = 0; i < rawHeaders.length; ++i) {
	      if (showdown.helper.isUndefined(styles[i])) {
	        styles[i] = '';
	      }
	      headers.push(parseHeaders(rawHeaders[i], styles[i]));
	    }

	    for (i = 0; i < rawCells.length; ++i) {
	      var row = [];
	      for (var ii = 0; ii < headers.length; ++ii) {
	        if (showdown.helper.isUndefined(rawCells[i][ii])) {

	        }
	        row.push(parseCells(rawCells[i][ii], styles[ii]));
	      }
	      cells.push(row);
	    }

	    return buildTable(headers, cells);
	  }

	  text = globals.converter._dispatch('tables.before', text, options, globals);

	  // find escaped pipe characters
	  text = text.replace(/\\(\|)/g, showdown.helper.escapeCharactersCallback);

	  // parse multi column tables
	  text = text.replace(tableRgx, parseTable);

	  // parse one column tables
	  text = text.replace(singeColTblRgx, parseTable);

	  text = globals.converter._dispatch('tables.after', text, options, globals);

	  return text;
	});

	showdown.subParser('underline', function (text, options, globals) {
	  'use strict';

	  if (!options.underline) {
	    return text;
	  }

	  text = globals.converter._dispatch('underline.before', text, options, globals);

	  if (options.literalMidWordUnderscores) {
	    text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
	      return '<u>' + txt + '</u>';
	    });
	    text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
	      return '<u>' + txt + '</u>';
	    });
	  } else {
	    text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
	      return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
	    });
	    text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
	      return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
	    });
	  }

	  // escape remaining underscores to prevent them being parsed by italic and bold
	  text = text.replace(/(_)/g, showdown.helper.escapeCharactersCallback);

	  text = globals.converter._dispatch('underline.after', text, options, globals);

	  return text;
	});

	/**
	 * Swap back in all the special characters we've hidden.
	 */
	showdown.subParser('unescapeSpecialChars', function (text, options, globals) {
	  'use strict';
	  text = globals.converter._dispatch('unescapeSpecialChars.before', text, options, globals);

	  text = text.replace(/¨E(\d+)E/g, function (wholeMatch, m1) {
	    var charCodeToReplace = parseInt(m1);
	    return String.fromCharCode(charCodeToReplace);
	  });

	  text = globals.converter._dispatch('unescapeSpecialChars.after', text, options, globals);
	  return text;
	});

	showdown.subParser('makeMarkdown.blockquote', function (node, globals) {
	  'use strict';

	  var txt = '';
	  if (node.hasChildNodes()) {
	    var children = node.childNodes,
	        childrenLength = children.length;

	    for (var i = 0; i < childrenLength; ++i) {
	      var innerTxt = showdown.subParser('makeMarkdown.node')(children[i], globals);

	      if (innerTxt === '') {
	        continue;
	      }
	      txt += innerTxt;
	    }
	  }
	  // cleanup
	  txt = txt.trim();
	  txt = '> ' + txt.split('\n').join('\n> ');
	  return txt;
	});

	showdown.subParser('makeMarkdown.codeBlock', function (node, globals) {
	  'use strict';

	  var lang = node.getAttribute('language'),
	      num  = node.getAttribute('precodenum');
	  return '```' + lang + '\n' + globals.preList[num] + '\n```';
	});

	showdown.subParser('makeMarkdown.codeSpan', function (node) {
	  'use strict';

	  return '`' + node.innerHTML + '`';
	});

	showdown.subParser('makeMarkdown.emphasis', function (node, globals) {
	  'use strict';

	  var txt = '';
	  if (node.hasChildNodes()) {
	    txt += '*';
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '*';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.header', function (node, globals, headerLevel) {
	  'use strict';

	  var headerMark = new Array(headerLevel + 1).join('#'),
	      txt = '';

	  if (node.hasChildNodes()) {
	    txt = headerMark + ' ';
	    var children = node.childNodes,
	        childrenLength = children.length;

	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.hr', function () {
	  'use strict';

	  return '---';
	});

	showdown.subParser('makeMarkdown.image', function (node) {
	  'use strict';

	  var txt = '';
	  if (node.hasAttribute('src')) {
	    txt += '![' + node.getAttribute('alt') + '](';
	    txt += '<' + node.getAttribute('src') + '>';
	    if (node.hasAttribute('width') && node.hasAttribute('height')) {
	      txt += ' =' + node.getAttribute('width') + 'x' + node.getAttribute('height');
	    }

	    if (node.hasAttribute('title')) {
	      txt += ' "' + node.getAttribute('title') + '"';
	    }
	    txt += ')';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.links', function (node, globals) {
	  'use strict';

	  var txt = '';
	  if (node.hasChildNodes() && node.hasAttribute('href')) {
	    var children = node.childNodes,
	        childrenLength = children.length;
	    txt = '[';
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '](';
	    txt += '<' + node.getAttribute('href') + '>';
	    if (node.hasAttribute('title')) {
	      txt += ' "' + node.getAttribute('title') + '"';
	    }
	    txt += ')';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.list', function (node, globals, type) {
	  'use strict';

	  var txt = '';
	  if (!node.hasChildNodes()) {
	    return '';
	  }
	  var listItems       = node.childNodes,
	      listItemsLenght = listItems.length,
	      listNum = node.getAttribute('start') || 1;

	  for (var i = 0; i < listItemsLenght; ++i) {
	    if (typeof listItems[i].tagName === 'undefined' || listItems[i].tagName.toLowerCase() !== 'li') {
	      continue;
	    }

	    // define the bullet to use in list
	    var bullet = '';
	    if (type === 'ol') {
	      bullet = listNum.toString() + '. ';
	    } else {
	      bullet = '- ';
	    }

	    // parse list item
	    txt += bullet + showdown.subParser('makeMarkdown.listItem')(listItems[i], globals);
	    ++listNum;
	  }

	  // add comment at the end to prevent consecutive lists to be parsed as one
	  txt += '\n<!-- -->\n';
	  return txt.trim();
	});

	showdown.subParser('makeMarkdown.listItem', function (node, globals) {
	  'use strict';

	  var listItemTxt = '';

	  var children = node.childNodes,
	      childrenLenght = children.length;

	  for (var i = 0; i < childrenLenght; ++i) {
	    listItemTxt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	  }
	  // if it's only one liner, we need to add a newline at the end
	  if (!/\n$/.test(listItemTxt)) {
	    listItemTxt += '\n';
	  } else {
	    // it's multiparagraph, so we need to indent
	    listItemTxt = listItemTxt
	      .split('\n')
	      .join('\n    ')
	      .replace(/^ {4}$/gm, '')
	      .replace(/\n\n+/g, '\n\n');
	  }

	  return listItemTxt;
	});



	showdown.subParser('makeMarkdown.node', function (node, globals, spansOnly) {
	  'use strict';

	  spansOnly = spansOnly || false;

	  var txt = '';

	  // edge case of text without wrapper paragraph
	  if (node.nodeType === 3) {
	    return showdown.subParser('makeMarkdown.txt')(node, globals);
	  }

	  // HTML comment
	  if (node.nodeType === 8) {
	    return '<!--' + node.data + '-->\n\n';
	  }

	  // process only node elements
	  if (node.nodeType !== 1) {
	    return '';
	  }

	  var tagName = node.tagName.toLowerCase();

	  switch (tagName) {

	    //
	    // BLOCKS
	    //
	    case 'h1':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 1) + '\n\n'; }
	      break;
	    case 'h2':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 2) + '\n\n'; }
	      break;
	    case 'h3':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 3) + '\n\n'; }
	      break;
	    case 'h4':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 4) + '\n\n'; }
	      break;
	    case 'h5':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 5) + '\n\n'; }
	      break;
	    case 'h6':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 6) + '\n\n'; }
	      break;

	    case 'p':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.paragraph')(node, globals) + '\n\n'; }
	      break;

	    case 'blockquote':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.blockquote')(node, globals) + '\n\n'; }
	      break;

	    case 'hr':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.hr')(node, globals) + '\n\n'; }
	      break;

	    case 'ol':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ol') + '\n\n'; }
	      break;

	    case 'ul':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ul') + '\n\n'; }
	      break;

	    case 'precode':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.codeBlock')(node, globals) + '\n\n'; }
	      break;

	    case 'pre':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.pre')(node, globals) + '\n\n'; }
	      break;

	    case 'table':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.table')(node, globals) + '\n\n'; }
	      break;

	    //
	    // SPANS
	    //
	    case 'code':
	      txt = showdown.subParser('makeMarkdown.codeSpan')(node, globals);
	      break;

	    case 'em':
	    case 'i':
	      txt = showdown.subParser('makeMarkdown.emphasis')(node, globals);
	      break;

	    case 'strong':
	    case 'b':
	      txt = showdown.subParser('makeMarkdown.strong')(node, globals);
	      break;

	    case 'del':
	      txt = showdown.subParser('makeMarkdown.strikethrough')(node, globals);
	      break;

	    case 'a':
	      txt = showdown.subParser('makeMarkdown.links')(node, globals);
	      break;

	    case 'img':
	      txt = showdown.subParser('makeMarkdown.image')(node, globals);
	      break;

	    default:
	      txt = node.outerHTML + '\n\n';
	  }

	  // common normalization
	  // TODO eventually

	  return txt;
	});

	showdown.subParser('makeMarkdown.paragraph', function (node, globals) {
	  'use strict';

	  var txt = '';
	  if (node.hasChildNodes()) {
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	  }

	  // some text normalization
	  txt = txt.trim();

	  return txt;
	});

	showdown.subParser('makeMarkdown.pre', function (node, globals) {
	  'use strict';

	  var num  = node.getAttribute('prenum');
	  return '<pre>' + globals.preList[num] + '</pre>';
	});

	showdown.subParser('makeMarkdown.strikethrough', function (node, globals) {
	  'use strict';

	  var txt = '';
	  if (node.hasChildNodes()) {
	    txt += '~~';
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '~~';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.strong', function (node, globals) {
	  'use strict';

	  var txt = '';
	  if (node.hasChildNodes()) {
	    txt += '**';
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '**';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.table', function (node, globals) {
	  'use strict';

	  var txt = '',
	      tableArray = [[], []],
	      headings   = node.querySelectorAll('thead>tr>th'),
	      rows       = node.querySelectorAll('tbody>tr'),
	      i, ii;
	  for (i = 0; i < headings.length; ++i) {
	    var headContent = showdown.subParser('makeMarkdown.tableCell')(headings[i], globals),
	        allign = '---';

	    if (headings[i].hasAttribute('style')) {
	      var style = headings[i].getAttribute('style').toLowerCase().replace(/\s/g, '');
	      switch (style) {
	        case 'text-align:left;':
	          allign = ':---';
	          break;
	        case 'text-align:right;':
	          allign = '---:';
	          break;
	        case 'text-align:center;':
	          allign = ':---:';
	          break;
	      }
	    }
	    tableArray[0][i] = headContent.trim();
	    tableArray[1][i] = allign;
	  }

	  for (i = 0; i < rows.length; ++i) {
	    var r = tableArray.push([]) - 1,
	        cols = rows[i].getElementsByTagName('td');

	    for (ii = 0; ii < headings.length; ++ii) {
	      var cellContent = ' ';
	      if (typeof cols[ii] !== 'undefined') {
	        cellContent = showdown.subParser('makeMarkdown.tableCell')(cols[ii], globals);
	      }
	      tableArray[r].push(cellContent);
	    }
	  }

	  var cellSpacesCount = 3;
	  for (i = 0; i < tableArray.length; ++i) {
	    for (ii = 0; ii < tableArray[i].length; ++ii) {
	      var strLen = tableArray[i][ii].length;
	      if (strLen > cellSpacesCount) {
	        cellSpacesCount = strLen;
	      }
	    }
	  }

	  for (i = 0; i < tableArray.length; ++i) {
	    for (ii = 0; ii < tableArray[i].length; ++ii) {
	      if (i === 1) {
	        if (tableArray[i][ii].slice(-1) === ':') {
	          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii].slice(-1), cellSpacesCount - 1, '-') + ':';
	        } else {
	          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount, '-');
	        }
	      } else {
	        tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount);
	      }
	    }
	    txt += '| ' + tableArray[i].join(' | ') + ' |\n';
	  }

	  return txt.trim();
	});

	showdown.subParser('makeMarkdown.tableCell', function (node, globals) {
	  'use strict';

	  var txt = '';
	  if (!node.hasChildNodes()) {
	    return '';
	  }
	  var children = node.childNodes,
	      childrenLength = children.length;

	  for (var i = 0; i < childrenLength; ++i) {
	    txt += showdown.subParser('makeMarkdown.node')(children[i], globals, true);
	  }
	  return txt.trim();
	});

	showdown.subParser('makeMarkdown.txt', function (node) {
	  'use strict';

	  var txt = node.nodeValue;

	  // multiple spaces are collapsed
	  txt = txt.replace(/ +/g, ' ');

	  // replace the custom ¨NBSP; with a space
	  txt = txt.replace(/¨NBSP;/g, ' ');

	  // ", <, > and & should replace escaped html entities
	  txt = showdown.helper.unescapeHTMLEntities(txt);

	  // escape markdown magic characters
	  // emphasis, strong and strikethrough - can appear everywhere
	  // we also escape pipe (|) because of tables
	  // and escape ` because of code blocks and spans
	  txt = txt.replace(/([*_~|`])/g, '\\$1');

	  // escape > because of blockquotes
	  txt = txt.replace(/^(\s*)>/g, '\\$1>');

	  // hash character, only troublesome at the beginning of a line because of headers
	  txt = txt.replace(/^#/gm, '\\#');

	  // horizontal rules
	  txt = txt.replace(/^(\s*)([-=]{3,})(\s*)$/, '$1\\$2$3');

	  // dot, because of ordered lists, only troublesome at the beginning of a line when preceded by an integer
	  txt = txt.replace(/^( {0,3}\d+)\./gm, '$1\\.');

	  // +, * and -, at the beginning of a line becomes a list, so we need to escape them also (asterisk was already escaped)
	  txt = txt.replace(/^( {0,3})([+-])/gm, '$1\\$2');

	  // images and links, ] followed by ( is problematic, so we escape it
	  txt = txt.replace(/]([\s]*)\(/g, '\\]$1\\(');

	  // reference URIs must also be escaped
	  txt = txt.replace(/^ {0,3}\[([\S \t]*?)]:/gm, '\\[$1]:');

	  return txt;
	});

	var root = this;

	// AMD Loader
	if (typeof undefined === 'function' && undefined.amd) {
	  undefined(function () {
	    'use strict';
	    return showdown;
	  });

	// CommonJS/nodeJS Loader
	} else if ('object' !== 'undefined' && module.exports) {
	  module.exports = showdown;

	// Regular Browser loader
	} else {
	  root.showdown = showdown;
	}
	}).call(commonjsGlobal);

	
} (showdown$1));

var showdown = showdown$1.exports;

const DOMPurify = purify(window);

// Ensure that any links generated either by Showdown or in the markdown/HTML
// passed to Showdown open in an external window.
DOMPurify.addHook('afterSanitizeAttributes', node => {
  if ('target' in node) {
    node.setAttribute('target', '_blank');
  }
});
function targetBlank() {
  /** @param {string} text */
  function filter(text) {
    return text.replace(/<a href=/g, '<a target="_blank" href=');
  }
  return [{
    type: 'output',
    filter
  }];
}

/** @type {showdown.Converter} */
let converter;

/** @param {string} markdown */
function renderMarkdown(markdown) {
  if (!converter) {
    // see https://github.com/showdownjs/showdown#valid-options
    converter = new showdown.Converter({
      extensions: [targetBlank],
      simplifiedAutoLink: true,
      // Since we're using simplifiedAutoLink we also use
      // literalMidWordUnderscores because otherwise _'s in URLs get
      // transformed into <em>'s.
      // See https://github.com/showdownjs/showdown/issues/211
      literalMidWordUnderscores: true,
      // Enable strikethrough, which is disabled by default
      strikethrough: true
    });
  }
  return converter.makeHtml(markdown);
}

/** @param {number} id */
function mathPlaceholder(id) {
  return '{math:' + id.toString() + '}';
}

/**
 * @typedef MathBlock
 * @prop {number} id
 * @prop {boolean} inline
 * @prop {string} expression
 */

/**
 * Parses a string containing mixed markdown and LaTeX in between
 * '$$..$$' or '\( ... \)' delimiters and returns an object containing a
 * list of math blocks found in the string, plus the input string with math
 * blocks replaced by placeholders.
 *
 * @param {string} content
 * @return {{ content: string, mathBlocks: MathBlock[]}}
 */
function extractMath(content) {
  /** @type {MathBlock[]} */
  const mathBlocks = [];
  let pos = 0;
  let replacedContent = content;

  // eslint-disable-next-line no-constant-condition
  while (true) {
    const blockMathStart = replacedContent.indexOf('$$', pos);
    const inlineMathStart = replacedContent.indexOf('\\(', pos);
    if (blockMathStart === -1 && inlineMathStart === -1) {
      break;
    }
    let mathStart;
    let mathEnd;
    if (blockMathStart !== -1 && (inlineMathStart === -1 || blockMathStart < inlineMathStart)) {
      mathStart = blockMathStart;
      mathEnd = replacedContent.indexOf('$$', mathStart + 2);
    } else {
      mathStart = inlineMathStart;
      mathEnd = replacedContent.indexOf('\\)', mathStart + 2);
    }
    if (mathEnd === -1) {
      break;
    } else {
      mathEnd = mathEnd + 2;
    }
    const id = mathBlocks.length + 1;
    const placeholder = mathPlaceholder(id);
    mathBlocks.push({
      id,
      expression: replacedContent.slice(mathStart + 2, mathEnd - 2),
      inline: inlineMathStart !== -1
    });
    let replacement;
    if (inlineMathStart !== -1) {
      replacement = placeholder;
    } else {
      // Add new lines before and after math blocks so that they render
      // as separate paragraphs
      replacement = '\n\n' + placeholder + '\n\n';
    }
    replacedContent = replacedContent.slice(0, mathStart) + replacement + replacedContent.slice(mathEnd);
    pos = mathStart + replacement.length;
  }
  return {
    mathBlocks,
    content: replacedContent
  };
}

/**
 * @param {string} html
 * @param {MathBlock[]} mathBlocks
 */
function insertMath(html, mathBlocks) {
  return mathBlocks.reduce((html, block) => {
    let renderedMath;
    try {
      if (block.inline) {
        renderedMath = katex.renderToString(block.expression);
      } else {
        renderedMath = katex.renderToString(block.expression, {
          displayMode: true
        });
      }
    } catch (err) {
      renderedMath = escapeHtml_1(block.expression);
    }
    return html.replace(mathPlaceholder(block.id), renderedMath);
  }, html);
}

/**
 * @param {string} markdown
 */
function renderMathAndMarkdown(markdown) {
  // KaTeX takes care of escaping its input, so we want to avoid passing its
  // output through the HTML sanitizer. Therefore we first extract the math
  // blocks from the input, render and sanitize the remaining markdown and then
  // render and re-insert the math blocks back into the output.
  const mathInfo = extractMath(markdown);
  const markdownHTML = DOMPurify.sanitize(renderMarkdown(mathInfo.content));
  const mathAndMarkdownHTML = insertMath(markdownHTML, mathInfo.mathBlocks);
  return mathAndMarkdownHTML;
}

var _jsxFileName$X = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/StyledText.js";
function StyledText({
  children,
  classes,
  ...restProps
}) {
  // The language for the quote may be different than the client's UI (set by
  // `<html lang="...">`).
  //
  // Use a blank string to indicate that it is unknown and it is up to the user
  // agent to pick a default or analyze the content and guess.
  //
  // For web documents we could do better here and gather language information
  // as part of the annotation anchoring process.
  const documentLanguage = '';
  return o("div", {
    dir: "auto",
    lang: documentLanguage,
    className: classnames('StyledText', classes),
    ...restProps,
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$X,
    lineNumber: 26,
    columnNumber: 5
  }, this);
}

var _jsxFileName$W = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/MarkdownView.js";
function MarkdownView({
  markdown,
  classes,
  style
}) {
  const html = F(() => markdown ? renderMathAndMarkdown(markdown) : '', [markdown]);
  const content = /** @type {{ current: HTMLDivElement }} */_$1();
  h(() => {
    replaceLinksWithEmbeds(content.current, {
      // Make embeds the full width of the sidebar, unless the sidebar has been
      // made wider than the `md` breakpoint. In that case, restrict width
      // to 380px.
      className: 'w-full md:w-[380px]'
    });
  }, [markdown]);

  // NB: The following could be implemented by setting attribute props directly
  // on `StyledText` (which renders a `div` itself), versus introducing a child
  // `div` as is done here. However, in initial testing, this interfered with
  // some overflow calculations in the `Excerpt` element. This could be worth
  // a review in the future.
  return o("div", {
    className: "w-full break-words cursor-text",
    children: o(StyledText, {
      children: o("div", {
        className: classes,
        "data-testid": "markdown-text",
        ref: content,
        dangerouslySetInnerHTML: {
          __html: html
        },
        style: style
      }, void 0, false, {
        fileName: _jsxFileName$W,
        lineNumber: 46,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$W,
      lineNumber: 45,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$W,
    lineNumber: 44,
    columnNumber: 5
  }, this);
}

var _jsxFileName$V = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/TagList.js";
/**
 * @typedef TagListProps
 * @prop {import("preact").ComponentChildren} children
 */

/**
 * Render a list container for a list of annotation tags.
 *
 * @param {TagListProps} props
 */
function TagList({
  children
}) {
  return o("ul", {
    className: "flex flex-wrap gap-2 leading-none",
    "aria-label": "Annotation tags",
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$V,
    lineNumber: 13,
    columnNumber: 5
  }, this);
}

var _jsxFileName$U = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/TagListItem.js";
function TagListItem({
  href,
  onRemoveTag,
  tag
}) {
  return o("li", {
    className: "flex items-center border rounded-sm bg-grey-0",
    children: [o("div", {
      className: "grow px-1.5 py-1 touch:p-2",
      children: href ? o(Link, {
        classes: "text-color-text-light hover:text-brand",
        href: href,
        lang: "",
        target: "_blank",
        "aria-label": `Tag: ${tag}`,
        title: `View annotations with tag: ${tag}`,
        children: tag
      }, void 0, false, {
        fileName: _jsxFileName$U,
        lineNumber: 22,
        columnNumber: 11
      }, this) : o("span", {
        className: "text-color-text-light cursor-default",
        "aria-label": `Tag: ${tag}`,
        lang: "",
        children: tag
      }, void 0, false, {
        fileName: _jsxFileName$U,
        lineNumber: 33,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$U,
      lineNumber: 20,
      columnNumber: 7
    }, this), onRemoveTag && o("button", {
      className: classnames(
      // More padding for mobile users to make touch target larger
      'px-1.5 py-1 touch:p-2',
      // Rounded border to match container edges and make keyboard focus
      // ring shape conform. Turn off left side
      // border radius to maintain a straight dividing line
      'border-l rounded-sm rounded-l-none', 'text-grey-6 hover:text-color-text hover:bg-grey-2',
      // Emulates transitions on *Button shared component styling
      'transition-colors duration-200', 'focus-visible-ring ring-inset'),
      onClick: () => {
        onRemoveTag(tag);
      },
      title: `Remove tag: ${tag}`,
      children: o(Icon, {
        classes: "font-base",
        name: "cancel",
        title: `Remove ${tag}`
      }, void 0, false, {
        fileName: _jsxFileName$U,
        lineNumber: 61,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$U,
      lineNumber: 43,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$U,
    lineNumber: 19,
    columnNumber: 5
  }, this);
}

var _jsxFileName$T = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/AnnotationBody.tsx";
/**
 * Button to expand or collapse the annotation excerpt (content)
 */
function ToggleExcerptButton({
  classes,
  setCollapsed,
  collapsed
}) {
  const toggleText = collapsed ? 'More' : 'Less';
  return o(ButtonNext, {
    classes: classnames('text-grey-7 font-normal', classes),
    expanded: !collapsed,
    onClick: () => setCollapsed(!collapsed),
    title: `Toggle visibility of full annotation text: Show ${toggleText}`,
    children: o("div", {
      className: "flex items-center gap-x-2",
      children: [collapsed ? o(ExpandIcon, {
        className: "w-3 h-3"
      }, void 0, false, {
        fileName: _jsxFileName$T,
        lineNumber: 47,
        columnNumber: 11
      }, this) : o(CollapseIcon, {
        className: "w-3 h-3"
      }, void 0, false, {
        fileName: _jsxFileName$T,
        lineNumber: 49,
        columnNumber: 11
      }, this), o("div", {
        children: toggleText
      }, void 0, false, {
        fileName: _jsxFileName$T,
        lineNumber: 51,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$T,
      lineNumber: 45,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$T,
    lineNumber: 39,
    columnNumber: 5
  }, this);
}
/**
 * Display the rendered content of an annotation.
 */
function AnnotationBody({
  annotation,
  settings
}) {
  var _draft$tags, _draft$text;
  // Should the text content of `Excerpt` be rendered in a collapsed state,
  // assuming it is collapsible (exceeds allotted collapsed space)?
  const [collapsed, setCollapsed] = p(true);

  // Does the text content of `Excerpt` take up enough vertical space that
  // collapsing/expanding is relevant?
  const [collapsible, setCollapsible] = p(false);
  const store = useSidebarStore();
  const defaultAuthority = store.defaultAuthority();
  const draft = store.getDraft(annotation);

  // If there is a draft use the tag and text from it.
  const tags = (_draft$tags = draft === null || draft === void 0 ? void 0 : draft.tags) !== null && _draft$tags !== void 0 ? _draft$tags : annotation.tags;
  const text = (_draft$text = draft === null || draft === void 0 ? void 0 : draft.text) !== null && _draft$text !== void 0 ? _draft$text : annotation.text;
  const showExcerpt = text.length > 0;
  const showTagList = tags.length > 0;
  const textStyle = applyTheme(['annotationFontFamily'], settings);
  const shouldLinkTags = F(() => annotation && !isThirdPartyUser(annotation === null || annotation === void 0 ? void 0 : annotation.user, defaultAuthority), [annotation, defaultAuthority]);
  const createTagSearchURL = tag => {
    return store.getLink('search.tag', {
      tag
    });
  };
  return o("div", {
    className: "space-y-4",
    children: [showExcerpt && o(Excerpt$1, {
      collapse: collapsed,
      collapsedHeight: 400,
      inlineControls: false,
      onCollapsibleChanged: setCollapsible,
      onToggleCollapsed: setCollapsed,
      overflowThreshold: 20,
      children: o(MarkdownView, {
        markdown: text,
        classes: classnames({
          'p-redacted-text': isHidden(annotation)
        }),
        style: textStyle
      }, void 0, false, {
        fileName: _jsxFileName$T,
        lineNumber: 108,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$T,
      lineNumber: 100,
      columnNumber: 9
    }, this), (collapsible || showTagList) && o("div", {
      className: "flex flex-row gap-x-2",
      children: [o("div", {
        className: "grow",
        children: showTagList && o(TagList, {
          children: tags.map(tag => {
            return o(TagListItem, {
              tag: tag,
              href: shouldLinkTags ? createTagSearchURL(tag) : undefined
            }, tag, false, {
              fileName: _jsxFileName$T,
              lineNumber: 124,
              columnNumber: 21
            }, this);
          })
        }, void 0, false, {
          fileName: _jsxFileName$T,
          lineNumber: 121,
          columnNumber: 15
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$T,
        lineNumber: 119,
        columnNumber: 11
      }, this), collapsible && o("div", {
        children: o(ToggleExcerptButton, {
          classes: classnames(
          // Pull button up toward bottom of excerpt content
          '-mt-3'),
          collapsed: collapsed,
          setCollapsed: setCollapsed
        }, void 0, false, {
          fileName: _jsxFileName$T,
          lineNumber: 138,
          columnNumber: 15
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$T,
        lineNumber: 137,
        columnNumber: 13
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$T,
      lineNumber: 118,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$T,
    lineNumber: 98,
    columnNumber: 5
  }, this);
}
var AnnotationBody$1 = withServices(AnnotationBody, ['settings']);

/**
 * Commands for toggling markdown formatting of a selection
 * in an input field.
 *
 * All of the functions in this module take as input the current state
 * of the input field, parameters for the operation to perform and return the
 * new state of the input field.
 */

/**
 * Describes the state of a plain text input field.
 *
 * @typedef EditorState
 * @prop {string} text
 * @prop {number} selectionStart
 * @prop {number} selectionEnd
 */

/**
 * Types of Markdown link that can be inserted with
 * convertSelectionToLink()
 *
 * @enum {number}
 */
const LinkType = {
  ANCHOR_LINK: 0,
  IMAGE_LINK: 1
};

/**
 * Replace text in an input field and return the new state.
 *
 * @param {EditorState} state - The state of the input field.
 * @param {number} pos - The start position of the text to remove.
 * @param {number} length - The number of characters to remove.
 * @param {string} text - The replacement text to insert at `pos`.
 * @return {EditorState} - The new state of the input field.
 */
function replaceText(state, pos, length, text) {
  let newSelectionStart = state.selectionStart;
  let newSelectionEnd = state.selectionEnd;
  if (newSelectionStart >= pos + length) {
    // 1. Selection is after replaced text:
    //    Increment (start, end) by difference in length between original and
    //    replaced text
    newSelectionStart += text.length - length;
    newSelectionEnd += text.length - length;
  } else if (newSelectionEnd <= pos) {
    // 2. Selection is before replaced text: Leave selection unchanged
  } else if (newSelectionStart <= pos && newSelectionEnd >= pos + length) {
    // 3. Selection fully contains replaced text:
    //    Increment end by difference in length between original and replaced
    //    text
    newSelectionEnd += text.length - length;
  } else if (newSelectionStart < pos && newSelectionEnd < pos + length) {
    // 4. Selection overlaps start but not end of replaced text:
    //    Decrement start to start of replacement text
    newSelectionStart = pos;
  } else if (newSelectionStart < pos + length && newSelectionEnd > pos + length) {
    // 5. Selection overlaps end but not start of replaced text:
    //    Increment end by difference in length between original and replaced
    //    text
    newSelectionEnd += text.length - length;
  } else if (pos < newSelectionStart && pos + length > newSelectionEnd) {
    // 6. Replaced text fully contains selection:
    //    Expand selection to replaced text
    newSelectionStart = pos;
    newSelectionEnd = pos + length;
  }
  return {
    text: state.text.slice(0, pos) + text + state.text.slice(pos + length),
    selectionStart: newSelectionStart,
    selectionEnd: newSelectionEnd
  };
}

/**
 * Convert the selected text into a Markdown link.
 *
 * @param {EditorState} state - The current state of the input field.
 * @param {LinkType} [linkType] - The type of link to insert.
 * @return {EditorState} - The new state of the input field.
 */
function convertSelectionToLink(state, linkType = LinkType.ANCHOR_LINK) {
  const selection = state.text.slice(state.selectionStart, state.selectionEnd);
  let linkPrefix = '';
  if (linkType === LinkType.IMAGE_LINK) {
    linkPrefix = '!';
  }
  let newState;
  if (selection.match(/[a-z]+:\/\/.*/)) {
    // Selection is a URL, wrap it with a link and use the selection as
    // the target.
    const dummyLabel = 'Description';
    newState = replaceText(state, state.selectionStart, selection.length, linkPrefix + '[' + dummyLabel + '](' + selection + ')');
    newState.selectionStart = state.selectionStart + linkPrefix.length + 1;
    newState.selectionEnd = newState.selectionStart + dummyLabel.length;
    return newState;
  } else {
    // Selection is not a URL, wrap it with a link and use the selection as
    // the label. Change the selection to the dummy link.
    const beforeURL = linkPrefix + '[' + selection + '](';
    const dummyLink = 'http://insert-your-link-here.com';
    newState = replaceText(state, state.selectionStart, selection.length, beforeURL + dummyLink + ')');
    newState.selectionStart = state.selectionStart + beforeURL.length;
    newState.selectionEnd = newState.selectionStart + dummyLink.length;
    return newState;
  }
}

/**
 * Toggle Markdown-style formatting around a span of text.
 *
 * @param {EditorState} state - The current state of the input field.
 * @param {string} prefix - The prefix to add or remove
 *                          before the selection.
 * @param {string|undefined} suffix - The suffix to add or remove after the selection,
 *                           defaults to being the same as the prefix.
 * @param {string} placeholder - The text to insert between 'prefix' and
 *                               'suffix' if the input text is empty.
 * @return {EditorState} The new state of the input field.
 */
function toggleSpanStyle(state, prefix, suffix, placeholder) {
  if (typeof suffix === 'undefined') {
    suffix = prefix;
  }
  const selectionPrefix = state.text.slice(state.selectionStart - prefix.length, state.selectionStart);
  const selectionSuffix = state.text.slice(state.selectionEnd, state.selectionEnd + prefix.length);
  let newState = state;
  if (state.selectionStart === state.selectionEnd && placeholder) {
    newState = replaceText(state, state.selectionStart, 0, placeholder);
    newState.selectionStart = newState.selectionEnd - placeholder.length;
  }
  if (selectionPrefix === prefix && selectionSuffix === suffix) {
    newState = replaceText(newState, newState.selectionStart - prefix.length, prefix.length, '');
    newState = replaceText(newState, newState.selectionEnd, suffix.length, '');
  } else {
    newState = replaceText(newState, newState.selectionStart, 0, prefix);
    newState = replaceText(newState, newState.selectionEnd, 0, suffix);
  }
  return newState;
}

/**
 * Find the nearest line beginning searching backwards from `pos`.
 *
 * @param {string} str
 * @param {number} pos
 */
function startOfLine(str, pos) {
  const start = str.lastIndexOf('\n', pos);
  if (start < 0) {
    return 0;
  } else {
    return start + 1;
  }
}

/**
 * Find the nearest line ending searching forwards from `pos`.
 *
 * @param {string} str
 * @param {number} pos
 */
function endOfLine(str, pos) {
  const end = str.indexOf('\n', pos);
  if (end < 0) {
    return str.length;
  } else {
    return end;
  }
}

/**
 * Transform lines between two positions in an input field.
 *
 * @param {EditorState} state - The initial state of the input field
 * @param {number} start - The start position within the input text
 * @param {number} end - The end position within the input text
 * @param {(s: EditorState, start: number, end: number) => EditorState} callback
 *  - Callback which is invoked with the current state of the input and
 *    the start of the current line and returns the new state of the input.
 */
function transformLines(state, start, end, callback) {
  let lineStart = startOfLine(state.text, start);
  let lineEnd = endOfLine(state.text, start);
  while (lineEnd <= endOfLine(state.text, end)) {
    const isLastLine = lineEnd === state.text.length;
    const currentLineLength = lineEnd - lineStart;
    state = callback(state, lineStart, lineEnd);
    const newLineLength = endOfLine(state.text, lineStart) - lineStart;
    end += newLineLength - currentLineLength;
    if (isLastLine) {
      break;
    }
    lineStart = lineStart + newLineLength + 1;
    lineEnd = endOfLine(state.text, lineStart);
  }
  return state;
}

/**
 * Toggle Markdown-style formatting around a block of text.
 *
 * @param {EditorState} state - The current state of the input field.
 * @param {string} prefix - The prefix to add or remove before each line
 *                          of the selection.
 * @return {EditorState} - The new state of the input field.
 */
function toggleBlockStyle(state, prefix) {
  const start = state.selectionStart;
  const end = state.selectionEnd;

  // Test whether all lines in the selected range already have the style
  // applied
  let blockHasStyle = true;
  transformLines(state, start, end, (state, lineStart) => {
    if (state.text.slice(lineStart, lineStart + prefix.length) !== prefix) {
      blockHasStyle = false;
    }
    return state;
  });
  if (blockHasStyle) {
    // Remove the formatting.
    return transformLines(state, start, end, (state, lineStart) => {
      return replaceText(state, lineStart, prefix.length, '');
    });
  } else {
    // Add the block style to any lines which do not already have it applied
    return transformLines(state, start, end, (state, lineStart) => {
      if (state.text.slice(lineStart, lineStart + prefix.length) === prefix) {
        return state;
      } else {
        return replaceText(state, lineStart, 0, prefix);
      }
    });
  }
}

/**
 * @param {HTMLElement & { disabled?: boolean }} element
 */
function isElementDisabled(element) {
  return typeof element.disabled === 'boolean' && element.disabled;
}

/** @param {HTMLElement} element */
function isElementVisible$1(element) {
  return element.offsetParent !== null;
}

/**
 * Enable arrow key navigation between interactive descendants of a
 * container element.
 *
 * In addition to moving focus between elements when arrow keys are pressed,
 * this also implements the "roving tabindex" pattern [1] which sets the
 * `tabindex` attribute of elements to control which element gets focus when the
 * user tabs into the container.
 *
 * See [2] for a reference of how keyboard navigation should work in web
 * applications and how it applies to various common widgets.
 *
 * @example
 *   function MyToolbar() {
 *     const container = useRef();
 *
 *     // Enable arrow key navigation between interactive elements in the
 *     // toolbar container.
 *     useArrowKeyNavigation(container);
 *
 *     return (
 *       <div ref={container} role="toolbar">
 *         <button>Bold</bold>
 *         <button>Italic</bold>
 *         <a href="https://example.com/help">Help</a>
 *       </div>
 *     )
 *   }
 *
 * [1] https://www.w3.org/TR/wai-aria-practices/#kbd_roving_tabindex
 * [2] https://www.w3.org/TR/wai-aria-practices/#keyboard
 *
 * @param {import('preact').RefObject<HTMLElement>} containerRef
 * @param {object} options
 *   @param {boolean} [options.autofocus] - Whether to focus the first element
 *     in the set of matching elements when the component is mounted
 *   @param {boolean} [options.horizontal] - Enable navigating elements using left/right arrow keys
 *   @param {boolean} [options.vertical] - Enable navigating elements using up/down arrow keys
 *   @param {string} [options.selector] - CSS selector which specifies the
 *     elements that navigation moves between
 */
function useArrowKeyNavigation(containerRef, {
  autofocus = false,
  horizontal = true,
  vertical = true,
  selector = 'a,button'
} = {}) {
  h(() => {
    if (!containerRef.current) {
      throw new Error('Container ref not set');
    }
    const container = containerRef.current;
    const getNavigableElements = () => {
      const elements = /** @type {HTMLElement[]} */
      Array.from(container.querySelectorAll(selector));
      return elements.filter(el => isElementVisible$1(el) && !isElementDisabled(el));
    };

    /**
     * Update the `tabindex` attribute of navigable elements.
     *
     * Exactly one element will have `tabindex=0` and all others will have
     * `tabindex=1`.
     *
     * @param {HTMLElement[]} elements
     * @param {number} currentIndex - Index of element in `elements` to make current.
     *   Defaults to the current element if there is one, or the first element
     *   otherwise.
     * @param {boolean} setFocus - Whether to focus the current element
     */
    const updateTabIndexes = (elements = getNavigableElements(), currentIndex = -1, setFocus = false) => {
      if (currentIndex < 0) {
        currentIndex = elements.findIndex(el => el.tabIndex === 0);
        if (currentIndex < 0) {
          currentIndex = 0;
        }
      }
      for (let [index, element] of elements.entries()) {
        element.tabIndex = index === currentIndex ? 0 : -1;
        if (index === currentIndex && setFocus) {
          element.focus();
        }
      }
    };

    /** @param {KeyboardEvent} event */
    const onKeyDown = event => {
      const elements = getNavigableElements();
      let currentIndex = elements.findIndex(item => item.tabIndex === 0);
      let handled = false;
      if (horizontal && event.key === 'ArrowLeft' || vertical && event.key === 'ArrowUp') {
        if (currentIndex === 0) {
          currentIndex = elements.length - 1;
        } else {
          --currentIndex;
        }
        handled = true;
      } else if (horizontal && event.key === 'ArrowRight' || vertical && event.key === 'ArrowDown') {
        if (currentIndex === elements.length - 1) {
          currentIndex = 0;
        } else {
          ++currentIndex;
        }
        handled = true;
      } else if (event.key === 'Home') {
        currentIndex = 0;
        handled = true;
      } else if (event.key === 'End') {
        currentIndex = elements.length - 1;
        handled = true;
      }
      if (!handled) {
        return;
      }
      updateTabIndexes(elements, currentIndex, true);
      event.preventDefault();
      event.stopPropagation();
    };
    updateTabIndexes(getNavigableElements(), 0, autofocus);
    const listeners = new ListenerCollection$1();

    // Set an element as current when it gains focus. In Safari this event
    // may not be received if the element immediately loses focus after it
    // is triggered.
    listeners.add(container, 'focusin', event => {
      const elements = getNavigableElements();
      const targetIndex = elements.indexOf( /** @type {HTMLElement} */event.target);
      if (targetIndex >= 0) {
        updateTabIndexes(elements, targetIndex);
      }
    });
    listeners.add(container, 'keydown', /** @type {EventListener} */onKeyDown);

    // Update the tab indexes of elements as they are added, removed, enabled
    // or disabled.
    const mo = new MutationObserver(() => {
      updateTabIndexes();
    });
    mo.observe(container, {
      subtree: true,
      attributes: true,
      attributeFilter: ['disabled'],
      childList: true
    });
    return () => {
      listeners.removeAll();
      mo.disconnect();
    };
  }, [autofocus, containerRef, horizontal, selector, vertical]);
}

var _jsxFileName$S = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/MarkdownEditor.js";
const SHORTCUT_KEYS = {
  bold: 'b',
  image: 'g',
  italic: 'i',
  link: 'l',
  list: 'u',
  math: 'm',
  numlist: 'o',
  quote: 'q'
};

/**
 * Apply a toolbar command to an editor input field.
 *
 * @param {Command} command
 * @param {HTMLInputElement|HTMLTextAreaElement} inputEl
 */
function handleToolbarCommand(command, inputEl) {
  /** @param {(prevState: EditorState) => EditorState} newStateFn */
  const update = newStateFn => {
    // Apply the toolbar command to the current state of the input field.
    const newState = newStateFn({
      text: inputEl.value,
      selectionStart: /** @type {number} */inputEl.selectionStart,
      selectionEnd: /** @type {number} */inputEl.selectionEnd
    });

    // Update the input field to match the new state.
    inputEl.value = newState.text;
    inputEl.selectionStart = newState.selectionStart;
    inputEl.selectionEnd = newState.selectionEnd;

    // Restore input field focus which is lost when its contents are changed.
    inputEl.focus();
  };

  /** @param {EditorState} state */
  const insertMath = state => {
    const before = state.text.slice(0, state.selectionStart);
    if (before.length === 0 || before.slice(-1) === '\n' || before.slice(-2) === '$$') {
      return toggleSpanStyle(state, '$$', '$$', 'Insert LaTeX');
    } else {
      return toggleSpanStyle(state, '\\(', '\\)', 'Insert LaTeX');
    }
  };
  switch (command) {
    case 'bold':
      update(state => toggleSpanStyle(state, '**', '**', 'Bold'));
      break;
    case 'italic':
      update(state => toggleSpanStyle(state, '*', '*', 'Italic'));
      break;
    case 'quote':
      update(state => toggleBlockStyle(state, '> '));
      break;
    case 'link':
      update(state => convertSelectionToLink(state));
      break;
    case 'image':
      update(state => convertSelectionToLink(state, LinkType.IMAGE_LINK));
      break;
    case 'math':
      update(insertMath);
      break;
    case 'numlist':
      update(state => toggleBlockStyle(state, '1. '));
      break;
    case 'list':
      update(state => toggleBlockStyle(state, '* '));
      break;
    default:
      throw new Error(`Unknown toolbar command "${command}"`);
  }
}

/**
 * Style a Link to look like an IconButton, including touch sizing
 * affordances.
 *
 * @param {Omit<LinkProps, 'children'> & { icon: string }} props
 */
function IconLink({
  classes,
  icon,
  linkRef,
  ...restProps
}) {
  return o(Link, {
    classes: classnames('flex justify-center items-center', 'text-grey-7 hover:!text-grey-7', 'touch:h-touch-minimum touch:w-touch-minimum', classes),
    linkRef: linkRef,
    ...restProps,
    children: o(Icon, {
      classes: "text-tiny touch:text-base",
      name: icon
    }, void 0, false, {
      fileName: _jsxFileName$S,
      lineNumber: 151,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$S,
    lineNumber: 141,
    columnNumber: 5
  }, this);
}

/**
 * @typedef ToolbarButtonProps
 * @prop {boolean} [disabled]
 * @prop {string} [iconName]
 * @prop {string} [label]
 * @prop {(e: MouseEvent) => void} onClick
 * @prop {string} [shortcutKey]
 * @prop {string} [title]
 */

/** @param {ToolbarButtonProps} props */
function ToolbarButton({
  disabled = false,
  iconName = '',
  label,
  onClick,
  shortcutKey,
  title = ''
}) {
  const modifierKey = F(() => isMacOS() ? 'Cmd' : 'Ctrl', []);
  let tooltip = title;
  if (shortcutKey) {
    tooltip += ` (${modifierKey}-${shortcutKey.toUpperCase()})`;
  }
  const buttonProps = {
    disabled,
    icon: iconName,
    onClick,
    title: tooltip
  };
  if (label) {
    return o(LabeledButton, {
      classes: classnames('font-normal bg-transparent',
      // TODO: Refactor shared button styles to reduce specificity and make
      // this !important rule unnecessary
      'hover:!bg-transparent'),
      ...buttonProps,
      children: label
    }, void 0, false, {
      fileName: _jsxFileName$S,
      lineNumber: 191,
      columnNumber: 7
    }, this);
  }
  return o(IconButton, {
    classes: "px-2 py-2.5 text-tiny touch:text-base",
    ...buttonProps
  }, void 0, false, {
    fileName: _jsxFileName$S,
    lineNumber: 205,
    columnNumber: 5
  }, this);
}

/**
 * @param {TextAreaAttributes & { classes?: string, containerRef?: Ref<HTMLTextAreaElement> }} props
 */
function TextArea({
  classes,
  containerRef,
  ...restProps
}) {
  return o("textarea", {
    className: classnames('border rounded-sm p-2', 'text-color-text-light bg-grey-0', 'focus:bg-white focus:outline-none focus:shadow-focus-inner', classes),
    ...restProps,
    ref: containerRef
  }, void 0, false, {
    fileName: _jsxFileName$S,
    lineNumber: 217,
    columnNumber: 5
  }, this);
}

/**
 * @typedef ToolbarProps
 * @prop {boolean} isPreviewing - `true` if the editor's "Preview" mode is active.
 * @prop {(a: Command) => void} onCommand - Callback invoked when a toolbar button is clicked.
 * @prop {() => void} onTogglePreview - Callback invoked when the "Preview" toggle button is clicked.
 */

/**
 * An array of toolbar elements with a roving tab stop. Left and right
 * array keys can be used to change focus of the elements. Home and end
 * keys will navigate to the first and last elements respectively.
 *
 * Canonical example
 * https://www.w3.org/TR/wai-aria-practices/examples/toolbar/toolbar.html
 *
 * @param {ToolbarProps} props
 */
function Toolbar({
  isPreviewing,
  onCommand,
  onTogglePreview
}) {
  const toolbarContainer = _$1(null);
  useArrowKeyNavigation(toolbarContainer);
  return o("div", {
    className: classnames(
    // Allow buttons to wrap to second line if necessary.
    'flex flex-wrap w-full items-center', 'p-1 border-x border-t rounded-t bg-white',
    // For touch interfaces, allow height to scale to larger button targets.
    // Don't wrap buttons but instead scroll horizontally. Add bottom
    // padding to provide some space for scrollbar.
    'touch:h-auto touch:overflow-x-scroll touch:flex-nowrap touch:pb-2.5'),
    "data-testid": "markdown-toolbar",
    role: "toolbar",
    "aria-label": "Markdown editor toolbar",
    ref: toolbarContainer,
    children: [o(ToolbarButton, {
      disabled: isPreviewing,
      iconName: "format-bold",
      onClick: () => onCommand('bold'),
      shortcutKey: SHORTCUT_KEYS.bold,
      title: "Bold"
    }, void 0, false, {
      fileName: _jsxFileName$S,
      lineNumber: 267,
      columnNumber: 7
    }, this), o(ToolbarButton, {
      disabled: isPreviewing,
      iconName: "format-italic",
      onClick: () => onCommand('italic'),
      shortcutKey: SHORTCUT_KEYS.italic,
      title: "Italic"
    }, void 0, false, {
      fileName: _jsxFileName$S,
      lineNumber: 274,
      columnNumber: 7
    }, this), o(ToolbarButton, {
      disabled: isPreviewing,
      iconName: "format-quote",
      onClick: () => onCommand('quote'),
      shortcutKey: SHORTCUT_KEYS.quote,
      title: "Quote"
    }, void 0, false, {
      fileName: _jsxFileName$S,
      lineNumber: 281,
      columnNumber: 7
    }, this), o(ToolbarButton, {
      disabled: isPreviewing,
      iconName: "link",
      onClick: () => onCommand('link'),
      shortcutKey: SHORTCUT_KEYS.link,
      title: "Insert link"
    }, void 0, false, {
      fileName: _jsxFileName$S,
      lineNumber: 288,
      columnNumber: 7
    }, this), o(ToolbarButton, {
      disabled: isPreviewing,
      iconName: "image",
      onClick: () => onCommand('image'),
      shortcutKey: SHORTCUT_KEYS.image,
      title: "Insert image"
    }, void 0, false, {
      fileName: _jsxFileName$S,
      lineNumber: 295,
      columnNumber: 7
    }, this), o(ToolbarButton, {
      disabled: isPreviewing,
      iconName: "format-functions",
      onClick: () => onCommand('math'),
      title: "Insert math (LaTeX is supported)"
    }, void 0, false, {
      fileName: _jsxFileName$S,
      lineNumber: 302,
      columnNumber: 7
    }, this), o(ToolbarButton, {
      disabled: isPreviewing,
      iconName: "format-list-numbered",
      onClick: () => onCommand('numlist'),
      shortcutKey: SHORTCUT_KEYS.numlist,
      title: "Numbered list"
    }, void 0, false, {
      fileName: _jsxFileName$S,
      lineNumber: 308,
      columnNumber: 7
    }, this), o(ToolbarButton, {
      disabled: isPreviewing,
      iconName: "format-list-unordered",
      onClick: () => onCommand('list'),
      shortcutKey: SHORTCUT_KEYS.list,
      title: "Bulleted list"
    }, void 0, false, {
      fileName: _jsxFileName$S,
      lineNumber: 315,
      columnNumber: 7
    }, this), o("div", {
      className: "grow flex justify-end",
      children: [o(IconLink, {
        classes: classnames(
        // Adjust padding to make element a little taller than wide
        // This matches ToolbarButton styling
        'px-2 py-2.5'),
        href: "https://web.hypothes.is/help/formatting-annotations-with-markdown/",
        icon: "help",
        target: "_blank",
        title: "Formatting help",
        "aria-label": "Formatting help"
      }, void 0, false, {
        fileName: _jsxFileName$S,
        lineNumber: 323,
        columnNumber: 9
      }, this), o(ToolbarButton, {
        label: isPreviewing ? 'كتابة' : 'معاينة',
        onClick: onTogglePreview
      }, void 0, false, {
        fileName: _jsxFileName$S,
        lineNumber: 335,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$S,
      lineNumber: 322,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$S,
    lineNumber: 252,
    columnNumber: 5
  }, this);
}

/**
 * @typedef MarkdownEditorProps
 * @prop {string} label - An accessible label for the input field.
 * @prop {Record<string,string>} [textStyle] -
 *   Additional CSS properties to apply to the input field and rendered preview
 * @prop {string} [text] - The markdown text to edit.
 * @prop {(text: string) => void} [onEditText]
 *   - Callback invoked with `{ text }` object when user edits text.
 *   TODO: Simplify this callback to take just a string rather than an object once the
 *   parent component is converted to Preact.
 */

/**
 * Viewer/editor for the body of an annotation in markdown format.
 *
 * @param {MarkdownEditorProps} props
 */
function MarkdownEditor({
  label = '',
  onEditText = () => {},
  text = '',
  textStyle = {}
}) {
  // Whether the preview mode is currently active.
  const [preview, setPreview] = p(false);

  // The input element where the user inputs their comment.
  const input = _$1( /** @type {HTMLTextAreaElement|null} */null);
  h(() => {
    if (!preview) {
      var _input$current;
      (_input$current = input.current) === null || _input$current === void 0 ? void 0 : _input$current.focus();
    }
  }, [preview]);
  const togglePreview = () => setPreview(!preview);

  /** @param {Command} command */
  const handleCommand = command => {
    if (input.current) {
      handleToolbarCommand(command, input.current);
      onEditText(input.current.value);
    }
  };

  /** @param {KeyboardEvent} event */
  const handleKeyDown = event => {
    if (!event.ctrlKey && !event.metaKey) {
      return;
    }
    for (let [command, key] of Object.entries(SHORTCUT_KEYS)) {
      if (key === event.key) {
        event.stopPropagation();
        event.preventDefault();
        handleCommand( /** @type {Command} */command);
      }
    }
  };
  return o("div", {
    className: "leading-none",
    children: [o(Toolbar, {
      onCommand: handleCommand,
      isPreviewing: preview,
      onTogglePreview: togglePreview
    }, void 0, false, {
      fileName: _jsxFileName$S,
      lineNumber: 406,
      columnNumber: 7
    }, this), preview ? o(MarkdownView, {
      markdown: text,
      classes: "border bg-grey-1 p-2",
      style: textStyle
    }, void 0, false, {
      fileName: _jsxFileName$S,
      lineNumber: 412,
      columnNumber: 9
    }, this) : o(TextArea, {
      "aria-label": label,
      dir: "auto",
      classes: classnames('w-full min-h-[8em] resize-y',
      // Turn off border-radius on top edges to align with toolbar above
      'rounded-t-none',
      // Larger font on touch devices
      'text-base touch:text-touch-base'),
      containerRef: input,
      onClick: e => e.stopPropagation(),
      onKeyDown: handleKeyDown,
      onInput: e => onEditText( /** @type {HTMLTextAreaElement} */e.target.value),
      value: text,
      style: textStyle
    }, void 0, false, {
      fileName: _jsxFileName$S,
      lineNumber: 418,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$S,
    lineNumber: 405,
    columnNumber: 5
  }, this);
}

var _jsxFileName$R = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/AutocompleteList.js";
const defaultListFormatter = item => item;

/**
 * @template T
 * @typedef AutocompleteListProps
 * @prop {number} [activeItem] - The index of the highlighted item.
 * @prop {string} [id] - Optional unique HTML attribute id. This can be used
 *   for parent `aria-controls` coupling.
 * @prop {string} [itemPrefixId] - Optional unique HTML attribute id prefix
 *   for each item in the list. The final value of each items' id is
 *   `{itemPrefixId}{activeItem}`
 * @prop {T[]} list - The list of items to render. This can be a simple
 *   list of strings or a list of objects when used with listFormatter.
 * @prop {(item: T, index?: number) => any} [listFormatter] - An optional formatter
 *   to render each item inside an <li> tag This is useful if the list is an array of
 *   objects rather than just strings.
 * @prop {(item: T) => void} onSelectItem - Callback when an item is clicked with
 *   the mouse.
 * @prop {boolean} [open] - Is the list open or closed?
 */

/**
 * Custom autocomplete component. Use this in conjunction with an <input> field.
 * To make this component W3 accessibility compliant, it is is intended to be
 * coupled to an <input> field or the TagEditor component and can not be
 * used by itself.
 *
 * Modeled after the "ARIA 1.1 Combobox with Listbox Popup"
 *
 * @template T
 * @param {AutocompleteListProps<T>} props
 */
function AutocompleteList({
  activeItem = -1,
  id,
  itemPrefixId,
  list,
  listFormatter = defaultListFormatter,
  onSelectItem,
  open = false
}) {
  const items = F(() => {
    return list.map((item, index) => {
      // only add an id if itemPrefixId is passed
      const props = itemPrefixId ? {
        id: `${itemPrefixId}${index}`
      } : {};
      return (
        // The parent <input> field should capture keyboard events
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events
        o("li", {
          role: "option",
          "aria-selected": (activeItem === index).toString(),
          className: classnames('flex items-center', 'border-l-4 py-1 px-3 cursor-pointer hover:bg-grey-2', 'touch:h-touch-minimum', {
            'border-brand bg-grey-1': activeItem === index,
            'border-transparent': activeItem !== index
          }),
          onClick: () => {
            onSelectItem(item);
          },
          ...props,
          children: listFormatter(item, index)
        }, `AutocompleteList-${index}`, false, {
          fileName: _jsxFileName$R,
          lineNumber: 60,
          columnNumber: 9
        }, this)
      );
    });
  }, [activeItem, itemPrefixId, list, listFormatter, onSelectItem]);
  const props = id ? {
    id
  } : {}; // only add the id if its passed
  const isHidden = list.length === 0 || !open;
  return o("div", {
    className: "relative",
    children: o("div", {
      className: classnames({
        hidden: isHidden
      },
      // Move the Card down a bit to make room for the up-pointing arrow
      'absolute top-[3px] z-3',
      // Ensure Card width is not too narrow
      'min-w-[10em]'),
      "data-testid": "autocomplete-list-container",
      children: o(CardNext, {
        width: "auto",
        children: [o("ul", {
          tabIndex: -1,
          "aria-label": "Suggestions",
          role: "listbox",
          ...props,
          children: items
        }, void 0, false, {
          fileName: _jsxFileName$R,
          lineNumber: 99,
          columnNumber: 11
        }, this), o(MenuArrow, {
          direction: "up",
          classes: "top-[-8px] left-[3px]"
        }, void 0, false, {
          fileName: _jsxFileName$R,
          lineNumber: 102,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName$R,
        lineNumber: 98,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$R,
      lineNumber: 88,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$R,
    lineNumber: 87,
    columnNumber: 5
  }, this);
}

var _jsxFileName$Q = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/TagEditor.js";
let tagEditorIdCounter = 0;

/**
 * @typedef TagEditorProps
 * @prop {(tag: string) => boolean} onAddTag - Callback to add a tag to the annotation
 * @prop {(tag: string) => boolean} onRemoveTag - Callback to remove a tag from the annotation
 * @prop {(tag: string) => void} onTagInput - Callback when inputted tag text changes
 * @prop {string[]} tagList - The list of tags for the annotation under edit
 * @prop {import('../services/tags').TagsService} tags
 */

/**
 * Component to edit annotation's tags.
 *
 * Component accessibility is modeled after "Combobox with Listbox Popup Examples" found here:
 * https://www.w3.org/TR/wai-aria-practices/examples/combobox/aria1.1pattern/listbox-combo.html
 *
 * @param {TagEditorProps} props
 */
function TagEditor({
  onAddTag,
  onRemoveTag,
  onTagInput,
  tagList,
  tags: tagsService
}) {
  const inputEl = /** @type {{ current: HTMLInputElement }} */_$1();
  const [suggestions, setSuggestions] = p( /** @type {string[]} */[]);
  const [activeItem, setActiveItem] = p(-1); // -1 is unselected
  const [suggestionsListOpen, setSuggestionsListOpen] = p(false);
  const [tagEditorId] = p(() => {
    ++tagEditorIdCounter;
    return `TagEditor-${tagEditorIdCounter}`;
  });

  // Set up callback to monitor outside click events to close the AutocompleteList
  const closeWrapperRef = /** @type {{ current: HTMLDivElement }} */_$1();
  useElementShouldClose(closeWrapperRef, suggestionsListOpen, () => {
    setSuggestionsListOpen(false);
  });

  /**
   * Retrieve the current trimmed text value of the tag <input>
   */
  const pendingTag = () => inputEl.current.value.trim();
  const hasPendingTag = () => pendingTag() && pendingTag().length > 0;
  const clearPendingTag = () => {
    inputEl.current.value = '';
    onTagInput === null || onTagInput === void 0 ? void 0 : onTagInput('');
  };

  /**
   * Helper function that returns a list of suggestions less any
   * results also found from the duplicates list.
   *
   * @param {string[]} suggestions - Original list of suggestions
   * @param {string[]} duplicates - Items to be removed from the result
   * @return {string[]}
   */
  const removeDuplicates = (suggestions, duplicates) => {
    const suggestionsSet = [];
    for (let suggestion of suggestions) {
      if (duplicates.indexOf(suggestion) < 0) {
        suggestionsSet.push(suggestion);
      }
    }
    return suggestionsSet.sort();
  };

  /**
   * Get a list of suggestions returned from the tagsService
   * reset the activeItem and open the AutocompleteList
   */
  const updateSuggestions = () => {
    if (!hasPendingTag()) {
      // If there is no input, just hide the suggestions
      setSuggestionsListOpen(false);
    } else {
      // Call filter() with a query value to return all matching suggestions.
      const suggestions = tagsService.filter(pendingTag());
      // Remove any repeated suggestions that are already tags
      // and set those to state.
      setSuggestions(removeDuplicates(suggestions, tagList));
      setSuggestionsListOpen(suggestions.length > 0);
    }
    setActiveItem(-1);
  };

  /**
   * Invokes callback to add tag. If the tag was added, close the suggestions
   * list, clear the field content and maintain focus.
   *
   * @param {string} newTag
   */
  const addTag = newTag => {
    if (onAddTag(newTag)) {
      setSuggestionsListOpen(false);
      setActiveItem(-1);
      clearPendingTag();
      inputEl.current.focus();
    }
  };
  const handleOnInput = () => {
    onTagInput === null || onTagInput === void 0 ? void 0 : onTagInput(pendingTag());
    updateSuggestions();
  };

  /**
   *  Callback when the user clicked one of the items in the suggestions list.
   *  This will add a new tag.
   *
   * @param {string} item
   */
  const handleSelect = item => {
    if (item) {
      addTag(item);
    }
  };

  /**
   * Opens the AutocompleteList on focus if there is a value in the input
   */
  const handleFocus = () => {
    if (hasPendingTag()) {
      setSuggestionsListOpen(true);
    }
  };

  /**
   *  Called when the user uses keyboard navigation to move
   *  up or down the suggestions list creating a highlighted
   *  item.
   *
   *  The first value in the list is an unselected value (-1).
   *  A user can arrive at this value by pressing the up arrow back to
   *  the beginning or the down arrow until the end.
   *
   * @param {number} direction - Pass 1 for the next item or -1 for the previous
   */
  const changeSelectedItem = direction => {
    let nextActiveItem = activeItem + direction;
    if (nextActiveItem < -1) {
      nextActiveItem = suggestions.length - 1;
    } else if (nextActiveItem >= suggestions.length) {
      nextActiveItem = -1;
    }
    setActiveItem(nextActiveItem);
  };

  /**
   * Keydown handler for keyboard navigation of the tag editor field and the
   * suggested-tags list.
   *
   * @param {KeyboardEvent} e
   */
  const handleKeyDown = e => {
    switch (e.key) {
      case 'ArrowUp':
        // Select the previous item in the suggestion list
        changeSelectedItem(-1);
        e.preventDefault();
        break;
      case 'ArrowDown':
        // Select the next item in the suggestion list
        changeSelectedItem(1);
        e.preventDefault();
        break;
      case 'Escape':
        // Clear any entered text, but retain focus
        clearPendingTag();
        e.preventDefault();
        break;
      case 'Enter':
      case ',':
        // Commit a tag
        if (activeItem === -1) {
          // nothing selected, just add the typed text
          addTag(pendingTag());
        } else {
          // Add the selected tag
          addTag(suggestions[activeItem]);
        }
        e.preventDefault();
        break;
      case 'Tab':
        // Commit a tag, or tab out of the field if it is empty (default browser
        // behavior)
        if (!hasPendingTag()) {
          // If the tag field is empty, allow `Tab` to have its default
          // behavior: continue to the next element in tab order
          break;
        }
        if (activeItem !== -1) {
          // If there is a selected item in the suggested tag list,
          // commit that tag (just like `Enter` and `,` in this case)
          addTag(suggestions[activeItem]);
        } else if (suggestions.length === 1) {
          // If there is exactly one suggested tag match, commit that tag
          // This emulates a "tab-complete" behavior
          addTag(suggestions[0]);
        } else {
          // Commit the tag as typed in the field
          addTag(pendingTag());
        }
        // Retain focus
        e.preventDefault();
        break;
    }
  };

  /**
   * Callback for formatting a suggested tag item. Use selective bolding
   * to help delineate which part of the entered tag text matches the
   * suggestion.
   *
   * @param {string} item - Suggested tag
   * @return {JSXElement} - Formatted tag for use in list
   */
  const formatSuggestedItem = item => {
    // filtering of tags is case-insensitive
    const curVal = pendingTag().toLowerCase();
    const suggestedTag = item.toLowerCase();
    const matchIndex = suggestedTag.indexOf(curVal);

    // If the current input doesn't seem to match the suggested tag,
    // just render the tag as-is.
    if (matchIndex === -1) {
      return o("span", {
        children: item
      }, void 0, false, {
        fileName: _jsxFileName$Q,
        lineNumber: 242,
        columnNumber: 14
      }, this);
    }

    // Break the suggested tag into three parts:
    // 1. Substring of the suggested tag that occurs before the match
    //    with the current input
    const prefix = item.slice(0, matchIndex);
    // 2. Substring of the suggested tag that matches the input text. NB:
    //    This may be in a different case than the input text.
    const matchString = item.slice(matchIndex, matchIndex + curVal.length);
    // 3. Substring of the suggested tag that occurs after the matched input
    const suffix = item.slice(matchIndex + curVal.length);
    return o("span", {
      children: [o("strong", {
        children: prefix
      }, void 0, false, {
        fileName: _jsxFileName$Q,
        lineNumber: 257,
        columnNumber: 9
      }, this), matchString, o("strong", {
        children: suffix
      }, void 0, false, {
        fileName: _jsxFileName$Q,
        lineNumber: 259,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$Q,
      lineNumber: 256,
      columnNumber: 7
    }, this);
  };

  // The activedescendant prop should match the activeItem's value except
  // when its -1 (no item selected), and in this case set the activeDescendant to "".
  const activeDescendant = activeItem >= 0 ? `${tagEditorId}-AutocompleteList-item-${activeItem}` : '';
  return o("div", {
    className: "space-y-4",
    children: [o(TagList, {
      children: tagList.map(tag => {
        return o(TagListItem, {
          onRemoveTag: onRemoveTag,
          tag: tag
        }, tag, false, {
          fileName: _jsxFileName$Q,
          lineNumber: 273,
          columnNumber: 18
        }, this);
      })
    }, void 0, false, {
      fileName: _jsxFileName$Q,
      lineNumber: 271,
      columnNumber: 7
    }, this), o("div", {
      id: tagEditorId,
      "data-testid": "combobox-container",
      ref: closeWrapperRef
      // Disabled because aria-controls must be attached to the <input> field
      // eslint-disable-next-line jsx-a11y/role-has-required-aria-props
      ,
      role: "combobox",
      "aria-expanded": suggestionsListOpen.toString(),
      "aria-owns": `${tagEditorId}-AutocompleteList`,
      "aria-haspopup": "listbox",
      children: [o(TextInput, {
        classes: "w-full",
        onInput: handleOnInput,
        onKeyDown: handleKeyDown,
        onFocus: handleFocus,
        inputRef: inputEl,
        placeholder: "\u0627\u0636\u0627\u0641\u0629 \u0648\u0633\u0645 \u062C\u062F\u064A\u062F",
        type: "text",
        autoComplete: "off",
        "aria-autocomplete": "list",
        "aria-activedescendant": activeDescendant,
        "aria-controls": `${tagEditorId}-AutocompleteList`,
        dir: "auto"
      }, void 0, false, {
        fileName: _jsxFileName$Q,
        lineNumber: 287,
        columnNumber: 9
      }, this), o(AutocompleteList, {
        id: `${tagEditorId}-AutocompleteList`,
        list: suggestions,
        listFormatter: formatSuggestedItem,
        open: suggestionsListOpen,
        onSelectItem: handleSelect,
        itemPrefixId: `${tagEditorId}-AutocompleteList-item-`,
        activeItem: activeItem
      }, void 0, false, {
        fileName: _jsxFileName$Q,
        lineNumber: 301,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$Q,
      lineNumber: 276,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$Q,
    lineNumber: 270,
    columnNumber: 5
  }, this);
}
var TagEditor$1 = withServices(TagEditor, ['tags']);

var _jsxFileName$P = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/AnnotationLicense.tsx";
function AnnotationLicense() {
  return o("div", {
    className: "pt-2 border-t text-sm leading-none",
    children: o(LinkNext, {
      classes: "flex items-center",
      color: "text-light",
      href: "http://creativecommons.org/publicdomain/zero/1.0/",
      target: "_blank",
      title: "View more information about the Creative Commons Public Domain dedication",
      children: [o(CcStdIcon, {
        className: "w-em h-em text-tiny"
      }, void 0, false, {
        fileName: _jsxFileName$P,
        lineNumber: 20,
        columnNumber: 9
      }, this), o(CcZeroIcon, {
        className: "w-em h-em ml-px text-tiny"
      }, void 0, false, {
        fileName: _jsxFileName$P,
        lineNumber: 21,
        columnNumber: 9
      }, this), o("div", {
        className: "ml-1",
        children: "Annotations can be freely reused by anyone for any purpose."
      }, void 0, false, {
        fileName: _jsxFileName$P,
        lineNumber: 22,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$P,
      lineNumber: 13,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$P,
    lineNumber: 12,
    columnNumber: 5
  }, this);
}

var _jsxFileName$O = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/MenuKeyboardNavigation.js";
function isElementVisible(element) {
  return element.offsetParent !== null;
}

/**
 * @typedef MenuKeyboardNavigationProps
 * @prop {string} [className]
 * @prop {(e: KeyboardEvent) => void} [closeMenu] - Callback when the menu is closed via keyboard input
 * @prop {boolean} [visible] - When  true`, sets focus on the first item in the list
 * @prop {import('preact').ComponentChildren} children - Array of nodes which may contain <MenuItems> or any nodes
 */

/**
 * Helper component used by Menu and MenuItem to facilitate keyboard navigation of a
 * list of <MenuItem> components. This component should not be used directly.
 *
 * Note that `ArrowRight` shall be handled by the parent <MenuItem> directly and
 * all other focus() related navigation is handled here.
 *
 * @param {MenuKeyboardNavigationProps} props
 */
function MenuKeyboardNavigation({
  className,
  closeMenu,
  children,
  visible
}) {
  const menuRef = /** @type {{ current: HTMLDivElement }} */_$1();
  h(() => {
    /** @type {number|undefined} */
    let focusTimer;
    if (visible) {
      focusTimer = setTimeout(() => {
        // The focus won't work without delaying rendering.
        const firstItem = menuRef.current.querySelector('[role^="menuitem"]');
        if (firstItem) {
          /** @type {HTMLElement} */firstItem.focus();
        }
      });
    }
    return () => {
      // unmount
      clearTimeout(focusTimer);
    };
  }, [visible]);

  /** @param {KeyboardEvent} event */
  const onKeyDown = event => {
    const menuItems = Array.from( /** @type {NodeListOf<HTMLElement>} */
    menuRef.current.querySelectorAll('[role^="menuitem"]')).filter(isElementVisible);
    let focusedIndex = menuItems.findIndex(el => el.contains(document.activeElement));
    let handled = false;
    switch (event.key) {
      case 'ArrowLeft':
      case 'Escape':
        if (closeMenu) {
          closeMenu(event);
          handled = true;
        }
        break;
      case 'ArrowUp':
        focusedIndex -= 1;
        if (focusedIndex < 0) {
          focusedIndex = menuItems.length - 1;
        }
        handled = true;
        break;
      case 'ArrowDown':
        focusedIndex += 1;
        if (focusedIndex === menuItems.length) {
          focusedIndex = 0;
        }
        handled = true;
        break;
      case 'Home':
        focusedIndex = 0;
        handled = true;
        break;
      case 'End':
        focusedIndex = menuItems.length - 1;
        handled = true;
        break;
    }
    if (handled && focusedIndex >= 0) {
      event.stopPropagation();
      event.preventDefault();
      menuItems[focusedIndex].focus();
    }
  };
  return (
    // This element needs to have role="menu" to facilitate readers
    // correctly enumerating discrete submenu items, but it also needs
    // to facilitate keydown events for navigation. Disable the linter
    // error so it can do both.
    // eslint-disable-next-line jsx-a11y/interactive-supports-focus
    o("div", {
      role: "menu",
      className: className,
      ref: menuRef,
      onKeyDown: onKeyDown,
      children: children
    }, void 0, false, {
      fileName: _jsxFileName$O,
      lineNumber: 109,
      columnNumber: 5
    }, this)
  );
}

var _jsxFileName$N = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Menu.js";
let ignoreNextClick = false;

/**
 * @typedef MenuProps
 * @prop {'left'|'right'} [align] -
 *   Whether the menu content is aligned with the left (default) or right edges of the
 *   toggle element.
 * @prop {string} [arrowClass] -
 *   Additional CSS class for the arrow caret at the edge of the menu content that "points"
 *   toward the menu's toggle button. This can be used to adjust the position of that caret
 *   respective to the toggle button.
 * @prop {object|string} [label] - Label element for the toggle button that hides and shows the menu.
 * @prop {object} [children] -
 *   Menu items and sections to display in the content area of the menu.  These are typically
 *   `MenuSection` and `MenuItem` components, but other custom content is also allowed.
 * @prop {boolean} [containerPositioned] -
 *   Whether the menu elements should be positioned relative to the Menu container. When
 *   `false`, the consumer is responsible for positioning.
 * @prop {string} [contentClass] - Additional CSS classes to apply to the menu.
 * @prop {boolean} [defaultOpen] - Whether the menu is open or closed when initially rendered.
 *   Ignored if `open` is present.
 * @prop {(open: boolean) => void} [onOpenChanged] - Callback invoked when the menu is
 *   opened or closed.  This can be used, for example, to reset any ephemeral state that the
 *   menu content may have.
 * @prop {boolean} [open] - Whether the menu is currently open; overrides internal state
 *   management for openness. External components managing state in this way should
 *   also pass an `onOpenChanged` handler to respond when the user closes the menu.
 * @prop {string} title -
 *   A title for the menu. This is important for accessibility if the menu's toggle button
 *   has only an icon as a label.
 * @prop {boolean} [menuIndicator] -
 *   Whether to display an indicator next to the label that there is a dropdown menu.
 */

const noop = () => {};

/**
 * A drop-down menu.
 *
 * Menus consist of a button which toggles whether the menu is open, an
 * an arrow indicating the state of the menu and content when is shown when
 * the menu is open. The children of the menu component are rendered as the
 * content of the menu when open. Typically this consists of a list of
 * `MenuSection` and/or `MenuItem` components.
 *
 * @example
 *   <Menu label="Preferences">
 *     <MenuItem label="View" onClick={showViewSettings}/>
 *     <MenuItem label="Theme" onClick={showThemeSettings}/>
 *     <MenuSection>
 *       <MenuItem label="Log out"/>
 *     </MenuSection>
 *   </Menu>
 *
 * @param {MenuProps} props
 */
function Menu({
  align = 'left',
  arrowClass = '',
  children,
  containerPositioned = true,
  contentClass,
  defaultOpen = false,
  label,
  open,
  onOpenChanged,
  menuIndicator = true,
  title
}) {
  /** @type {[boolean, (open: boolean) => void]} */
  let [isOpen, setOpen] = p(defaultOpen);
  if (typeof open === 'boolean') {
    isOpen = open;
    setOpen = onOpenChanged || noop;
  }

  // Notify parent when menu is opened or closed.
  const wasOpen = _$1(isOpen);
  h(() => {
    if (typeof onOpenChanged === 'function' && wasOpen.current !== isOpen) {
      wasOpen.current = isOpen;
      onOpenChanged(isOpen);
    }
  }, [isOpen, onOpenChanged]);

  // Toggle menu when user presses toggle button. The menu is shown on mouse
  // press for a more responsive/native feel but also handles a click event for
  // activation via other input methods.
  /** @param {Event} event */
  const toggleMenu = event => {
    // If the menu was opened on press, don't close it again on the subsequent
    // mouse up ("click") event.
    if (event.type === 'mousedown') {
      ignoreNextClick = true;
    } else if (event.type === 'click' && ignoreNextClick) {
      // Ignore "click" event triggered from the mouse up action.
      ignoreNextClick = false;
      event.stopPropagation();
      event.preventDefault();
      return;
    }
    setOpen(!isOpen);
  };
  const closeMenu = T$1(() => setOpen(false), [setOpen]);

  // Set up an effect which adds document-level event handlers when the menu
  // is open and removes them when the menu is closed or removed.
  //
  // These handlers close the menu when the user taps or clicks outside the
  // menu or presses Escape.
  const menuRef = /** @type {{ current: HTMLDivElement }} */_$1();

  // Menu element should close via `closeMenu` whenever it's open and there
  // are user interactions outside of it (e.g. clicks) in the document
  useElementShouldClose(menuRef, isOpen, closeMenu);

  /** @param {Event} e */
  const stopPropagation = e => e.stopPropagation();

  // It should also close if the user presses a key which activates menu items.
  /** @param {KeyboardEvent} event */
  const handleMenuKeyDown = event => {
    const key = event.key;
    if (key === 'Enter' || key === ' ') {
      // The browser will not open the link if the link element is removed
      // from within the keypress event that triggers it. Add a little
      // delay to work around that.
      setTimeout(() => {
        closeMenu();
      });
    }
  };

  /** @type {{ position: 'relative'|'static' }} */
  const containerStyle = {
    position: containerPositioned ? 'relative' : 'static'
  };
  return (
    // See https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md#case-the-event-handler-is-only-being-used-to-capture-bubbled-events
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events
    o("div", {
      className: "relative",
      "data-testid": "menu-container",
      ref: menuRef
      // Add inline styles for positioning
      ,
      style: containerStyle
      // Don't close the menu if the mouse is released over one of the menu
      // elements outside the content area (eg. the arrow at the top of the
      // content).
      ,
      onClick: stopPropagation
      // Don't close the menu if the user presses the mouse down on menu elements
      // except for the toggle button.
      ,
      onMouseDown: stopPropagation,
      children: [o("button", {
        "aria-expanded": isOpen ? 'true' : 'false',
        "aria-haspopup": true,
        className: classnames('focus-visible-ring', 'flex items-center justify-center rounded-sm transition-colors', {
          'text-grey-7 hover:text-grey-9': !isOpen,
          'text-brand': isOpen
        }),
        "data-testid": "menu-toggle-button",
        onMouseDown: toggleMenu,
        onClick: toggleMenu,
        "aria-label": title,
        title: title,
        children: o("span", {
          // wrapper is needed to serve as the flex layout for the label and indicator content.
          className: "flex items-center gap-x-1",
          children: [label, menuIndicator && o("span", {
            className: classnames({
              'rotate-180 text-color-text': isOpen
            }),
            children: o(Icon, {
              name: "expand-menu",
              classes: "w-2.5 h-2.5"
            }, void 0, false, {
              fileName: _jsxFileName$N,
              lineNumber: 197,
              columnNumber: 15
            }, this)
          }, void 0, false, {
            fileName: _jsxFileName$N,
            lineNumber: 192,
            columnNumber: 13
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName$N,
          lineNumber: 186,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$N,
        lineNumber: 169,
        columnNumber: 7
      }, this), isOpen && o(p$2, {
        children: [o(MenuArrow, {
          direction: "up",
          classes: classnames(
          // Position menu-arrow caret near bottom right of menu label/toggle control
          'right-0 top-[calc(100%-3px)] w-[15px]', arrowClass)
        }, void 0, false, {
          fileName: _jsxFileName$N,
          lineNumber: 204,
          columnNumber: 11
        }, this), o("div", {
          className: classnames('focus-visible-ring',
          // Position menu content near bottom of menu label/toggle control
          'absolute top-[calc(100%+5px)] z-1 border shadow', 'bg-white text-lg', {
            'left-0': align === 'left',
            'right-0': align === 'right'
          }, contentClass),
          "data-testid": "menu-content",
          role: "menu",
          tabIndex: -1,
          onClick: closeMenu,
          onKeyDown: handleMenuKeyDown,
          children: o(MenuKeyboardNavigation, {
            visible: true,
            children: children
          }, void 0, false, {
            fileName: _jsxFileName$N,
            lineNumber: 230,
            columnNumber: 13
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName$N,
          lineNumber: 212,
          columnNumber: 11
        }, this)]
      }, void 0, true)]
    }, void 0, true, {
      fileName: _jsxFileName$N,
      lineNumber: 155,
      columnNumber: 5
    }, this)
  );
}

var _jsxFileName$M = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Slider.js";
function Slider({
  children,
  visible
}) {
  const containerRef = /** @type {{ current: HTMLDivElement }} */_$1();
  const [containerHeight, setContainerHeight] = p(visible ? 'auto' : 0);

  // Whether the content is currently partially or wholly visible. This is
  // different from `visible` when collapsing as it is true until the collapse
  // animation completes.
  const [contentVisible, setContentVisible] = p(visible);

  // Adjust the container height when the `visible` prop changes.
  h(() => {
    const isVisible = containerHeight !== 0;
    if (visible === isVisible) {
      // Do nothing after the initial mount.
      return;
    }
    const el = containerRef.current;
    if (visible) {
      // Show the content synchronously so that we can measure it here.
      el.style.display = '';

      // Make content visible in future renders.
      setContentVisible(true);

      // When expanding, transition the container to the current fixed height
      // of the content. After the transition completes, we'll reset to "auto"
      // height to adapt to future content changes.
      setContainerHeight(el.scrollHeight);
    } else {
      // When collapsing, immediately change the current height to a fixed height
      // (in case it is currently "auto"), force a synchronous layout,
      // then transition to 0.
      //
      // These steps are needed because browsers will not animate transitions
      // from "auto" => "0" and may not animate "auto" => fixed height => 0
      // if the layout tree transitions directly from "auto" => 0.
      el.style.height = `${el.scrollHeight}px`;

      // Force a sync layout.
      el.getBoundingClientRect();
      setContainerHeight(0);
    }
  }, [containerHeight, visible]);
  const handleTransitionEnd = T$1(() => {
    if (visible) {
      setContainerHeight('auto');
    } else {
      // When the collapse animation completes, stop rendering the content so
      // that the browser has fewer nodes to render and the content is removed
      // from keyboard navigation.
      setContentVisible(false);
    }
  }, [setContainerHeight, visible]);
  const isFullyVisible = containerHeight === 'auto';
  return o("div", {
    // nb. Preact uses "ontransitionend" rather than "onTransitionEnd".
    // See https://bugs.chromium.org/p/chromium/issues/detail?id=961193
    //
    // @ts-ignore
    // eslint-disable-next-line react/no-unknown-property
    ontransitionend: handleTransitionEnd,
    ref: containerRef,
    style: {
      display: contentVisible ? '' : 'none',
      height: containerHeight,
      // When the Slider is fully open, overflow is made visible so that
      // focus rings, which may extend outside the bounds of the Slider content,
      // are visible.
      overflow: isFullyVisible ? 'visible' : 'hidden',
      transition: `height 0.15s ease-in`
    },
    children: children
  }, void 0, false, {
    fileName: _jsxFileName$M,
    lineNumber: 81,
    columnNumber: 5
  }, this);
}

var _jsxFileName$L = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/MenuItem.js";
function SubmenuToggle({
  title,
  isExpanded,
  onToggleSubmenu
}) {
  return o("div", {
    "data-testid": "submenu-toggle"
    // We should not have a <button> inside of the menu item itself
    // but we have a non-standard mechanism with the toggle control
    // requiring an onClick event nested inside a "menuitemradio|menuitem".
    // Therefore, a static element with a role="none" is necessary here.
    ,
    role: "none",
    className: classnames(
    // Center content in a 40px square. The entire element is clickable
    'flex flex-col items-center justify-center w-10 h-10', 'text-grey-6 bg-grey-1',
    // Clip the background (color) such that it only shows within the
    // content box, which is a 24px rounded square formed by the large
    // borders
    'bg-clip-content border-[8px] border-transparent rounded-xl',
    // When the menu item is hovered AND this element is hovered, darken
    // the text color so it is clear that the toggle is the hovered element
    'group-hover:hover:text-grey-8', {
      // When the submenu is expanded, this element always has a darker
      // background color regardless of hover state.
      'bg-grey-4': isExpanded,
      // When the parent menu item is hovered, it gets a darker background.
      // Make the toggle background darker also.
      'group-hover:bg-grey-3': !isExpanded
    }),
    onClick: onToggleSubmenu,
    title: title,
    children: o(Icon, {
      name: isExpanded ? 'collapse-menu' : 'expand-menu',
      classes: "w-3 h-3"
    }, void 0, false, {
      fileName: _jsxFileName$L,
      lineNumber: 53,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$L,
    lineNumber: 23,
    columnNumber: 5
  }, this);
}

/**
 * @typedef MenuItemProps
 * @prop {string} [href] -
 *   URL of the external link to open when this item is clicked. Either the `href` or an
 *   `onClick` callback should be supplied.
 * @prop {string} [iconAlt] - Alt text for icon.
 * @prop {string} [icon] -
 *   Name or URL of icon to display. If the value is a URL it is displayed using an `<img>`;
 *   if it is a non-URL string it is assumed to be the `name` of a registered icon.
 *   If the property is `"blank"` a blank placeholder is displayed in place of an icon.
 *   The placeholder is useful to keep menu item labels aligned.
 * @prop {boolean} [isDisabled] -
 *   Dim the label to indicate that this item is not currently available.  The `onClick`
 *   callback will still be invoked when this item is clicked and the submenu, if any,
 *   can still be toggled.
 * @prop {boolean} [isExpanded] -
 *   Indicates that the submenu associated with this item is currently open.
 * @prop {boolean} [isSelected] -
 *   Display an indicator to show that this menu item represents something which is currently
 *   selected/active/focused.
 * @prop {boolean} [isSubmenuItem] -
 *   True if this item is part of a submenu, in which case it is rendered with a different
 *   style (shaded background)
 * @prop {boolean|undefined} [isSubmenuVisible] -
 *   If present, display a button to toggle the sub-menu associated with this item and
 *   indicate the current state; `true` if the submenu is visible. Note. Omit this prop,
 *    or set it to null, if there is no `submenu`.
 * @prop {string} label - Label of the menu item.
 * @prop {(e: Event) => void} [onClick] - Callback to invoke when the menu item is clicked.
 * @prop {(e: Event) => void} [onToggleSubmenu] -
 *   Callback when the user clicks on the toggle to change the expanded state of the menu.
 * @prop {object} [submenu] -
 *   Contents of the submenu for this item.  This is typically a list of `MenuItem` components
 *    with the `isSubmenuItem` prop set to `true`, but can include other content as well.
 *    The submenu is only rendered if `isSubmenuVisible` is `true`.
 */

/**
 * An item in a dropdown menu.
 *
 * Dropdown menu items display an icon, a label and can optionally have a submenu
 * associated with them.
 *
 * When clicked, menu items either open an external link, if the `href` prop
 * is provided, or perform a custom action via the `onClick` callback.
 *
 * The icon can either be an external SVG image, referenced by URL, or the
 * name of an icon registered in the application. @see {SidebarIcons}
 *
 * For items that have submenus, the `MenuItem` will call the `renderSubmenu`
 * prop to render the content of the submenu, when the submenu is visible.
 * Note that the `submenu` is not supported for link (`href`) items.
 *
 * @param {MenuItemProps} props
 */
function MenuItem({
  href,
  icon,
  iconAlt,
  isDisabled,
  isExpanded,
  isSelected,
  isSubmenuItem,
  isSubmenuVisible,
  label,
  onClick,
  onToggleSubmenu,
  submenu
}) {
  const iconIsUrl = icon && icon.indexOf('/') !== -1;
  const menuItemRef = /** @type {{ current: HTMLAnchorElement & HTMLDivElement }} */_$1();

  /** @type {number|undefined} */
  let focusTimer;

  // menuItem can be either a link or a button
  let menuItem;
  const hasSubmenuVisible = typeof isSubmenuVisible === 'boolean';
  const isRadioButtonType = typeof isSelected === 'boolean';
  h(() => {
    return () => {
      // unmount
      clearTimeout(focusTimer);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  /** @param {Event} event */
  const onCloseSubmenu = event => {
    if (onToggleSubmenu) {
      onToggleSubmenu(event);
    }
    // The focus won't work without delaying rendering.
    focusTimer = setTimeout(() => {
      menuItemRef.current.focus();
    });
  };

  /** @param {KeyboardEvent} event */
  const onKeyDown = event => {
    switch (event.key) {
      case 'ArrowRight':
        if (onToggleSubmenu) {
          event.stopPropagation();
          event.preventDefault();
          onToggleSubmenu(event);
        }
        break;
      case 'Enter':
      case ' ':
        if (onClick) {
          // Let event propagate so the menu closes
          onClick(event);
        }
    }
  };
  let renderedIcon = null;
  if (icon && icon !== 'blank') {
    renderedIcon = iconIsUrl ? o("img", {
      className: "w-4 h-4",
      alt: iconAlt,
      src: icon
    }, void 0, false, {
      fileName: _jsxFileName$L,
      lineNumber: 184,
      columnNumber: 7
    }, this) : o(Icon, {
      name: icon,
      classes: "h-3 w-3"
    }, void 0, false, {
      fileName: _jsxFileName$L,
      lineNumber: 186,
      columnNumber: 7
    }, this);
  }
  const leftIcon = isSubmenuItem ? null : renderedIcon;
  const rightIcon = isSubmenuItem ? renderedIcon : null;

  // MenuItem content layout consists of:
  // - Sometimes a left item, which may contain an icon or serve as
  //   an indenting space for label alignment
  // - Always a label
  // - Sometimes a right item, which contains an icon (submenu items)
  // - Sometimes a submenu-toggle control (only if the item has a submenu)
  const hasLeftItem = leftIcon || isSubmenuItem || icon === 'blank';
  const hasRightItem = rightIcon && isSubmenuItem;
  const menuItemContent = o(p$2, {
    children: [hasLeftItem && o("div", {
      className: "w-7 flex items-center justify-center",
      "data-testid": "left-item-container",
      children: leftIcon
    }, void 0, false, {
      fileName: _jsxFileName$L,
      lineNumber: 204,
      columnNumber: 9
    }, this), o("span", {
      className: "flex items-center grow whitespace-nowrap px-1",
      children: label
    }, void 0, false, {
      fileName: _jsxFileName$L,
      lineNumber: 211,
      columnNumber: 7
    }, this), hasRightItem && o("div", {
      className: "w-8 flex items-center justify-center",
      "data-testid": "right-item-container",
      children: rightIcon
    }, void 0, false, {
      fileName: _jsxFileName$L,
      lineNumber: 215,
      columnNumber: 9
    }, this), hasSubmenuVisible && o(SubmenuToggle, {
      title: `Show actions for ${label}`,
      isExpanded: isSubmenuVisible,
      onToggleSubmenu: onToggleSubmenu
    }, void 0, false, {
      fileName: _jsxFileName$L,
      lineNumber: 223,
      columnNumber: 9
    }, this)]
  }, void 0, true);
  const wrapperClasses = classnames('focus-visible-ring ring-inset', 'w-full min-w-[150px] flex items-center select-none', 'border-b',
  // Set this container as a "group" so that children may style based on its
  // layout state.
  // See https://tailwindcss.com/docs/hover-focus-and-other-states#styling-based-on-parent-state
  'group', {
    'min-h-[30px] font-normal': isSubmenuItem,
    'min-h-[40px] font-medium': !isSubmenuItem,
    'bg-grey-1 hover:bg-grey-3': isSubmenuItem || isExpanded,
    'bg-white hover:bg-grey-1': !isSubmenuItem && !isExpanded,
    // visual "padding" on the right is part of SubmenuToggle when rendered,
    // but when not rendering a SubmenuToggle, we need to add some padding here
    'pr-1': !hasSubmenuVisible
  }, {
    // When the item is selected, show a left border to indicate it
    'border-l-[4px] border-l-brand': isSelected,
    // Add equivalent padding to border size when not selected. This instead
    // of a transparent left border to make focus ring cover the full
    // menu item. Otherwise the focus ring will be inset on the left too far.
    'pl-[4px]': !isSelected,
    'border-b-grey-3': isExpanded,
    'border-b-transparent': !isExpanded,
    'text-color-text-light': isDisabled,
    'text-color-text': !isDisabled
  });
  if (href) {
    // The menu item is a link
    menuItem = o("a", {
      ref: menuItemRef,
      className: wrapperClasses,
      "data-testid": "menu-item",
      href: href,
      target: "_blank",
      tabIndex: -1,
      rel: "noopener noreferrer",
      role: "menuitem",
      onKeyDown: onKeyDown,
      children: menuItemContent
    }, void 0, false, {
      fileName: _jsxFileName$L,
      lineNumber: 266,
      columnNumber: 7
    }, this);
  } else {
    // The menu item is a clickable button or radio button.
    // In either case there may be an optional submenu.
    menuItem = o("div", {
      ref: menuItemRef,
      className: wrapperClasses,
      "data-testid": "menu-item",
      tabIndex: -1,
      onKeyDown: onKeyDown,
      onClick: onClick,
      role: isRadioButtonType ? 'menuitemradio' : 'menuitem',
      "aria-checked": isRadioButtonType ? isSelected : undefined,
      "aria-haspopup": hasSubmenuVisible,
      "aria-expanded": hasSubmenuVisible ? isSubmenuVisible : undefined,
      children: menuItemContent
    }, void 0, false, {
      fileName: _jsxFileName$L,
      lineNumber: 284,
      columnNumber: 7
    }, this);
  }
  return o(p$2, {
    children: [menuItem, hasSubmenuVisible && o(Slider, {
      visible: /** @type {boolean} */isSubmenuVisible,
      children: o(MenuKeyboardNavigation, {
        closeMenu: onCloseSubmenu,
        visible: /** @type {boolean} */isSubmenuVisible,
        className: "border-b",
        children: submenu
      }, void 0, false, {
        fileName: _jsxFileName$L,
        lineNumber: 305,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$L,
      lineNumber: 304,
      columnNumber: 9
    }, this)]
  }, void 0, true);
}

var _jsxFileName$K = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/AnnotationPublishControl.js";
function AnnotationPublishControl({
  group,
  isDisabled,
  isPrivate,
  onCancel,
  onSave,
  onSetPrivate,
  settings
}) {
  const buttonStyle = applyTheme(['ctaTextColor', 'ctaBackgroundColor'], settings);
  const menuLabel = o("div", {
    className: "w-9 h-9 flex items-center justify-center text-color-text-inverted",
    style: buttonStyle,
    children: o(Icon, {
      name: "expand-menu",
      classes: "w-4 h-4"
    }, void 0, false, {
      fileName: _jsxFileName$K,
      lineNumber: 53,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$K,
    lineNumber: 49,
    columnNumber: 5
  }, this);
  return o("div", {
    className: "flex flex-row gap-x-3",
    children: [o("div", {
      className: "flex relative",
      children: [o(LabeledButton, {
        classes: classnames(
        // Turn off right-side border radius to align with menu-open button
        'rounded-r-none'),
        "data-testid": "publish-control-button",
        style: buttonStyle,
        onClick: onSave,
        disabled: isDisabled,
        size: "large",
        variant: "primary",
        children: ["\u0627\u0644\u0646\u0634\u0631 \u0641\u064A ", isPrivate ? 'خاص بي' : group.name]
      }, void 0, true, {
        fileName: _jsxFileName$K,
        lineNumber: 60,
        columnNumber: 9
      }, this), o("div", {
        className: classnames(
        // Round the right side of this menu-open button only
        'flex flex-row rounded-r-sm bg-grey-7 hover:bg-grey-8'),
        style: buttonStyle,
        children: o(Menu, {
          arrowClass: classnames(
          // Position up-pointing menu caret aligned beneath the
          // down-pointing menu-open button icon
          'right-[10px]'),
          containerPositioned: false,
          contentClass: classnames(
          // Ensure the menu is wide enough to "reach" the right-aligned
          // up-pointing menu arrow
          'min-w-full'),
          label: menuLabel,
          menuIndicator: false,
          title: "Change annotation sharing setting",
          align: "left",
          children: [o(MenuItem, {
            icon: group.type === 'open' ? 'public' : 'groups',
            label: group.name,
            isSelected: !isPrivate,
            onClick: () => onSetPrivate(false)
          }, void 0, false, {
            fileName: _jsxFileName$K,
            lineNumber: 100,
            columnNumber: 13
          }, this), o(MenuItem, {
            icon: "lock",
            label: "Only Me",
            isSelected: isPrivate,
            onClick: () => onSetPrivate(true)
          }, void 0, false, {
            fileName: _jsxFileName$K,
            lineNumber: 106,
            columnNumber: 13
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName$K,
          lineNumber: 83,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$K,
        lineNumber: 76,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$K,
      lineNumber: 59,
      columnNumber: 7
    }, this), o("div", {
      children: o(LabeledButton, {
        classes: "p-2.5",
        icon: "cancel",
        onClick: onCancel,
        size: "large",
        children: "\u0627\u0644\u063A\u0627\u0621"
      }, void 0, false, {
        fileName: _jsxFileName$K,
        lineNumber: 116,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$K,
      lineNumber: 115,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$K,
    lineNumber: 58,
    columnNumber: 5
  }, this);
}
var AnnotationPublishControl$1 = withServices(AnnotationPublishControl, ['settings']);

var _jsxFileName$J = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/AnnotationEditor.js";
function AnnotationEditor({
  annotation,
  draft,
  annotationsService,
  settings,
  tags: tagsService,
  toastMessenger
}) {
  // Track the currently-entered text in the tag editor's input
  const [pendingTag, setPendingTag] = p( /** @type {string|null} */null);
  const store = useSidebarStore();
  const group = store.getGroup(annotation.group);
  const shouldShowLicense = !draft.isPrivate && group && group.type !== 'private';
  const tags = draft.tags;
  const text = draft.text;
  const isEmpty = !text && !tags.length;
  const onEditTags = T$1( /** @param {string[]} tags */
  tags => {
    store.createDraft(draft.annotation, {
      ...draft,
      tags
    });
  }, [draft, store]);
  const onAddTag = T$1(
  /**
   * Verify `newTag` has content and is not a duplicate; add the tag
   *
   * @param {string} newTag
   * @return {boolean} Tag was added to the draft's tags; `false` if duplicate
   *   or empty
   */
  newTag => {
    if (!newTag || tags.indexOf(newTag) >= 0) {
      // don't add empty or duplicate tags
      return false;
    }
    const tagList = [...tags, newTag];
    // Update the tag locally for the suggested-tag list
    tagsService.store(tagList);
    onEditTags(tagList);
    return true;
  }, [onEditTags, tags, tagsService]);
  const onRemoveTag = T$1(
  /**
   * Remove tag from draft if present.
   *
   * @param {string} tag
   * @return {boolean} Tag removed from draft
   */
  tag => {
    const newTagList = [...tags]; // make a copy
    const index = newTagList.indexOf(tag);
    if (index >= 0) {
      newTagList.splice(index, 1);
      onEditTags(newTagList);
      return true;
    }
    return false;
  }, [onEditTags, tags]);
  const onEditText = T$1( /** @param {string} text */
  text => {
    store.createDraft(draft.annotation, {
      ...draft,
      text
    });
  }, [draft, store]);

  /**
   * @param {boolean} isPrivate
   */
  const onSetPrivate = T$1( /** @param {boolean} isPrivate */
  isPrivate => {
    store.createDraft(annotation, {
      ...draft,
      isPrivate
    });
    // Persist this as privacy default for future annotations unless this is a reply
    if (!isReply(annotation)) {
      store.setDefault('annotationPrivacy', isPrivate ? 'private' : 'shared');
    }
  }, [annotation, draft, store]);
  const onSave = async () => {
    // If there is any content in the tag editor input field that has
    // not been committed as a tag, go ahead and add it as a tag
    // See https://github.com/hypothesis/product-backlog/issues/1122
    if (pendingTag) {
      onAddTag(pendingTag);
    }
    const successMessage = `${annotationRole(annotation)} ${isSaved(annotation) ? 'updated' : 'saved'}`;
    try {
      await annotationsService.save(annotation);
      toastMessenger.success(successMessage, {
        visuallyHidden: true
      });
    } catch (err) {
      toastMessenger.error('Saving annotation failed');
    }
  };

  // Revert changes to this annotation
  const onCancel = T$1(() => {
    store.removeDraft(annotation);
    if (!isSaved(annotation)) {
      store.removeAnnotations([annotation]);
    }
  }, [annotation, store]);

  // Allow saving of annotation by pressing CMD/CTRL-Enter
  /** @param {KeyboardEvent} event */
  const onKeyDown = event => {
    const key = event.key;
    if (isEmpty) {
      return;
    }
    if ((event.metaKey || event.ctrlKey) && key === 'Enter') {
      event.stopPropagation();
      event.preventDefault();
      onSave();
    }
  };
  const textStyle = applyTheme(['annotationFontFamily'], settings);
  return (/* eslint-disable-next-line jsx-a11y/no-static-element-interactions */
    o("div", {
      "data-testid": "annotation-editor",
      className: "space-y-4",
      onKeyDown: onKeyDown,
      children: [o(MarkdownEditor, {
        textStyle: textStyle,
        label: "Annotation body",
        text: text,
        onEditText: onEditText
      }, void 0, false, {
        fileName: _jsxFileName$J,
        lineNumber: 187,
        columnNumber: 7
      }, this), o(TagEditor$1, {
        onAddTag: onAddTag,
        onRemoveTag: onRemoveTag,
        onTagInput: setPendingTag,
        tagList: tags
      }, void 0, false, {
        fileName: _jsxFileName$J,
        lineNumber: 193,
        columnNumber: 7
      }, this), group && o(AnnotationPublishControl$1, {
        group: group,
        isDisabled: isEmpty,
        isPrivate: draft.isPrivate,
        onCancel: onCancel,
        onSave: onSave,
        onSetPrivate: onSetPrivate
      }, void 0, false, {
        fileName: _jsxFileName$J,
        lineNumber: 200,
        columnNumber: 9
      }, this), shouldShowLicense && o(AnnotationLicense, {}, void 0, false, {
        fileName: _jsxFileName$J,
        lineNumber: 209,
        columnNumber: 29
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$J,
      lineNumber: 182,
      columnNumber: 5
    }, this)
  );
}
var AnnotationEditor$1 = withServices(AnnotationEditor, ['annotationsService', 'settings', 'tags', 'toastMessenger']);

var _jsxFileName$I = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/AnnotationDocumentInfo.tsx";
/**
 * Render some metadata about an annotation's document and link to it
 * if a link is available.
 *
 * @param {AnnotationDocumentInfoProps} props
 */
function AnnotationDocumentInfo({
  domain,
  link,
  title
}) {
  return o("div", {
    className: "flex gap-x-1",
    children: [o("div", {
      className: "text-color-text-light",
      children: ["on \"", link ? o(LinkNext, {
        href: link,
        target: "_blank",
        children: title
      }, void 0, false, {
        fileName: _jsxFileName$I,
        lineNumber: 26,
        columnNumber: 11
      }, this) : o("span", {
        children: title
      }, void 0, false, {
        fileName: _jsxFileName$I,
        lineNumber: 30,
        columnNumber: 11
      }, this), "\""]
    }, void 0, true, {
      fileName: _jsxFileName$I,
      lineNumber: 23,
      columnNumber: 7
    }, this), domain && o("span", {
      className: "text-color-text-light",
      children: ["(", domain, ")"]
    }, void 0, true, {
      fileName: _jsxFileName$I,
      lineNumber: 34,
      columnNumber: 18
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$I,
    lineNumber: 22,
    columnNumber: 5
  }, this);
}

var _jsxFileName$H = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/AnnotationShareInfo.js";
function AnnotationShareInfo({
  group,
  isPrivate
}) {
  // Only show the name of the group and link to it if there is a
  // URL (link) returned by the API for this group. Some groups do not have links
  const linkToGroup = group === null || group === void 0 ? void 0 : group.links.html;
  return o(p$2, {
    children: [group && linkToGroup && o(Link, {
      classes: classnames('flex items-baseline gap-x-1', 'p-muted-link'),
      href: group.links.html,
      target: "_blank",
      children: [o(Icon, {
        classes: "text-tiny",
        name: group.type === 'open' ? 'public' : 'groups'
      }, void 0, false, {
        fileName: _jsxFileName$H,
        lineNumber: 33,
        columnNumber: 11
      }, this), o("span", {
        children: group.name
      }, void 0, false, {
        fileName: _jsxFileName$H,
        lineNumber: 37,
        columnNumber: 11
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$H,
      lineNumber: 28,
      columnNumber: 9
    }, this), isPrivate && !linkToGroup && o("div", {
      className: "text-color-text-light",
      "data-testid": "private-info",
      children: "Only me"
    }, void 0, false, {
      fileName: _jsxFileName$H,
      lineNumber: 41,
      columnNumber: 9
    }, this)]
  }, void 0, true);
}

const SECOND = 1000;
const MINUTE = 60 * SECOND;
const HOUR = 60 * MINUTE;

/**
 * Map of stringified `DateTimeFormatOptions` to cached `DateTimeFormat` instances.
 *
 * @type {Record<string, Intl.DateTimeFormat>}
 */
let formatters = {};

/**
 * Clears the cache of formatters.
 */
function clearFormatters() {
  formatters = {};
}

/**
 * Calculate time delta in milliseconds between two `Date` objects
 *
 * @param {Date} date
 * @param {Date} now
 */
function delta(date, now) {
  // @ts-ignore
  return now - date;
}

/**
 * Return date string formatted with `options`.
 *
 * This is a caching wrapper for `Intl.DateTimeFormat.format`, useful because
 * constructing a `DateTimeFormat` is expensive.
 *
 * @param {Date} date
 * @param {Intl.DateTimeFormatOptions} options
 * @param {Intl} Intl - Test seam. JS `Intl` API implementation.
 * @return {string}
 */
function format(date, options, Intl = window.Intl) {
  const key = JSON.stringify(options);
  let formatter = formatters[key];
  if (!formatter) {
    formatter = formatters[key] = new Intl.DateTimeFormat(undefined, options);
  }
  return formatter.format(date);
}

/**
 * @callback DateFormatter
 * @param {Date} date
 * @param {Date} now
 * @param {Intl} [intl]
 * @return {string} formatted date
 */

/** @type {DateFormatter} */
function nSec(date, now) {
  const n = Math.floor(delta(date, now) / SECOND);
  return `${n} secs ago`;
}

/** @type {DateFormatter} */
function nMin(date, now) {
  const n = Math.floor(delta(date, now) / MINUTE);
  const plural = n > 1 ? 's' : '';
  return `${n} min${plural} ago`;
}

/** @type {DateFormatter} */
function nHr(date, now) {
  const n = Math.floor(delta(date, now) / HOUR);
  const plural = n > 1 ? 's' : '';
  return `${n} hr${plural} ago`;
}

/** @type {DateFormatter} */
function dayAndMonth(date, now, Intl) {
  return format(date, {
    month: 'short',
    day: 'numeric'
  }, Intl);
}

/** @type {DateFormatter} */
function dayAndMonthAndYear(date, now, Intl) {
  return format(date, {
    day: 'numeric',
    month: 'short',
    year: 'numeric'
  }, Intl);
}

/**
 * @typedef Breakpoint
 * @prop {(date: Date, now: Date) => boolean} test
 * @prop {(date: Date, now: Date, Intl?: typeof window.Intl) => string} formatter
 * @prop {number|null} nextUpdate
 */

/** @type {Breakpoint[]} */
const BREAKPOINTS = [{
  // Less than 30 seconds
  test: (date, now) => delta(date, now) < 30 * SECOND,
  formatter: () => 'Just now',
  nextUpdate: 1 * SECOND
}, {
  // Less than 1 minute
  test: (date, now) => delta(date, now) < 1 * MINUTE,
  formatter: nSec,
  nextUpdate: 1 * SECOND
}, {
  // Less than one hour
  test: (date, now) => delta(date, now) < 1 * HOUR,
  formatter: nMin,
  nextUpdate: 1 * MINUTE
}, {
  // Less than one day
  test: (date, now) => delta(date, now) < 24 * HOUR,
  formatter: nHr,
  nextUpdate: 1 * HOUR
}, {
  // This year
  test: (date, now) => date.getFullYear() === now.getFullYear(),
  formatter: dayAndMonth,
  nextUpdate: null
}];

/** @type {Breakpoint} */
const DEFAULT_BREAKPOINT = {
  test: /* istanbul ignore next */() => true,
  formatter: dayAndMonthAndYear,
  nextUpdate: null
};

/**
 * Returns a dict that describes how to format the date based on the delta
 * between date and now.
 *
 * @param {Date} date - The date to consider as the timestamp to format.
 * @param {Date} now - The date to consider as the current time.
 * @return {Breakpoint} An object that describes how to format the date.
 */
function getBreakpoint(date, now) {
  for (let breakpoint of BREAKPOINTS) {
    if (breakpoint.test(date, now)) {
      return breakpoint;
    }
  }
  return DEFAULT_BREAKPOINT;
}

/**
 * See https://262.ecma-international.org/6.0/#sec-time-values-and-time-range
 *
 * @param {Date} date
 */
function isDateValid(date) {
  return !isNaN(date.valueOf());
}

/**
 * Return the number of milliseconds until the next update for a given date
 * should be handled, based on the delta between `date` and `now`.
 *
 * @param {Date|null} date
 * @param {Date} now
 * @return {Number|null} - ms until next update or `null` if no update
 *                         should occur
 */
function nextFuzzyUpdate(date, now) {
  if (!date || !isDateValid(date) || !isDateValid(now)) {
    return null;
  }
  let nextUpdate = getBreakpoint(date, now).nextUpdate;
  if (nextUpdate === null) {
    return null;
  }

  // We don't want to refresh anything more often than 5 seconds
  nextUpdate = Math.max(nextUpdate, 5 * SECOND);

  // setTimeout limit is MAX_INT32=(2^31-1) (in ms),
  // which is about 24.8 days. So we don't set up any timeouts
  // longer than 24 days, that is, 2073600 seconds.
  nextUpdate = Math.min(nextUpdate, 2073600 * SECOND);
  return nextUpdate;
}

/**
 * Start an interval whose frequency depends on the age of a timestamp.
 *
 * This is useful for refreshing UI components displaying timestamps generated
 * by `formatRelativeDate`, since the output changes less often for older timestamps.
 *
 * @param {string} date - Date string to use to determine the interval frequency
 * @param {() => void} callback - Interval callback
 * @return {() => void} A function that cancels the interval
 */
function decayingInterval(date, callback) {
  /** @type {number|undefined} */
  let timer;
  const timestamp = new Date(date);
  const update = () => {
    const fuzzyUpdate = nextFuzzyUpdate(timestamp, new Date());
    if (fuzzyUpdate === null) {
      return;
    }
    const nextUpdate = fuzzyUpdate + 500;
    timer = setTimeout(() => {
      callback();
      update();
    }, nextUpdate);
  };
  update();
  return () => clearTimeout(timer);
}

/**
 * Formats a date as a short approximate string relative to the current date.
 *
 * The level of precision is proportional to how recent the date is.
 *
 * For example:
 *
 *  - "Just now"
 *  - "5 minutes ago"
 *  - "25 Oct 2018"
 *
 * @param {Date|null} date - The date to consider as the timestamp to format.
 * @param {Date} now - The date to consider as the current time.
 * @param {Intl} [Intl] - Test seam. JS `Intl` API implementation.
 * @return {string} A 'fuzzy' string describing the relative age of the date.
 */
function formatRelativeDate(date, now, Intl) {
  if (!date) {
    return '';
  }
  return getBreakpoint(date, now).formatter(date, now, Intl);
}

/**
 * Formats a date as an absolute string in a human readable format.
 *
 * The exact format will vary depending on the locale, but the verbosity will
 * be consistent across locales. In en-US for example this will look like:
 *
 *  "Sunday, Dec 17, 2017, 10:00 AM"
 *
 * @param {Date} date
 * @param {Intl} [Intl] - Test seam. JS `Intl` API implementation.
 * @return {string}
 */
function formatDate(date, Intl) {
  return format(date, {
    year: 'numeric',
    month: 'short',
    day: '2-digit',
    weekday: 'long',
    hour: '2-digit',
    minute: '2-digit'
  }, Intl);
}

var _jsxFileName$G = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/AnnotationTimestamps.tsx";
/**
 * Render textual timestamp information for an annotation. This includes
 * a relative date string (e.g. "5 hours ago") for the annotation's creation,
 * and, if `withEditedTimestamp` is `true`, a relative date string for when it
 * was last edited. If the `annotation` has an HTML link, the created-date
 * timestamp will be linked to that URL (the single-annotation view
 * for this annotation).
 *
 * @param {AnnotationTimestampsProps} props
 */
function AnnotationTimestamps({
  annotationCreated,
  annotationUpdated,
  annotationURL,
  withEditedTimestamp
}) {
  // "Current" time, used when calculating the relative age of `timestamp`.
  const [now, setNow] = p(() => new Date());
  const createdDate = F(() => new Date(annotationCreated), [annotationCreated]);
  const updatedDate = F(() => withEditedTimestamp && new Date(annotationUpdated), [annotationUpdated, withEditedTimestamp]);
  const created = F(() => {
    return {
      absolute: formatDate(createdDate),
      relative: formatRelativeDate(createdDate, now)
    };
  }, [createdDate, now]);
  const updated = F(() => {
    if (!updatedDate) {
      return {};
    }
    return {
      absolute: formatDate(updatedDate),
      relative: formatRelativeDate(updatedDate, now)
    };
  }, [updatedDate, now]);

  // Refresh relative timestamp, at a frequency appropriate for the age.
  h(() => {
    // Determine which of the two Dates to use for the `decayingInterval`
    // It should be the latest relevant date, as the interval will be
    // shorter the closer the date is to "now"
    const laterDate = updatedDate ? annotationUpdated : annotationCreated;
    const cancelRefresh = decayingInterval(laterDate, () => setNow(new Date()));
    return cancelRefresh;
  }, [annotationCreated, annotationUpdated, createdDate, updatedDate, now]);

  // Do not show the relative timestamp for the edited date if it is the same
  // as the relative timestamp for the created date
  const editedString = updated && updated.relative !== created.relative ? `edited ${updated.relative}` : 'edited';
  return o("div", {
    children: [withEditedTimestamp && o("span", {
      className: "text-color-text-light text-sm italic",
      "data-testid": "timestamp-edited",
      title: updated.absolute,
      children: ["(", editedString, ")", ' ']
    }, void 0, true, {
      fileName: _jsxFileName$G,
      lineNumber: 82,
      columnNumber: 9
    }, this), annotationURL ? o(LinkBaseNext
    // The light-text hover color is not a standard color for a Link, so
    // LinkBase is used here
    , {
      classes: "text-color-text-light hover:text-color-text-light hover:underline",
      target: "_blank",
      title: created.absolute,
      href: annotationURL,
      children: created.relative
    }, void 0, false, {
      fileName: _jsxFileName$G,
      lineNumber: 91,
      columnNumber: 9
    }, this) : o("span", {
      className: "color-text-color-light",
      "data-testid": "timestamp-created",
      title: created.absolute,
      children: created.relative
    }, void 0, false, {
      fileName: _jsxFileName$G,
      lineNumber: 102,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$G,
    lineNumber: 80,
    columnNumber: 5
  }, this);
}

var _jsxFileName$F = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/AnnotationUser.js";
function AnnotationUser({
  authorLink,
  displayName
}) {
  const user = o("h3", {
    className: "text-color-text font-bold",
    children: displayName
  }, void 0, false, {
    fileName: _jsxFileName$F,
    lineNumber: 16,
    columnNumber: 16
  }, this);
  if (authorLink) {
    return o(LinkBaseNext, {
      href: authorLink,
      target: "_blank",
      children: user
    }, void 0, false, {
      fileName: _jsxFileName$F,
      lineNumber: 20,
      columnNumber: 7
    }, this);
  }
  return o("div", {
    children: user
  }, void 0, false, {
    fileName: _jsxFileName$F,
    lineNumber: 26,
    columnNumber: 10
  }, this);
}

var _jsxFileName$E = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/AnnotationHeader.tsx";
/**
 * Render an annotation's header summary, including metadata about its user,
 * sharing status, document and timestamp. It also allows the user to
 * toggle sub-threads/replies in certain cases.
 *
 * @param {AnnotationHeaderProps} props
 */
function AnnotationHeader({
  annotation,
  isEditing,
  replyCount,
  threadIsCollapsed,
  settings
}) {
  var _annotation$links;
  const store = useSidebarStore();
  const defaultAuthority = store.defaultAuthority();
  const displayNamesEnabled = store.isFeatureEnabled('client_display_names');
  const userURL = store.getLink('user', {
    user: annotation.user
  });
  const authorName = F(() => annotationDisplayName(annotation, defaultAuthority, displayNamesEnabled), [annotation, defaultAuthority, displayNamesEnabled]);
  const authorLink = F(() => annotationAuthorLink(annotation, settings, defaultAuthority, userURL), [annotation, settings, defaultAuthority, userURL]);
  const isCollapsedReply = isReply(annotation) && threadIsCollapsed;

  // Link (URL) to single-annotation view for this annotation, if it has
  // been provided by the service. Note: this property is not currently
  // present on third-party annotations.
  const annotationURL = ((_annotation$links = annotation.links) === null || _annotation$links === void 0 ? void 0 : _annotation$links.html) || '';
  const showEditedTimestamp = F(() => {
    return hasBeenEdited(annotation) && !isCollapsedReply;
  }, [annotation, isCollapsedReply]);

  // Pull together some document metadata related to this annotation
  const documentInfo = domainAndTitle(annotation);
  // There are some cases at present in which linking directly to an
  // annotation's document is not immediately feasible—e.g in an LMS context
  // where the original document might not be available outside of an
  // assignment (e.g. Canvas files), and/or wouldn't be able to present
  // any associated annotations.
  // For the present, disable links to annotation documents for all third-party
  // annotations until we have a more nuanced way of making linking determinations.
  // The absence of a link to a single-annotation view is a signal that this
  // is a third-party annotation.
  // Also, of course, verify that there is a URL to the document (titleLink)
  const documentLink = annotationURL && documentInfo.titleLink ? documentInfo.titleLink : '';
  // Show document information on non-sidebar routes, assuming there is a title
  // to show, at the least
  const showDocumentInfo = store.route() !== 'sidebar' && documentInfo.titleText;
  const onReplyCountClick = () =>
  // If an annotation has replies it must have been saved and therefore have
  // an ID.
  store.setExpanded(annotation.id, true);
  const group = store.getGroup(annotation.group);
  return o("header", {
    children: [o("div", {
      className: "flex gap-x-1 items-baseline flex-wrap-reverse",
      children: [isPrivate(annotation.permissions) && !isEditing && o(LockIcon, {
        className: "text-tiny w-em h-em",
        title: "This annotation is visible only to you"
      }, void 0, false, {
        fileName: _jsxFileName$E,
        lineNumber: 112,
        columnNumber: 11
      }, this), o(AnnotationUser, {
        authorLink: authorLink,
        displayName: authorName
      }, void 0, false, {
        fileName: _jsxFileName$E,
        lineNumber: 117,
        columnNumber: 9
      }, this), replyCount > 0 && isCollapsedReply && o(LinkButtonNext, {
        color: "text-light",
        onClick: onReplyCountClick,
        title: "Expand replies",
        underline: "hover",
        children: `${replyCount} ${replyCount > 1 ? 'replies' : 'reply'}`
      }, void 0, false, {
        fileName: _jsxFileName$E,
        lineNumber: 119,
        columnNumber: 11
      }, this), !isEditing && annotation.created && o("div", {
        className: "flex justify-end grow",
        children: o(AnnotationTimestamps, {
          annotationCreated: annotation.created,
          annotationUpdated: annotation.updated,
          annotationURL: annotationURL,
          withEditedTimestamp: showEditedTimestamp
        }, void 0, false, {
          fileName: _jsxFileName$E,
          lineNumber: 131,
          columnNumber: 13
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$E,
        lineNumber: 130,
        columnNumber: 11
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$E,
      lineNumber: 110,
      columnNumber: 7
    }, this), !isReply(annotation) && o("div", {
      className: "flex gap-x-1 items-baseline flex-wrap-reverse",
      "data-testid": "extended-header-info",
      children: [group && o(AnnotationShareInfo, {
        group: group,
        isPrivate: isPrivate(annotation.permissions)
      }, void 0, false, {
        fileName: _jsxFileName$E,
        lineNumber: 147,
        columnNumber: 13
      }, this), !isEditing && isHighlight(annotation) && o(HighlightIcon, {
        title: "This is a highlight. Click 'edit' to add a note or tag.",
        className: "text-tiny w-em h-em text-color-text-light"
      }, void 0, false, {
        fileName: _jsxFileName$E,
        lineNumber: 153,
        columnNumber: 13
      }, this), showDocumentInfo && o(AnnotationDocumentInfo, {
        domain: documentInfo.domain,
        link: documentLink,
        title: documentInfo.titleText
      }, void 0, false, {
        fileName: _jsxFileName$E,
        lineNumber: 159,
        columnNumber: 13
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$E,
      lineNumber: 142,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$E,
    lineNumber: 109,
    columnNumber: 5
  }, this);
}
var AnnotationHeader$1 = withServices(AnnotationHeader, ['settings']);

var _jsxFileName$D = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/AnnotationQuote.js";
function AnnotationQuote({
  quote,
  isHovered,
  isOrphan,
  settings
}) {
  return o(Excerpt$1, {
    collapsedHeight: 35,
    inlineControls: true,
    overflowThreshold: 20,
    children: o(StyledText, {
      classes: classnames({
        'p-redacted-text': isOrphan
      }),
      children: o("blockquote", {
        className: classnames('hover:border-l-blue-quote', {
          'border-l-blue-quote': isHovered
        }),
        style: applyTheme(['selectionFontFamily'], settings),
        children: quote
      }, void 0, false, {
        fileName: _jsxFileName$D,
        lineNumber: 30,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$D,
      lineNumber: 29,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$D,
    lineNumber: 28,
    columnNumber: 5
  }, this);
}
var AnnotationQuote$1 = withServices(AnnotationQuote, ['settings']);

var _jsxFileName$C = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/AnnotationReplyToggle.js";
function AnnotationReplyToggle({
  onToggleReplies,
  replyCount,
  threadIsCollapsed
}) {
  const toggleAction = threadIsCollapsed ? 'Show replies' : 'Hide replies';
  const toggleText = `${toggleAction} (${replyCount})`;
  return o(LinkButton, {
    onClick: onToggleReplies,
    title: toggleText,
    children: toggleText
  }, void 0, false, {
    fileName: _jsxFileName$C,
    lineNumber: 25,
    columnNumber: 5
  }, this);
}

var _jsxFileName$B = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/Annotation.tsx";
function SavingMessage() {
  return o("div", {
    className: classnames('flex grow justify-end items-center gap-x-1',
    // Make sure height matches that of action-bar icons so that there
    // isn't a height change when transitioning in and out of saving state
    'h-8 touch:h-touch-minimum'),
    "data-testid": "saving-message",
    children: [o("span", {
      // Slowly fade in the Spinner such that it only shows up if the saving
      // is slow
      className: "text-xl animate-fade-in-slow",
      children: o(SpinnerNext, {
        size: "sm"
      }, void 0, false, {
        fileName: _jsxFileName$B,
        lineNumber: 40,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$B,
      lineNumber: 35,
      columnNumber: 7
    }, this), o("div", {
      className: "text-color-text-light font-medium",
      children: "Saving..."
    }, void 0, false, {
      fileName: _jsxFileName$B,
      lineNumber: 42,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$B,
    lineNumber: 26,
    columnNumber: 5
  }, this);
}
/**
 * A single annotation.
 *
 * @param {AnnotationProps} props
 */
function Annotation({
  annotation,
  isReply,
  onToggleReplies,
  replyCount,
  threadIsCollapsed,
  annotationsService
}) {
  const store = useSidebarStore();
  const annotationQuote = quote(annotation);
  const draft = store.getDraft(annotation);
  const userid = store.profile().userid;
  const isHovered = store.isAnnotationHovered(annotation.$tag);
  const isSaving = store.isSavingAnnotation(annotation);
  const isEditing = !!draft && !isSaving;
  const isCollapsedReply = isReply && threadIsCollapsed;
  const showActions = !isSaving && !isEditing && isSaved(annotation);
  const defaultAuthority = store.defaultAuthority();
  const displayNamesEnabled = store.isFeatureEnabled('client_display_names');
  const onReply = () => {
    if (isSaved(annotation) && userid) {
      annotationsService.reply(annotation, userid);
    }
  };
  const authorName = F(() => annotationDisplayName(annotation, defaultAuthority, displayNamesEnabled), [annotation, defaultAuthority, displayNamesEnabled]);
  const annotationDescription = isSaved(annotation) ? annotationRole(annotation) : `New ${annotationRole(annotation).toLowerCase()}`;
  return o("article", {
    className: "space-y-4",
    "aria-label": `${annotationDescription} by ${authorName}`,
    children: [o(AnnotationHeader$1, {
      annotation: annotation,
      isEditing: isEditing,
      replyCount: replyCount,
      threadIsCollapsed: threadIsCollapsed
    }, void 0, false, {
      fileName: _jsxFileName$B,
      lineNumber: 115,
      columnNumber: 7
    }, this), annotationQuote && o(AnnotationQuote$1, {
      quote: annotationQuote,
      isHovered: isHovered,
      isOrphan: isOrphan(annotation)
    }, void 0, false, {
      fileName: _jsxFileName$B,
      lineNumber: 123,
      columnNumber: 9
    }, this), !isCollapsedReply && !isEditing && o(AnnotationBody$1, {
      annotation: annotation
    }, void 0, false, {
      fileName: _jsxFileName$B,
      lineNumber: 131,
      columnNumber: 9
    }, this), isEditing && o(AnnotationEditor$1, {
      annotation: annotation,
      draft: draft
    }, void 0, false, {
      fileName: _jsxFileName$B,
      lineNumber: 134,
      columnNumber: 21
    }, this), !isCollapsedReply && o("footer", {
      className: "flex items-center",
      children: [onToggleReplies && o(AnnotationReplyToggle, {
        onToggleReplies: onToggleReplies,
        replyCount: replyCount,
        threadIsCollapsed: threadIsCollapsed
      }, void 0, false, {
        fileName: _jsxFileName$B,
        lineNumber: 139,
        columnNumber: 13
      }, this), isSaving && o(SavingMessage, {}, void 0, false, {
        fileName: _jsxFileName$B,
        lineNumber: 145,
        columnNumber: 24
      }, this), showActions && o(CardActionsNext, {
        classes: "grow",
        children: o(AnnotationActionBar$1, {
          annotation: annotation,
          onReply: onReply
        }, void 0, false, {
          fileName: _jsxFileName$B,
          lineNumber: 148,
          columnNumber: 15
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$B,
        lineNumber: 147,
        columnNumber: 13
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$B,
      lineNumber: 137,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$B,
    lineNumber: 111,
    columnNumber: 5
  }, this);
}
var Annotation$1 = withServices(Annotation, ['annotationsService']);

var _jsxFileName$A = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Annotation/EmptyAnnotation.js";
function EmptyAnnotation({
  isReply,
  replyCount,
  threadIsCollapsed,
  onToggleReplies
}) {
  return o("article", {
    className: "space-y-4",
    "aria-label": `${isReply ? 'Reply' : 'Annotation'} with unavailable content`,
    children: [o("div", {
      children: o("em", {
        children: "Message not available."
      }, void 0, false, {
        fileName: _jsxFileName$A,
        lineNumber: 29,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$A,
      lineNumber: 28,
      columnNumber: 7
    }, this), onToggleReplies && o("footer", {
      className: "flex items-center",
      children: o(AnnotationReplyToggle, {
        onToggleReplies: onToggleReplies,
        replyCount: replyCount,
        threadIsCollapsed: threadIsCollapsed
      }, void 0, false, {
        fileName: _jsxFileName$A,
        lineNumber: 33,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$A,
      lineNumber: 32,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$A,
    lineNumber: 22,
    columnNumber: 5
  }, this);
}

var _jsxFileName$z = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/ModerationBanner.js";
function ModerationBanner({
  annotation,
  api,
  toastMessenger
}) {
  const store = useSidebarStore();
  const flagCount$1 = flagCount(annotation);
  const isHiddenOrFlagged = flagCount$1 !== null && (flagCount$1 > 0 || annotation.hidden);

  /**
   * Hide an annotation from non-moderator users.
   */
  const hideAnnotation = () => {
    const id = /** @type {string} */annotation.id;
    api.annotation.hide({
      id
    }).then(() => {
      store.hideAnnotation(id);
    }).catch(() => {
      toastMessenger.error('Failed to hide annotation');
    });
  };

  /**
   * Un-hide an annotation from non-moderator users.
   */
  const unhideAnnotation = () => {
    const id = /** @type {string} */annotation.id;
    api.annotation.unhide({
      id
    }).then(() => {
      store.unhideAnnotation(id);
    }).catch(() => {
      toastMessenger.error('Failed to unhide annotation');
    });
  };
  if (!isHiddenOrFlagged) {
    return null;
  }
  return o("div", {
    className: classnames('flex gap-x-3 bg-grey-1 text-color-text font-semibold',
    // Vertical margins should ultimately be handled by the parent, but
    // until we can refactor outer components (e.g. `ThreadCard`), this
    // component manages its own bottom margin
    'mb-2 ', {
      // For top-level annotations, use negative margins to "break out" of
      // the parent card's 3-unit padding and have the banner span the
      // full card width with no padding
      '-mt-3 -ml-3 -mr-3': !isReply(annotation),
      // For replies, break out of the right padding only
      '-mr-3': isReply(annotation)
    }),
    children: [o("div", {
      className: classnames('p-3 text-white', {
        'bg-red-error': !annotation.hidden,
        'bg-grey-6': annotation.hidden
      }),
      children: o(Icon, {
        name: annotation.hidden ? 'hide' : 'flag'
      }, void 0, false, {
        fileName: _jsxFileName$z,
        lineNumber: 91,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$z,
      lineNumber: 85,
      columnNumber: 7
    }, this), o("div", {
      className: "self-center grow",
      children: [!annotation.hidden && o("span", {
        children: ["Flagged for review by ", flagCount$1, ' ', flagCount$1 === 1 ? 'user' : 'users']
      }, void 0, true, {
        fileName: _jsxFileName$z,
        lineNumber: 95,
        columnNumber: 11
      }, this), annotation.hidden && o("span", {
        children: "Hidden from users"
      }, void 0, false, {
        fileName: _jsxFileName$z,
        lineNumber: 100,
        columnNumber: 31
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$z,
      lineNumber: 93,
      columnNumber: 7
    }, this), o("div", {
      className: "self-center pr-2",
      children: o(LabeledButton, {
        classes: "py-1 bg-slate-1",
        onClick: annotation.hidden ? unhideAnnotation : hideAnnotation,
        title: annotation.hidden ? 'Make this annotation visible to everyone' : 'Hide this annotationn from non-moderators',
        variant: "dark",
        children: annotation.hidden ? 'Unhide' : 'Hide'
      }, void 0, false, {
        fileName: _jsxFileName$z,
        lineNumber: 103,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$z,
      lineNumber: 102,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$z,
    lineNumber: 68,
    columnNumber: 5
  }, this);
}
var ModerationBanner$1 = withServices(ModerationBanner, ['api', 'toastMessenger']);

var _jsxFileName$y = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Thread.js";
function ThreadCollapseControl({
  threadIsCollapsed,
  onToggleReplies
}) {
  const toggleIcon = threadIsCollapsed ? 'collapsed' : 'expand-menu';
  const toggleTitle = threadIsCollapsed ? 'Expand replies' : 'Collapse replies';
  return o("div", {
    className: classnames(
    // ThreadCards set a pointer cursor. Set cursor to auto so that
    // hovering over non-clickable parts of this gutter area do not show a
    // pointer.
    'cursor-auto', {
      'bg-thread-line': !threadIsCollapsed
    }),
    "data-testid": "thread-collapse-channel",
    children: o("div", {
      className: classnames(
      // Set a background color so the dashed line in the background
      // doesn't show through the button
      'bg-white'),
      children: o(IconButton, {
        classes: classnames(
        // Pull the button up a little to align horizontally with the
        // thread/annotation's header. Override large touch targets for
        // touch interfaces; we need to conserve space here
        '-mt-1 touch:min-w-[auto] touch:min-h-[auto]'),
        expanded: !threadIsCollapsed,
        icon: toggleIcon,
        title: toggleTitle,
        onClick: onToggleReplies,
        size: "medium",
        variant: "light"
      }, void 0, false, {
        fileName: _jsxFileName$y,
        lineNumber: 48,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$y,
      lineNumber: 41,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$y,
    lineNumber: 29,
    columnNumber: 5
  }, this);
}

/**
 * @typedef ThreadProps
 * @prop {Thread} thread
 * @prop {import('../services/threads').ThreadsService} threadsService
 */

/**
 * A thread, which contains a single annotation at its top level, and its
 * recursively-rendered children (i.e. replies).
 *
 * - Threads with parents (replies) may be "collapsed". Top-level threads are
 *   never collapsed.
 * - Any thread may be "hidden" because it does not match current filters.
 *
 * Each reply thread renders as a two-column "row", with a control to toggle
 * the thread's collapsed state at left and the content for the thread and its
 * children to the right.
 *
 * Top-level threads do not render a collapse control, as they are not
 * collapsible.
 *
 * @param {ThreadProps} props
 */
function Thread({
  thread,
  threadsService
}) {
  const isReply = !!thread.parent;

  // If rendering child threads, only render those that have at least one
  // visible item within them—i.e. don't render empty/totally-hidden threads.
  const visibleChildren = thread.children.filter(child => countVisible(child) > 0);
  const store = useSidebarStore();
  const hasAppliedFilter = store.hasAppliedFilter();
  const isSaving = thread.annotation && store.isSavingAnnotation(thread.annotation);
  const isEditing = thread.annotation && !!store.getDraft(thread.annotation) && !isSaving;
  const onToggleReplies = T$1(() => store.setExpanded(thread.id, !!thread.collapsed), [store, thread.id, thread.collapsed]);
  const showReplyToggle = !isReply && !isEditing && !hasAppliedFilter && thread.replyCount > 0;

  // Memoize annotation content to avoid re-rendering an annotation when content
  // in other annotations/threads change.
  const annotationContent = F(() => thread.visible && o(p$2, {
    children: thread.annotation ? o(p$2, {
      children: [o(ModerationBanner$1, {
        annotation: thread.annotation
      }, void 0, false, {
        fileName: _jsxFileName$y,
        lineNumber: 122,
        columnNumber: 15
      }, this), o(Annotation$1, {
        annotation: thread.annotation,
        isReply: isReply,
        onToggleReplies: showReplyToggle ? onToggleReplies : undefined,
        replyCount: thread.replyCount,
        threadIsCollapsed: thread.collapsed
      }, void 0, false, {
        fileName: _jsxFileName$y,
        lineNumber: 123,
        columnNumber: 15
      }, this)]
    }, void 0, true) : o(EmptyAnnotation, {
      isReply: isReply,
      onToggleReplies: showReplyToggle ? onToggleReplies : undefined,
      replyCount: thread.replyCount,
      threadIsCollapsed: thread.collapsed
    }, void 0, false, {
      fileName: _jsxFileName$y,
      lineNumber: 132,
      columnNumber: 13
    }, this)
  }, void 0, false), [isReply, onToggleReplies, showReplyToggle, thread.annotation, thread.replyCount, thread.collapsed, thread.visible]);
  return o("section", {
    className: "flex",
    "data-testid": "thread-container",
    children: [isReply && o(ThreadCollapseControl, {
      threadIsCollapsed: thread.collapsed,
      onToggleReplies: onToggleReplies
    }, void 0, false, {
      fileName: _jsxFileName$y,
      lineNumber: 155,
      columnNumber: 9
    }, this), o("div", {
      className: classnames(
      // Set a max-width to ensure that annotation content does not exceed
      // the width of the container
      'grow max-w-full'),
      "data-testid": "thread-content",
      children: [annotationContent, countHidden(thread) > 0 && o("div", {
        className: "space-y-2",
        children: [!thread.parent && thread.annotation && o(AnnotationHeader$1, {
          annotation: thread.annotation,
          isEditing: isEditing,
          replyCount: thread.replyCount,
          threadIsCollapsed: thread.collapsed
        }, void 0, false, {
          fileName: _jsxFileName$y,
          lineNumber: 181,
          columnNumber: 15
        }, this), o("div", {
          children: o(LabeledButton, {
            onClick: () => threadsService.forceVisible(thread),
            children: ["Show ", countHidden(thread), " more in conversation"]
          }, void 0, true, {
            fileName: _jsxFileName$y,
            lineNumber: 189,
            columnNumber: 15
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName$y,
          lineNumber: 188,
          columnNumber: 13
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName$y,
        lineNumber: 172,
        columnNumber: 11
      }, this), !thread.collapsed && o("ul", {
        className: classnames(
        // Pull this list to the left to bring it closer to the left edge
        // of the ThreadCard and give more space for nested replies' content
        '-ml-3'),
        "data-testid": "thread-children",
        children: visibleChildren.map(child => o("li", {
          className: classnames('mt-2',
          // Ensure correct rendering of replies with RTL content.
          // See https://github.com/hypothesis/client/issues/4705.
          '[text-align:start]'),
          children: o(Thread, {
            thread: child,
            threadsService: threadsService
          }, void 0, false, {
            fileName: _jsxFileName$y,
            lineNumber: 217,
            columnNumber: 17
          }, this)
        }, child.id, false, {
          fileName: _jsxFileName$y,
          lineNumber: 208,
          columnNumber: 15
        }, this))
      }, void 0, false, {
        fileName: _jsxFileName$y,
        lineNumber: 199,
        columnNumber: 11
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$y,
      lineNumber: 161,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$y,
    lineNumber: 153,
    columnNumber: 5
  }, this);
}
var Thread$1 = withServices(Thread, ['threadsService']);

var _jsxFileName$x = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/ThreadCard.js";
function ThreadCard({
  frameSync,
  thread
}) {
  var _thread$annotation$$t, _thread$annotation;
  const store = useSidebarStore();
  const threadTag = (_thread$annotation$$t = (_thread$annotation = thread.annotation) === null || _thread$annotation === void 0 ? void 0 : _thread$annotation.$tag) !== null && _thread$annotation$$t !== void 0 ? _thread$annotation$$t : null;
  const isHovered = threadTag && store.isAnnotationHovered(threadTag);
  const focusThreadAnnotation = F(() => lodash_debounce( /** @param {Annotation|null} ann */
  ann => frameSync.hoverAnnotation(ann), 10), [frameSync]);
  const scrollToAnnotation = T$1( /** @param {Annotation} ann */
  ann => {
    frameSync.scrollToAnnotation(ann);
  }, [frameSync]);

  /**
   * Is the target's event an <a> or <button> element, or does it have
   * either as an ancestor?
   *
   * @param {Element} target
   */
  const isFromButtonOrLink = target => {
    return !!target.closest('button') || !!target.closest('a');
  };

  // Memoize threads to reduce avoid re-rendering when something changes in a
  // parent component but the `Thread` itself has not changed.
  const threadContent = F(() => o(Thread$1, {
    thread: thread
  }, void 0, false, {
    fileName: _jsxFileName$x,
    lineNumber: 62,
    columnNumber: 39
  }, this), [thread]);

  // Handle requests to give this thread keyboard focus.
  const focusRequest = store.annotationFocusRequest();
  const cardRef = _$1( /** @type {HTMLElement|null} */null);
  h(() => {
    if (focusRequest !== thread.id || !cardRef.current) {
      return;
    }
    cardRef.current.focus();
    store.clearAnnotationFocusRequest();
  }, [focusRequest, store, thread.id]);
  return (/* eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions */
    o(Card, {
      classes: classnames('p-3 cursor-pointer focus-visible-ring', {
        'is-hovered': isHovered
      }),
      "data-testid": "thread-card",
      elementRef: cardRef,
      tabIndex: -1,
      onClick: e => {
        // Prevent click events intended for another action from
        // triggering a page scroll.
        if (!isFromButtonOrLink( /** @type {Element} */e.target) && thread.annotation) {
          scrollToAnnotation(thread.annotation);
        }
      },
      onMouseEnter: () => {
        var _thread$annotation2;
        return focusThreadAnnotation((_thread$annotation2 = thread.annotation) !== null && _thread$annotation2 !== void 0 ? _thread$annotation2 : null);
      },
      onMouseLeave: () => focusThreadAnnotation(null),
      children: threadContent
    }, thread.id, false, {
      fileName: _jsxFileName$x,
      lineNumber: 77,
      columnNumber: 5
    }, this)
  );
}
var ThreadCard$1 = withServices(ThreadCard, ['frameSync']);

var _jsxFileName$w = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/ThreadList.tsx";
const SCROLL_PRECISION = 50;
function getScrollContainer() {
  const container = document.querySelector('.js-thread-list-scroll-root');
  if (!container) {
    throw new Error('Scroll container is missing');
  }
  return container;
}
function roundScrollPosition(pos) {
  return Math.max(pos - pos % SCROLL_PRECISION, 0);
}
/**
 * Render a list of threads.
 *
 * The thread list is "virtualized", meaning that only threads in or near the
 * viewport are rendered. This is critical for performance and memory usage as
 * annotations (and replies) are complex interactive components whose
 * user-defined content may include rich media such as images, audio clips,
 * embedded YouTube videos, rendered math and more.
 */
function ThreadList({
  threads
}) {
  // Client height of the scroll container.
  const [scrollContainerHeight, setScrollContainerHeight] = p(0);

  // Scroll offset of scroll container, rounded to a multiple of `SCROLL_PRECISION`
  // to avoid excessive re-renderings.
  const [scrollPosition, setScrollPosition] = p(0);

  // Measure the initial size and offset of the scroll container once rendering
  // is complete and attach listeners to observe future size or scroll offset changes.
  s(() => {
    const listeners = new ListenerCollection$1();
    const scrollContainer = getScrollContainer();
    setScrollContainerHeight(scrollContainer.clientHeight);
    setScrollPosition(roundScrollPosition(scrollContainer.scrollTop));
    const updateScrollPosition = lodash_debounce(() => {
      setScrollContainerHeight(scrollContainer.clientHeight);
      setScrollPosition(roundScrollPosition(scrollContainer.scrollTop));
    }, 10, {
      maxWait: 100
    });
    listeners.add(scrollContainer, 'scroll', updateScrollPosition);

    // We currently assume that the scroll container's size only changes with
    // the window as a whole. A more general approach would involve using
    // ResizeObserver via the `observeElementSize` utility.
    listeners.add(window, 'resize', updateScrollPosition);
    return () => {
      listeners.removeAll();
      updateScrollPosition.cancel();
    };
  }, []);

  // Map of thread ID to measured height of thread.
  const [threadHeights, setThreadHeights] = p(() => new Map());

  // ID of thread to scroll to after the next render. If the thread is not
  // present, the value persists until it can be "consumed".
  const [scrollToId, setScrollToId] = p(null);
  const topLevelThreads = threads;
  const {
    offscreenLowerHeight,
    offscreenUpperHeight,
    visibleThreads
  } = F(() => calculateVisibleThreads(topLevelThreads, threadHeights, scrollPosition, scrollContainerHeight), [topLevelThreads, threadHeights, scrollPosition, scrollContainerHeight]);
  const store = useSidebarStore();

  // Get the `$tag` of the most recently created unsaved annotation.
  const newAnnotationTag = (() => {
    // If multiple unsaved annotations exist, assume that the last one in the
    // list is the most recently created one.
    const newAnnotations = store.unsavedAnnotations();
    if (!newAnnotations.length) {
      return null;
    }
    return newAnnotations[newAnnotations.length - 1].$tag;
  })();

  // Scroll to newly created annotations and replies.
  //
  // nb. If there are multiple unsaved annotations and the newest one is saved
  // or removed, `newAnnotationTag` will revert to the previous unsaved annotation
  // and the thread list will scroll to that.
  h(() => {
    if (newAnnotationTag) {
      store.setForcedVisible(newAnnotationTag, true);
      setScrollToId(newAnnotationTag);
    }
  }, [store, newAnnotationTag]);

  // Effect to scroll a particular thread into view. This is mainly used to
  // scroll a newly created annotation into view.
  h(() => {
    if (!scrollToId) {
      return;
    }
    const threadIndex = topLevelThreads.findIndex(t => t.id === scrollToId);
    if (threadIndex === -1) {
      // Thread is not currently present. The `scrollToId` will be consumed
      // when this thread appears.
      return;
    }

    // Clear `scrollToId` so we don't scroll again after the next render.
    setScrollToId(null);
    const getThreadHeight = thread => threadHeights.get(thread.id) || THREAD_DIMENSION_DEFAULTS.defaultHeight;
    const yOffset = topLevelThreads.slice(0, threadIndex).reduce((total, thread) => total + getThreadHeight(thread), 0);
    const scrollContainer = getScrollContainer();
    scrollContainer.scrollTop = yOffset;
  }, [scrollToId, topLevelThreads, threadHeights]);

  // When the set of visible threads changes, recalculate the real rendered
  // heights of thread cards and update `threadHeights` state if there are changes.
  h(() => {
    setThreadHeights(prevHeights => {
      const changedHeights = new Map();
      for (const {
        id
      } of visibleThreads) {
        const threadElement = document.getElementById(id);
        if (!threadElement) {
          // This could happen if the `ThreadList` DOM is not connected to the document.
          //
          // Errors earlier in the render can also potentially cause this (see
          // https://github.com/hypothesis/client/pull/3665#issuecomment-895857072),
          // although we don't in general try to make all effects robust to that
          // as it is a problem that needs to be handled elsewhere.
          console.warn('ThreadList could not measure thread. Element not found.');
          return prevHeights;
        }
        const height = getElementHeightWithMargins(threadElement);
        if (height !== prevHeights.get(id)) {
          changedHeights.set(id, height);
        }
      }

      // Skip update if no heights changed from previous measured values
      // (or defaults).
      if (changedHeights.size === 0) {
        return prevHeights;
      }
      return new Map([...prevHeights, ...changedHeights]);
    });
  }, [visibleThreads]);
  return o("div", {
    children: [o("div", {
      style: {
        height: offscreenUpperHeight
      }
    }, void 0, false, {
      fileName: _jsxFileName$w,
      lineNumber: 197,
      columnNumber: 7
    }, this), visibleThreads.map(child => o("div", {
      className: classnames(
      // The goal is to space out each annotation card vertically. Typically
      // this is better handled by applying vertical spacing to the parent
      // element (e.g. `space-y-3`) but in this case, the constraints of
      // sibling divs before and after the list of annotation cards prevents
      // this, so a bottom margin is added to each card's wrapping element.
      'mb-3'),
      "data-testid": "thread-card-container",
      id: child.id,
      children: o(ThreadCard$1, {
        thread: child
      }, void 0, false, {
        fileName: _jsxFileName$w,
        lineNumber: 212,
        columnNumber: 11
      }, this)
    }, child.id, false, {
      fileName: _jsxFileName$w,
      lineNumber: 199,
      columnNumber: 9
    }, this)), o("div", {
      style: {
        height: offscreenLowerHeight
      }
    }, void 0, false, {
      fileName: _jsxFileName$w,
      lineNumber: 215,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$w,
    lineNumber: 196,
    columnNumber: 5
  }, this);
}

var _jsxFileName$v = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/SidebarContentError.js";
function SidebarContentError({
  errorType,
  onLoginRequest,
  showClearSelection = false
}) {
  const store = useSidebarStore();
  const isLoggedIn = store.isLoggedIn();
  const errorTitle = errorType === 'annotation' ? 'Annotation unavailable' : 'Group unavailable';
  const errorMessage = (() => {
    if (!isLoggedIn) {
      return `The ${errorType} associated with the current URL is unavailable.
        You may need to log in to see it.`;
    }
    if (errorType === 'group') {
      return `The current URL links to a group, but that group cannot be found,
        or you do not have permission to view the annotations in that group.`;
    }
    return `The current URL links to an annotation, but that annotation
      cannot be found, or you do not have permission to view it.`;
  })();
  return o("div", {
    className: "mb-4",
    children: o(Panel, {
      icon: "restricted",
      title: errorTitle,
      children: [o("p", {
        children: errorMessage
      }, void 0, false, {
        fileName: _jsxFileName$v,
        lineNumber: 45,
        columnNumber: 9
      }, this), o("div", {
        className: "flex justify-end space-x-2",
        children: [showClearSelection && o(LabeledButton, {
          variant: isLoggedIn ? 'primary' : undefined,
          onClick: () => store.clearSelection(),
          children: "Show all annotations"
        }, void 0, false, {
          fileName: _jsxFileName$v,
          lineNumber: 48,
          columnNumber: 13
        }, this), !isLoggedIn && o(LabeledButton, {
          variant: "primary",
          onClick: onLoginRequest,
          children: "Log in"
        }, void 0, false, {
          fileName: _jsxFileName$v,
          lineNumber: 56,
          columnNumber: 13
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName$v,
        lineNumber: 46,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$v,
      lineNumber: 44,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$v,
    lineNumber: 43,
    columnNumber: 5
  }, this);
}

var _jsxFileName$u = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/AnnotationView.js";
function AnnotationView({
  loadAnnotationsService,
  onLogin
}) {
  const store = useSidebarStore();
  const annotationId = store.routeParams().id;
  const rootThread = useRootThread();
  const userid = store.profile().userid;
  const [fetchError, setFetchError] = p(false);
  h(() => {
    setFetchError(false);
    store.clearAnnotations();
    loadAnnotationsService.loadThread(annotationId).then(annots => {
      // Find the top-level annotation in the thread that `annotationId` is
      // part of. This will be different to `annotationId` if `annotationId`
      // is a reply. A top-level annotation will not have any references.
      const topLevelAnnot = annots.filter(ann => (ann.references || []).length === 0)[0];
      if (!topLevelAnnot) {
        // We were able to fetch annotations in the thread that `annotationId`
        // is part of (note that `annotationId` may refer to a reply) but
        // couldn't find a top-level (non-reply) annotation in that thread.
        //
        // This might happen if the top-level annotation was deleted or
        // moderated or had its permissions changed.
        //
        // We need to decide what what be the most useful behavior in this case
        // and implement it.
        /* istanbul ignore next */
        return;
      }

      // Make the full thread of annotations visible. By default replies are
      // not shown until the user expands the thread.
      annots.forEach(annot => store.setExpanded( /** @type {string} */annot.id, true));

      // FIXME - This should show a visual indication of which reply the
      // annotation ID in the URL refers to. That isn't currently working.
      if (topLevelAnnot.id !== annotationId) {
        store.highlightAnnotations([annotationId]);
      }
    }).catch(() => {
      setFetchError(true);
    });
  }, [annotationId,
  // This is not used by the effect but ensures that the annotation is
  // fetched after the user logs in/out, in case the annotation is private.
  userid,
  // Static dependencies.
  loadAnnotationsService, store]);
  return o(p$2, {
    children: [fetchError &&
    // This is the same error shown if a direct-linked annotation cannot
    // be fetched in the sidebar. Fortunately the error message makes sense
    // for this scenario as well.
    o(SidebarContentError, {
      errorType: "annotation",
      onLoginRequest: onLogin
    }, void 0, false, {
      fileName: _jsxFileName$u,
      lineNumber: 90,
      columnNumber: 9
    }, this), o(ThreadList, {
      threads: rootThread.children
    }, void 0, false, {
      fileName: _jsxFileName$u,
      lineNumber: 92,
      columnNumber: 7
    }, this)]
  }, void 0, true);
}
var AnnotationView$1 = withServices(AnnotationView, ['loadAnnotationsService']);

var _jsxFileName$t = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/FilterStatus.tsx";
/**
 * Render status text describing the currently-applied filters.
 */
function FilterStatusMessage({
  additionalCount = 0,
  entitySingular = 'annotation',
  entityPlural = 'annotations',
  filterQuery,
  focusDisplayName,
  resultCount
}) {
  return o(p$2, {
    children: [resultCount > 0 && o("span", {
      children: "Showing "
    }, void 0, false, {
      fileName: _jsxFileName$t,
      lineNumber: 57,
      columnNumber: 27
    }, this), o("span", {
      className: "whitespace-nowrap font-bold",
      children: [resultCount > 0 ? resultCount : 'No', ' ', resultCount === 1 ? entitySingular : entityPlural]
    }, void 0, true, {
      fileName: _jsxFileName$t,
      lineNumber: 58,
      columnNumber: 7
    }, this), filterQuery && o("span", {
      children: [' ', "for ", o("span", {
        className: "break-words",
        children: `'${filterQuery}'`
      }, void 0, false, {
        fileName: _jsxFileName$t,
        lineNumber: 65,
        columnNumber: 15
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$t,
      lineNumber: 63,
      columnNumber: 9
    }, this), focusDisplayName && o("span", {
      children: [' ', "by", ' ', o("span", {
        className: "whitespace-nowrap font-bold",
        children: focusDisplayName
      }, void 0, false, {
        fileName: _jsxFileName$t,
        lineNumber: 72,
        columnNumber: 11
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$t,
      lineNumber: 69,
      columnNumber: 9
    }, this), additionalCount > 0 && o("span", {
      className: "whitespace-nowrap italic text-color-text-light",
      children: [' ', "(and ", additionalCount, " more)"]
    }, void 0, true, {
      fileName: _jsxFileName$t,
      lineNumber: 78,
      columnNumber: 9
    }, this)]
  }, void 0, true);
}

/**
 * Show a description of currently-applied filters and a button to clear the
 * filter(s).
 *
 * There are four filter modes. Exactly one is applicable at any time. In order
 * of precedence:
 *
 * 1. selection
 *    One or more annotations is "selected", either by direct user input or
 *    "direct-linked" annotation(s)
 *
 *    Message formatting:
 *      "[Showing] (No|<resultCount>) annotation[s] [\(and <additionalCount> more\)]"
 *    Button:
 *      "<cancel icon> Show all [\(<totalCount)\)]" - clears the selection
 *
 * 2. query
 *    A search query filter is applied
 *
 *    Message formatting:
 *      "[Showing] (No|<resultCount>) result[s] for '<filterQuery>'
 *       by <focusDisplayName] [\(and <additionalCount> more\)]"
 *    Button:
 *      "<cancel icon> Clear search" - Clears the search query
 *
 * 3. focus
 *    User-focused mode is configured, but may or may not be active/applied.
 *
 *    Message formatting:
 *      "[Showing] (No|<resultCount>) annotation[s] [by <focusDisplayName>]
 *       [\(and <additionalCount> more\)]"
 *    Button:
 *    - If there are no forced-visible threads:
 *      "Show (all|only <focusDisplayName>)" - Toggles the user filter activation
 *    - If there are any forced-visible threads:
 *      "Reset filters" - Clears selection/filters (does not affect user filter activation)
 *
 * 4. null
 *    No filters are applied.
 *
 *   Message formatting:
 *     N/A (but container elements still render)
 *   Button:
 *     N/A
 *
 * This component must render its container elements if no filters are applied
 * ("null" filter mode). This is because the element with `role="status"`
 * needs to be continuously present in the DOM such that dynamic updates to its
 * text content are available to assistive technology.
 * See https://www.w3.org/WAI/WCAG21/Techniques/aria/ARIA22
 */
function FilterStatus() {
  const store = useSidebarStore();
  const rootThread = useRootThread();
  const annotationCount = store.annotationCount();
  const directLinkedId = store.directLinkedAnnotationId();
  const filterQuery = store.filterQuery();
  const focusState = store.focusState();
  const forcedVisibleCount = store.forcedVisibleThreads().length;
  const selectedCount = store.selectedAnnotations().length;
  const filterMode = F(() => {
    if (selectedCount > 0) {
      return 'selection';
    } else if (filterQuery) {
      return 'query';
    } else if (focusState.configured) {
      return 'focus';
    }
    return null;
  }, [selectedCount, filterQuery, focusState]);

  // Number of items that match the current filters
  const resultCount = F(() => {
    return filterMode === 'selection' ? selectedCount : countVisible(rootThread) - forcedVisibleCount;
  }, [filterMode, selectedCount, rootThread, forcedVisibleCount]);

  // Number of additional items that are visible but do not match current
  // filters. This can happen when, e.g.:
  //  - A user manually expands a thread that does not match the current
  //    filtering
  //  - A user creates a new annotation when there are applied filters
  const additionalCount = F(() => {
    if (filterMode === 'selection') {
      // Selection filtering deals in top-level annotations only.
      // Compare visible top-level annotations against the count of selected
      // (top-level) annotatinos.
      const visibleAnnotationCount = (rootThread.children || []).filter(thread => thread.annotation && thread.visible).length;
      return visibleAnnotationCount - selectedCount;
    } else {
      return forcedVisibleCount;
    }
  }, [filterMode, forcedVisibleCount, rootThread.children, selectedCount]);
  const buttonText = F(() => {
    if (filterMode === 'selection') {
      // Because of the confusion between counts of entities between selected
      // annotations and filtered annotations, don't display the total number
      // when in user-focus mode because the numbers won't appear to make sense.
      // Don't display total count, either, when viewing a direct-linked annotation.
      const showCount = !focusState.configured && !directLinkedId;
      return showCount ? `Show all (${annotationCount})` : 'Show all';
    } else if (filterMode === 'focus') {
      if (forcedVisibleCount > 0) {
        return 'Reset filters';
      }
      return focusState.active ? 'Show all' : `Show only ${focusState.displayName}`;
    }
    return 'Clear search';
  }, [annotationCount, directLinkedId, focusState, filterMode, forcedVisibleCount]);
  return o("div", {
    // This container element needs to be present at all times but
    // should only be visible when there are applied filters
    className: classnames('mb-3', {
      'sr-only': !filterMode
    }),
    "data-testid": "filter-status-container",
    children: o(CardNext, {
      children: o(CardContentNext, {
        children: store.isLoading() ? o(SpinnerNext, {
          size: "md"
        }, void 0, false, {
          fileName: _jsxFileName$t,
          lineNumber: 221,
          columnNumber: 13
        }, this) : o("div", {
          className: "flex items-center justify-center space-x-1",
          children: [o("div", {
            className: classnames(
            // Setting `min-width: 0` here allows wrapping to work as
            // expected for long `filterQuery` strings. See
            // https://css-tricks.com/flexbox-truncated-text/
            'grow min-w-[0]'),
            role: "status",
            children: filterMode && o(FilterStatusMessage, {
              additionalCount: additionalCount,
              entitySingular: filterMode === 'query' ? 'result' : 'annotation',
              entityPlural: filterMode === 'query' ? 'results' : 'annotations',
              filterQuery: filterQuery,
              focusDisplayName: filterMode !== 'selection' && focusState.active ? focusState.displayName : '',
              resultCount: resultCount
            }, void 0, false, {
              fileName: _jsxFileName$t,
              lineNumber: 234,
              columnNumber: 19
            }, this)
          }, void 0, false, {
            fileName: _jsxFileName$t,
            lineNumber: 224,
            columnNumber: 15
          }, this), filterMode && o(ButtonNext, {
            onClick: filterMode === 'focus' && !forcedVisibleCount ? () => store.toggleFocusMode() : () => store.clearSelection(),
            size: "sm",
            title: buttonText,
            variant: "primary",
            "data-testid": "clear-button",
            children: [filterMode !== 'focus' && o(CancelIcon, {}, void 0, false, {
              fileName: _jsxFileName$t,
              lineNumber: 265,
              columnNumber: 46
            }, this), buttonText]
          }, void 0, true, {
            fileName: _jsxFileName$t,
            lineNumber: 253,
            columnNumber: 17
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName$t,
          lineNumber: 223,
          columnNumber: 13
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$t,
        lineNumber: 219,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$t,
      lineNumber: 218,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$t,
    lineNumber: 212,
    columnNumber: 5
  }, this);
}

var _jsxFileName$s = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/LoggedOutMessage.tsx";
/**
 * Render a call-to-action to log in or sign up. This message is intended to be
 * displayed to non-auth'd users when viewing a single annotation in a
 * direct-linked context (i.e. URL with syntax `/#annotations:<annotation_id>`)
 */
function LoggedOutMessage({
  onLogin
}) {
  const store = useSidebarStore();
  return o("div", {
    className: "flex flex-col items-center m-6 space-y-6",
    children: [o("span", {
      className: "text-center",
      children: ["This is a public annotation created with Hypothesis. ", o("br", {}, void 0, false, {
        fileName: _jsxFileName$s,
        lineNumber: 25,
        columnNumber: 62
      }, this), "To reply or make your own annotations on this document,", ' ', o(LinkNext, {
        color: "text",
        href: store.getLink('signup'),
        target: "_blank",
        underline: "always",
        children: "create a free account"
      }, void 0, false, {
        fileName: _jsxFileName$s,
        lineNumber: 27,
        columnNumber: 9
      }, this), ' ', "or", ' ', o(LinkButtonNext, {
        inline: true,
        color: "text",
        onClick: onLogin,
        underline: "always",
        children: "log in"
      }, void 0, false, {
        fileName: _jsxFileName$s,
        lineNumber: 36,
        columnNumber: 9
      }, this), "."]
    }, void 0, true, {
      fileName: _jsxFileName$s,
      lineNumber: 24,
      columnNumber: 7
    }, this), o("div", {
      children: o(LinkBaseNext, {
        href: "https://hypothes.is",
        "aria-label": "Hypothesis homepage",
        target: "_blank",
        title: "Hypothesis homepage",
        children: o(LogoIcon, {
          className: "w-16 h-16 text-grey-7"
        }, void 0, false, {
          fileName: _jsxFileName$s,
          lineNumber: 48,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$s,
        lineNumber: 42,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$s,
      lineNumber: 41,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$s,
    lineNumber: 23,
    columnNumber: 5
  }, this);
}

var COMPLETE = 'complete',
    CANCELED = 'canceled';

function raf(task){
    if('requestAnimationFrame' in window){
        return window.requestAnimationFrame(task);
    }

    setTimeout(task, 16);
}

function setElementScroll(element, x, y){
    Math.max(0, x);
    Math.max(0, y);

    if(element.self === element){
        element.scrollTo(x, y);
    }else {
        element.scrollLeft = x;
        element.scrollTop = y;
    }
}

function getTargetScrollLocation(scrollSettings, parent){
    var align = scrollSettings.align,
        target = scrollSettings.target,
        targetPosition = target.getBoundingClientRect(),
        parentPosition,
        x,
        y,
        differenceX,
        differenceY,
        targetWidth,
        targetHeight,
        leftAlign = align && align.left != null ? align.left : 0.5,
        topAlign = align && align.top != null ? align.top : 0.5,
        leftOffset = align && align.leftOffset != null ? align.leftOffset : 0,
        topOffset = align && align.topOffset != null ? align.topOffset : 0,
        leftScalar = leftAlign,
        topScalar = topAlign;

    if(scrollSettings.isWindow(parent)){
        targetWidth = Math.min(targetPosition.width, parent.innerWidth);
        targetHeight = Math.min(targetPosition.height, parent.innerHeight);
        x = targetPosition.left + parent.pageXOffset - parent.innerWidth * leftScalar + targetWidth * leftScalar;
        y = targetPosition.top + parent.pageYOffset - parent.innerHeight * topScalar + targetHeight * topScalar;
        x -= leftOffset;
        y -= topOffset;
        x = scrollSettings.align.lockX ? parent.pageXOffset : x;
        y = scrollSettings.align.lockY ? parent.pageYOffset : y;
        differenceX = x - parent.pageXOffset;
        differenceY = y - parent.pageYOffset;
    }else {
        targetWidth = targetPosition.width;
        targetHeight = targetPosition.height;
        parentPosition = parent.getBoundingClientRect();
        var offsetLeft = targetPosition.left - (parentPosition.left - parent.scrollLeft);
        var offsetTop = targetPosition.top - (parentPosition.top - parent.scrollTop);
        x = offsetLeft + (targetWidth * leftScalar) - parent.clientWidth * leftScalar;
        y = offsetTop + (targetHeight * topScalar) - parent.clientHeight * topScalar;
        x -= leftOffset;
        y -= topOffset;
        x = Math.max(Math.min(x, parent.scrollWidth - parent.clientWidth), 0);
        y = Math.max(Math.min(y, parent.scrollHeight - parent.clientHeight), 0);
        x = scrollSettings.align.lockX ? parent.scrollLeft : x;
        y = scrollSettings.align.lockY ? parent.scrollTop : y;
        differenceX = x - parent.scrollLeft;
        differenceY = y - parent.scrollTop;
    }

    return {
        x: x,
        y: y,
        differenceX: differenceX,
        differenceY: differenceY
    };
}

function animate(parent){
    var scrollSettings = parent._scrollSettings;

    if(!scrollSettings){
        return;
    }

    var maxSynchronousAlignments = scrollSettings.maxSynchronousAlignments;

    var location = getTargetScrollLocation(scrollSettings, parent),
        time = Date.now() - scrollSettings.startTime,
        timeValue = Math.min(1 / scrollSettings.time * time, 1);

    if(scrollSettings.endIterations >= maxSynchronousAlignments){
        setElementScroll(parent, location.x, location.y);
        parent._scrollSettings = null;
        return scrollSettings.end(COMPLETE);
    }

    var easeValue = 1 - scrollSettings.ease(timeValue);

    setElementScroll(parent,
        location.x - location.differenceX * easeValue,
        location.y - location.differenceY * easeValue
    );

    if(time >= scrollSettings.time){
        scrollSettings.endIterations++;
        // Align ancestor synchronously
        scrollSettings.scrollAncestor && animate(scrollSettings.scrollAncestor);
        animate(parent);
        return;
    }

    raf(animate.bind(null, parent));
}

function defaultIsWindow(target){
    return target.self === target
}

function transitionScrollTo(target, parent, settings, scrollAncestor, callback){
    var idle = !parent._scrollSettings,
        lastSettings = parent._scrollSettings,
        now = Date.now(),
        cancelHandler,
        passiveOptions = { passive: true };

    if(lastSettings){
        lastSettings.end(CANCELED);
    }

    function end(endType){
        parent._scrollSettings = null;

        if(parent.parentElement && parent.parentElement._scrollSettings){
            parent.parentElement._scrollSettings.end(endType);
        }

        if(settings.debug){
            console.log('Scrolling ended with type', endType, 'for', parent);
        }

        callback(endType);
        if(cancelHandler){
            parent.removeEventListener('touchstart', cancelHandler, passiveOptions);
            parent.removeEventListener('wheel', cancelHandler, passiveOptions);
        }
    }

    var maxSynchronousAlignments = settings.maxSynchronousAlignments;

    if(maxSynchronousAlignments == null){
        maxSynchronousAlignments = 3;
    }

    parent._scrollSettings = {
        startTime: now,
        endIterations: 0,
        target: target,
        time: settings.time,
        ease: settings.ease,
        align: settings.align,
        isWindow: settings.isWindow || defaultIsWindow,
        maxSynchronousAlignments: maxSynchronousAlignments,
        end: end,
        scrollAncestor
    };

    if(!('cancellable' in settings) || settings.cancellable){
        cancelHandler = end.bind(null, CANCELED);
        parent.addEventListener('touchstart', cancelHandler, passiveOptions);
        parent.addEventListener('wheel', cancelHandler, passiveOptions);
    }

    if(idle){
        animate(parent);
    }

    return cancelHandler
}

function defaultIsScrollable(element){
    return (
        'pageXOffset' in element ||
        (
            element.scrollHeight !== element.clientHeight ||
            element.scrollWidth !== element.clientWidth
        ) &&
        getComputedStyle(element).overflow !== 'hidden'
    );
}

function defaultValidTarget(){
    return true;
}

function findParentElement(el){
    if (el.assignedSlot) {
        return findParentElement(el.assignedSlot);
    }

    if (el.parentElement) {
        if(el.parentElement.tagName.toLowerCase() === 'body'){
            return el.parentElement.ownerDocument.defaultView || el.parentElement.ownerDocument.ownerWindow;
        }
        return el.parentElement;
    }

    if (el.getRootNode){
        var parent = el.getRootNode();
        if(parent.nodeType === 11) {
            return parent.host;
        }
    }
}

var scrollIntoView = function(target, settings, callback){
    if(!target){
        return;
    }

    if(typeof settings === 'function'){
        callback = settings;
        settings = null;
    }

    if(!settings){
        settings = {};
    }

    settings.time = isNaN(settings.time) ? 1000 : settings.time;
    settings.ease = settings.ease || function(v){return 1 - Math.pow(1 - v, v / 2);};
    settings.align = settings.align || {};

    var parent = findParentElement(target),
        parents = 1;

    function done(endType){
        parents--;
        if(!parents){
            callback && callback(endType);
        }
    }

    var validTarget = settings.validTarget || defaultValidTarget;
    var isScrollable = settings.isScrollable;

    if(settings.debug){
        console.log('About to scroll to', target);

        if(!parent){
            console.error('Target did not have a parent, is it mounted in the DOM?');
        }
    }

    var scrollingElements = [];

    while(parent){
        if(settings.debug){
            console.log('Scrolling parent node', parent);
        }

        if(validTarget(parent, parents) && (isScrollable ? isScrollable(parent, defaultIsScrollable) : defaultIsScrollable(parent))){
            parents++;
            scrollingElements.push(parent);
        }

        parent = findParentElement(parent);

        if(!parent){
            done(COMPLETE);
            break;
        }
    }

    return scrollingElements.reduce((cancel, parent, index) => transitionScrollTo(target, parent, settings, scrollingElements[index + 1], done), null);
};

var _jsxFileName$r = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/SidebarPanel.js";
function SidebarPanel({
  children,
  icon = '',
  panelName,
  title,
  onActiveChanged
}) {
  const store = useSidebarStore();
  const panelIsActive = store.isSidebarPanelOpen(panelName);
  const panelElement = _$1( /** @type {HTMLDivElement|null}*/null);
  const panelWasActive = _$1(panelIsActive);

  // Scroll the panel into view if it has just been opened
  h(() => {
    if (panelWasActive.current !== panelIsActive) {
      panelWasActive.current = panelIsActive;
      if (panelIsActive && panelElement.current) {
        scrollIntoView(panelElement.current);
      }
      if (typeof onActiveChanged === 'function') {
        onActiveChanged(panelIsActive);
      }
    }
  }, [panelIsActive, onActiveChanged]);
  const closePanel = T$1(() => {
    store.toggleSidebarPanel(panelName, false);
  }, [store, panelName]);
  return o(Slider, {
    visible: panelIsActive,
    children: o("div", {
      ref: panelElement,
      className: "mb-4",
      children: o(Panel, {
        title: title,
        icon: icon,
        onClose: closePanel,
        children: children
      }, void 0, false, {
        fileName: _jsxFileName$r,
        lineNumber: 64,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$r,
      lineNumber: 63,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$r,
    lineNumber: 62,
    columnNumber: 5
  }, this);
}

var _jsxFileName$q = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/LoginPromptPanel.js";
function LoginPromptPanel({
  onLogin,
  onSignUp
}) {
  const store = useSidebarStore();
  const isLoggedIn = store.isLoggedIn();
  if (isLoggedIn) {
    return null;
  }
  return o(SidebarPanel, {
    icon: "restricted",
    title: "Login needed",
    panelName: "loginPrompt",
    children: [o("p", {
      children: "Please log in to create annotations or highlights."
    }, void 0, false, {
      fileName: _jsxFileName$q,
      lineNumber: 30,
      columnNumber: 7
    }, this), o(Actions, {
      children: [o(LabeledButton, {
        title: "Sign up",
        onClick: onSignUp,
        children: "Sign up"
      }, void 0, false, {
        fileName: _jsxFileName$q,
        lineNumber: 32,
        columnNumber: 9
      }, this), o(LabeledButton, {
        title: "Log in",
        variant: "primary",
        onClick: onLogin,
        children: "Log in"
      }, void 0, false, {
        fileName: _jsxFileName$q,
        lineNumber: 35,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$q,
      lineNumber: 31,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$q,
    lineNumber: 25,
    columnNumber: 5
  }, this);
}

var _jsxFileName$p = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/SelectionTabs.js";
function Tab({
  children,
  count,
  isWaitingToAnchor,
  isSelected,
  label,
  onSelect
}) {
  const selectTab = () => {
    if (!isSelected) {
      onSelect();
    }
  };
  const title = count > 0 ? `${label} (${count} available)` : label;
  return o(LinkButton, {
    classes: classnames('inline bg-transparent min-w-[5.25rem] text-color-text hover:!no-underline', {
      'font-bold': isSelected
    })
    // Listen for `onMouseDown` so that the tab is selected when _pressed_
    // as this makes the UI feel faster. Also listen for `onClick` as a fallback
    // to enable selecting the tab via other input methods.
    ,
    onClick: selectTab,
    onMouseDown: selectTab,
    pressed: !!isSelected,
    role: "tab",
    tabIndex: 0,
    title: title,
    children: o(p$2, {
      children: [children, count > 0 && !isWaitingToAnchor && o("span", {
        className: "relative bottom-[3px] left-[2px] text-tiny",
        children: count
      }, void 0, false, {
        fileName: _jsxFileName$p,
        lineNumber: 72,
        columnNumber: 11
      }, this)]
    }, void 0, true)
  }, void 0, false, {
    fileName: _jsxFileName$p,
    lineNumber: 52,
    columnNumber: 5
  }, this);
}

/**
 * @typedef SelectionTabsProps
 * @prop {boolean} isLoading - Are we waiting on any annotations from the server?
 * @prop {SidebarSettings} settings - Injected service.
 * @prop {import('../services/annotations').AnnotationsService} annotationsService
 */

/**
 * Tabbed display of annotations and notes
 *
 * @param {SelectionTabsProps} props
 */
function SelectionTabs({
  annotationsService,
  isLoading,
  settings
}) {
  const store = useSidebarStore();
  const selectedTab = store.selectedTab();
  const noteCount = store.noteCount();
  const annotationCount = store.annotationCount();
  const orphanCount = store.orphanCount();
  const isWaitingToAnchorAnnotations = store.isWaitingToAnchorAnnotations();

  /**
   * @param {TabName} tabId
   */
  const selectTab = tabId => {
    store.clearSelection();
    store.selectTab(tabId);
  };
  const showAnnotationsUnavailableMessage = selectedTab === 'annotation' && annotationCount === 0 && !isWaitingToAnchorAnnotations;
  const showNotesUnavailableMessage = selectedTab === 'note' && noteCount === 0;
  return o("div", {
    className: classnames(
    // 9px balances out the space above the tabs
    'space-y-3 pb-[9px]'),
    children: [o("div", {
      className: "flex gap-x-6 theme-clean:ml-[15px]",
      role: "tablist",
      children: [o(Tab, {
        count: annotationCount,
        isWaitingToAnchor: isWaitingToAnchorAnnotations,
        isSelected: selectedTab === 'annotation',
        label: "Annotations",
        onSelect: () => selectTab('annotation'),
        children: "\u0627\u0644\u0643\u0644\u0645\u0627\u062A \u0627\u0644\u0645\u0648\u0633\u0645\u0629"
      }, void 0, false, {
        fileName: _jsxFileName$p,
        lineNumber: 124,
        columnNumber: 9
      }, this), o(Tab, {
        count: noteCount,
        isWaitingToAnchor: isWaitingToAnchorAnnotations,
        isSelected: selectedTab === 'note',
        label: "Page notes",
        onSelect: () => selectTab('note'),
        children: "\u0645\u0644\u0627\u062D\u0638\u0627\u062A \u0627\u0644\u0635\u0641\u062D\u0629"
      }, void 0, false, {
        fileName: _jsxFileName$p,
        lineNumber: 133,
        columnNumber: 9
      }, this), orphanCount > 0 && o(Tab, {
        count: orphanCount,
        isWaitingToAnchor: isWaitingToAnchorAnnotations,
        isSelected: selectedTab === 'orphan',
        label: "Orphans",
        onSelect: () => selectTab('orphan'),
        children: "Orphans"
      }, void 0, false, {
        fileName: _jsxFileName$p,
        lineNumber: 143,
        columnNumber: 11
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$p,
      lineNumber: 123,
      columnNumber: 7
    }, this), selectedTab === 'note' && settings.enableExperimentalNewNoteButton && o("div", {
      className: "flex justify-end",
      children: o(LabeledButton, {
        "data-testid": "new-note-button",
        icon: "add",
        onClick: () => annotationsService.createPageNote(),
        variant: "primary",
        style: applyTheme(['ctaBackgroundColor'], settings),
        children: "\u0645\u0644\u0627\u062D\u0638\u0629 \u062C\u062F\u064A\u062F\u0629"
      }, void 0, false, {
        fileName: _jsxFileName$p,
        lineNumber: 156,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$p,
      lineNumber: 155,
      columnNumber: 9
    }, this), !isLoading && showNotesUnavailableMessage && o(Frame, {
      classes: "text-center",
      children: o("span", {
        "data-testid": "notes-unavailable-message",
        children: "\u0644\u0627 \u062A\u0648\u062C\u062F \u0645\u0644\u0627\u062D\u0638\u0627\u062A \u0644\u0644\u0635\u0641\u062D\u0629 \u0641\u064A \u0647\u0630\u0629 \u0627\u0644\u0645\u062C\u0645\u0648\u0639\u0629"
      }, void 0, false, {
        fileName: _jsxFileName$p,
        lineNumber: 169,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$p,
      lineNumber: 168,
      columnNumber: 9
    }, this), !isLoading && showAnnotationsUnavailableMessage && o(Frame, {
      classes: "text-center",
      children: o("span", {
        "data-testid": "annotations-unavailable-message",
        children: ["\u0644\u0627 \u062A\u0648\u062C\u062F \u0643\u0644\u0645\u0627\u062A \u0645\u0648\u0633\u0645\u0629 \u0641\u064A \u0647\u0630\u0629 \u0627\u0644\u0645\u062C\u0645\u0648\u0639\u0629", o("br", {}, void 0, false, {
          fileName: _jsxFileName$p,
          lineNumber: 178,
          columnNumber: 13
        }, this), "\u0627\u0628\u062F\u0623 \u0628\u0627\u0644\u062A\u0648\u0633\u064A\u0645 \u0639\u0646 \u0637\u0631\u064A\u0642 \u062A\u062D\u062F\u064A\u062F \u0628\u0639\u0636 \u0627\u0644\u0646\u0635\u0648\u0635 \u0648\u0627\u0644\u0646\u0642\u0631 \u0639\u0644\u0649 \u0632\u0631", ' ', o(Icon, {
          classes: "inline m-0.5 -mt-0.5",
          name: "annotate",
          title: "Annotate"
        }, void 0, false, {
          fileName: _jsxFileName$p,
          lineNumber: 180,
          columnNumber: 13
        }, this), ' ', "."]
      }, void 0, true, {
        fileName: _jsxFileName$p,
        lineNumber: 176,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$p,
      lineNumber: 175,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$p,
    lineNumber: 117,
    columnNumber: 5
  }, this);
}
var SelectionTabs$1 = withServices(SelectionTabs, ['annotationsService', 'settings']);

var _jsxFileName$o = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/SidebarView.js";
function SidebarView({
  frameSync,
  onLogin,
  onSignUp,
  loadAnnotationsService,
  streamer
}) {
  const rootThread = useRootThread();

  // Store state values
  const store = useSidebarStore();
  const focusedGroupId = store.focusedGroupId();
  const hasAppliedFilter = store.hasAppliedFilter() || store.hasSelectedAnnotations();
  const isLoading = store.isLoading();
  const isLoggedIn = store.isLoggedIn();
  const linkedAnnotationId = store.directLinkedAnnotationId();
  const linkedAnnotation = linkedAnnotationId ? store.findAnnotationByID(linkedAnnotationId) : undefined;
  const directLinkedTab = linkedAnnotation ? tabForAnnotation(linkedAnnotation) : 'annotation';
  const searchUris = store.searchUris();
  const sidebarHasOpened = store.hasSidebarOpened();
  const userId = store.profile().userid;

  // If, after loading completes, no `linkedAnnotation` object is present when
  // a `linkedAnnotationId` is set, that indicates an error
  const hasDirectLinkedAnnotationError = !isLoading && linkedAnnotationId ? !linkedAnnotation : false;
  const hasDirectLinkedGroupError = store.directLinkedGroupFetchFailed();
  const hasContentError = hasDirectLinkedAnnotationError || hasDirectLinkedGroupError;
  const showFilterStatus = !hasContentError;
  const showTabs = !hasContentError && !hasAppliedFilter;

  // Show a CTA to log in if successfully viewing a direct-linked annotation
  // and not logged in
  const showLoggedOutMessage = linkedAnnotationId && !isLoggedIn && !hasDirectLinkedAnnotationError && !isLoading;
  const prevGroupId = _$1(focusedGroupId);

  // Reload annotations when group, user or document search URIs change
  h(() => {
    if (!prevGroupId.current || prevGroupId.current !== focusedGroupId) {
      // Clear any selected annotations and filters when the focused group
      // changes.
      // We don't clear the selection/filters on the initial load when
      // the focused group transitions from null to non-null, as this would clear
      // any filters intended to be used for the initial display (eg. to focus
      // on a particular user).
      if (prevGroupId.current) {
        // Respect applied focus-mode filtering when changing focused group
        let restoreFocus = store.focusState().active;
        store.clearSelection();
        if (restoreFocus) {
          store.toggleFocusMode(true);
        }
      }
      prevGroupId.current = focusedGroupId;
    }
    if (focusedGroupId && searchUris.length) {
      loadAnnotationsService.load({
        groupId: focusedGroupId,
        uris: searchUris
      });
    }
  }, [store, loadAnnotationsService, focusedGroupId, userId, searchUris]);

  // When a `linkedAnnotationAnchorTag` becomes available, scroll to it
  // and focus it
  h(() => {
    if (linkedAnnotation && linkedAnnotation.$orphan === false) {
      frameSync.hoverAnnotation(linkedAnnotation);
      frameSync.scrollToAnnotation(linkedAnnotation);
      store.selectTab(directLinkedTab);
    } else if (linkedAnnotation) {
      // Make sure to allow for orphaned annotations (which won't have an anchor)
      store.selectTab(directLinkedTab);
    }
  }, [directLinkedTab, frameSync, linkedAnnotation, store]);

  // Connect to the streamer when the sidebar has opened or if user is logged in
  const hasFetchedProfile = store.hasFetchedProfile();
  h(() => {
    if (hasFetchedProfile && (sidebarHasOpened || isLoggedIn)) {
      streamer.connect({
        applyUpdatesImmediately: false
      });
    }
  }, [hasFetchedProfile, isLoggedIn, sidebarHasOpened, streamer]);
  return o("div", {
    children: [o("h2", {
      className: "sr-only",
      children: "Annotations"
    }, void 0, false, {
      fileName: _jsxFileName$o,
      lineNumber: 132,
      columnNumber: 7
    }, this), showFilterStatus && o(FilterStatus, {}, void 0, false, {
      fileName: _jsxFileName$o,
      lineNumber: 133,
      columnNumber: 28
    }, this), o(LoginPromptPanel, {
      onLogin: onLogin,
      onSignUp: onSignUp
    }, void 0, false, {
      fileName: _jsxFileName$o,
      lineNumber: 134,
      columnNumber: 7
    }, this), hasDirectLinkedAnnotationError && o(SidebarContentError, {
      errorType: "annotation",
      onLoginRequest: onLogin,
      showClearSelection: true
    }, void 0, false, {
      fileName: _jsxFileName$o,
      lineNumber: 136,
      columnNumber: 9
    }, this), hasDirectLinkedGroupError && o(SidebarContentError, {
      errorType: "group",
      onLoginRequest: onLogin
    }, void 0, false, {
      fileName: _jsxFileName$o,
      lineNumber: 143,
      columnNumber: 9
    }, this), showTabs && o(SelectionTabs$1, {
      isLoading: isLoading
    }, void 0, false, {
      fileName: _jsxFileName$o,
      lineNumber: 145,
      columnNumber: 20
    }, this), o(ThreadList, {
      threads: rootThread.children
    }, void 0, false, {
      fileName: _jsxFileName$o,
      lineNumber: 146,
      columnNumber: 7
    }, this), showLoggedOutMessage && o(LoggedOutMessage, {
      onLogin: onLogin
    }, void 0, false, {
      fileName: _jsxFileName$o,
      lineNumber: 147,
      columnNumber: 32
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$o,
    lineNumber: 131,
    columnNumber: 5
  }, this);
}
var SidebarView$1 = withServices(SidebarView, ['frameSync', 'loadAnnotationsService', 'streamer']);

var _jsxFileName$n = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/StreamView.js";
function StreamView({
  api,
  toastMessenger
}) {
  const store = useSidebarStore();
  const currentQuery = store.routeParams().q;

  /**
   * Fetch annotations from the API and display them in the stream.
   */
  const loadAnnotations = T$1( /** @param {string} query */
  async query => {
    const queryParams = {
      _separate_replies: true,
      // nb. There is currently no way to load anything except the first
      // 20 matching annotations in the UI.
      offset: 0,
      limit: 20,
      ...toObject(query)
    };
    try {
      store.annotationFetchStarted();
      const results = await api.search(queryParams);
      store.addAnnotations([...results.rows, ...results.replies]);
    } finally {
      store.annotationFetchFinished();
    }
  }, [api, store]);

  // Update the stream when this route is initially displayed and whenever
  // the search query is updated.
  h(() => {
    // Sort the stream so that the newest annotations are at the top
    store.setSortKey('Newest');
    store.clearAnnotations();
    loadAnnotations(currentQuery).catch(err => {
      toastMessenger.error(`Unable to fetch annotations: ${err.message}`);
    });
  }, [currentQuery, loadAnnotations, store, toastMessenger]);
  const rootThread = useRootThread();
  return o(ThreadList, {
    threads: rootThread.children
  }, void 0, false, {
    fileName: _jsxFileName$n,
    lineNumber: 65,
    columnNumber: 10
  }, this);
}
var StreamView$1 = withServices(StreamView, ['api', 'toastMessenger']);

/**
 * @typedef {import('../../types/annotator').SegmentInfo} SegmentInfo
 * @typedef {import('../store/modules/frames').Frame} Frame
 */

/**
 * @typedef UserDetails
 * @prop {string|null} [userid]
 * @prop {string} [displayName]
 */

class VersionData {
  /**
   * @param {UserDetails} userInfo
   * @param {Frame[]} documentFrames - Metadata for connected frames.
   *   If there are multiple frames, the "main" one should be listed first.
   * @param {Window} window_ - test seam
   */
  constructor(userInfo, documentFrames, window_ = window) {
    var _documentFrames$0$met, _documentFrames$, _documentFrames$$meta, _documentFrames$2;
    const noValueString = 'N/A';
    let accountString = noValueString;
    if (userInfo.userid) {
      accountString = userInfo.userid;
      if (userInfo.displayName) {
        accountString = `${userInfo.displayName} (${accountString})`;
      }
    }
    this.version = '1.0.0-dummy-version';
    this.userAgent = window_.navigator.userAgent;
    this.urls = documentFrames.map(df => df.uri).join(', ') || noValueString;

    // We currently assume that only the main (first) frame may have a fingerprint.
    this.fingerprint = (_documentFrames$0$met = (_documentFrames$ = documentFrames[0]) === null || _documentFrames$ === void 0 ? void 0 : (_documentFrames$$meta = _documentFrames$.metadata) === null || _documentFrames$$meta === void 0 ? void 0 : _documentFrames$$meta.documentFingerprint) !== null && _documentFrames$0$met !== void 0 ? _documentFrames$0$met : noValueString;
    this.account = accountString;
    this.timestamp = new Date().toString();
    const segmentInfo = (_documentFrames$2 = documentFrames[0]) === null || _documentFrames$2 === void 0 ? void 0 : _documentFrames$2.segment;
    if (segmentInfo) {
      const segmentFields = [];
      if (segmentInfo.cfi) {
        segmentFields.push(['CFI', segmentInfo.cfi]);
      }
      if (segmentInfo.url) {
        segmentFields.push(['URL', segmentInfo.url]);
      }
      this.segment = segmentFields.map(([field, value]) => `${field}: ${value}`).join(', ');
    }
  }

  /**
   * Return a single formatted string representing version data, suitable for
   * copying to the clipboard.
   *
   * @return {string} - Single, multiline string representing current version data
   */
  asFormattedString() {
    return `Version: ${this.version}
User Agent: ${this.userAgent}
URL: ${this.urls}
Fingerprint: ${this.fingerprint}
Account: ${this.account}
Date: ${this.timestamp}
`;
  }

  /**
   * Return a single, encoded URL string of version data suitable for use in
   * a querystring (as the value of a single parameter)
   *
   * @return {string} - URI-encoded string
   */
  asEncodedURLString() {
    return encodeURIComponent(this.asFormattedString());
  }
}

/**
 * @typedef {import('../../types/config').SidebarSettings} SidebarSettings
 */

/**
 * Return `true` if the first configured service is a "third-party" service.
 *
 * Return `true` if the first custom annotation service configured in the
 * services array in the host page is a third-party service, `false` otherwise.
 *
 * If no custom annotation services are configured then return `false`.
 *
 * @param {SidebarSettings} settings
 * @return {boolean}
 */
function isThirdPartyService(settings) {
  const service = serviceConfig(settings);
  if (service !== null && service !== void 0 && service.authority) {
    return service.authority !== settings.authDomain;
  }
  return false;
}

var _jsxFileName$m = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/Tutorial.js";
function TutorialInstruction({
  commandName,
  iconName
}) {
  return o("span", {
    className: "whitespace-nowrap",
    children: [o(Icon, {
      name: iconName,
      classes: classnames('mx-1 -mt-1',
      // Give horizontal space; pull up top margin a little
      'text-color-text-light inline')
    }, void 0, false, {
      fileName: _jsxFileName$m,
      lineNumber: 19,
      columnNumber: 7
    }, this), o("em", {
      children: commandName
    }, void 0, false, {
      fileName: _jsxFileName$m,
      lineNumber: 26,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$m,
    lineNumber: 18,
    columnNumber: 5
  }, this);
}

/**
 * Tutorial for using the sidebar app
 *
 * @param {object} props
 *   @param {import('../../types/config').SidebarSettings} props.settings
 */
function Tutorial({
  settings
}) {
  const canCreatePrivateGroups = !isThirdPartyService(settings);
  return o("ol", {
    className: "list-decimal pl-10 space-y-2",
    children: [o("li", {
      children: ["\u0644\u062A\u0648\u0633\u064A\u0645 \u0627\u0644\u0643\u0644\u0645\u0629 \u060C \u062D\u062F\u062F \u0627\u0644\u0646\u0635 \u062B\u0645 \u0627\u062E\u062A\u0631 \u0632\u0631", ' ', o(TutorialInstruction, {
        iconName: "annotate",
        commandName: "\u062A\u0648\u0633\u064A\u0645"
      }, void 0, false, {
        fileName: _jsxFileName$m,
        lineNumber: 43,
        columnNumber: 9
      }, this), ' ', "."]
    }, void 0, true, {
      fileName: _jsxFileName$m,
      lineNumber: 41,
      columnNumber: 7
    }, this), o("li", {
      children: ["\u0644\u062A\u0638\u0644\u064A\u0644 \u0627\u0644\u0643\u0644\u0645\u0629 (", o(Link, {
        classes: "underline hover:underline",
        href: "https://web.hypothes.is/help/why-are-highlights-private-by-default/",
        target: "_blank",
        children: "\u0638\u0627\u0647\u0631\u0629 \u0644\u0643 \u0641\u0642\u0637"
      }, void 0, false, {
        fileName: _jsxFileName$m,
        lineNumber: 48,
        columnNumber: 9
      }, this), "), \u062D\u062F\u062F \u0627\u0644\u0646\u0635 \u062B\u0645 \u0627\u062E\u062A\u0631", ' ', o(TutorialInstruction, {
        iconName: "highlight",
        commandName: "\u062A\u0638\u0644\u064A\u0644"
      }, void 0, false, {
        fileName: _jsxFileName$m,
        lineNumber: 56,
        columnNumber: 9
      }, this), ' ', "."]
    }, void 0, true, {
      fileName: _jsxFileName$m,
      lineNumber: 46,
      columnNumber: 7
    }, this), canCreatePrivateGroups && o("li", {
      children: ["\u0644\u0644\u062A\u0648\u0633\u064A\u0645 \u0641\u064A \u0645\u062C\u0645\u0648\u0639\u0629 \u062E\u0627\u0635\u0629\u060C \u0627\u062E\u062A\u0631 \u0627\u0644\u0645\u062C\u0645\u0648\u0639\u0629 \u0645\u0646 \u0627\u0644\u0642\u0627\u0626\u0645\u0629 \u0627\u0639\u0644\u0627\u0647. \u0641\u064A \u062D\u0627\u0644 \u0644\u0645 \u062A\u0638\u0647\u0631 \u0627\u0644\u0645\u062C\u0645\u0648\u0639\u0629 \u0627\u0633\u0623\u0644 \u0645\u0646\u0634\u0626 \u0627\u0644\u0645\u062C\u0645\u0648\u0639\u0629", ' ', o(Link, {
        classes: "underline hover:underline",
        href: "https://web.hypothes.is/help/how-to-join-a-private-group/",
        target: "_blank",
        children: "\u0631\u0627\u0628\u0637 \u0627\u0644\u0627\u0646\u0636\u0645\u0627\u0645"
      }, void 0, false, {
        fileName: _jsxFileName$m,
        lineNumber: 62,
        columnNumber: 11
      }, this), ")."]
    }, void 0, true, {
      fileName: _jsxFileName$m,
      lineNumber: 60,
      columnNumber: 9
    }, this), o("li", {
      children: ["\u0644\u0644\u0631\u062F \u0639\u0644\u0649 \u0643\u0644\u0645\u0629 \u0645\u0648\u0633\u0645\u0629\u060C \u0627\u062E\u062A\u0631 ", ' ', o(TutorialInstruction, {
        iconName: "reply",
        commandName: "\u0627\u0644\u0631\u062F"
      }, void 0, false, {
        fileName: _jsxFileName$m,
        lineNumber: 74,
        columnNumber: 9
      }, this), " ."]
    }, void 0, true, {
      fileName: _jsxFileName$m,
      lineNumber: 72,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$m,
    lineNumber: 40,
    columnNumber: 5
  }, this);
}
var Tutorial$1 = withServices(Tutorial, ['settings']);

var _jsxFileName$l = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/VersionInfo.tsx";
function VersionInfoItem({
  label,
  children,
  classes
}) {
  return o(p$2, {
    children: [o("dt", {
      className: "col-span-1 sm:text-right font-medium",
      children: label
    }, void 0, false, {
      fileName: _jsxFileName$l,
      lineNumber: 19,
      columnNumber: 7
    }, this), o("dd", {
      className: classnames('col-span-1 sm:col-span-3 text-color-text-light break-words', classes),
      children: children
    }, void 0, false, {
      fileName: _jsxFileName$l,
      lineNumber: 20,
      columnNumber: 7
    }, this)]
  }, void 0, true);
}
function VersionInfo({
  toastMessenger,
  versionData
}) {
  const copyVersionData = () => {
    try {
      copyText(versionData.asFormattedString());
      toastMessenger.success('Copied version info to clipboard');
    } catch (err) {
      toastMessenger.error('Unable to copy version info');
    }
  };
  return o("div", {
    className: "space-y-4",
    children: [o("dl", {
      className: "grid grid-cols-1 sm:grid-cols-4 sm:gap-x-2",
      children: [o(VersionInfoItem, {
        label: "Version",
        children: versionData.version
      }, void 0, false, {
        fileName: _jsxFileName$l,
        lineNumber: 52,
        columnNumber: 9
      }, this), o(VersionInfoItem, {
        label: "User Agent",
        children: versionData.userAgent
      }, void 0, false, {
        fileName: _jsxFileName$l,
        lineNumber: 53,
        columnNumber: 9
      }, this), o(VersionInfoItem, {
        classes: classnames(
        // Intermittent odd overflow behavior in Safari causes long strings
        // with no wrap points to break layout — `overflow-wrap: break-words`
        // is not reliable in this case. Use `break-all` here, which causes
        // more inelgant wrapping in all browsers, but is safely contained
        // in the layout.
        // See: https://github.com/hypothesis/client/issues/4469
        'break-all'),
        label: "URL",
        children: versionData.urls
      }, void 0, false, {
        fileName: _jsxFileName$l,
        lineNumber: 56,
        columnNumber: 9
      }, this), o(VersionInfoItem, {
        label: "Fingerprint",
        children: versionData.fingerprint
      }, void 0, false, {
        fileName: _jsxFileName$l,
        lineNumber: 70,
        columnNumber: 9
      }, this), versionData.segment && o(VersionInfoItem, {
        label: "Segment",
        children: versionData.segment
      }, void 0, false, {
        fileName: _jsxFileName$l,
        lineNumber: 74,
        columnNumber: 11
      }, this), o(VersionInfoItem, {
        label: "Account",
        children: versionData.account
      }, void 0, false, {
        fileName: _jsxFileName$l,
        lineNumber: 78,
        columnNumber: 9
      }, this), o(VersionInfoItem, {
        label: "Date",
        children: versionData.timestamp
      }, void 0, false, {
        fileName: _jsxFileName$l,
        lineNumber: 79,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$l,
      lineNumber: 51,
      columnNumber: 7
    }, this), o("div", {
      className: "flex items-center justify-center",
      children: o(ButtonNext, {
        onClick: copyVersionData,
        icon: CopyIcon,
        children: "Copy version details"
      }, void 0, false, {
        fileName: _jsxFileName$l,
        lineNumber: 82,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$l,
      lineNumber: 81,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$l,
    lineNumber: 50,
    columnNumber: 5
  }, this);
}
var VersionInfo$1 = withServices(VersionInfo, ['toastMessenger']);

var _jsxFileName$k = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/HelpPanel.tsx";
/**
 * Navigation link-button to swap between sub-panels in the help panel
 */
function HelpPanelNavigationButton({
  children,
  onClick
}) {
  return o(LinkButtonNext, {
    color: "brand",
    onClick: onClick,
    underline: "hover",
    children: o("div", {
      className: "flex items-center gap-x-1",
      children: [children, o(ArrowRightIcon, {
        className: "w-em h-em"
      }, void 0, false, {
        fileName: _jsxFileName$k,
        lineNumber: 35,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$k,
      lineNumber: 33,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$k,
    lineNumber: 32,
    columnNumber: 5
  }, this);
}
/**
 * External link "tabs" inside of the help panel.
 */
function HelpPanelTab({
  linkText,
  url
}) {
  return o("div", {
    // Set this element's flex-basis and also establish
    // a flex container (centered on both axes)
    className: "flex-1 flex items-center justify-center border-r last-of-type:border-r-0 text-lg font-medium",
    children: o(LinkNext, {
      color: "text-light",
      href: url,
      target: "_blank",
      children: o("div", {
        className: "flex items-center gap-x-2",
        children: [o("span", {
          children: linkText
        }, void 0, false, {
          fileName: _jsxFileName$k,
          lineNumber: 60,
          columnNumber: 11
        }, this), " ", o(ExternalIcon, {
          className: "w-3 h-3"
        }, void 0, false, {
          fileName: _jsxFileName$k,
          lineNumber: 60,
          columnNumber: 35
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName$k,
        lineNumber: 59,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$k,
      lineNumber: 58,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$k,
    lineNumber: 53,
    columnNumber: 5
  }, this);
}
/**
 * A help sidebar panel with two sub-panels: tutorial and version info.
 */
function HelpPanel({
  session
}) {
  var _profile$user_info$di, _profile$user_info;
  const store = useSidebarStore();
  const frames = store.frames();
  const mainFrame = store.mainFrame();
  const profile = store.profile();
  const displayName = (_profile$user_info$di = (_profile$user_info = profile.user_info) === null || _profile$user_info === void 0 ? void 0 : _profile$user_info.display_name) !== null && _profile$user_info$di !== void 0 ? _profile$user_info$di : username(profile.userid);

  // Should this panel be auto-opened at app launch? Note that the actual
  // auto-open triggering of this panel is owned by the `HypothesisApp` component.
  // This reference is such that we know whether we should "dismiss" the tutorial
  // (permanently for this user) when it is closed.
  const hasAutoDisplayPreference = !!store.profile().preferences.show_sidebar_tutorial;
  const subPanelTitles = {
    tutorial: 'بدء الاستخدام',
    versionInfo: 'عن هذه النسخة'
  };
  // The "Tutorial" (getting started) subpanel is the default panel shown
  const [activeSubPanel, setActiveSubPanel] = p('tutorial');

  // Build version details about this session/app
  const versionData = F(() => {
    // Sort frames so the main frame is listed first. Other frames will retain
    // their original order, assuming a stable sort.
    const documentFrames = [...frames].sort((a, b) => {
      if (a === mainFrame) {
        return -1;
      } else if (b === mainFrame) {
        return 1;
      } else {
        return 0;
      }
    });
    return new VersionData({
      userid: profile.userid,
      displayName
    }, documentFrames);
  }, [profile, displayName, frames, mainFrame]);

  // The support ticket URL encodes some version info in it to pre-fill in the
  // create-new-ticket form
  const supportTicketURL = `https://web.hypothes.is/get-help/?sys_info=${versionData.asEncodedURLString()}`;
  const openSubPanel = (e, panelName) => {
    e.preventDefault();
    setActiveSubPanel(panelName);
  };
  const onActiveChanged = T$1(active => {
    if (!active && hasAutoDisplayPreference) {
      // If the tutorial is currently being auto-displayed, update the user
      // preference to disable the auto-display from happening on subsequent
      // app launches
      session.dismissSidebarTutorial();
    }
  }, [session, hasAutoDisplayPreference]);
  return o(SidebarPanel, {
    title: "Help",
    panelName: "help",
    onActiveChanged: onActiveChanged,
    children: o("div", {
      className: "space-y-4",
      children: [o("div", {
        className: "flex items-center",
        children: [o("h3", {
          className: "grow text-lg font-medium",
          "data-testid": "subpanel-title",
          children: subPanelTitles[activeSubPanel]
        }, void 0, false, {
          fileName: _jsxFileName$k,
          lineNumber: 147,
          columnNumber: 11
        }, this), activeSubPanel === 'versionInfo' && o(HelpPanelNavigationButton, {
          onClick: e => openSubPanel(e, 'tutorial'),
          children: "\u0628\u062F\u0621 \u0627\u0644\u0627\u0633\u062A\u062E\u062F\u0627\u0645"
        }, void 0, false, {
          fileName: _jsxFileName$k,
          lineNumber: 151,
          columnNumber: 13
        }, this), activeSubPanel === 'tutorial' && o(HelpPanelNavigationButton, {
          onClick: e => openSubPanel(e, 'versionInfo'),
          children: "\u0639\u0646 \u0647\u0630\u0647 \u0627\u0644\u0646\u0633\u062E\u0629"
        }, void 0, false, {
          fileName: _jsxFileName$k,
          lineNumber: 158,
          columnNumber: 13
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName$k,
        lineNumber: 146,
        columnNumber: 9
      }, this), o("div", {
        className: "border-y py-4",
        children: [activeSubPanel === 'tutorial' && o(Tutorial$1, {}, void 0, false, {
          fileName: _jsxFileName$k,
          lineNumber: 166,
          columnNumber: 45
        }, this), activeSubPanel === 'versionInfo' && o(VersionInfo$1, {
          versionData: versionData
        }, void 0, false, {
          fileName: _jsxFileName$k,
          lineNumber: 168,
          columnNumber: 13
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName$k,
        lineNumber: 165,
        columnNumber: 9
      }, this), o("div", {
        className: "flex items-center",
        children: [o(HelpPanelTab, {
          linkText: "Help topics",
          url: "https://web.hypothes.is/help/"
        }, void 0, false, {
          fileName: _jsxFileName$k,
          lineNumber: 172,
          columnNumber: 11
        }, this), o(HelpPanelTab, {
          linkText: "New support ticket",
          url: supportTicketURL
        }, void 0, false, {
          fileName: _jsxFileName$k,
          lineNumber: 176,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName$k,
        lineNumber: 171,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$k,
      lineNumber: 145,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$k,
    lineNumber: 140,
    columnNumber: 5
  }, this);
}
var HelpPanel$1 = withServices(HelpPanel, ['session']);

var tinyEmitter = {exports: {}};

function E () {
  // Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}

E.prototype = {
  on: function (name, callback, ctx) {
    var e = this.e || (this.e = {});

    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });

    return this;
  },

  once: function (name, callback, ctx) {
    var self = this;
    function listener () {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    };

    listener._ = callback;
    return this.on(name, listener, ctx);
  },

  emit: function (name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  },

  off: function (name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }

    // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    (liveEvents.length)
      ? e[name] = liveEvents
      : delete e[name];

    return this;
  }
};

tinyEmitter.exports = E;
var TinyEmitter = tinyEmitter.exports.TinyEmitter = E;

/**
 * @typedef {import('../types/api').Annotation} Annotation
 * @typedef {import('../types/api').SearchQuery} SearchQuery
 * @typedef {import('../types/api').SearchResponse} SearchResponse
 *
 */

/**
 * Indicates that there are more annotations matching the current API
 * search request than the interface can currently handle displaying
 * (Notebook).
 */
class ResultSizeError extends Error {
  /**
   * @param {number} limit
   */
  constructor(limit) {
    super(`Results size exceeds ${limit}`);
  }
}

/**
 * @typedef {'created'|'updated'} SortBy
 * @typedef {'asc'|'desc'} SortOrder
 */
/**
 * Default callback used to get the page size for iterating through annotations.
 *
 * This uses a small number for the first page to reduce the time until some
 * results are displayed and a larger number for remaining pages to lower the
 * total fetch time.
 *
 * @param {number} index
 */
function defaultPageSize(index) {
  return index === 0 ? 50 : 200;
}

/**
 * Client for the Hypothesis search API [1]
 *
 * SearchClient handles paging through results, canceling search etc.
 *
 * [1] https://h.readthedocs.io/en/latest/api-reference/#tag/annotations/paths/~1search/get
 */
class SearchClient extends TinyEmitter {
  /**
   * @param {(query: SearchQuery) => Promise<SearchResponse>} searchFn -
   *   Callback that executes a search request against the Hypothesis API
   * @param {object} options
   *   @param {(index: number) => number} [options.getPageSize] -
   *     Callback that returns the page size to use when fetching the index'th
   *     page of results.  Callers can vary this to balance the latency of
   *     getting some results against the time taken to fetch all results.
   *
   *     The returned page size must be at least 1 and no more than the maximum
   *     value of the `limit` query param for the search API.
   *   @param {boolean} [options.separateReplies] - When `true`, request that
   *   top-level annotations and replies be returned separately.
   *   NOTE: This has issues with annotations that have large numbers of
   *   replies.
   *   @param {boolean} [options.incremental] - Emit `results` events incrementally
   *   as pages of annotations are fetched
   *   @param {number|null} [options.maxResults] - Safety valve for protection when
   *   loading all annotations in a group in the NotebookView. If the Notebook
   *   is opened while focused on a group that contains many thousands of
   *   annotations, it could cause rendering and network misery in the browser.
   *   When present, do not load annotations if the result set size exceeds
   *   this value.
   *   @param {SortBy} [options.sortBy] - Together with `sortOrder`, specifies in
   *     what order annotations are fetched from the backend.
   *   @param {SortOrder} [options.sortOrder]
   */
  constructor(searchFn, {
    getPageSize = defaultPageSize,
    separateReplies = true,
    incremental = true,
    maxResults = null,
    sortBy = 'created',
    sortOrder = 'asc'
  } = {}) {
    super();
    this._searchFn = searchFn;
    this._getPageSize = getPageSize;
    this._separateReplies = separateReplies;
    this._incremental = incremental;
    this._maxResults = maxResults;
    this._sortBy = sortBy;
    this._sortOrder = sortOrder;
    this._canceled = false;
    /** @type {Annotation[]} */
    this._results = [];
    this._resultCount = null;
  }

  /**
   * Fetch a page of annotations.
   *
   * @param {SearchQuery} query - Query params for /api/search call
   * @param {string} [searchAfter] - Cursor value to use when paginating
   *   through results. Omitted for the first page. See docs for `search_after`
   *   query param for /api/search API.
   * @param {number} [pageIndex]
   */
  async _getPage(query, searchAfter, pageIndex = 0) {
    const pageSize = this._getPageSize(pageIndex);

    /** @type {SearchQuery} */
    const searchQuery = {
      limit: pageSize,
      sort: this._sortBy,
      order: this._sortOrder,
      _separate_replies: this._separateReplies,
      ...query
    };
    if (searchAfter) {
      searchQuery.search_after = searchAfter;
    }
    try {
      const results = await this._searchFn(searchQuery);
      if (this._canceled) {
        return;
      }
      if (this._resultCount === null) {
        // Emit the result count (total) on first encountering it
        this._resultCount = results.total;
        this.emit('resultCount', this._resultCount);
      }

      // For now, abort loading of annotations if `maxResults` is set and the
      // number of annotations in the results set exceeds that value.
      //
      // NB: We can’t currently, reliably load a subset of a group’s
      // annotations, as replies are mixed in with top-level annotations—when
      // `separateReplies` is false, which it is in most or all cases—so we’d
      // end up with partially-loaded threads.
      //
      // This change has no effect on loading annotations in the SidebarView,
      // where the `maxResults` option is not used.
      if (this._maxResults && results.total > this._maxResults) {
        this.emit('error', new ResultSizeError(this._maxResults));
        this.emit('end');
        return;
      }
      const page = results.rows.concat(results.replies || []);
      if (this._incremental) {
        this.emit('results', page);
      } else {
        this._results = this._results.concat(page);
      }

      // If the current page was full, there might be additional pages available.
      const nextPageAvailable = page.length === pageSize;

      // Get the cursor for the start of the next page. This is the last
      // value for whatever field results are sorted by from the current page.
      const nextSearchAfter = page.length > 0 ? page[page.length - 1][this._sortBy] : null;
      if (nextPageAvailable && nextSearchAfter) {
        this._getPage(query, nextSearchAfter, pageIndex + 1);
      } else {
        if (!this._incremental) {
          this.emit('results', this._results);
        }
        this.emit('end');
      }
    } catch (err) {
      if (this._canceled) {
        return;
      }
      this.emit('error', err);
      this.emit('end');
    }
  }

  /**
   * Perform a search against the Hypothesis API.
   *
   * Emits a 'results' event with an array of annotations as they become
   * available (in incremental mode) or when all annotations are available
   * (in non-incremental mode).
   *
   * Emits an 'error' event if the search fails.
   * Emits an 'end' event once the search completes.
   *
   * @param {SearchQuery} query
   */
  get(query) {
    this._results = [];
    this._resultCount = null;
    this._getPage(query);
  }

  /**
   * Cancel the current search and emit the 'end' event.
   * No further events will be emitted after this.
   */
  cancel() {
    this._canceled = true;
    this.emit('end');
  }
}

/** @typedef {import('../../store/modules/filters').FilterOption} FilterOption */

/**
 * Generate a list of users for filtering annotations; update when set of
 * annotations or filter state changes meaningfully.
 *
 * @return {FilterOption[]}
 */
function useUserFilterOptions() {
  const store = useSidebarStore();
  const annotations = store.allAnnotations();
  const focusFilters = store.getFocusFilters();
  const currentUsername = username(store.profile().userid);
  const defaultAuthority = store.defaultAuthority();
  const displayNamesEnabled = store.isFeatureEnabled('client_display_names');
  return F(() => {
    // Determine unique users (authors) in annotation collection
    /** @type {Record<string, string>} */
    const users = {};
    annotations.forEach(annotation => {
      const username_ = username(annotation.user);
      users[username_] = annotationDisplayName(annotation, defaultAuthority, displayNamesEnabled);
    });

    // If user-focus is configured (even if not applied) add a filter
    // option for that user. Note that this always respects the display
    // value, even if `client_display_names` feature flags is not enabled:
    // this matches current implementation of focus mode.
    if (focusFilters.user) {
      const username_ = username(focusFilters.user.value) || focusFilters.user.value;
      users[username_] = focusFilters.user.display;
    }

    // Convert to an array of `FilterOption` objects
    const userOptions = Object.keys(users).map(user => {
      // If the user is the current user, add "(Me)" to the displayed name
      const display = user === currentUsername ? `${users[user]} (Me)` : users[user];
      return {
        display,
        value: user
      };
    });
    userOptions.sort((a, b) => {
      // Ensure that the current user "Me" resides at the front of the list
      if (currentUsername === a.value) {
        return -1;
      } else if (currentUsername === b.value) {
        return 1;
      } else {
        return a.display.localeCompare(b.display);
      }
    });
    return userOptions;
  }, [annotations, currentUsername, defaultAuthority, displayNamesEnabled, focusFilters.user]);
}

var _jsxFileName$j = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/FilterSelect.js";
function FilterSelect({
  defaultOption,
  icon: Icon,
  onSelect,
  options,
  selectedOption,
  title
}) {
  const filterOptions = [defaultOption, ...options];
  const selected = selectedOption !== null && selectedOption !== void 0 ? selectedOption : defaultOption;
  const menuLabel = o("span", {
    className: classnames(
    // Don't allow the label text to wrap
    'shrink-0 flex items-center gap-x-2', 'text-color-text font-bold text-lg'),
    children: [Icon && o(Icon, {
      className: "w-4 h-4"
    }, void 0, false, {
      fileName: _jsxFileName$j,
      lineNumber: 46,
      columnNumber: 16
    }, this), selected.display]
  }, void 0, true, {
    fileName: _jsxFileName$j,
    lineNumber: 39,
    columnNumber: 5
  }, this);
  return o(Menu, {
    label: menuLabel,
    title: title,
    contentClass: classnames(
    // Don't let filter list get too terribly tall. On shorter screens,
    // restrict to 70vh; set a static max-height for taller screens.
    'max-h-[70vh] tall:max-h-[504px] overflow-y-auto'),
    children: filterOptions.map(filterOption => o(MenuItem, {
      onClick: () => onSelect(filterOption),
      isSelected: filterOption.value === selected.value,
      label: filterOption.display
    }, filterOption.value, false, {
      fileName: _jsxFileName$j,
      lineNumber: 62,
      columnNumber: 9
    }, this))
  }, void 0, false, {
    fileName: _jsxFileName$j,
    lineNumber: 52,
    columnNumber: 5
  }, this);
}

var _jsxFileName$i = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/NotebookFilters.js";
function NotebookFilters() {
  const store = useSidebarStore();
  const userFilter = store.getFilter('user');
  const userFilterOptions = useUserFilterOptions();
  return o(FilterSelect, {
    defaultOption: {
      value: '',
      display: 'Everybody'
    },
    icon: ProfileIcon,
    onSelect: userFilter => store.setFilter('user', userFilter),
    options: userFilterOptions,
    selectedOption: userFilter,
    title: "Filter by user"
  }, void 0, false, {
    fileName: _jsxFileName$i,
    lineNumber: 22,
    columnNumber: 5
  }, this);
}

var _jsxFileName$h = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/NotebookResultCount.js";
function NotebookResultCount({
  forcedVisibleCount,
  isFiltered,
  isLoading,
  resultCount
}) {
  const rootThread = useRootThread();
  const visibleCount = isLoading ? resultCount : countVisible(rootThread);
  const hasResults = rootThread.children.length > 0;
  const hasForcedVisible = isFiltered && forcedVisibleCount > 0;
  const matchCount = visibleCount - forcedVisibleCount;
  const threadCount = rootThread.children.length;
  return o("div", {
    className: "flex gap-x-1 leading-none",
    children: [isLoading && o(Spinner, {
      size: "small"
    }, void 0, false, {
      fileName: _jsxFileName$h,
      lineNumber: 42,
      columnNumber: 21
    }, this), !isLoading && o("h2", {
      className: "font-bold",
      children: [!hasResults && o("span", {
        children: "No results"
      }, void 0, false, {
        fileName: _jsxFileName$h,
        lineNumber: 45,
        columnNumber: 27
      }, this), hasResults && isFiltered && o("span", {
        children: [matchCount, " ", matchCount === 1 ? 'result' : 'results']
      }, void 0, true, {
        fileName: _jsxFileName$h,
        lineNumber: 47,
        columnNumber: 13
      }, this), hasResults && !isFiltered && o("span", {
        children: [threadCount, " ", threadCount === 1 ? 'thread' : 'threads']
      }, void 0, true, {
        fileName: _jsxFileName$h,
        lineNumber: 52,
        columnNumber: 13
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$h,
      lineNumber: 44,
      columnNumber: 9
    }, this), hasForcedVisible && o("h3", {
      className: "italic font-normal",
      children: ["(and ", forcedVisibleCount, " more)"]
    }, void 0, true, {
      fileName: _jsxFileName$h,
      lineNumber: 59,
      columnNumber: 9
    }, this), !isFiltered && hasResults && o("h3", {
      className: "italic font-normal",
      children: ["(", visibleCount, " ", visibleCount === 1 ? 'annotation' : 'annotations', ")"]
    }, void 0, true, {
      fileName: _jsxFileName$h,
      lineNumber: 62,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$h,
    lineNumber: 41,
    columnNumber: 5
  }, this);
}

/**
 * The number of an available pagination page, or `null`, indicating a gap
 * between sequential numbered pages.
 *
 * @typedef {number|null} PageNumber
 */

/**
 * Determine the set of (pagination) page numbers that should be provided to
 * a user, given the current page the user is on, the total number of pages
 * available, and the number of individual page options desired.
 *
 * The first, last and current pages will always be included in the returned
 * results. Additional pages adjacent to the current page will be added until
 * `maxPages` is reached. Gaps in the sequence of pages are represented by
 * `null` values.
 *
 * @example
 *   pageNumberOptions(1, 10, 5) => [1, 2, 3, 4, null, 10]
 *   pageNumberOptions(3, 10, 5) => [1, 2, 3, 4, null, 10]
 *   pageNumberOptions(6, 10, 5) => [1, null, 5, 6, 7, null, 10]
 *   pageNumberOptions(9, 10, 5) => [1, null, 7, 8, 9, 10]
 *   pageNumberOptions(2, 3, 5) => [1, 2, 3]
 *
 * @param {number} currentPage - The currently-visible/-active page of results.
 *   Note that pages are 1-indexed
 * @param {number} totalPages
 * @param {number} [maxPages] - The maximum number of numbered pages to make
 *   available
 * @return {PageNumber[]} Set of navigation page options to show. `null`
 *   values represent gaps in the sequence of pages, to be represented later
 *   as ellipses (...)
 */
function pageNumberOptions(currentPage, totalPages, maxPages = 5) {
  if (totalPages <= 1) {
    return [];
  }

  // Start with first, last and current page. Use a set to avoid dupes.
  const pageNumbers = new Set([1, currentPage, totalPages]);

  // Fill out the `pageNumbers` with additional pages near the currentPage,
  // if available
  let increment = 1;
  while (pageNumbers.size < Math.min(totalPages, maxPages)) {
    // Build the set "outward" from the currently-active page
    if (currentPage + increment <= totalPages) {
      pageNumbers.add(currentPage + increment);
    }
    if (currentPage - increment >= 1) {
      pageNumbers.add(currentPage - increment);
    }
    ++increment;
  }
  const pageOptions = /** @type {PageNumber[]} */[];

  // Construct a numerically-sorted array with `null` entries inserted
  // between non-sequential entries
  [...pageNumbers].sort((a, b) => a - b).forEach((page, idx, arr) => {
    if (idx > 0 && page - arr[idx - 1] > 1) {
      // Two page entries are non-sequential. Push a `null` value between
      // them to indicate the gap, which will later be represented as an
      // ellipsis
      pageOptions.push(null);
    }
    pageOptions.push(page);
  });
  return pageOptions;
}

var _jsxFileName$g = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/PaginationNavigation.tsx";
function NavigationButton({
  ...buttonProps
}) {
  return o(ButtonBaseNext, {
    classes: classnames('px-3.5 py-2.5 gap-x-1 font-semibold',
    // These colors are the same as the "dark" variant of IconButton
    'text-grey-7 bg-grey-2 enabled:hover:text-grey-9 enabled:hover:bg-grey-3', 'disabled:text-grey-5 aria-pressed:bg-grey-3 aria-expanded:bg-grey-3'),
    ...buttonProps
  }, void 0, false, {
    fileName: _jsxFileName$g,
    lineNumber: 19,
    columnNumber: 5
  }, this);
}
/**
 * Render pagination navigation controls, with buttons to go next, previous
 * and nearby pages. Buttons corresponding to nearby pages are shown on wider
 * screens; for narrow screens only Prev and Next buttons are shown.
 *
 */
function PaginationNavigation({
  currentPage,
  onChangePage,
  totalPages
}) {
  // Pages are 1-indexed
  const hasNextPage = currentPage < totalPages;
  const hasPreviousPage = currentPage > 1;
  const pageNumbers = pageNumberOptions(currentPage, totalPages);

  /**
   * @param {number} pageNumber
   * @param {HTMLElement} element
   */
  const changePageTo = (pageNumber, element) => {
    onChangePage(pageNumber);
    // Because changing pagination page doesn't reload the page (as it would
    // in a "traditional" HTML context), the clicked-upon navigation button
    // will awkwardly retain focus unless it is actively removed.
    // TODO: Evaluate this for a11y issues
    element.blur();
  };
  return o("div", {
    className: "flex items-center text-lg",
    "data-testid": "pagination-navigation",
    children: [o("div", {
      className: "w-28 h-10",
      children: hasPreviousPage && o(NavigationButton, {
        title: "Go to previous page",
        onClick: e => changePageTo(currentPage - 1, e.target),
        children: [o(ArrowLeftIcon, {}, void 0, false, {
          fileName: _jsxFileName$g,
          lineNumber: 80,
          columnNumber: 13
        }, this), "prev"]
      }, void 0, true, {
        fileName: _jsxFileName$g,
        lineNumber: 74,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$g,
      lineNumber: 72,
      columnNumber: 7
    }, this), o("ul", {
      className: classnames(
      // Where there's enough horizontal space,
      // lay out page navigation buttons horizontally between prev/next:
      // | prevPage  |       numberedPages          | nextPage
      //
      // e.g.
      // | [<- prev] | [2] ... [5] [6] [7] ... [10] | [next ->] |
      //
      // These page buttons are hidden on narrow screens
      'hidden',
      // For slightly wider screens, they are shown in a horizontal row
      'md:flex md:items-center md:justify-center md:gap-x-2',
      // when visible, this element should stretch to fill available space
      'md:grow'),
      children: pageNumbers.map((page, idx) => o("li", {
        children: page === null ? o("div", {
          "data-testid": "pagination-gap",
          children: "..."
        }, void 0, false, {
          fileName: _jsxFileName$g,
          lineNumber: 105,
          columnNumber: 15
        }, this) : o(NavigationButton, {
          title: `Go to page ${page}`,
          pressed: page === currentPage,
          onClick: e => changePageTo(page, e.target),
          children: page.toString()
        }, `page-${idx}`, false, {
          fileName: _jsxFileName$g,
          lineNumber: 107,
          columnNumber: 15
        }, this)
      }, idx, false, {
        fileName: _jsxFileName$g,
        lineNumber: 103,
        columnNumber: 11
      }, this))
    }, void 0, false, {
      fileName: _jsxFileName$g,
      lineNumber: 85,
      columnNumber: 7
    }, this), o("div", {
      className: classnames('w-28 h-10 flex justify-end',
      // When page buttons are not shown, this element should grow to fill
      // available space. But when page buttons are shown, it should not.
      'grow md:grow-0'),
      children: hasNextPage && o(NavigationButton, {
        title: "Go to next page",
        onClick: e => changePageTo(currentPage + 1, e.target),
        children: ["next", o(ArrowRightIcon, {}, void 0, false, {
          fileName: _jsxFileName$g,
          lineNumber: 135,
          columnNumber: 13
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName$g,
        lineNumber: 128,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$g,
      lineNumber: 119,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$g,
    lineNumber: 68,
    columnNumber: 5
  }, this);
}

var _jsxFileName$f = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/PaginatedThreadList.js";
function PaginatedThreadList({
  currentPage,
  isLoading,
  onChangePage,
  threads,
  pageSize = 25
}) {
  const {
    paginatedThreads,
    totalPages
  } = F(() => {
    const visibleThreads = threads.filter(thread => countVisible(thread) > 0);
    const startIndex = (currentPage - 1) * pageSize;
    const endIndex = startIndex + pageSize;
    const totalPages = Math.ceil(visibleThreads.length / pageSize);
    return {
      paginatedThreads: visibleThreads.slice(startIndex, endIndex),
      totalPages
    };
  }, [threads, currentPage, pageSize]);
  return o(p$2, {
    children: [o(ThreadList, {
      threads: paginatedThreads
    }, void 0, false, {
      fileName: _jsxFileName$f,
      lineNumber: 47,
      columnNumber: 7
    }, this), !isLoading && o(PaginationNavigation, {
      currentPage: currentPage,
      onChangePage: onChangePage,
      totalPages: totalPages
    }, void 0, false, {
      fileName: _jsxFileName$f,
      lineNumber: 49,
      columnNumber: 9
    }, this)]
  }, void 0, true);
}

var _jsxFileName$e = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/NotebookView.js";
function NotebookView({
  loadAnnotationsService,
  streamer
}) {
  var _focusedGroup$name;
  const store = useSidebarStore();
  const filters = store.getFilterValues();
  const focusedGroup = store.focusedGroup();
  const forcedVisibleCount = store.forcedVisibleThreads().length;
  const hasAppliedFilter = store.hasAppliedFilter();
  const isLoading = store.isLoading();
  const resultCount = store.annotationResultCount();
  const pendingUpdateCount = store.pendingUpdateCount();
  const rootThread = useRootThread();
  const groupName = (_focusedGroup$name = focusedGroup === null || focusedGroup === void 0 ? void 0 : focusedGroup.name) !== null && _focusedGroup$name !== void 0 ? _focusedGroup$name : '…';

  // Get the ID of the group to fetch annotations from.
  //
  // Once groups have been fetched and one has been focused, use its ID. If
  // groups haven't been fetched yet but we know the ID of the group that is
  // likely to be focused (eg. because the notebook has been configured to
  // display a particular group when launched), we can optimistically fetch
  // annotations from that group.
  const groupId = (focusedGroup === null || focusedGroup === void 0 ? void 0 : focusedGroup.id) || store.directLinkedGroupId();
  const lastPaginationPage = _$1(1);
  const [paginationPage, setPaginationPage] = p(1);
  const [hasTooManyAnnotationsError, setHasTooManyAnnotationsError] = p(false);

  // Load all annotations in the group, unless there are more than 5000
  // of them: this is a performance safety valve.
  const maxResults = 5000;

  /** @param {Error} error */
  const onLoadError = error => {
    if (error instanceof ResultSizeError) {
      setHasTooManyAnnotationsError(true);
    }
  };
  const hasFetchedProfile = store.hasFetchedProfile();

  // Establish websocket connection
  h(() => {
    if (hasFetchedProfile) {
      streamer.connect({
        applyUpdatesImmediately: false
      });
    }
  }, [hasFetchedProfile, streamer]);

  // Load all annotations; re-load if `focusedGroup` changes
  h(() => {
    // NB: In current implementation, this will only happen/load once (initial
    // annotation fetch on application startup), as there is no mechanism
    // within the Notebook to change the `focusedGroup`. If the focused group
    // is changed within the sidebar and the Notebook re-opened, an entirely
    // new iFrame/app is created. This will need to be revisited.
    store.setSortKey('Newest');
    if (groupId) {
      loadAnnotationsService.load({
        groupId,
        // Load annotations in reverse-chronological order because that is how
        // threads are sorted in the notebook view. By aligning the fetch
        // order with the thread display order we reduce the changes in visible
        // content as annotations are loaded. This reduces the amount of time
        // the user has to wait for the content to load before they can start
        // reading it.
        //
        // Fetching is still suboptimal because we fetch both annotations and
        // replies together from the backend, but the user initially sees only
        // the top-level threads.
        sortBy: 'updated',
        sortOrder: 'desc',
        maxResults,
        onError: onLoadError,
        streamFilterBy: 'group'
      });
    }
  }, [loadAnnotationsService, groupId, store]);

  /** @param {number} newPage */
  const onChangePage = newPage => {
    setPaginationPage(newPage);
  };

  // When filter values or focused group are changed, reset pagination to page 1
  h(() => {
    onChangePage(1);
  }, [filters, focusedGroup]);

  // Scroll back to here when pagination page changes
  const threadListScrollTop = _$1( /** @type {HTMLElement|null}*/null);
  s(() => {
    // TODO: Transition and effects here should be improved
    if (paginationPage !== lastPaginationPage.current) {
      if (threadListScrollTop.current) {
        scrollIntoView(threadListScrollTop.current);
      }
      lastPaginationPage.current = paginationPage;
    }
  }, [paginationPage]);
  const tooltip = `Show ${pendingUpdateCount} new or updated ${pendingUpdateCount > 1 ? 'annotations' : 'annotation'}`;
  return o("div", {
    className: "grid gap-2 lg:grid-cols-2",
    "data-testid": "notebook-container",
    children: [o("header", {
      className: "leading-none lg:col-span-2",
      ref: threadListScrollTop,
      children: o("h1", {
        className: "text-2xl font-bold",
        "data-testid": "notebook-group-name",
        children: groupName
      }, void 0, false, {
        fileName: _jsxFileName$e,
        lineNumber: 134,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$e,
      lineNumber: 133,
      columnNumber: 7
    }, this), o("div", {
      className: "justify-self-start",
      children: o(NotebookFilters, {}, void 0, false, {
        fileName: _jsxFileName$e,
        lineNumber: 139,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$e,
      lineNumber: 138,
      columnNumber: 7
    }, this), o("div", {
      className: "flex items-center lg:justify-self-end text-lg font-medium",
      children: [pendingUpdateCount > 0 && !hasAppliedFilter && o(IconButton, {
        icon: "refresh",
        onClick: () => streamer.applyPendingUpdates(),
        variant: "primary",
        title: tooltip
      }, void 0, false, {
        fileName: _jsxFileName$e,
        lineNumber: 143,
        columnNumber: 11
      }, this), o(NotebookResultCount, {
        forcedVisibleCount: forcedVisibleCount,
        isFiltered: hasAppliedFilter,
        isLoading: isLoading,
        resultCount: resultCount !== null && resultCount !== void 0 ? resultCount : 0
      }, void 0, false, {
        fileName: _jsxFileName$e,
        lineNumber: 150,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$e,
      lineNumber: 141,
      columnNumber: 7
    }, this), o("div", {
      className: "lg:col-span-2",
      children: [hasTooManyAnnotationsError && o("div", {
        className: "py-4",
        "data-testid": "notebook-messages",
        children: o(Panel, {
          title: "Too many results to show",
          children: ["This preview of the Notebook can show", ' ', o("strong", {
            children: ["up to ", maxResults, " results"]
          }, void 0, true, {
            fileName: _jsxFileName$e,
            lineNumber: 162,
            columnNumber: 15
          }, this), " at a time (there are", ' ', resultCount, " to show here).", ' ', o("a", {
            href: "mailto:support@hypothes.is?subject=Hypothesis%20Notebook&body=Please%20notify%20me%20when%20the%20Hypothesis%20Notebook%20is%20updated%20to%20support%20more%20than%205000%20annotations",
            children: "Contact us"
          }, void 0, false, {
            fileName: _jsxFileName$e,
            lineNumber: 164,
            columnNumber: 15
          }, this), ' ', "if you would like to be notified when support for more annotations is available."]
        }, void 0, true, {
          fileName: _jsxFileName$e,
          lineNumber: 160,
          columnNumber: 13
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$e,
        lineNumber: 159,
        columnNumber: 11
      }, this), o(PaginatedThreadList, {
        currentPage: paginationPage,
        isLoading: isLoading,
        onChangePage: onChangePage,
        threads: rootThread.children
      }, void 0, false, {
        fileName: _jsxFileName$e,
        lineNumber: 172,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$e,
      lineNumber: 157,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$e,
    lineNumber: 132,
    columnNumber: 5
  }, this);
}
var NotebookView$1 = withServices(NotebookView, ['loadAnnotationsService', 'streamer']);

var _jsxFileName$d = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/ShareAnnotationsPanel.js";
function ShareAnnotationsPanel({
  toastMessenger
}) {
  const store = useSidebarStore();
  const mainFrame = store.mainFrame();
  const focusedGroup = store.focusedGroup();
  const groupName = focusedGroup && focusedGroup.name || '...';
  const panelTitle = `مشاركة التوسيم في ${groupName}`;

  // To be able to concoct a sharing link, a focused group and frame need to
  // be available
  const sharingReady = focusedGroup && mainFrame;
  const shareURI = sharingReady && pageSharingLink(notNull(mainFrame).uri, notNull(focusedGroup).id);
  const copyShareLink = () => {
    try {
      copyText( /** @type {string} */shareURI);
      toastMessenger.success('تم نسخ رابط المشاركة بنجاح');
    } catch (err) {
      toastMessenger.error('حدثت مشكلة اثناء عملية نسخ الرابط');
    }
  };
  return o(SidebarPanel, {
    title: panelTitle,
    panelName: "shareGroupAnnotations",
    children: [!sharingReady && o("div", {
      className: "flex flex-row items-center justify-center",
      children: o(Spinner, {}, void 0, false, {
        fileName: _jsxFileName$d,
        lineNumber: 60,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$d,
      lineNumber: 59,
      columnNumber: 9
    }, this), sharingReady && o("div", {
      className: "text-color-text-light space-y-3",
      children: shareURI ? o(p$2, {
        children: [o("div", {
          className: "text-color-text font-medium",
          "data-testid": "sharing-intro",
          children: notNull(focusedGroup).type === 'private' ? o("p", {
            children: "\u0627\u0633\u062A\u062E\u062F\u0645 \u0647\u0630\u0627 \u0627\u0644\u0631\u0627\u0628\u0637 \u0644\u0645\u0634\u0627\u0631\u0643\u0629 \u0627\u0644\u0643\u0644\u0645\u0627\u062A \u0627\u0644\u0645\u0648\u0633\u0645\u0629 \u0645\u0639 \u0627\u0644\u0627\u062E\u0631\u064A\u0646 \u0641\u064A \u0646\u0641\u0633 \u0627\u0644\u0645\u062C\u0645\u0648\u0639\u0629"
          }, void 0, false, {
            fileName: _jsxFileName$d,
            lineNumber: 72,
            columnNumber: 19
          }, this) : o("p", {
            children: "\u0627\u0633\u062A\u062E\u062F\u0645 \u0647\u0630\u0627 \u0627\u0644\u0631\u0627\u0628\u0637 \u0644\u0645\u0634\u0627\u0631\u0643\u0629 \u0627\u0644\u0643\u0644\u0645\u0627\u062A \u0627\u0644\u0645\u0648\u0633\u0645\u0629 \u0645\u0639 \u0627\u0644\u062C\u0645\u064A\u0639"
          }, void 0, false, {
            fileName: _jsxFileName$d,
            lineNumber: 76,
            columnNumber: 19
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName$d,
          lineNumber: 67,
          columnNumber: 15
        }, this), o("div", {
          children: o(TextInputWithButton, {
            children: [o(TextInput, {
              "aria-label": "Use this URL to share these annotations",
              type: "text",
              value: shareURI,
              readOnly: true
            }, void 0, false, {
              fileName: _jsxFileName$d,
              lineNumber: 81,
              columnNumber: 19
            }, this), o(IconButton, {
              icon: "copy",
              onClick: copyShareLink,
              title: "Copy share link",
              variant: "dark"
            }, void 0, false, {
              fileName: _jsxFileName$d,
              lineNumber: 87,
              columnNumber: 19
            }, this)]
          }, void 0, true, {
            fileName: _jsxFileName$d,
            lineNumber: 80,
            columnNumber: 17
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName$d,
          lineNumber: 79,
          columnNumber: 15
        }, this), o("p", {
          "data-testid": "sharing-details",
          children: [notNull(focusedGroup).type === 'private' ? o("span", {
            children: ["\u0627\u0644\u0643\u0644\u0645\u0627\u062A \u0627\u0644\u0645\u0648\u0633\u0645\u0629 \u0641\u064A \u0627\u0644\u0645\u062C\u0645\u0648\u0639\u0629 \u0627\u0644\u062E\u0627\u0635\u0629", ' ', o("em", {
              children: notNull(focusedGroup).name
            }, void 0, false, {
              fileName: _jsxFileName$d,
              lineNumber: 99,
              columnNumber: 21
            }, this), " \u0633\u062A\u0638\u0647\u0631 \u0641\u0642\u0637 \u0644\u0644\u0627\u0639\u0636\u0627\u0621 \u0641\u064A \u0646\u0641\u0633 \u0627\u0644\u0645\u062C\u0645\u0648\u0639\u0629"]
          }, void 0, true, {
            fileName: _jsxFileName$d,
            lineNumber: 97,
            columnNumber: 19
          }, this) : o("span", {
            children: ["\u064A\u0645\u0643\u0646 \u0644\u0627\u064A \u0627\u062D\u062F \u064A\u0645\u0644\u0643 \u0627\u0644\u0631\u0627\u0628\u0637 \u0627\u0644\u0627\u0637\u0644\u0627\u0639 \u0639\u0644\u0649 \u0627\u0644\u0645\u062D\u062A\u0648\u064A\u0627\u062A", ' ', o("em", {
              children: notNull(focusedGroup).name
            }, void 0, false, {
              fileName: _jsxFileName$d,
              lineNumber: 104,
              columnNumber: 21
            }, this), "."]
          }, void 0, true, {
            fileName: _jsxFileName$d,
            lineNumber: 102,
            columnNumber: 19
          }, this), ' ', o("span", {
            children: ["\u0627\u0644\u0645\u062C\u0645\u0648\u0639\u0629 (", o(Icon, {
              name: "lock",
              classes: "inline -mt-0.5"
            }, void 0, false, {
              fileName: _jsxFileName$d,
              lineNumber: 109,
              columnNumber: 19
            }, this), " ", o("em", {
              children: "\u0627\u0644\u062E\u0627\u0635\u0629 \u0628\u064A"
            }, void 0, false, {
              fileName: _jsxFileName$d,
              lineNumber: 109,
              columnNumber: 65
            }, this), ") \u0627\u0644\u0643\u0644\u0645\u0627\u062A \u0627\u0644\u0645\u0648\u0633\u0645\u0629 \u0633\u062A\u0638\u0631 \u0644\u0643 \u0641\u0642\u0637"]
          }, void 0, true, {
            fileName: _jsxFileName$d,
            lineNumber: 107,
            columnNumber: 17
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName$d,
          lineNumber: 95,
          columnNumber: 15
        }, this), o("div", {
          className: "text-[24px]",
          children: o(ShareLinks, {
            shareURI: shareURI
          }, void 0, false, {
            fileName: _jsxFileName$d,
            lineNumber: 114,
            columnNumber: 17
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName$d,
          lineNumber: 113,
          columnNumber: 15
        }, this)]
      }, void 0, true) : o("p", {
        "data-testid": "no-sharing",
        children: "These annotations cannot be shared because this document is not available on the web."
      }, void 0, false, {
        fileName: _jsxFileName$d,
        lineNumber: 118,
        columnNumber: 13
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$d,
      lineNumber: 64,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$d,
    lineNumber: 57,
    columnNumber: 5
  }, this);
}
var ShareAnnotationsPanel$1 = withServices(ShareAnnotationsPanel, ['toastMessenger']);

var _jsxFileName$c = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/ToastMessages.js";
function ToastMessage({
  message,
  onDismiss
}) {
  // Capitalize the message type for prepending; Don't prepend a message
  // type for "notice" messages
  const prefix = message.type !== 'notice' ? `${message.type.charAt(0).toUpperCase() + message.type.slice(1)}: ` : '';
  const iconName = message.type === 'notice' ? 'cancel' : message.type;
  /**
   * a11y linting is disabled here: There is a click-to-remove handler on a
   * non-interactive element. This allows sighted users to get the toast message
   * out of their way if it interferes with interacting with the underlying
   * components. This shouldn't pose the same irritation to users with screen-
   * readers as the rendered toast messages shouldn't impede interacting with
   * the underlying document.
   */
  return (/* eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-noninteractive-element-interactions */
    o(Card, {
      classes: classnames('p-0 flex border', {
        'sr-only': message.visuallyHidden,
        'border-red-error': message.type === 'error',
        'border-yellow-notice': message.type === 'notice',
        'border-green-success': message.type === 'success'
      }),
      onClick: () => onDismiss(message.id),
      children: [o("div", {
        className: classnames('flex items-center p-3 text-white', {
          'bg-red-error': message.type === 'error',
          'bg-yellow-notice': message.type === 'notice',
          'bg-green-success': message.type === 'success'
        }),
        children: o(Icon, {
          name: iconName,
          classes: classnames(
          // Adjust alignment of icon to appear more aligned with text
          'mt-[2px]')
        }, void 0, false, {
          fileName: _jsxFileName$c,
          lineNumber: 61,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName$c,
        lineNumber: 54,
        columnNumber: 7
      }, this), o("div", {
        className: classnames(
        // TODO: After re-factoring of Card styling, `mt-0` should not need
        // !important
        'grow p-3 !mt-0'),
        "data-testid": "toast-message-text",
        children: [o("strong", {
          children: prefix
        }, void 0, false, {
          fileName: _jsxFileName$c,
          lineNumber: 77,
          columnNumber: 9
        }, this), message.message, message.moreInfoURL && o("div", {
          className: "text-right",
          children: o(Link, {
            href: message.moreInfoURL,
            onClick: event => event.stopPropagation() /* consume the event so that it does not dismiss the message */,

            target: "_new",
            children: "More info"
          }, void 0, false, {
            fileName: _jsxFileName$c,
            lineNumber: 81,
            columnNumber: 13
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName$c,
          lineNumber: 80,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName$c,
        lineNumber: 69,
        columnNumber: 7
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$c,
      lineNumber: 45,
      columnNumber: 5
    }, this)
  );
}

/**
 * @typedef ToastMessagesProps
 * @prop {import('../services/toast-messenger').ToastMessengerService} toastMessenger
 */

/**
 * A collection of toast messages. These are rendered within an `aria-live`
 * region for accessibility with screen readers.
 *
 * @param {ToastMessagesProps} props
 */
function ToastMessages({
  toastMessenger
}) {
  const store = useSidebarStore();
  const messages = store.getToastMessages();
  // The `ul` containing any toast messages is absolute-positioned and the full
  // width of the viewport. Each toast message `li` has its position and width
  // constrained by `container` configuration in tailwind.
  return o("div", {
    children: o("ul", {
      "aria-live": "polite",
      "aria-relevant": "additions",
      className: "absolute z-2 left-0 w-full",
      children: messages.map(message => o("li", {
        className: classnames('relative w-full container hover:cursor-pointer', {
          // Add a bottom margin to visible messages only. Typically we'd
          // use a `space-y-2` class on the parent to space children.
          // Doing that here could cause an undesired top margin on
          // the first visible message in a list that contains (only)
          // visually-hidden messages before it.
          // See https://tailwindcss.com/docs/space#limitations
          'mb-2': !message.visuallyHidden,
          // Slide in from right in narrow viewports; fade in in
          // larger viewports to toast message isn't flying too far
          'motion-safe:animate-slide-in-from-right lg:animate-fade-in': !message.isDismissed,
          // Only ever fade in if motion-reduction is preferred
          'motion-reduce:animate-fade-in': !message.isDismissed,
          'animate-fade-out': message.isDismissed
        }),
        children: o(ToastMessage, {
          message: message,
          onDismiss: id => toastMessenger.dismiss(id)
        }, void 0, false, {
          fileName: _jsxFileName$c,
          lineNumber: 145,
          columnNumber: 13
        }, this)
      }, message.id, false, {
        fileName: _jsxFileName$c,
        lineNumber: 123,
        columnNumber: 11
      }, this))
    }, void 0, false, {
      fileName: _jsxFileName$c,
      lineNumber: 117,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$c,
    lineNumber: 116,
    columnNumber: 5
  }, this);
}
var ToastMessages$1 = withServices(ToastMessages, ['toastMessenger']);

/**
 * @typedef {import('../../types/api').Group} Group
 */

/**
 * @param {Group} group
 * @return {string}
 */
function orgName(group) {
  return group.organization && group.organization.name;
}

/**
 * @typedef {import('../../types/api').Group} Group
 * @typedef {import('../../types/api').Organization} Organization
 */

/**
 * @typedef {Organization & { groups: Group[] }} OrganizationWithGroups
 */

// TODO: Update when this is a property available on the API response
const DEFAULT_ORG_ID$1 = '__default__';

/**
 * Generate consistent object keys for organizations so that they
 * may be sorted
 *
 * @param {Organization} organization
 * @return {String}
 */
function orgKey(organization) {
  if (organization.id === DEFAULT_ORG_ID$1) {
    return DEFAULT_ORG_ID$1;
  }
  return `${organization.name.toLowerCase()}${organization.id}`;
}

/**
 * Add a clone of the group object to the given organization object's
 * groups Array.
 *
 * @param {Group} group
 * @param {OrganizationWithGroups} organization
 * @return undefined - organization is mutated in place
 */
function addGroup(group, organization) {
  // Object.assign won't suffice because of nested objects on groups
  const groupObj = Object.assign({}, group);
  const groupList = organization.groups;
  if (!groupList.length && group.organization.logo) {
    groupObj.logo = group.organization.logo;
  }
  groupList.push(immutable(groupObj));
}

/**
 * Iterate over groups and locate unique organizations. Slot groups into
 * their appropriate "parent" organizations.
 *
 * @param {Group[]} groups
 * @return {Record<string, OrganizationWithGroups>} - A collection of all unique
 *   organizations, containing their groups. Keyed by each org's "orgKey"
 */
function organizations(groups) {
  /** @type {Record<string, OrganizationWithGroups>} */
  const orgs = {};
  groups.forEach(group => {
    // Ignore groups with undefined or non-object organizations
    if (typeof group.organization !== 'object') {
      return;
    }
    const orgId = orgKey(group.organization);
    if (typeof orgs[orgId] === 'undefined') {
      // First time we've seen this org
      orgs[orgId] = {
        ...group.organization,
        groups: []
      };
    }
    addGroup(group, orgs[orgId]); // Add the current group to its organization's groups
  });

  return orgs;
}

/**
 * Take groups as returned from API service and sort them by which organization
 * they are in (all groups within a given organization will be contiguous
 * in the resulting Array).
 *
 * Groups with no organization or an unexpanded organization
 * will be omitted from the resulting Array.
 *
 * Organization ordering is by name, secondarily (pub)ID. Groups in the default
 * organization will appear at the end of the list. The first group
 * in each organization will have a logo property (if available on the
 * organization).
 *
 * @param {Group[]} groups
 * @return {Group[]} - groups sorted by which organization they're in
 */
function groupsByOrganization(groups) {
  const orgs = organizations(groups);
  const defaultOrganizationGroups = /** @type {Group[]} */[];
  const sortedGroups = [];
  const sortedOrgKeys = Object.keys(orgs).sort();
  sortedOrgKeys.forEach(orgKey => {
    if (orgKey === DEFAULT_ORG_ID$1) {
      // Handle default groups separately
      defaultOrganizationGroups.push(...orgs[orgKey].groups);
    } else {
      sortedGroups.push(...orgs[orgKey].groups);
    }
  });
  if (defaultOrganizationGroups.length) {
    // Put default groups at end
    sortedGroups.push(...defaultOrganizationGroups);
  }
  return sortedGroups;
}

var _jsxFileName$b = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/MenuSection.js";
function MenuSection({
  heading,
  children
}) {
  return o(p$2, {
    children: [heading && o("h2", {
      className: "text-color-text-light p-3 leading-none uppercase",
      children: heading
    }, void 0, false, {
      fileName: _jsxFileName$b,
      lineNumber: 32,
      columnNumber: 9
    }, this), o("ul", {
      className: "border-b",
      children: x$1(children).map(child => o("li", {
        children: child
      }, /** @type {JSXElement} **/child.key, false, {
        fileName: _jsxFileName$b,
        lineNumber: 38,
        columnNumber: 11
      }, this))
    }, void 0, false, {
      fileName: _jsxFileName$b,
      lineNumber: 36,
      columnNumber: 7
    }, this)]
  }, void 0, true);
}

var _jsxFileName$a = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/GroupList/GroupListItem.js";
function GroupListItem({
  isExpanded,
  group,
  groups: groupsService,
  onExpand,
  toastMessenger
}) {
  const activityUrl = group.links.html;
  const hasActionMenu = activityUrl || group.canLeave;
  const isSelectable = group.scopes && !group.scopes.enforced || group.isScopedToUri;
  const store = useSidebarStore();
  const focusedGroupId = store.focusedGroupId();
  const isSelected = group.id === focusedGroupId;
  const focusGroup = () => {
    store.clearDirectLinkedGroupFetchFailed();
    store.clearDirectLinkedIds();
    groupsService.focus(group.id);
  };
  const leaveGroup = async () => {
    const message = `Are you sure you want to leave the group "${group.name}"?`;
    if (await confirm({
      title: 'Leave group?',
      message,
      confirmAction: 'Leave'
    })) {
      groupsService.leave(group.id);
    }
  };

  /**
   * Opens or closes the submenu.
   *
   * @param {Event} event
   */
  const toggleSubmenu = event => {
    event.stopPropagation();

    // Prevents group items opening a new window when clicked.
    // TODO - Fix this more cleanly in `MenuItem`.
    event.preventDefault();
    onExpand(!isExpanded);
  };

  /**
   * @param {string} url
   */
  const copyLink = url => {
    try {
      copyText(url);
      toastMessenger.success(`Copied link for "${group.name}"`);
    } catch (err) {
      toastMessenger.error('Unable to copy link');
    }
  };
  const copyLinkLabel = group.type === 'private' ? 'Copy invite link' : 'Copy activity link';
  return o(MenuItem, {
    icon: group.logo || 'blank',
    iconAlt: orgName(group),
    isDisabled: !isSelectable,
    isExpanded: hasActionMenu ? isExpanded : false,
    isSelected: isSelected,
    isSubmenuVisible: hasActionMenu ? isExpanded : undefined,
    label: group.name,
    onClick: isSelectable ? focusGroup : toggleSubmenu,
    onToggleSubmenu: toggleSubmenu,
    submenu: o(p$2, {
      children: [o("ul", {
        children: [activityUrl && o("li", {
          children: o(MenuItem, {
            href: activityUrl,
            icon: "external",
            isSubmenuItem: true,
            label: "View group activity"
          }, void 0, false, {
            fileName: _jsxFileName$a,
            lineNumber: 114,
            columnNumber: 17
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName$a,
          lineNumber: 113,
          columnNumber: 15
        }, this), activityUrl && o("li", {
          children: o(MenuItem, {
            onClick: () => copyLink(activityUrl),
            icon: "copy",
            isSubmenuItem: true,
            label: copyLinkLabel
          }, void 0, false, {
            fileName: _jsxFileName$a,
            lineNumber: 124,
            columnNumber: 17
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName$a,
          lineNumber: 123,
          columnNumber: 15
        }, this), group.canLeave && o("li", {
          children: o(MenuItem, {
            icon: "leave",
            isSubmenuItem: true,
            label: "Leave group",
            onClick: leaveGroup
          }, void 0, false, {
            fileName: _jsxFileName$a,
            lineNumber: 134,
            columnNumber: 17
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName$a,
          lineNumber: 133,
          columnNumber: 15
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName$a,
        lineNumber: 111,
        columnNumber: 11
      }, this), !isSelectable && o("p", {
        className: classnames(
        // Left padding to match submenu items above. Turn off hyphenation
        // as it causes this content to hyphenate awkwardly.
        'p-2 pl-9 bg-grey-1 hyphens-none'),
        "data-testid": "unselectable-group-note",
        children: "This group is restricted to specific URLs."
      }, void 0, false, {
        fileName: _jsxFileName$a,
        lineNumber: 144,
        columnNumber: 13
      }, this)]
    }, void 0, true)
  }, void 0, false, {
    fileName: _jsxFileName$a,
    lineNumber: 99,
    columnNumber: 5
  }, this);
}
var GroupListItem$1 = withServices(GroupListItem, ['groups', 'toastMessenger']);

var _jsxFileName$9 = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/GroupList/GroupListSection.js";
function GroupListSection({
  expandedGroup,
  onExpandGroup,
  groups,
  heading
}) {
  return o(MenuSection, {
    heading: heading,
    children: groups.map(group => o(GroupListItem$1, {
      isExpanded: group === expandedGroup,
      onExpand: expanded => onExpandGroup(expanded ? group : null),
      group: group
    }, group.id, false, {
      fileName: _jsxFileName$9,
      lineNumber: 34,
      columnNumber: 9
    }, this))
  }, void 0, false, {
    fileName: _jsxFileName$9,
    lineNumber: 32,
    columnNumber: 5
  }, this);
}

var _jsxFileName$8 = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/GroupList/GroupList.js";
function publisherProvidedIcon(settings) {
  const svc = serviceConfig(settings);
  return svc && svc.icon ? svc.icon : null;
}

/**
 * @typedef GroupListProps
 * @prop {SidebarSettings} settings
 */

/**
 * Menu allowing the user to select which group to show and also access
 * additional actions related to groups.
 *
 * @param {GroupListProps} props
 */
function GroupList({
  settings
}) {
  const store = useSidebarStore();
  const currentGroups = store.getCurrentlyViewingGroups();
  const featuredGroups = store.getFeaturedGroups();
  const myGroups = store.getMyGroups();
  const focusedGroup = store.focusedGroup();
  const userid = store.profile().userid;
  const myGroupsSorted = F(() => groupsByOrganization(myGroups), [myGroups]);
  const featuredGroupsSorted = F(() => groupsByOrganization(featuredGroups), [featuredGroups]);
  const currentGroupsSorted = F(() => groupsByOrganization(currentGroups), [currentGroups]);
  const defaultAuthority = store.defaultAuthority();
  const canCreateNewGroup = userid && !isThirdPartyUser(userid, defaultAuthority);
  const newGroupLink = store.getLink('groups.new');

  // The group whose submenu is currently open, or `null` if no group item is
  // currently expanded.
  //
  // nb. If we create other menus that behave similarly in future, we may want
  // to move this state to the `Menu` component.
  const [expandedGroup, setExpandedGroup] = p( /** @type {Group|null} */null);
  let label;
  if (focusedGroup) {
    const icon = focusedGroup.organization.logo || publisherProvidedIcon(settings) || '';

    // If org name is missing, then treat this icon like decoration
    // and pass an empty string.
    const altName = orgName(focusedGroup) ? orgName(focusedGroup) : '';
    label = o("span", {
      className: classnames(
      // Don't allow this label to shrink (wrap to next line)
      'shrink-0 flex items-center gap-x-1 text-lg text-color-text font-bold'),
      children: [icon && o("img", {
        className: classnames(
        // Tiny adjustment to make H logo align better with group name
        'relative top-[1px] w-4 h-4'),
        src: icon,
        alt: altName
      }, void 0, false, {
        fileName: _jsxFileName$8,
        lineNumber: 97,
        columnNumber: 11
      }, this), focusedGroup.name]
    }, void 0, true, {
      fileName: _jsxFileName$8,
      lineNumber: 90,
      columnNumber: 7
    }, this);
  } else {
    label = o("span", {
      children: "\u2026"
    }, void 0, false, {
      fileName: _jsxFileName$8,
      lineNumber: 110,
      columnNumber: 13
    }, this);
  }

  // If there is only one group and no actions available for that group,
  // just show the group name as a label.
  const actionsAvailable = !isThirdPartyService(settings);
  if (!actionsAvailable && currentGroups.length + featuredGroups.length + myGroups.length < 2) {
    return label;
  }
  const menuTitle = focusedGroup ? `Select group (now viewing: ${focusedGroup.name})` : 'Select group';
  return o(Menu, {
    align: "left",
    contentClass: "min-w-[250px]",
    label: label,
    onOpenChanged: () => setExpandedGroup(null),
    title: menuTitle,
    children: [currentGroupsSorted.length > 0 && o(GroupListSection, {
      expandedGroup: expandedGroup,
      onExpandGroup: setExpandedGroup,
      heading: "Currently Viewing",
      groups: currentGroupsSorted
    }, void 0, false, {
      fileName: _jsxFileName$8,
      lineNumber: 136,
      columnNumber: 9
    }, this), featuredGroupsSorted.length > 0 && o(GroupListSection, {
      expandedGroup: expandedGroup,
      onExpandGroup: setExpandedGroup,
      heading: "Featured Groups",
      groups: featuredGroupsSorted
    }, void 0, false, {
      fileName: _jsxFileName$8,
      lineNumber: 144,
      columnNumber: 9
    }, this), myGroupsSorted.length > 0 && o(GroupListSection, {
      expandedGroup: expandedGroup,
      onExpandGroup: setExpandedGroup,
      heading: "\u0645\u062C\u0645\u0648\u0639\u0627\u062A\u064A",
      groups: myGroupsSorted
    }, void 0, false, {
      fileName: _jsxFileName$8,
      lineNumber: 152,
      columnNumber: 9
    }, this), canCreateNewGroup && o(MenuItem, {
      icon: "add",
      href: newGroupLink,
      label: "\u0645\u062C\u0645\u0648\u0639\u0629 \u062E\u0627\u0635\u0629 \u062C\u062F\u064A\u062F\u0629"
    }, void 0, false, {
      fileName: _jsxFileName$8,
      lineNumber: 161,
      columnNumber: 9
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$8,
    lineNumber: 128,
    columnNumber: 5
  }, this);
}
var GroupList$1 = withServices(GroupList, ['settings']);

/**
 * Bit flags indicating modifiers required by a shortcut or pressed in a key event.
 */
const modifiers = {
  alt: 1,
  ctrl: 2,
  meta: 4,
  shift: 8
};

/**
 * Match a `shortcut` key sequence against a keydown event.
 *
 * A shortcut key sequence is a string of "+"-separated keyboard modifiers and
 * keys. The list may contain zero or more modifiers and must contain exactly
 * one non-modifier key. The key and modifier names are case-insensitive.
 * For example "Ctrl+Enter", "shift+a".
 *
 * Key names are matched against {@link KeyboardEvent.key}. Be aware that this
 * property is affected by the modifiers for certain keys. For example on a US
 * QWERTY keyboard, "Shift+1" would not match any event because the key value
 * would be "!" instead. See also https://github.com/w3c/uievents/issues/247.
 */
function matchShortcut(event, shortcut) {
  const parts = shortcut.split('+').map(p => p.toLowerCase());
  let requiredModifiers = 0;
  let requiredKey = null;
  for (const part of parts) {
    const modifierFlag = modifiers[part];
    if (modifierFlag) {
      requiredModifiers |= modifierFlag;
    } else if (requiredKey === null) {
      requiredKey = part;
    } else {
      throw new Error('Multiple non-modifier keys specified');
    }
  }
  if (!requiredKey) {
    throw new Error(`Invalid shortcut: ${shortcut}`);
  }
  const actualModifiers = (event.ctrlKey ? modifiers.ctrl : 0) | (event.metaKey ? modifiers.meta : 0) | (event.altKey ? modifiers.alt : 0) | (event.shiftKey ? modifiers.shift : 0);
  return actualModifiers === requiredModifiers && event.key.toLowerCase() === requiredKey;
}
/**
 * Install a shortcut key listener on the document.
 *
 * This can be used directly outside of a component. To use within a Preact
 * component, you probably want {@link useShortcut}.
 *
 * @param shortcut - Shortcut key sequence. See {@link matchShortcut}.
 * @param onPress - A function to call when the shortcut matches
 * @return A function that removes the shortcut
 */
function installShortcut(shortcut, onPress, {
  // We use `documentElement` as the root element rather than `document.body`
  // which is used as a root element in some other places because the body
  // element is not keyboard-focusable in XHTML documents in Safari/Chrome.
  // See https://github.com/hypothesis/client/issues/4364.
  rootElement = document.documentElement
} = {}) {
  const onKeydown = event => {
    if (matchShortcut(event, shortcut)) {
      onPress(event);
    }
  };
  rootElement.addEventListener('keydown', onKeydown);
  return () => rootElement.removeEventListener('keydown', onKeydown);
}

/**
 * An effect hook that installs a shortcut using {@link installShortcut} and
 * removes it when the component is unmounted.
 *
 * This provides a convenient way to enable a document-level shortcut while
 * a component is mounted. This differs from adding an `onKeyDown` handler to
 * one of the component's DOM elements in that it doesn't require the component
 * to have focus.
 *
 * To conditionally disable the shortcut, set `shortcut` to `null`.
 *
 * @param shortcut - A shortcut key sequence to match or `null` to disable. See {@link matchShortcut}.
 * @param onPress - A function to call when the shortcut matches
 */
function useShortcut(shortcut, onPress, {
  rootElement
} = {}) {
  h(() => {
    if (!shortcut) {
      return undefined;
    }
    return installShortcut(shortcut, onPress, {
      rootElement
    });
  }, [shortcut, onPress, rootElement]);
}

var _jsxFileName$7 = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/SearchInput.js";
function useSearchKeyboardShortcuts(searchInputRef) {
  const prevFocusRef = /** @type {import('preact').RefObject<HTMLOrSVGElement>} */_$1();
  const focusSearch = T$1( /** @param {KeyboardEvent} event */event => {
    var _searchInputRef$curre;
    // When user is in an input field, respond to CMD-/CTRL-K keypresses,
    // but ignore '/' keypresses
    if (!event.metaKey && !event.ctrlKey && event.target instanceof HTMLElement && ['INPUT', 'TEXTAREA'].includes(event.target.tagName)) {
      return;
    }
    prevFocusRef.current = /** @type {HTMLOrSVGElement|null} */
    document.activeElement;
    (_searchInputRef$curre = searchInputRef.current) === null || _searchInputRef$curre === void 0 ? void 0 : _searchInputRef$curre.focus();
    event.preventDefault();
    event.stopPropagation();
  }, [searchInputRef]);
  const restoreFocus = T$1(() => {
    if (document.activeElement === searchInputRef.current) {
      var _searchInputRef$curre2;
      if (prevFocusRef.current) {
        prevFocusRef.current.focus();
        prevFocusRef.current = null;
      }
      (_searchInputRef$curre2 = searchInputRef.current) === null || _searchInputRef$curre2 === void 0 ? void 0 : _searchInputRef$curre2.blur();
    }
  }, [searchInputRef]);
  const modifierKey = isMacOS() ? 'meta' : 'ctrl';
  useShortcut('/', focusSearch);
  useShortcut(`${modifierKey}+k`, focusSearch);
  useShortcut('escape', restoreFocus);
}

/**
 * @typedef SearchInputProps
 * @prop {boolean} [alwaysExpanded] -
 *   If true, the input field is always shown. If false, the input field is only shown
 *   if the query is non-empty.
 * @prop {string|null} query - The currently active filter query
 * @prop {(value: string) => void} onSearch -
 *   Callback to invoke when the current filter query changes
 */

/**
 * An input field in the top bar for entering a query that filters annotations
 * (in the sidebar) or searches annotations (in the stream/single annotation
 * view).
 *
 * This component also renders a eloading spinner to indicate when the client
 * is fetching for data from the API or in a "loading" state for any other
 * reason.
 *
 * @param {SearchInputProps} props
 */
function SearchInput({
  alwaysExpanded,
  query,
  onSearch
}) {
  const store = useSidebarStore();
  const isLoading = store.isLoading();
  const input = /** @type {import('preact').RefObject<HTMLInputElement>} */
  _$1();
  useSearchKeyboardShortcuts(input);

  // The active filter query from the previous render.
  const [prevQuery, setPrevQuery] = p(query);

  // The query that the user is currently typing, but may not yet have applied.
  const [pendingQuery, setPendingQuery] = p(query);

  /** @param {Event} e */
  const onSubmit = e => {
    var _input$current;
    e.preventDefault();
    if ((_input$current = input.current) !== null && _input$current !== void 0 && _input$current.value || prevQuery) {
      var _input$current$value, _input$current2;
      // Don't set an initial empty query, but allow a later empty query to
      // clear `prevQuery`
      onSearch((_input$current$value = (_input$current2 = input.current) === null || _input$current2 === void 0 ? void 0 : _input$current2.value) !== null && _input$current$value !== void 0 ? _input$current$value : '');
    }
  };

  // When the active query changes outside of this component, update the input
  // field to match. This happens when clearing the current filter for example.
  if (query !== prevQuery) {
    setPendingQuery(query);
    setPrevQuery(query);
  }
  const isExpanded = alwaysExpanded || query;
  return o("form", {
    action: "#",
    className: classnames(
    // Relative positioning allows the search input to expand without
    // pushing other things in the top bar to the right when there is
    // a long group name (input will slide "over" end of group name in menu)
    'relative', 'flex items-center',
    // Having a nearly opaque white background makes the collision with
    // group names to the left a little less jarring. Full white on hover
    // to fully remove the distraction.
    'bg-white/90 hover:bg-white transition-colors'),
    name: "searchForm",
    onSubmit: onSubmit,
    children: [o(TextInput, {
      "aria-label": "Search",
      classes: classnames(
      // This element is ordered second in the flex layout (appears to the
      // right of the search icon-button) but having it first in source
      // ensures it is first in keyboard tab order
      'order-1', 'text-base', {
        // Borders must be turned off when input is not expanded or focused
        // to ensure it has 0 dimensions
        'border-0': !isExpanded,
        // The goal is to have a one-pixel grey border when `isExpanded`.
        // Setting it both on focus (when it will be ofuscated by the focus
        // ring) and when expanded prevents any change in the input's size
        // when moving between the two states.
        'focus:border': true,
        border: isExpanded
      }, {
        // Make the input dimensionless when not expanded (or focused)
        'max-w-0 p-0': !isExpanded,
        // Make the input have dimensions and padding when focused or
        // expanded. The left-margin is to make room for the focus ring of
        // the search icon-button when navigating by keyboard. Set a
        // max-width to allow transition to work when exact width is unknown.
        'focus:max-w-[150px] focus:p-1.5 focus:ml-[2px]': true,
        'max-w-[150px] p-1.5 ml-[2px]': isExpanded
      }, 'transition-[max-width] duration-300 ease-out'),
      "data-testid": "search-input",
      dir: "auto",
      type: "text",
      name: "query",
      placeholder: isLoading && 'Loading…' || 'البحث...',
      disabled: isLoading,
      inputRef: input,
      value: pendingQuery || '',
      onInput: e => setPendingQuery( /** @type {HTMLInputElement} */e.target.value)
    }, void 0, false, {
      fileName: _jsxFileName$7,
      lineNumber: 135,
      columnNumber: 7
    }, this), !isLoading && o("div", {
      className: "order-0",
      children: o(IconButton, {
        icon: "search",
        onClick: () => {
          var _input$current3;
          return (_input$current3 = input.current) === null || _input$current3 === void 0 ? void 0 : _input$current3.focus();
        },
        size: "small",
        title: "\u0627\u0644\u0628\u062D\u062B \u0641\u064A \u0627\u0644\u0643\u0644\u0645\u0627\u062A \u0627\u0644\u0645\u0648\u0633\u0645\u0629"
      }, void 0, false, {
        fileName: _jsxFileName$7,
        lineNumber: 180,
        columnNumber: 11
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$7,
      lineNumber: 179,
      columnNumber: 9
    }, this), isLoading && o(Spinner, {
      size: "small"
    }, void 0, false, {
      fileName: _jsxFileName$7,
      lineNumber: 189,
      columnNumber: 21
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$7,
    lineNumber: 119,
    columnNumber: 5
  }, this);
}

var _jsxFileName$6 = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/SortMenu.tsx";
function SortMenu() {
  const store = useSidebarStore();
  // The currently-applied sort order
  const sortKey = store.sortKey();
  // All available sorting options. These change depending on current
  // "tab" or context.
  const sortKeysAvailable = store.sortKeys();
  const menuItems = sortKeysAvailable.map(sortOption => {
    return o(MenuItem, {
      label: sortOption,
      onClick: () => store.setSortKey(sortOption),
      isSelected: sortOption === sortKey
    }, sortOption, false, {
      fileName: _jsxFileName$6,
      lineNumber: 21,
      columnNumber: 7
    }, this);
  });
  const menuLabel = o("span", {
    className: "p-1",
    children: o(SortIcon, {}, void 0, false, {
      fileName: _jsxFileName$6,
      lineNumber: 32,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$6,
    lineNumber: 31,
    columnNumber: 5
  }, this);
  return o("div", {
    className: "SortMenu",
    children: o(Menu, {
      label: menuLabel,
      title: ` الترتيب بحسب ${sortKey}`,
      align: "right",
      menuIndicator: false,
      children: menuItems
    }, void 0, false, {
      fileName: _jsxFileName$6,
      lineNumber: 38,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$6,
    lineNumber: 37,
    columnNumber: 5
  }, this);
}

var _jsxFileName$5 = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/StreamSearchInput.js";
function StreamSearchInput({
  router
}) {
  const store = useSidebarStore();
  const query = store.routeParams().q;
  /** @param {string} query */
  const setQuery = query => {
    // Re-route the user to `/stream` if they are on `/a/:id` and then set
    // the search query.
    router.navigate('stream', {
      q: query
    });
  };
  return o(SearchInput, {
    query: query,
    onSearch: setQuery,
    alwaysExpanded: true
  }, void 0, false, {
    fileName: _jsxFileName$5,
    lineNumber: 29,
    columnNumber: 5
  }, this);
}
var StreamSearchInput$1 = withServices(StreamSearchInput, ['router']);

var _jsxFileName$4 = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/UserMenu.tsx";
/**
 * A menu with user and account links.
 *
 * This menu will contain different items depending on service configuration,
 * context and whether the user is first- or third-party.
 */
function UserMenu({
  frameSync,
  onLogout,
  settings
}) {
  var _profile$user_info$di, _profile$user_info;
  const store = useSidebarStore();
  const defaultAuthority = store.defaultAuthority();
  const profile = store.profile();
  const isThirdParty = isThirdPartyUser(profile.userid, defaultAuthority);
  const service = serviceConfig(settings);
  const username$1 = username(profile.userid);
  const displayName = (_profile$user_info$di = (_profile$user_info = profile.user_info) === null || _profile$user_info === void 0 ? void 0 : _profile$user_info.display_name) !== null && _profile$user_info$di !== void 0 ? _profile$user_info$di : username$1;
  const [isOpen, setOpen] = p(false);
  const serviceSupports = feature => service && !!service[feature];
  const isSelectableProfile = !isThirdParty || serviceSupports('onProfileRequestProvided');
  const isLogoutEnabled = !isThirdParty || serviceSupports('onLogoutRequestProvided');
  const onSelectNotebook = () => {
    frameSync.notifyHost('openNotebook', store.focusedGroupId());
  };

  // Access to the Notebook:
  // type the key 'n' when user menu is focused/open
  const onKeyDown = event => {
    if (event.key === 'n') {
      onSelectNotebook();
      setOpen(false);
    }
  };
  const onProfileSelected = () => isThirdParty && frameSync.notifyHost('profileRequested');
  const profileHref = isSelectableProfile && !isThirdParty ? store.getLink('user', {
    user: username$1
  }) : undefined;
  const menuLabel = o("span", {
    className: "p-1",
    children: o(ProfileIcon, {}, void 0, false, {
      fileName: _jsxFileName$4,
      lineNumber: 71,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$4,
    lineNumber: 70,
    columnNumber: 5
  }, this);
  return (
    // Allow keyboard shortcut 'n' to open Notebook
    /* eslint-disable-next-line jsx-a11y/no-static-element-interactions */
    o("div", {
      "data-testid": "user-menu",
      onKeyDown: onKeyDown,
      children: o(Menu, {
        label: menuLabel,
        title: displayName,
        align: "right",
        open: isOpen,
        onOpenChanged: setOpen,
        children: [o(MenuSection, {
          children: [o(MenuItem, {
            label: displayName,
            isDisabled: !isSelectableProfile,
            href: profileHref,
            onClick: isSelectableProfile ? onProfileSelected : undefined
          }, void 0, false, {
            fileName: _jsxFileName$4,
            lineNumber: 86,
            columnNumber: 11
          }, this), !isThirdParty && o(MenuItem, {
            label: "Account settings",
            href: store.getLink('account.settings')
          }, void 0, false, {
            fileName: _jsxFileName$4,
            lineNumber: 93,
            columnNumber: 13
          }, this), o(MenuItem, {
            label: "Open notebook",
            onClick: () => onSelectNotebook()
          }, void 0, false, {
            fileName: _jsxFileName$4,
            lineNumber: 98,
            columnNumber: 11
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName$4,
          lineNumber: 85,
          columnNumber: 9
        }, this), isLogoutEnabled && o(MenuSection, {
          children: o(MenuItem, {
            label: "Log out",
            onClick: onLogout
          }, void 0, false, {
            fileName: _jsxFileName$4,
            lineNumber: 102,
            columnNumber: 13
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName$4,
          lineNumber: 101,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName$4,
        lineNumber: 78,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName$4,
      lineNumber: 77,
      columnNumber: 5
    }, this)
  );
}
var UserMenu$1 = withServices(UserMenu, ['frameSync', 'settings']);

var _jsxFileName$3 = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/TopBar.js";
function TopBar({
  frameSync,
  isSidebar,
  onLogin,
  onLogout,
  onSignUp,
  settings,
  streamer
}) {
  const showSharePageButton = !isThirdPartyService(settings);
  const loginLinkStyle = applyTheme(['accentColor'], settings);
  const store = useSidebarStore();
  const filterQuery = store.filterQuery();
  const pendingUpdateCount = store.pendingUpdateCount();
  const isLoggedIn = store.isLoggedIn();
  const hasFetchedProfile = store.hasFetchedProfile();
  const applyPendingUpdates = () => streamer.applyPendingUpdates();
  const toggleSharePanel = () => {
    store.toggleSidebarPanel('shareGroupAnnotations');
  };
  const isHelpPanelOpen = store.isSidebarPanelOpen('help');
  const isAnnotationsPanelOpen = store.isSidebarPanelOpen('shareGroupAnnotations');

  /**
   * Open the help panel, or, if a service callback is configured to handle
   * help requests, fire a relevant event instead
   */
  const requestHelp = () => {
    const service = serviceConfig(settings);
    if (service && service.onHelpRequestProvided) {
      frameSync.notifyHost('helpRequested');
    } else {
      store.toggleSidebarPanel('help');
    }
  };
  return o("div", {
    className: classnames('absolute h-10 left-0 top-0 right-0 z-4', 'text-grey-7 border-b theme-clean:border-b-0 bg-white'),
    "data-testid": "top-bar",
    children: o("div", {
      className: classnames('container flex items-center h-full',
      // Text sizing will size icons in buttons correctly
      'text-xl'),
      "data-testid": "top-bar-content",
      children: [isSidebar ? o(GroupList$1, {}, void 0, false, {
        fileName: _jsxFileName$3,
        lineNumber: 98,
        columnNumber: 22
      }, this) : o(StreamSearchInput$1, {}, void 0, false, {
        fileName: _jsxFileName$3,
        lineNumber: 98,
        columnNumber: 38
      }, this), o("div", {
        className: "grow flex items-center justify-end",
        children: [isSidebar && o(p$2, {
          children: [pendingUpdateCount > 0 && o(IconButton, {
            icon: "refresh",
            onClick: applyPendingUpdates,
            size: "small",
            variant: "primary",
            title: `Show ${pendingUpdateCount} new/updated ${pendingUpdateCount === 1 ? 'annotation' : 'annotations'}`
          }, void 0, false, {
            fileName: _jsxFileName$3,
            lineNumber: 103,
            columnNumber: 17
          }, this), o(SearchInput, {
            query: filterQuery || null,
            onSearch: store.setFilterQuery
          }, void 0, false, {
            fileName: _jsxFileName$3,
            lineNumber: 113,
            columnNumber: 15
          }, this), o(SortMenu, {}, void 0, false, {
            fileName: _jsxFileName$3,
            lineNumber: 117,
            columnNumber: 15
          }, this), showSharePageButton && o(IconButton, {
            icon: "share",
            expanded: isAnnotationsPanelOpen,
            onClick: toggleSharePanel,
            size: "small",
            title: "Share annotations on this page"
          }, void 0, false, {
            fileName: _jsxFileName$3,
            lineNumber: 119,
            columnNumber: 17
          }, this)]
        }, void 0, true), o(IconButton, {
          icon: "help",
          expanded: isHelpPanelOpen,
          onClick: requestHelp,
          size: "small",
          title: "Help"
        }, void 0, false, {
          fileName: _jsxFileName$3,
          lineNumber: 129,
          columnNumber: 11
        }, this), isLoggedIn ? o(UserMenu$1, {
          onLogout: onLogout
        }, void 0, false, {
          fileName: _jsxFileName$3,
          lineNumber: 137,
          columnNumber: 13
        }, this) : o("div", {
          className: "flex items-center text-lg font-medium space-x-1",
          "data-testid": "login-links",
          children: [!isLoggedIn && !hasFetchedProfile && o("span", {
            children: "\u22EF"
          }, void 0, false, {
            fileName: _jsxFileName$3,
            lineNumber: 143,
            columnNumber: 53
          }, this), !isLoggedIn && hasFetchedProfile && o(p$2, {
            children: [o(LinkButton, {
              classes: "inline",
              onClick: onSignUp,
              style: loginLinkStyle,
              variant: "primary",
              children: "Sign up"
            }, void 0, false, {
              fileName: _jsxFileName$3,
              lineNumber: 146,
              columnNumber: 19
            }, this), o("div", {
              children: "/"
            }, void 0, false, {
              fileName: _jsxFileName$3,
              lineNumber: 154,
              columnNumber: 19
            }, this), o(LinkButton, {
              classes: "inline",
              onClick: onLogin,
              style: loginLinkStyle,
              variant: "primary",
              children: "Log in"
            }, void 0, false, {
              fileName: _jsxFileName$3,
              lineNumber: 155,
              columnNumber: 19
            }, this)]
          }, void 0, true)]
        }, void 0, true, {
          fileName: _jsxFileName$3,
          lineNumber: 139,
          columnNumber: 13
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName$3,
        lineNumber: 99,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$3,
      lineNumber: 90,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$3,
    lineNumber: 83,
    columnNumber: 5
  }, this);
}
var TopBar$1 = withServices(TopBar, ['frameSync', 'settings', 'streamer']);

var _jsxFileName$2 = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/HypothesisApp.js";
function HypothesisApp({
  auth,
  frameSync,
  settings,
  session,
  toastMessenger
}) {
  const store = useSidebarStore();
  const profile = store.profile();
  const route = store.route();
  const backgroundStyle = F(() => applyTheme(['appBackgroundColor'], settings), [settings]);
  const isThemeClean = settings.theme === 'clean';
  const isSidebar = route === 'sidebar';
  h(() => {
    if (shouldAutoDisplayTutorial(isSidebar, profile, settings)) {
      store.openSidebarPanel('help');
    }
  }, [isSidebar, profile, settings, store]);
  const login = async () => {
    if (serviceConfig(settings)) {
      // Let the host page handle the login request
      frameSync.notifyHost('loginRequested');
      return;
    }
    try {
      await auth.login();
      store.closeSidebarPanel('loginPrompt');
      store.clearGroups();
      session.reload();
    } catch (err) {
      toastMessenger.error(err.message);
    }
  };
  const signUp = () => {
    if (serviceConfig(settings)) {
      // Let the host page handle the signup request
      frameSync.notifyHost('signupRequested');
      return;
    }
    window.open(store.getLink('signup'));
  };
  const promptToLogout = async () => {
    const drafts = store.countDrafts();
    if (drafts === 0) {
      return true;
    }
    let message = '';
    if (drafts === 1) {
      message = 'You have an unsaved annotation.\n' + 'Do you really want to discard this draft?';
    } else if (drafts > 1) {
      message = 'You have ' + drafts + ' unsaved annotations.\n' + 'Do you really want to discard these drafts?';
    }
    return confirm({
      title: 'Discard drafts?',
      message,
      confirmAction: 'Discard'
    });
  };
  const logout = async () => {
    if (!(await promptToLogout())) {
      return;
    }
    store.clearGroups();
    store.removeAnnotations(store.unsavedAnnotations());
    store.discardAllDrafts();
    if (serviceConfig(settings)) {
      frameSync.notifyHost('logoutRequested');
      return;
    }
    session.logout();
  };
  return o("div", {
    className: classnames('h-full min-h-full overflow-scroll',
    // Precise padding to align with annotation cards in content
    // Larger padding on bottom for wide screens
    'lg:pb-16 bg-grey-2', 'js-thread-list-scroll-root', {
      'theme-clean': isThemeClean,
      // Make room at top for the TopBar (40px) plus custom padding (9px)
      // but not in the Notebook, which doesn't use the TopBar
      'pt-[49px]': route !== 'notebook',
      'p-4 lg:p-12': route === 'notebook'
    }),
    "data-testid": "hypothesis-app",
    style: backgroundStyle,
    children: [route !== 'notebook' && o(TopBar$1, {
      onLogin: login,
      onSignUp: signUp,
      onLogout: logout,
      isSidebar: isSidebar
    }, void 0, false, {
      fileName: _jsxFileName$2,
      lineNumber: 149,
      columnNumber: 9
    }, this), o("div", {
      className: "container",
      children: [o(ToastMessages$1, {}, void 0, false, {
        fileName: _jsxFileName$2,
        lineNumber: 157,
        columnNumber: 9
      }, this), o(HelpPanel$1, {}, void 0, false, {
        fileName: _jsxFileName$2,
        lineNumber: 158,
        columnNumber: 9
      }, this), o(ShareAnnotationsPanel$1, {}, void 0, false, {
        fileName: _jsxFileName$2,
        lineNumber: 159,
        columnNumber: 9
      }, this), route && o("main", {
        children: [route === 'annotation' && o(AnnotationView$1, {
          onLogin: login
        }, void 0, false, {
          fileName: _jsxFileName$2,
          lineNumber: 163,
          columnNumber: 40
        }, this), route === 'notebook' && o(NotebookView$1, {}, void 0, false, {
          fileName: _jsxFileName$2,
          lineNumber: 164,
          columnNumber: 38
        }, this), route === 'stream' && o(StreamView$1, {}, void 0, false, {
          fileName: _jsxFileName$2,
          lineNumber: 165,
          columnNumber: 36
        }, this), route === 'sidebar' && o(SidebarView$1, {
          onLogin: login,
          onSignUp: signUp
        }, void 0, false, {
          fileName: _jsxFileName$2,
          lineNumber: 167,
          columnNumber: 15
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName$2,
        lineNumber: 162,
        columnNumber: 11
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName$2,
      lineNumber: 156,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName$2,
    lineNumber: 130,
    columnNumber: 5
  }, this);
}
var HypothesisApp$1 = withServices(HypothesisApp, ['auth', 'frameSync', 'session', 'settings', 'toastMessenger']);

var _jsxFileName$1 = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/components/LaunchErrorPanel.js";
function LaunchErrorPanel({
  error
}) {
  return o("div", {
    className: classnames(
    // The large top-margin is to ensure the panel clears the close button
    // in the Notebook
    'm-2 mt-12'),
    children: o(Panel, {
      title: "Unable to start Hypothesis",
      children: error.message
    }, void 0, false, {
      fileName: _jsxFileName$1,
      lineNumber: 26,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName$1,
    lineNumber: 19,
    columnNumber: 5
  }, this);
}

/**
 * @typedef {import('../../types/api').Annotation} Annotation
 * @typedef {import('../../types/annotator').AnnotationData} AnnotationData
 * @typedef {import('../../types/api').SavedAnnotation} SavedAnnotation
 */

/**
 * A service for creating, updating and persisting annotations both in the
 * local store and on the backend via the API.
 */
// @inject
class AnnotationsService {
  /**
   * @param {import('./api').APIService} api
   * @param {import('./annotation-activity').AnnotationActivityService} annotationActivity
   * @param {import('../store').SidebarStore} store
   */
  constructor(annotationActivity, api, store) {
    this._activity = annotationActivity;
    this._api = api;
    this._store = store;
  }

  /**
   * Apply changes for the given `annotation` from its draft in the store (if
   * any) and return a new object with those changes integrated.
   *
   * @param {Annotation} annotation
   */
  _applyDraftChanges(annotation) {
    const changes = {};
    const draft = this._store.getDraft(annotation);
    if (draft) {
      changes.tags = draft.tags;
      changes.text = draft.text;
      changes.permissions = draft.isPrivate ? privatePermissions(annotation.user) : sharedPermissions(annotation.user, annotation.group);
    }

    // Integrate changes from draft into object to be persisted
    return {
      ...annotation,
      ...changes
    };
  }

  /**
   * Extend new annotation objects with defaults and permissions.
   *
   * @param {Omit<AnnotationData, '$tag'>} annotationData
   * @param {Date} now
   * @return {Annotation}
   */
  _initialize(annotationData, now = new Date()) {
    const defaultPrivacy = this._store.getDefault('annotationPrivacy');
    const groupid = this._store.focusedGroupId();
    const profile = this._store.profile();
    if (!groupid) {
      throw new Error('Cannot create annotation without a group');
    }
    const userid = profile.userid;
    if (!userid) {
      throw new Error('Cannot create annotation when logged out');
    }
    const userInfo = profile.user_info;

    // We need a unique local/app identifier for this new annotation such
    // that we might look it up later in the store. It won't have an ID yet,
    // as it has not been persisted to the service.
    const $tag = 's:' + generateHexString(8);

    /** @type {Annotation} */
    const annotation = Object.assign({
      created: now.toISOString(),
      group: groupid,
      permissions: defaultPermissions(userid, groupid, defaultPrivacy),
      tags: [],
      text: '',
      updated: now.toISOString(),
      user: userid,
      user_info: userInfo,
      $tag,
      hidden: false,
      links: {},
      document: {
        title: ''
      }
    }, annotationData);

    // Highlights are peculiar in that they always have private permissions
    if (isHighlight(annotation)) {
      annotation.permissions = privatePermissions(userid);
    }
    return annotation;
  }

  /**
   * Populate a new annotation object from `annotation` and add it to the store.
   * Create a draft for it unless it's a highlight and clear other empty
   * drafts out of the way.
   *
   * @param {Omit<AnnotationData, '$tag'>} annotationData
   * @param {Date} now
   */
  create(annotationData, now = new Date()) {
    const annotation = this._initialize(annotationData, now);
    this._store.addAnnotations([annotation]);

    // Remove other drafts that are in the way, and their annotations (if new)
    this._store.deleteNewAndEmptyDrafts();

    // Create a draft unless it's a highlight
    if (!isHighlight(annotation)) {
      this._store.createDraft(annotation, {
        tags: annotation.tags,
        text: annotation.text,
        isPrivate: !isPublic(annotation)
      });
    }

    // NB: It may make sense to move the following code at some point to
    // the UI layer
    // Select the correct tab
    // If the annotation is of type note or annotation, make sure
    // the appropriate tab is selected. If it is of type reply, user
    // stays in the selected tab.
    if (isPageNote(annotation)) {
      this._store.selectTab('note');
    } else if (isAnnotation(annotation)) {
      this._store.selectTab('annotation');
    }
    (annotation.references || []).forEach(parent => {
      // Expand any parents of this annotation.
      this._store.setExpanded(parent, true);
    });
  }

  /**
   * Create a new empty "page note" annotation and add it to the store. If the
   * user is not logged in, open the `loginPrompt` panel instead.
   */
  createPageNote() {
    const topLevelFrame = this._store.mainFrame();
    if (!this._store.isLoggedIn()) {
      this._store.openSidebarPanel('loginPrompt');
      return;
    }
    if (!topLevelFrame) {
      return;
    }
    const pageNoteAnnotation = {
      target: [],
      uri: topLevelFrame.uri
    };
    this.create(pageNoteAnnotation);
  }

  /**
   * Delete an annotation via the API and update the store.
   *
   * @param {SavedAnnotation} annotation
   */
  async delete(annotation) {
    await this._api.annotation.delete({
      id: annotation.id
    });
    this._activity.reportActivity('delete', annotation);
    this._store.removeAnnotations([annotation]);
  }

  /**
   * Flag an annotation for review by a moderator.
   *
   * @param {SavedAnnotation} annotation
   */
  async flag(annotation) {
    await this._api.annotation.flag({
      id: annotation.id
    });
    this._activity.reportActivity('flag', annotation);
    this._store.updateFlagStatus(annotation.id, true);
  }

  /**
   * Create a reply to `annotation` by the user `userid` and add to the store.
   *
   * @param {SavedAnnotation} annotation
   * @param {string} userid
   */
  reply(annotation, userid) {
    const replyAnnotation = {
      group: annotation.group,
      permissions: isPublic(annotation) ? sharedPermissions(userid, annotation.group) : privatePermissions(userid),
      references: (annotation.references || []).concat(annotation.id),
      target: [{
        source: annotation.target[0].source
      }],
      uri: annotation.uri
    };
    this.create(replyAnnotation);
  }

  /**
   * Save new (or update existing) annotation. On success,
   * the annotation's `Draft` will be removed and the annotation added
   * to the store.
   *
   * @param {Annotation} annotation
   */
  async save(annotation) {
    let saved;
    /** @type {import('../../types/config').AnnotationEventType} */
    let eventType;
    const annotationWithChanges = this._applyDraftChanges(annotation);
    if (!isSaved(annotation)) {
      saved = this._api.annotation.create({}, annotationWithChanges);
      eventType = 'create';
    } else {
      saved = this._api.annotation.update({
        id: annotation.id
      }, annotationWithChanges);
      eventType = 'update';
    }

    /** @type {Annotation} */
    let savedAnnotation;
    this._store.annotationSaveStarted(annotation);
    try {
      savedAnnotation = await saved;
      this._activity.reportActivity(eventType, savedAnnotation);
    } finally {
      this._store.annotationSaveFinished(annotation);
    }

    // Copy local/internal fields from the original annotation to the saved
    // version.
    for (let [key, value] of Object.entries(annotation)) {
      if (key.startsWith('$')) {
        const fields = /** @type {Record<string, any>} */savedAnnotation;
        fields[key] = value;
      }
    }

    // Clear out any pending changes (draft)
    this._store.removeDraft(annotation);

    // Add (or, in effect, update) the annotation to the store's collection
    this._store.addAnnotations([savedAnnotation]);
    return savedAnnotation;
  }
}
AnnotationsService.$inject = ["annotationActivity", "api", "store"];

/**
 * @typedef {import('../../types/api').Annotation} Annotation
 * @typedef {import('../../types/config').SidebarSettings} SidebarSettings
 * @typedef {import('../../types/config').AnnotationEventType} AnnotationEventType
 */

/**
 * Send messages to configured ancestor frame on annotation activity
 */
// @inject
class AnnotationActivityService {
  /**
   * @param {SidebarSettings} settings
   */
  constructor(settings) {
    this._rpc = settings.rpc;
    this._reportConfig = settings.reportActivity;
  }

  /**
   * @param {AnnotationEventType} eventType
   * @param {Annotation} annotation
   */
  reportActivity(eventType, annotation) {
    if (!this._rpc || !this._reportConfig) {
      return;
    }

    // Determine the appropriate ISO-8601 timestamp for this "activity"
    let activityDate;
    switch (eventType) {
      case 'create':
        activityDate = new Date(annotation.created).toISOString();
        break;
      case 'update':
        activityDate = new Date(annotation.updated).toISOString();
        break;
      default:
        activityDate = new Date().toISOString();
    }
    const data = {
      date: activityDate,
      annotation: {
        id: annotation.id,
        isShared: isShared(annotation.permissions)
      }
    };
    if (this._reportConfig.events.includes(eventType)) {
      notify(this._rpc.targetFrame, this._rpc.origin, this._reportConfig.method, [eventType, data]);
    }
  }
}
AnnotationActivityService.$inject = ["settings"];

/**
 * An error indicating a failed network request.
 *
 * Failures that this error can represent include:
 *
 *  - Failures to send an HTTP request
 *  - Requests that returned non-2xx responses
 *  - Failures to parse the response in the expected format (eg. JSON)
 */
class FetchError extends Error {
  /**
   * @param {string} url - The URL that was requested. This may be different
   *   than the final URL of the response if a redirect happened.
   * @param {Response|null} response - The response to the `fetch` request or
   *   `null` if the fetch failed
   * @param {string} [reason] - Additional details about the error. This might
   *   include context of the network request or a server-provided error in
   *   the response.
   */
  constructor(url, response, reason = '') {
    let message = 'Network request failed';
    if (response) {
      message += ` (${response.status})`;
    }
    if (reason) {
      message += `: ${reason}`;
    }
    super(message);
    this.url = url;
    this.response = response;
    this.reason = reason;
  }
}

/**
 * Execute a network request and return the parsed JSON response.
 *
 * fetchJSON wraps the browser's `fetch` API to standardize error handling when
 * making network requests that return JSON responses.
 *
 * @param {string} url
 * @param {RequestInit} [init] - Parameters for `fetch` request
 * @return {Promise<unknown>} - Parsed JSON response or `null` if response status is 204 (No Content)
 * @throws {FetchError} if the request fails, returns a non-2xx status or a JSON
 *   response is expected but cannot be parsed
 */
async function fetchJSON(url, init) {
  let response;
  try {
    response = await fetch(url, init);
  } catch (err) {
    // If the request fails for any reason, wrap the result in a `FetchError`.
    // Different browsers use different error messages for `fetch` failures, so
    // wrapping the error allows downstream clients to handle this uniformly.
    throw new FetchError(url, null, err.message);
  }
  if (response.status === 204 /* No Content */) {
    return null;
  }

  // Attempt to parse a JSON response. This may fail even if the status code
  // indicates success.
  let data;
  try {
    data = await response.json();
  } catch (err) {
    throw new FetchError(url, response, 'Failed to parse response');
  }

  // If the HTTP status indicates failure, attempt to extract a server-provided
  // reason from the response, assuming certain conventions for the formatting
  // of error responses.
  if (!response.ok) {
    var _data;
    throw new FetchError(url, response, (_data = data) === null || _data === void 0 ? void 0 : _data.reason);
  }
  return data;
}

/**
 * @typedef {import('../../types/api').Annotation} Annotation
 * @typedef {import('../../types/api').Group} Group
 * @typedef {import('../../types/api').RouteMap} RouteMap
 * @typedef {import('../../types/api').RouteMetadata} RouteMetadata
 * @typedef {import('../../types/api').Profile} Profile
 */

/**
 * Return a shallow clone of `obj` with all client-only properties removed.
 * Client-only properties are marked by a '$' prefix.
 *
 * @param {Record<string, unknown>} obj
 */
function stripInternalProperties(obj) {
  /** @type {Record<string, unknown>} */
  const result = {};
  for (let [key, value] of Object.entries(obj)) {
    if (!key.startsWith('$')) {
      result[key] = value;
    }
  }
  return result;
}

/**
 * @template {object} Body
 * @typedef APIResponse
 * @prop {Body} data -
 *  The JSON response from the API call, unless this call returned a
 *  "204 No Content" status.
 * @prop {string|null} token - The access token that was used to make the call
 *   or `null` if unauthenticated.
 */

/**
 * Types of value that can be passed as a parameter to API calls.
 *
 * @typedef {string|number|boolean} Param
 */

/**
 * Function which makes an API request.
 *
 * @template {Record<string, Param|Param[]>} [Params={}]
 * @template [Body=void]
 * @template [Result=void]
 * @callback APICall
 * @param {Params} params - A map of URL and query string parameters to include with the request.
 * @param {Body} [data] - The body of the request.
 * @return {Promise<Result>}
 */

/**
 * Callbacks invoked at various points during an API call to get an access token etc.
 *
 * @typedef APIMethodCallbacks
 * @prop {() => Promise<string|null>} getAccessToken -
 *   Function which acquires a valid access token for making an API request.
 * @prop {() => string|null} getClientId -
 *   Function that returns a per-session client ID to include with the request
 *   or `null`.
 * @prop {() => void} onRequestStarted - Callback invoked when the API request starts.
 * @prop {() => void} onRequestFinished - Callback invoked when the API request finishes.
 */

/**
 * @param {RouteMap|RouteMetadata} link
 * @return {link is RouteMetadata}
 */
function isRouteMetadata(link) {
  return 'url' in link;
}

/**
 * Lookup metadata for an API route in the result of an `/api/` response.
 *
 * @param {RouteMap} routeMap
 * @param {string} route - Dot-separated path of route in `routeMap`
 */
function findRouteMetadata(routeMap, route) {
  /** @type {RouteMap} */
  let cursor = routeMap;
  const pathSegments = route.split('.');
  for (let [index, segment] of pathSegments.entries()) {
    const nextCursor = cursor[segment];
    if (!nextCursor || isRouteMetadata(nextCursor)) {
      if (nextCursor && index === pathSegments.length - 1) {
        // Found the RouteMetadata at the end of the path.
        return nextCursor;
      }
      // Didn't find the route, or found a RouteMetadata before we reached the
      // end of the path.
      break;
    }
    cursor = nextCursor;
  }
  return null;
}

/**
 * Creates a function that will make an API call to a named route.
 *
 * @param {Promise<RouteMap>} links - API route data from API index endpoint (`/api/`)
 * @param {string} route - The dotted path of the named API route (eg. `annotation.create`)
 * @param {APIMethodCallbacks} callbacks
 * @return {APICall<Record<string, any>, Record<string, any>|void, unknown>} - Function that makes
 *   an API call. The returned `APICall` has generic parameter, body and return types.
 *   This can be cast to an `APICall` with more specific types.
 */
function createAPICall(links, route, {
  getAccessToken,
  getClientId,
  onRequestStarted,
  onRequestFinished
}) {
  return async (params, data) => {
    onRequestStarted();
    try {
      const [linksMap, token] = await Promise.all([links, getAccessToken()]);
      const descriptor = findRouteMetadata(linksMap, route);
      if (!descriptor) {
        throw new Error(`Missing API route: ${route}`);
      }

      /** @type {Record<string, string>} */
      const headers = {
        'Content-Type': 'application/json',
        'Hypothesis-Client-Version': '1.0.0-dummy-version'
      };
      if (token) {
        headers.Authorization = 'Bearer ' + token;
      }
      const clientId = getClientId();
      if (clientId) {
        headers['X-Client-Id'] = clientId;
      }
      const {
        url,
        unusedParams: queryParams
      } = replaceURLParams(descriptor.url, params);
      const apiURL = new URL(url);
      for (let [key, value] of Object.entries(queryParams)) {
        if (!Array.isArray(value)) {
          value = [value];
        }
        for (let item of value) {
          // eslint-disable-next-line eqeqeq
          if (item == null) {
            // Skip all parameters with nullish values.
            continue;
          }
          apiURL.searchParams.append(key, item.toString());
        }
      }

      // nb. Don't "simplify" the lines below to `return fetchJSON(...)` as this
      // would cause `onRequestFinished` to be called before the API response
      // is received.
      const result = await fetchJSON(apiURL.toString(), {
        body: data ? JSON.stringify(stripInternalProperties(data)) : null,
        headers,
        method: descriptor.method
      });
      return result;
    } finally {
      onRequestFinished();
    }
  };
}

/**
 * API client for the Hypothesis REST API.
 *
 * Returns an object that with keys that match the routes in
 * the Hypothesis API (see http://h.readthedocs.io/en/latest/api/).
 * @see APICall for the syntax of API calls. For example:
 *
 * ```
 * api.annotations.update({ id: '1234' }, annotation).then(ann => {
 *   // Do something with the updated annotation.
 * }).catch(err => {
 *   // Do something if the API call fails.
 * });
 * ```
 *
 * This service makes authenticated calls to the API, using `AuthService`
 * to get auth tokens. The URLs for API endpoints are provided by the `APIRoutesService`
 * service.
 */
// @inject
class APIService {
  /**
   * @param {import('./api-routes').APIRoutesService} apiRoutes
   * @param {import('./auth').AuthService} auth
   * @param {import('../store').SidebarStore} store
   */
  constructor(apiRoutes, auth, store) {
    const links = apiRoutes.routes();

    /**
     * Client session identifier included with requests. Used by the backend
     * to associate API requests with WebSocket connections from the same client.
     *
     * @type {string|null}
     */
    this._clientId = null;
    const getClientId = () => this._clientId;

    /** @param {string} route */
    const apiCall = route => createAPICall(links, route, {
      getAccessToken: auth.getAccessToken,
      getClientId,
      onRequestStarted: store.apiRequestStarted,
      onRequestFinished: store.apiRequestFinished
    });

    // Define available API calls.
    //
    // The type syntax is APICall<Parameters, Body, Result>, where `void` means
    // no body / empty response.

    /**
     * @typedef AnnotationSearchResult
     * @prop {Annotation[]} rows
     * @prop {Annotation[]} replies
     * @prop {number} total
     */

    /** @typedef {{ id: string }} IDParam */

    this.search = /** @type {APICall<{}, void, AnnotationSearchResult>} */
    apiCall('search');
    this.annotation = {
      create: /** @type {APICall<{}, Partial<Annotation>, Annotation>} */
      apiCall('annotation.create'),
      delete: /** @type {APICall<IDParam>} */apiCall('annotation.delete'),
      get: /** @type {APICall<IDParam, void, Annotation>} */
      apiCall('annotation.read'),
      update: /** @type {APICall<IDParam, Partial<Annotation>, Annotation>} */
      apiCall('annotation.update'),
      flag: /** @type {APICall<IDParam>} */apiCall('annotation.flag'),
      hide: /** @type {APICall<IDParam>} */apiCall('annotation.hide'),
      unhide: /** @type {APICall<IDParam>} */apiCall('annotation.unhide')
    };
    this.group = {
      member: {
        delete: /** @type {APICall<{ pubid: string, userid: string }>} */
        apiCall('group.member.delete')
      },
      read: /** @type {APICall<{ id: string, expand: string[] }, void, Group>} */
      apiCall('group.read')
    };

    /**
     * @typedef ListGroupParams
     * @prop {string} [authority]
     * @prop {string} [document_uri]
     * @prop {string[]} [expand]
     */

    this.groups = {
      list: /** @type {APICall<ListGroupParams, void, Group[]>} */
      apiCall('groups.read')
    };
    this.profile = {
      groups: {
        read: /** @type {APICall<{ expand: string[] }, void, Group[]>} */
        apiCall('profile.groups.read')
      },
      read: /** @type {APICall<{ authority?: string }, void, Profile>} */
      apiCall('profile.read'),
      update: /** @type {APICall<{}, Partial<Profile>, Profile>} */
      apiCall('profile.update')
    };
  }

  /**
   * Set the "client ID" sent with API requests.
   *
   * This is a per-session unique ID which the client sends with REST API
   * requests and in the configuration for the real-time API to prevent the
   * client from receiving real-time notifications about its own actions.
   *
   * @param {string} clientId
   */
  setClientId(clientId) {
    this._clientId = clientId;
  }
}
APIService.$inject = ["apiRoutes", "auth", "store"];

var retry$2 = {exports: {}};

var retry$1 = {};

function RetryOperation(timeouts, options) {
  // Compatibility for the old (timeouts, retryForever) signature
  if (typeof options === 'boolean') {
    options = { forever: options };
  }

  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
  this._timeouts = timeouts;
  this._options = options || {};
  this._maxRetryTime = options && options.maxRetryTime || Infinity;
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;
  this._operationStart = null;
  this._timer = null;

  if (this._options.forever) {
    this._cachedTimeouts = this._timeouts.slice(0);
  }
}
var retry_operation = RetryOperation;

RetryOperation.prototype.reset = function() {
  this._attempts = 1;
  this._timeouts = this._originalTimeouts.slice(0);
};

RetryOperation.prototype.stop = function() {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }
  if (this._timer) {
    clearTimeout(this._timer);
  }

  this._timeouts       = [];
  this._cachedTimeouts = null;
};

RetryOperation.prototype.retry = function(err) {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }

  if (!err) {
    return false;
  }
  var currentTime = new Date().getTime();
  if (err && currentTime - this._operationStart >= this._maxRetryTime) {
    this._errors.push(err);
    this._errors.unshift(new Error('RetryOperation timeout occurred'));
    return false;
  }

  this._errors.push(err);

  var timeout = this._timeouts.shift();
  if (timeout === undefined) {
    if (this._cachedTimeouts) {
      // retry forever, only keep last error
      this._errors.splice(0, this._errors.length - 1);
      timeout = this._cachedTimeouts.slice(-1);
    } else {
      return false;
    }
  }

  var self = this;
  this._timer = setTimeout(function() {
    self._attempts++;

    if (self._operationTimeoutCb) {
      self._timeout = setTimeout(function() {
        self._operationTimeoutCb(self._attempts);
      }, self._operationTimeout);

      if (self._options.unref) {
          self._timeout.unref();
      }
    }

    self._fn(self._attempts);
  }, timeout);

  if (this._options.unref) {
      this._timer.unref();
  }

  return true;
};

RetryOperation.prototype.attempt = function(fn, timeoutOps) {
  this._fn = fn;

  if (timeoutOps) {
    if (timeoutOps.timeout) {
      this._operationTimeout = timeoutOps.timeout;
    }
    if (timeoutOps.cb) {
      this._operationTimeoutCb = timeoutOps.cb;
    }
  }

  var self = this;
  if (this._operationTimeoutCb) {
    this._timeout = setTimeout(function() {
      self._operationTimeoutCb();
    }, self._operationTimeout);
  }

  this._operationStart = new Date().getTime();

  this._fn(this._attempts);
};

RetryOperation.prototype.try = function(fn) {
  console.log('Using RetryOperation.try() is deprecated');
  this.attempt(fn);
};

RetryOperation.prototype.start = function(fn) {
  console.log('Using RetryOperation.start() is deprecated');
  this.attempt(fn);
};

RetryOperation.prototype.start = RetryOperation.prototype.try;

RetryOperation.prototype.errors = function() {
  return this._errors;
};

RetryOperation.prototype.attempts = function() {
  return this._attempts;
};

RetryOperation.prototype.mainError = function() {
  if (this._errors.length === 0) {
    return null;
  }

  var counts = {};
  var mainError = null;
  var mainErrorCount = 0;

  for (var i = 0; i < this._errors.length; i++) {
    var error = this._errors[i];
    var message = error.message;
    var count = (counts[message] || 0) + 1;

    counts[message] = count;

    if (count >= mainErrorCount) {
      mainError = error;
      mainErrorCount = count;
    }
  }

  return mainError;
};

(function (exports) {
	var RetryOperation = retry_operation;

	exports.operation = function(options) {
	  var timeouts = exports.timeouts(options);
	  return new RetryOperation(timeouts, {
	      forever: options && (options.forever || options.retries === Infinity),
	      unref: options && options.unref,
	      maxRetryTime: options && options.maxRetryTime
	  });
	};

	exports.timeouts = function(options) {
	  if (options instanceof Array) {
	    return [].concat(options);
	  }

	  var opts = {
	    retries: 10,
	    factor: 2,
	    minTimeout: 1 * 1000,
	    maxTimeout: Infinity,
	    randomize: false
	  };
	  for (var key in options) {
	    opts[key] = options[key];
	  }

	  if (opts.minTimeout > opts.maxTimeout) {
	    throw new Error('minTimeout is greater than maxTimeout');
	  }

	  var timeouts = [];
	  for (var i = 0; i < opts.retries; i++) {
	    timeouts.push(this.createTimeout(i, opts));
	  }

	  if (options && options.forever && !timeouts.length) {
	    timeouts.push(this.createTimeout(i, opts));
	  }

	  // sort the array numerically ascending
	  timeouts.sort(function(a,b) {
	    return a - b;
	  });

	  return timeouts;
	};

	exports.createTimeout = function(attempt, opts) {
	  var random = (opts.randomize)
	    ? (Math.random() + 1)
	    : 1;

	  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
	  timeout = Math.min(timeout, opts.maxTimeout);

	  return timeout;
	};

	exports.wrap = function(obj, options, methods) {
	  if (options instanceof Array) {
	    methods = options;
	    options = null;
	  }

	  if (!methods) {
	    methods = [];
	    for (var key in obj) {
	      if (typeof obj[key] === 'function') {
	        methods.push(key);
	      }
	    }
	  }

	  for (var i = 0; i < methods.length; i++) {
	    var method   = methods[i];
	    var original = obj[method];

	    obj[method] = function retryWrapper(original) {
	      var op       = exports.operation(options);
	      var args     = Array.prototype.slice.call(arguments, 1);
	      var callback = args.pop();

	      args.push(function(err) {
	        if (op.retry(err)) {
	          return;
	        }
	        if (err) {
	          arguments[0] = op.mainError();
	        }
	        callback.apply(this, arguments);
	      });

	      op.attempt(function() {
	        original.apply(obj, args);
	      });
	    }.bind(obj, original);
	    obj[method].options = options;
	  }
	};
} (retry$1));

(function (module) {
	module.exports = retry$1;
} (retry$2));

var retry = /*@__PURE__*/getDefaultExportFromCjs(retry$2.exports);

/**
 * Options passed that control how the operation is retried.
 *
 * See https://github.com/tim-kos/node-retry#retrytimeoutsoptions
 *
 * @typedef RetryOptions
 * @prop {number} minTimeout
 */

/**
 * Retry a Promise-returning operation until it succeeds or
 * fails after a set number of attempts.
 *
 * @template T
 * @param {() => Promise<T>} callback - The operation to retry
 * @param {RetryOptions} [options]
 * @return {Promise<T>} - Result of first successful `callback` call (ie. that
 *   did not reject)
 */
function retryPromiseOperation(callback, options) {
  return new Promise((resolve, reject) => {
    const operation = retry.operation(options);
    operation.attempt(async () => {
      try {
        const result = await callback();

        // After a successful call `retry` still needs to be invoked without
        // arguments to clear internal timeouts.
        operation.retry();
        resolve(result);
      } catch (err) {
        if (!operation.retry(err)) {
          reject(err);
        }
      }
    });
  });
}

/**
 * Fetch an API metadata file, retrying the operation if it fails.
 *
 * @param {string} url
 */
function getJSON(url) {
  return retryPromiseOperation(() =>
  // nb. The `/api/` and `/api/links` routes are fetched without specifying
  // any additional headers/config so that we can use `<link rel="preload">` in
  // the `/app.html` response to fetch them early, while the client JS app
  // is loading.
  fetchJSON(url));
}

/**
 * @typedef {import('../../types/api').IndexResponse} IndexResponse
 * @typedef {import('../../types/api').LinksResponse} LinksResponse
 * @typedef {import('../../types/api').RouteMap} RouteMap
 * @typedef {import('../../types/api').RouteMetadata} RouteMetadata
 * @typedef {import('../../types/config').SidebarSettings} SidebarSettings
 */

/**
 * A service which fetches and caches API route metadata.
 */
// @inject
class APIRoutesService {
  /**
   * @param {SidebarSettings} settings
   */
  constructor(settings) {
    this._apiURL = settings.apiUrl;

    /** @type {Promise<RouteMap>|null} */
    this._routeCache = null;

    /** @type {Promise<LinksResponse>|null} */
    this._linkCache = null;
  }

  /**
   * Fetch and cache API route metadata.
   *
   * Routes are fetched without any authentication and therefore assumed to be
   * the same regardless of whether the user is authenticated or not.
   *
   * @return {Promise<RouteMap>} - Map of routes to route metadata.
   */
  routes() {
    if (!this._routeCache) {
      this._routeCache = getJSON(this._apiURL).then(result => {
        const index = /** @type {IndexResponse} */result;
        return index.links;
      });
    }
    return this._routeCache;
  }

  /**
   * Fetch and cache service page links from the API.
   *
   * @return {Promise<LinksResponse>}
   */
  links() {
    if (!this._linkCache) {
      this._linkCache = this.routes().then(async routes => {
        const linksRoute = /** @type {RouteMetadata} */routes.links;
        const links = await getJSON(linksRoute.url);
        return (/** @type {LinksResponse} */links
        );
      });
    }
    return this._linkCache;
  }
}
APIRoutesService.$inject = ["settings"];

/**
 * OAuth access token response.
 *
 * See https://datatracker.ietf.org/doc/html/rfc6749#section-5.1
 *
 * @typedef AccessTokenResponse
 * @prop {string} access_token
 * @prop {number} expires_in
 * @prop {string} refresh_token
 */

/**
 * An object holding the details of an access token from the tokenUrl endpoint.
 *
 * @typedef TokenInfo
 * @prop {string} accessToken  - The access token itself.
 * @prop {number} expiresAt    - The date when the timestamp will expire.
 * @prop {string} refreshToken - The refresh token that can be used to
 *                               get a new access token.
 */

/**
 * Error thrown if fetching or revoking an access token fails.
 */
class TokenError extends Error {
  /**
   * @param {string} message
   * @param {Error} cause - The error which caused the token fetch to fail
   */
  constructor(message, cause) {
    super(message);
    this.cause = cause;
  }
}

/**
 * OAuthClient configuration.
 *
 * @typedef Config
 * @prop {string} clientId - OAuth client ID
 * @prop {string} tokenEndpoint - OAuth token exchange/refresh endpoint
 * @prop {string} authorizationEndpoint - OAuth authorization endpoint
 * @prop {string} revokeEndpoint - RFC 7009 token revocation endpoint
 */

/**
 * OAuthClient handles interaction with the annotation service's OAuth
 * endpoints.
 */
class OAuthClient {
  /**
   * Create a new OAuthClient
   *
   * @param {Config} config
   */
  constructor(config) {
    this.clientId = config.clientId;
    this.tokenEndpoint = config.tokenEndpoint;
    this.authorizationEndpoint = config.authorizationEndpoint;
    this.revokeEndpoint = config.revokeEndpoint;
  }

  /**
   * Exchange an authorization code for access and refresh tokens.
   *
   * @param {string} code
   * @return {Promise<TokenInfo>}
   */
  exchangeAuthCode(code) {
    return this._getAccessToken({
      client_id: this.clientId,
      grant_type: 'authorization_code',
      code
    });
  }

  /**
   * Exchange a grant token for access and refresh tokens.
   *
   * See https://tools.ietf.org/html/rfc7523#section-4
   *
   * @param {string} token
   * @return {Promise<TokenInfo>}
   */
  exchangeGrantToken(token) {
    return this._getAccessToken({
      grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
      assertion: token
    });
  }

  /**
   * Refresh an access and refresh token pair.
   *
   * See https://tools.ietf.org/html/rfc6749#section-6
   *
   * @param {string} refreshToken
   * @return {Promise<TokenInfo>}
   */
  refreshToken(refreshToken) {
    return this._getAccessToken({
      grant_type: 'refresh_token',
      refresh_token: refreshToken
    });
  }

  /**
   * Revoke an access and refresh token pair.
   *
   * @param {string} accessToken
   * @return {Promise<void>}
   */
  async revokeToken(accessToken) {
    try {
      await this._formPost(this.revokeEndpoint, {
        token: accessToken
      });
    } catch (err) {
      throw new TokenError('Failed to revoke access token', err);
    }
  }

  /**
   * Prompt the user for permission to access their data.
   *
   * Returns an authorization code which can be passed to `exchangeAuthCode`.
   *
   * @param {Window} $window - Window which will receive the auth response.
   * @return {Promise<string>}
   */
  authorize($window) {
    // Random state string used to check that auth messages came from the popup
    // window that we opened.
    //
    // See https://tools.ietf.org/html/rfc6749#section-4.1.1.
    const state = generateHexString(16);

    // Promise which resolves or rejects when the user accepts or closes the
    // auth popup.
    const authResponse = new Promise((resolve, reject) => {
      /** @param {MessageEvent} event */
      function authRespListener(event) {
        if (typeof event.data !== 'object') {
          return;
        }
        if (event.data.state !== state) {
          // This message came from a different popup window.
          return;
        }
        if (event.data.type === 'authorization_response') {
          resolve(event.data);
        }
        if (event.data.type === 'authorization_canceled') {
          reject(new Error('Authorization window was closed'));
        }
        $window.removeEventListener('message', authRespListener);
      }
      $window.addEventListener('message', authRespListener);
    });

    // Authorize user and retrieve grant token
    const authURL = new URL(this.authorizationEndpoint);
    authURL.searchParams.set('client_id', this.clientId);
    authURL.searchParams.set('origin', $window.location.origin);
    authURL.searchParams.set('response_mode', 'web_message');
    authURL.searchParams.set('response_type', 'code');
    authURL.searchParams.set('state', state);

    // In Chrome & Firefox the sizes passed to `window.open` are used for the
    // viewport size. In Safari the size is used for the window size including
    // title bar etc. There is enough vertical space at the bottom to allow for
    // this.
    //
    // See https://bugs.webkit.org/show_bug.cgi?id=143678
    const width = 475;
    const height = 430;
    const left = $window.screen.width / 2 - width / 2;
    const top = $window.screen.height / 2 - height / 2;

    // Generate settings for `window.open` in the required comma-separated
    // key=value format.
    const authWindowSettings = `left=${left},top=${top},width=${width},height=${height}`;
    const authWindow = $window.open(authURL.toString(), 'Log in to Hypothesis', authWindowSettings);
    if (!authWindow) {
      throw new Error('Failed to open login window');
    }
    return authResponse.then(rsp => rsp.code);
  }

  /**
   * Make an `application/x-www-form-urlencoded` POST request.
   *
   * @param {string} url
   * @param {Record<string, string>} data - Parameter dictionary
   */
  async _formPost(url, data) {
    const params = new URLSearchParams();
    for (let [key, value] of Object.entries(data)) {
      params.set(key, value);
    }

    // Tests currently expect sorted parameters.
    params.sort();
    const headers = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };
    return fetchJSON(url, {
      method: 'POST',
      headers,
      body: params.toString()
    });
  }

  /**
   * Fetch an OAuth access token.
   *
   * See https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3
   *
   * @param {Record<string, string>} data - Parameters for form POST request
   * @return {Promise<TokenInfo>}
   */
  async _getAccessToken(data) {
    let response;
    try {
      response = /** @type {AccessTokenResponse} */
      await this._formPost(this.tokenEndpoint, data);
    } catch (err) {
      throw new TokenError('Failed to fetch access token', err);
    }
    return {
      accessToken: response.access_token,
      // Set the expiry date to some time slightly before that implied by
      // `expires_in` to account for the delay in the client receiving the
      // response.
      expiresAt: Date.now() + (response.expires_in - 10) * 1000,
      refreshToken: response.refresh_token
    };
  }
}

/**
 * @typedef {import('../util/oauth-client').TokenInfo} TokenInfo
 *
 * @typedef RefreshOptions
 * @prop {boolean} persist - True if access tokens should be persisted for
 *   use in future sessions.
 */

/**
 * Authorization service.
 *
 * This service is responsible for acquiring access tokens for making API
 * requests and making them available via the `getAccessToken()` method.
 *
 * Access tokens are acquired via the OAuth authorization flow, loading valid
 * tokens from a previous session or, on some websites, by exchanging a grant
 * token provided by the host page.
 *
 * Interaction with OAuth endpoints in the annotation service is delegated to
 * the `OAuthClient` class.
 *
 * @inject
 */
class AuthService extends TinyEmitter {
  /**
   * @param {Window} $window
   * @param {import('./api-routes').APIRoutesService} apiRoutes
   * @param {import('./local-storage').LocalStorageService} localStorage
   * @param {import('./toast-messenger').ToastMessengerService} toastMessenger
   * @param {import('../../types/config').SidebarSettings} settings
   */
  constructor($window, apiRoutes, localStorage, settings, toastMessenger) {
    super();

    /**
     * Authorization code from auth popup window.
     * @type {string|null}
     */
    let authCode;

    /**
     * Token info retrieved via `POST /api/token` endpoint.
     *
     * Resolves to `null` if the user is not logged in.
     *
     * @type {Promise<TokenInfo|null>|null}
     */
    let tokenInfoPromise;

    /** @type {OAuthClient} */
    let client;

    /**
     * Absolute URL of the `/api/token` endpoint.
     */
    const tokenUrl = resolve('token', settings.apiUrl);

    /**
     * Show an error message telling the user that the access token has expired.
     *
     * @param {string} message
     */
    function showAccessTokenExpiredErrorMessage(message) {
      toastMessenger.error(`Hypothesis login lost: ${message}`, {
        autoDismiss: false
      });
    }

    /**
     * Return the storage key used for storing access/refresh token data for a given
     * annotation service.
     */
    function storageKey() {
      // Use a unique key per annotation service. Currently OAuth tokens are only
      // persisted for the default annotation service. If in future we support
      // logging into other services from the client, this function will need to
      // take the API URL as an argument.
      let apiDomain = new URL(settings.apiUrl).hostname;

      // Percent-encode periods to avoid conflict with section delimeters.
      apiDomain = apiDomain.replace(/\./g, '%2E');
      return `hypothesis.oauth.${apiDomain}.token`;
    }

    /**
     * Fetch the last-saved access/refresh tokens for `authority` from local
     * storage.
     */
    function loadToken() {
      const token = localStorage.getObject(storageKey());
      if (!token || typeof token.accessToken !== 'string' || typeof token.refreshToken !== 'string' || typeof token.expiresAt !== 'number') {
        return null;
      }
      return {
        accessToken: token.accessToken,
        refreshToken: token.refreshToken,
        expiresAt: token.expiresAt
      };
    }

    /**
     * Persist access & refresh tokens for future use.
     *
     * @param {TokenInfo} token
     */
    function saveToken(token) {
      localStorage.setObject(storageKey(), token);
    }

    /**
     * Listen for updated access & refresh tokens saved by other instances of the
     * client.
     */
    const listenForTokenStorageEvents = () => {
      $window.addEventListener('storage', ({
        key
      }) => {
        if (key === storageKey()) {
          // Reset cached token information. Tokens will be reloaded from storage
          // on the next call to `getAccessToken()`.
          tokenInfoPromise = null;
          this.emit('oauthTokensChanged');
        }
      });
    };
    const oauthClient = async () => {
      if (client) {
        return client;
      }
      const links = await apiRoutes.links();
      client = new OAuthClient({
        clientId: settings.oauthClientId,
        authorizationEndpoint: links['oauth.authorize'],
        revokeEndpoint: links['oauth.revoke'],
        tokenEndpoint: tokenUrl
      });
      return client;
    };

    /**
     * Exchange a refresh token for a new access token and refresh token pair.
     *
     * @param {string} refreshToken
     * @param {RefreshOptions} options
     * @return {Promise<TokenInfo|null>} Promise for the new access token
     */
    const refreshAccessToken = async (refreshToken, options) => {
      const client = await oauthClient();
      let token;
      try {
        token = await client.refreshToken(refreshToken);

        // Sanity check that prevents an infinite loop. Mostly useful in
        // tests.
        if (Date.now() > token.expiresAt) {
          /* istanbul ignore next */
          throw new Error('Refreshed token expired in the past');
        }
      } catch {
        // If refreshing the token fails, the user is simply logged out.
        return null;
      }
      if (options.persist) {
        saveToken(token);
      }
      return token;
    };

    /**
     * Exchange authorization code retrieved from login popup for a new
     * access token.
     *
     * @param {string} code
     */
    const exchangeAuthCodeForToken = async code => {
      const client = await oauthClient();
      const tokenInfo = await client.exchangeAuthCode(code);
      saveToken(tokenInfo);
      return tokenInfo;
    };

    /**
     * Return the grant token provided by the host page or parent frame used
     * for automatic login. This will be:
     *  - `undefined` if automatic login is not used
     *  - `null` if automatic login is used but the user is not logged in
     *  - a non-empty string if automatic login is used and the user is logged in
     */
    const getGrantToken = () => {
      var _serviceConfig;
      return (_serviceConfig = serviceConfig(settings)) === null || _serviceConfig === void 0 ? void 0 : _serviceConfig.grantToken;
    };

    /**
     * Retrieve an access token for the API.
     *
     * @return {Promise<string|null>} The API access token or `null` if not logged in.
     */
    const getAccessToken = async () => {
      // Determine how to get an access token, depending on the login method being used.
      if (!tokenInfoPromise) {
        const grantToken = getGrantToken();
        if (grantToken !== undefined) {
          if (grantToken) {
            // User is logged-in on the publisher's website.
            // Exchange the grant token for a new access token.
            tokenInfoPromise = oauthClient().then(client => client.exchangeGrantToken(grantToken)).catch(err => {
              showAccessTokenExpiredErrorMessage('You must reload the page to annotate.');
              throw err;
            });
          } else {
            // User is anonymous on the publisher's website.
            tokenInfoPromise = Promise.resolve(null);
          }
        } else if (authCode) {
          tokenInfoPromise = exchangeAuthCodeForToken(authCode);
          authCode = null; // Auth codes can only be used once.
        } else {
          // Attempt to load the tokens from the previous session.
          tokenInfoPromise = Promise.resolve(loadToken());
        }
      }

      // Wait for the token to be fetched, and check that it is valid and that
      // it wasn't invalidated while it was being fetched.
      const origToken = tokenInfoPromise;
      const token = await tokenInfoPromise;
      if (!token) {
        // No token available. User will need to log in.
        return null;
      }
      if (origToken !== tokenInfoPromise) {
        // The token source was changed while waiting for the token to be fetched.
        // This can happen for various reasons. We'll just need to try again.
        return getAccessToken();
      }
      if (Date.now() > token.expiresAt) {
        // Token has expired, so we need to fetch a new one.
        const grantToken = getGrantToken();
        tokenInfoPromise = refreshAccessToken(token.refreshToken, {
          // Only persist tokens if automatic login is not being used.
          persist: typeof grantToken === 'undefined'
        });
        return getAccessToken();
      }
      return token.accessToken;
    };

    /**
     * Login to the annotation service using OAuth.
     *
     * This displays a popup window which allows the user to login to the service
     * (if necessary) and then responds with an auth code which the client can
     * then exchange for access and refresh tokens.
     */
    async function login() {
      // Any async steps before the call to `client.authorize` must complete
      // in less than ~1 second, otherwise the browser's popup blocker may block
      // the popup.
      //
      // `oauthClient` is async in case in needs to fetch links from the API.
      // This should already have happened by the time this function is called
      // however, so it will just be returning a cached value.
      const client = await oauthClient();
      const code = await client.authorize($window);

      // Save the auth code. It will be exchanged for an access token when the
      // next API request is made.
      authCode = code;
      tokenInfoPromise = null;
    }

    /**
     * Log out of the service (in the client only).
     *
     * This revokes and then forgets any OAuth credentials that the user has.
     */
    async function logout() {
      const [token, client] = await Promise.all([tokenInfoPromise, oauthClient()]);
      if (token) {
        await client.revokeToken(token.accessToken);
      }

      // eslint-disable-next-line require-atomic-updates
      tokenInfoPromise = Promise.resolve(null);
      localStorage.removeItem(storageKey());
    }
    listenForTokenStorageEvents();

    // TODO - Convert these to ordinary class methods.
    this.login = login;
    this.logout = logout;
    this.getAccessToken = getAccessToken;
  }
}
AuthService.$inject = ["$window", "apiRoutes", "localStorage", "settings", "toastMessenger"];

/**
 * A service for automatically saving new highlights.
 *
 * @inject
 */
class AutosaveService {
  /**
   * @param {import('./annotations').AnnotationsService} annotationsService
   * @param {import('./toast-messenger').ToastMessengerService} toastMessenger
   * @param {import('../store').SidebarStore} store
   */
  constructor(annotationsService, toastMessenger, store) {
    this._annotationsService = annotationsService;
    this._toastMessenger = toastMessenger;
    this._store = store;

    // A set of annotation $tags that have save requests in-flight
    this._saving = new Set();

    // A set of annotation $tags that have failed to save after retries
    this._failed = new Set();
  }

  /**
   * Begin watching the store for new unsaved highlights and save them in
   * response.
   */
  init() {
    /**
     * Determine whether we should try to send a save request for the highlight
     * indicated by `htag`
     *
     * @param {string} htag - The local unique identifier for the unsaved highlight
     * @return {boolean}
     */
    const shouldSaveHighlight = htag => {
      return !this._saving.has(htag) && !this._failed.has(htag);
    };

    /**
     * Store-subscribed call back. Automatically save new highlights.
     */
    const autosaveNewHighlights = () => {
      const newHighlights = this._store.newHighlights();
      newHighlights.forEach(highlight => {
        // Because this is a new annotation object, it does not yet have an `id`
        // property. Use the local `$tag` for uniqueness instead.
        const htag = highlight.$tag;
        if (!shouldSaveHighlight(htag)) {
          return;
        }
        this._saving.add(htag);
        retryPromiseOperation(() => this._annotationsService.save(highlight)).then(() => {
          this._toastMessenger.success('Highlight saved', {
            visuallyHidden: true
          });
        }).catch(() => {
          // save failed after retries
          this._failed.add(htag);
        }).finally(() => {
          // Request is complete, no longer attempting to save
          this._saving.delete(htag);
        });
      });
    };
    this._store.subscribe(autosaveNewHighlights);
  }

  /**
   * Return `true` if any new highlights are currently being saved.
   */
  isSaving() {
    return this._saving.size > 0;
  }
}
AutosaveService.$inject = ["annotationsService", "toastMessenger", "store"];

/**
 * Message sent by `PortProvider` and `PortFinder` to establish a
 * MessageChannel-based connection between two frames.
 *
 * @typedef {'guest'|'host'|'notebook'|'sidebar'} Frame
 *
 * @typedef Message
 * @prop {Frame} frame1 - Role of the source frame
 * @prop {Frame} frame2 - Role of the target frame
 * @prop {'offer'|'request'} type - Message type. "request" messages are sent
 *   by the source frame to the host frame to request a connection. "offer"
 *   messages are sent from the host frame back to the source frame and also
 *   to the target frame, accompanied by a MessagePort.
 * @prop {string} requestId - ID of the request. Used to associate "offer"
 *   messages with their corresponding "request" messages.
 * @prop {string} [sourceId] - Identifier for the source frame. This is useful
 *   in cases where multiple source frames with a given role may connect to
 *   the same destination frame.
 */

/**
 * Return true if an object, eg. from the data field of a `MessageEvent`, is a
 * valid `Message`.
 *
 * @param {any} data
 * @return {data is Message}
 */
function isMessage(data) {
  if (data === null || typeof data !== 'object') {
    return false;
  }
  for (let property of ['frame1', 'frame2', 'type', 'requestId']) {
    if (typeof data[property] !== 'string') {
      return false;
    }
  }
  return true;
}

/**
 * Return true if the data payload from a MessageEvent matches `message`.
 *
 * @param {any} data
 * @param {Partial<Message>} message
 */
function isMessageEqual(data, message) {
  if (!isMessage(data)) {
    return false;
  }

  // We assume `JSON.stringify` cannot throw because `isMessage` verifies that
  // all the fields we serialize here are serializable values.
  return JSON.stringify(data, Object.keys(message).sort()) === JSON.stringify(message, Object.keys(message).sort());
}

/**
 * Check that source is of type Window.
 *
 * @param {MessageEventSource|null} source
 * @return {source is Window}
 */
function isSourceWindow(source) {
  if (
  // `source` can be of type Window, MessagePort, ServiceWorker, or null.
  // `source instanceof Window` doesn't work in Chrome if `source` is a
  // cross-origin window.
  source === null || source instanceof MessagePort || window.ServiceWorker && source instanceof ServiceWorker) {
    return false;
  }
  return true;
}

/** Timeout for waiting for the host frame to respond to a port request. */
const MAX_WAIT_FOR_PORT = 1000 * 20;

/** Polling interval for requests to the host frame for a port. */
const POLLING_INTERVAL_FOR_PORT = 250;

/**
 * @typedef {import('../../types/annotator').Destroyable} Destroyable
 * @typedef {import('./port-util').Message} Message
 * @typedef {import('./port-util').Frame} Frame
 */

/**
 * PortFinder is used by non-host frames in the client to establish a
 * MessagePort-based connection to other frames. It is used together with
 * PortProvider which runs in the host frame. See PortProvider for an overview.
 *
 * @implements {Destroyable}
 */
class PortFinder {
  /**
   * @param {object} options
   *   @param {Exclude<Frame, 'host'>} options.source - the role of this frame
   *   @param {string} [options.sourceId] - Identifier for this frame
   *   @param {Window} options.hostFrame - the frame where the `PortProvider` is
   *     listening for messages.
   */
  constructor({
    hostFrame,
    source,
    sourceId
  }) {
    this._hostFrame = hostFrame;
    this._source = source;
    this._sourceId = sourceId;
    this._listeners = new ListenerCollection$1();
  }
  destroy() {
    this._listeners.removeAll();
  }

  /**
   * Request a specific port from the host frame
   *
   * @param {Frame} target - the frame aiming to be discovered
   * @return {Promise<MessagePort>}
   */
  async discover(target) {
    let isValidRequest = false;
    if (this._source === 'guest' && target === 'host' || this._source === 'guest' && target === 'sidebar' || this._source === 'sidebar' && target === 'host' || this._source === 'notebook' && target === 'sidebar') {
      isValidRequest = true;
    }
    if (!isValidRequest) {
      throw new Error('Invalid request of channel/port');
    }
    const requestId = generateHexString(6);
    return new Promise((resolve, reject) => {
      const postRequest = () => {
        this._hostFrame.postMessage({
          frame1: this._source,
          frame2: target,
          type: 'request',
          requestId,
          sourceId: this._sourceId
        }, '*');
      };

      // Because `guest` iframes load in parallel to the `host` frame, we can
      // not assume that the code in the `host` frame is executed before the
      // code in a `guest` frame. Hence, we can't assume that `PortProvider` (in
      // the `host` frame) is initialized before `PortFinder` (in the non-host
      // frames). Therefore, for the `PortFinder`, we implement a polling
      // strategy (sending a message every N milliseconds) until a response is
      // received.
      const intervalId = setInterval(postRequest, POLLING_INTERVAL_FOR_PORT);

      // The `host` frame maybe busy, that's why we should wait.
      const timeoutId = setTimeout(() => {
        clearInterval(intervalId);
        reject(new Error(`Unable to establish ${this._source}-${target} communication channel`));
      }, MAX_WAIT_FOR_PORT);
      const listenerId = this._listeners.add(window, 'message', event => {
        const {
          data,
          ports
        } = event;
        if (isMessageEqual(data, {
          frame1: this._source,
          frame2: target,
          type: 'offer',
          requestId
        })) {
          clearInterval(intervalId);
          clearTimeout(timeoutId);
          this._listeners.remove(listenerId);
          resolve(ports[0]);
        }
      });
      postRequest();
    });
  }
}

/**
 * @typedef {import('../../types/annotator').Destroyable} Destroyable
 * @typedef {import('./port-util').Message} Message
 * @typedef {import('./port-util').Frame} Frame
 * @typedef {'guest-host'|'guest-sidebar'|'notebook-sidebar'|'sidebar-host'} Channel
 */

/**
 * PortProvider creates a `MessageChannel` for communication between two
 * frames.
 *
 * There are 4 types of frames:
 * - `host`: frame where the Hypothesis client is initially loaded.
 * - `guest`: frames with annotatable content. In some instances a `guest`
 *    frame can be the same as the `host` frame, in other cases, it is an iframe
 *    where either (1) the hypothesis client has been injected or (2) the
 *    hypothesis client has been configured to act exclusively as a `guest` (not
 *    showing the sidebar).
 * - `notebook`: another hypothesis app that runs in a separate iframe.
 * - `sidebar`: the main hypothesis app. It runs in an iframe on a different
 *    origin than the host and is responsible for the communication with the
 *    backend (fetching and saving annotations).
 *
 * This layout represents the current arrangement of frames:
 *
 * `host` frame
 * |-> `sidebar` iframe
 * |-> `notebook` iframe
 * |-> [`guest` iframes]
 *
 * Currently, we support communication between the following pairs of frames:
 * - `guest-host`
 * - `guest-sidebar`
 * - `notebook-sidebar`
 * - `sidebar-host`
 *
 * `PortProvider` is used only in the `host` frame. The other frames use the
 * companion class, `PortFinder`. `PortProvider` creates a `MessageChannel`
 * for two frames to communicate with each other. It also listens to requests for
 * particular `MessagePort` and dispatches the corresponding `MessagePort`.
 *
 *
 *        PortFinder (non-host frame)                 |       PortProvider (host frame)
 * -----------------------------------------------------------------------------------------------
 * 1. Request `MessagePort` via `window.postMessage` ---> 2. Receive request and create port pair
 *                                                                          |
 *                                                                          V
 * 4. Receive requested port      <---------------------- 3. Send first port to requesting frame
 *                                                        5. Send second port to other frame
 *                                                           (eg. via MessageChannel connection
 *                                                           between host and other frame)
 *
 * @implements {Destroyable}
 */
class PortProvider {
  /**
   * Begin listening to port requests from other frames.
   *
   * @param {string} hypothesisAppsOrigin - the origin of the hypothesis apps
   *   is use to send the notebook and sidebar ports to only the frames that
   *   match the origin.
   */
  constructor(hypothesisAppsOrigin) {
    this._hypothesisAppsOrigin = hypothesisAppsOrigin;
    this._emitter = new TinyEmitter();

    /**
     * IDs of port requests that have been handled.
     *
     * This is used to avoid responding to the same request multiple times.
     * Guest frames in particular may send duplicate requests (see comments in
     * PortFinder).
     *
     * @type {Set<string>}
     */
    this._handledRequests = new Set();

    // Create the `sidebar-host` channel immediately, while other channels are
    // created on demand
    this._sidebarHostChannel = new MessageChannel();
    this._listeners = new ListenerCollection$1();

    /** @type {Array<Partial<Message> & {allowedOrigin: string}>} */
    this._allowedMessages = [{
      allowedOrigin: '*',
      frame1: 'guest',
      frame2: 'host',
      type: 'request'
    }, {
      allowedOrigin: '*',
      frame1: 'guest',
      frame2: 'sidebar',
      type: 'request'
    }, {
      allowedOrigin: this._hypothesisAppsOrigin,
      frame1: 'sidebar',
      frame2: 'host',
      type: 'request'
    }, {
      allowedOrigin: this._hypothesisAppsOrigin,
      frame1: 'notebook',
      frame2: 'sidebar',
      type: 'request'
    }];
    this._listen();
  }
  _listen() {
    const errorContext = 'Handling port request';
    const sentErrors = /** @type {Set<string>} */new Set();

    /** @param {string} message */
    const reportError = message => {
      if (sentErrors.has(message)) {
        // PortFinder will send requests repeatedly until it gets a response or
        // a timeout is reached.
        //
        // Only send errors once to avoid spamming Sentry.
        return;
      }
      sentErrors.add(message);
      sendError(new Error(message), errorContext);
    };

    /** @param {MessageEvent} event */
    const handleRequest = event => {
      const {
        data,
        origin,
        source
      } = event;
      if (!isMessage(data) || data.type !== 'request') {
        // If this does not look like a message intended for us, ignore it.
        return;
      }
      const {
        frame1,
        frame2,
        requestId,
        sourceId
      } = data;
      const channel = /** @type {Channel} */`${frame1}-${frame2}`;
      if (!isSourceWindow(source)) {
        reportError(`Ignored port request for channel ${channel} from non-Window source`);
        return;
      }
      const match = this._allowedMessages.find(({
        allowedOrigin,
        ...allowedMessage
      }) => this._messageMatches({
        allowedMessage,
        allowedOrigin,
        data,
        origin
      }));
      if (match === undefined) {
        reportError(`Ignored invalid port request for channel ${channel} from ${origin}`);
        return;
      }
      if (this._handledRequests.has(requestId)) {
        return;
      }
      this._handledRequests.add(requestId);

      // Create the channel for these two frames to communicate and send the
      // corresponding ports to them.
      const messageChannel = channel === 'sidebar-host' ? this._sidebarHostChannel : new MessageChannel();

      // The message that is sent to the target frame that the source wants to
      // connect to, as well as the source frame requesting the connection.
      // Each message is accompanied by a port for the appropriate end of the
      // connection.
      const message = {
        frame1,
        frame2,
        type: 'offer',
        requestId,
        sourceId
      };

      // If the source window has an opaque origin [1], `event.origin` will be
      // the string "null". This is not a legal value for the `targetOrigin`
      // parameter to `postMessage`, so remap it to "*".
      //
      // [1] https://html.spec.whatwg.org/multipage/origin.html#origin.
      //     Documents with opaque origins include file:// URLs and
      //     sandboxed iframes.
      const targetOrigin = origin === 'null' ? '*' : origin;
      source.postMessage(message, targetOrigin, [messageChannel.port1]);
      if (frame2 === 'sidebar') {
        this._sidebarHostChannel.port2.postMessage(message, [messageChannel.port2]);
      } else if (frame2 === 'host') {
        this._emitter.emit('frameConnected', frame1, messageChannel.port2);
      }
    };
    this._listeners.add(window, 'message', captureErrors(handleRequest, errorContext));
  }

  /**
   * @param {object} options
   *   @param {Partial<Message>} options.allowedMessage - the `data` must match this
   *     `Message`.
   *   @param {string} options.allowedOrigin - the `origin` must match this
   *     value. If `allowedOrigin` is '*', the origin is ignored.
   *   @param {unknown} options.data - the data to be compared with `allowedMessage`.
   *   @param {string} options.origin - the origin to be compared with
   *     `allowedOrigin`.
   */
  _messageMatches({
    allowedMessage,
    allowedOrigin,
    data,
    origin
  }) {
    if (allowedOrigin !== '*' && origin !== allowedOrigin) {
      return false;
    }
    return isMessageEqual(data, allowedMessage);
  }

  /**
   * @param {'frameConnected'} eventName
   * @param {(source: 'guest'|'sidebar', port: MessagePort) => void} handler - this handler
   *   fires when a frame connects to the host frame
   */
  on(eventName, handler) {
    this._emitter.on(eventName, handler);
  }
  destroy() {
    this._listeners.removeAll();
  }
}

/*
  This module was adapted from `index.js` in https://github.com/substack/frame-rpc.

  This software is released under the MIT license:

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 */

const VERSION = '1.0.0';
const PROTOCOL = 'frame-rpc';

/**
 * Format of messages sent between frames.
 *
 * See https://github.com/substack/frame-rpc#protocol
 *
 * @typedef RequestMessage
 * @prop {unknown[]} arguments
 * @prop {string} method
 * @prop {PROTOCOL} protocol
 * @prop {number} sequence
 * @prop {VERSION} version
 *
 * @typedef ResponseMessage
 * @prop {unknown[]} arguments
 * @prop {PROTOCOL} protocol
 * @prop {number} response
 * @prop {VERSION} version
 *
 * @typedef {RequestMessage|ResponseMessage} Message
 *
 * @typedef {import('../../types/annotator').Destroyable} Destroyable
 */

/**
 * Send a PortRPC method call.
 *
 * @param {MessagePort} port
 * @param {string} method
 * @param {unknown[]} [args]
 * @param {number} [sequence] - Sequence number used for replies
 */
function sendCall(port, method, args = [], sequence = -1) {
  port.postMessage( /** @type {RequestMessage} */{
    protocol: PROTOCOL,
    version: VERSION,
    arguments: args,
    method,
    sequence
  });
}

/**
 * Install a message listener that ensures proper delivery of "close" notifications
 * from {@link PortRPC}s in Safari <= 15.
 *
 * This must be called in the _parent_ frame of the frame that owns the port.
 * In Hypothesis this means for example that the workaround would be installed
 * in the host frame to ensure delivery of "close" notifications from "guest"
 * frames.
 *
 * @param {string} [userAgent] - Test seam
 * @return {() => void} - Callback that removes the listener
 */
function installPortCloseWorkaroundForSafari( /* istanbul ignore next */
userAgent = navigator.userAgent) {
  if (!shouldUseSafariWorkaround(userAgent)) {
    return () => {};
  }

  /** @param {MessageEvent} event */
  const handler = event => {
    var _event$data;
    if (((_event$data = event.data) === null || _event$data === void 0 ? void 0 : _event$data.type) === 'hypothesisPortClosed' && event.ports[0]) {
      const port = event.ports[0];
      sendCall(port, 'close');
      port.close();
    }
  };
  window.addEventListener('message', handler);
  return () => window.removeEventListener('message', handler);
}

/**
 * Test whether this browser needs the workaround for https://bugs.webkit.org/show_bug.cgi?id=231167.
 *
 * @param {string} userAgent
 */
function shouldUseSafariWorkaround(userAgent) {
  const webkitVersionMatch = userAgent.match(/\bAppleWebKit\/([0-9]+)\b/);
  if (!webkitVersionMatch) {
    return false;
  }
  const version = parseInt(webkitVersionMatch[1]);

  // Chrome's user agent contains the token "AppleWebKit/537.36", where the
  // version number is frozen. This corresponds to a version of Safari from 2013,
  // which is older than all supported Safari versions.
  if (version <= 537) {
    return false;
  }
  return true;
}

/**
 * Callback type used for RPC method handlers and result callbacks.
 *
 * @typedef {(...args: unknown[]) => void} Callback
 */

/**
 * @param {any} value
 * @return {value is Callback}
 */
function isCallback(value) {
  return typeof value === 'function';
}

/**
 * PortRPC provides remote procedure calls between frames or workers. It uses
 * the Channel Messaging API [1] as a transport.
 *
 * To communicate between two frames with this class, construct a PortRPC
 * instance in each and register method handlers with {@link on}. Create a
 * {@link MessageChannel} and send one of its two ports to each frame. Then call
 * {@link connect} to make the PortRPC instance in each frame use the corresponding
 * port.
 *
 * In addition to the custom methods that a PortRPC handles, there are several
 * built-in events which are sent automatically:
 *
 * - "connect" is sent when a PortRPC connects to a port. This event can
 *   be used to confirm that the sending frame has received the port and will
 *   send a "close" event when it goes away.
 * - "close" is sent when a PortRPC is destroyed or the owning frame is
 *   unloaded. This event may not be dispatched if the guest frame terminates
 *   abnormally (eg. due to an OS process crash).
 *
 * [1] https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API
 *
 * @template {string} OnMethod - Names of RPC methods this client responds to
 * @template {string} CallMethod - Names of RPC methods this client invokes
 * @implements {Destroyable}
 */
class PortRPC {
  /**
   * @param {object} options
   *   @param {string} [options.userAgent] - Test seam
   *   @param {Window} [options.currentWindow] - Test seam
   */
  constructor({
    userAgent = navigator.userAgent,
    currentWindow = window
  } = {}) {
    /** @type {MessagePort|null} */
    this._port = null;

    /** @type {Map<string, Callback>} */
    this._methods = new Map();
    this._sequence = 1;

    /** @type {Map<number, Callback>} */
    this._callbacks = new Map();
    this._listeners = new ListenerCollection$1();
    this._listeners.add(currentWindow, 'unload', () => {
      if (this._port) {
        // Send "close" notification directly. This works in Chrome, Firefox and
        // Safari >= 16.
        sendCall(this._port, 'close');

        // To work around a bug in Safari <= 15 which prevents sending messages
        // while a window is unloading, try transferring the port to the parent frame
        // and re-sending the "close" event from there.
        if (currentWindow !== currentWindow.parent && shouldUseSafariWorkaround(userAgent)) {
          currentWindow.parent.postMessage({
            type: 'hypothesisPortClosed'
          }, '*', [this._port]);
        }
      }
    });

    /**
     * Method and arguments of pending RPC calls made before a port was connected.
     *
     * @type {Array<[CallMethod, unknown[]]>}
     */
    this._pendingCalls = [];
    this._receivedCloseEvent = false;
  }

  /**
   * Register a method handler for incoming RPC requests.
   *
   * This can also be used to register a handler for the built-in "connect"
   * and "close" events.
   *
   * All handlers must be registered before {@link connect} is invoked.
   *
   * @template {function} Handler
   * @param {OnMethod|'close'|'connect'} method
   * @param {Handler} handler
   */
  on(method, handler) {
    if (this._port) {
      throw new Error('Cannot add a method handler after a port is connected');
    }
    this._methods.set(method, /** @type {any} */handler);
  }

  /**
   * Connect to a MessagePort and process any queued RPC requests.
   *
   * @param {MessagePort} port
   */
  connect(port) {
    this._port = port;
    this._listeners.add(port, 'message', event => this._handle(event));
    port.start();
    sendCall(port, 'connect');
    for (let [method, args] of this._pendingCalls) {
      this.call(method, ...args);
    }
    this._pendingCalls = [];
  }

  /**
   * Disconnect the RPC channel and close the MessagePort.
   */
  destroy() {
    if (this._port) {
      sendCall(this._port, 'close');
      this._port.close();
    }
    this._destroyed = true;
    this._listeners.removeAll();
  }

  /**
   * Send an RPC request via the connected port.
   *
   * If this client is not yet connected to a port, the call will be queued and
   * sent when {@link connect} is called.
   *
   * If the final argument in `args` is a function, it is treated as a callback
   * which is invoked with the response in the form of (error, result) arguments.
   *
   * @param {CallMethod} method
   * @param {unknown[]} args
   */
  call(method, ...args) {
    if (!this._port) {
      this._pendingCalls.push([method, args]);
    }
    if (!this._port || this._destroyed) {
      return;
    }
    const seq = this._sequence++;
    const finalArg = args[args.length - 1];
    if (isCallback(finalArg)) {
      this._callbacks.set(seq, finalArg);
      args = args.slice(0, -1);
    }
    sendCall(this._port, method, args, seq);
  }

  /**
   * Validate message
   *
   * @param {MessageEvent} event
   * @return {null|Message}
   */
  _parseMessage({
    data
  }) {
    if (!data || typeof data !== 'object') {
      return null;
    }
    if (data.protocol !== PROTOCOL) {
      return null;
    }
    if (data.version !== VERSION) {
      return null;
    }
    if (!Array.isArray(data.arguments)) {
      return null;
    }
    return data;
  }

  /**
   * @param {MessageEvent} event
   */
  _handle(event) {
    const msg = this._parseMessage(event);
    const port = this._port;
    if (!msg || !port) {
      return;
    }
    if ('method' in msg) {
      // Only allow close event to fire once.
      if (msg.method === 'close') {
        if (this._receivedCloseEvent) {
          return;
        } else {
          this._receivedCloseEvent = true;
        }
      }
      const handler = this._methods.get(msg.method);
      if (!handler) {
        return;
      }

      /** @param {unknown[]} args */
      const callback = (...args) => {
        /** @type {ResponseMessage} */
        const message = {
          arguments: args,
          protocol: PROTOCOL,
          response: msg.sequence,
          version: VERSION
        };
        port.postMessage(message);
      };
      handler(...msg.arguments, callback);
    } else if ('response' in msg) {
      const cb = this._callbacks.get(msg.response);
      this._callbacks.delete(msg.response);
      if (cb) {
        cb(...msg.arguments);
      }
    }
  }
}

/**
 * Return true if an annotation matches the currently loaded segment of a document.
 *
 * For web pages and PDFs, this is always true. In EPUBs, this is used to send
 * only the annotations for the current chapter to the guest frame.
 */
function annotationMatchesSegment(ann, segment) {
  var _ann$target$0$selecto;
  const selector = (_ann$target$0$selecto = ann.target[0].selector) === null || _ann$target$0$selecto === void 0 ? void 0 : _ann$target$0$selecto.find(s => s.type === 'EPUBContentSelector');
  if (!selector) {
    return true;
  }
  return Boolean(segment.url && selector.url === segment.url || segment.cfi && selector.cfi && stripCFIAssertions(selector.cfi) === stripCFIAssertions(segment.cfi));
}

/**
 * Watch a data source for changes to a subset of its data.
 *
 * `watch` subscribes to change notifications from a data source, computes
 * values using the data in it, and runs a callback with the current and
 * previous computed values each time the computed result changes.
 *
 * @example
 *   const unsubscribe = watch(
 *     store.subscribe,
 *
 *     // Extract some data of interest from the store.
 *     () => store.getValue(),
 *
 *     // Callback that is invoked each time the extracted data changes.
 *     (currentValue, prevValue) => { ... }
 *   );
 *   unsubcribe(); // Remove the subscription
 *
 * To watch multiple values, make {@link getValue} return an array and set
 * {@link compare} to a function that compares each element of the array:
 *
 * @example
 *   watch(
 *     store.subscribe,
 *     () => [store.getValueA(), store.getValueB()],
 *
 *     ([currentValueA, currentValueB], [prevValueA, prevValueB]) => { ... },
 *
 *     // Compare each element of the result
 *     shallowEqual,
 *   );
 *
 * @template T
 * @param {(callback: () => void) => VoidFunction} subscribe - Function to
 *   subscribe to changes from the data source.
 * @param {() => T} getValue - Callback that extracts information of interest
 *   from the data source.
 * @param {(current: T, previous: T) => void} callback -
 *   A callback that receives the data extracted by `getValue`. It is called
 *   each time the result of `getValue` changes.
 * @param {((current: T, previous: T) => boolean)} [compare] -
 *   Comparison function that tests whether the results of two `getValue` calls
 *   are equal. If omitted, a strict equality check is used
 * @return {VoidFunction} - Return value of `subscribe`
 */
function watch(subscribe, getValue, callback, compare) {
  let prevValue = getValue();
  const unsubscribe = subscribe(() => {
    const currentValue = getValue();
    if (compare ? compare(currentValue, prevValue) : currentValue === prevValue) {
      return;
    }

    // Save and then update `prevValues` before invoking `callback` in case
    // `callback` triggers another update.
    const savedPrevValue = prevValue;
    prevValue = currentValue;
    callback(currentValue, savedPrevValue);
  });
  return unsubscribe;
}

/**
 * Return a minimal representation of an annotation that can be sent from the
 * sidebar app to a guest frame.
 *
 * Because this representation will be exposed to untrusted third-party
 * JavaScript, it includes only the information needed to uniquely identify it
 * within the current session and anchor it in the document.
 */
function formatAnnot({
  $cluster,
  $tag,
  target,
  uri
}) {
  return {
    $cluster,
    $tag,
    target,
    uri
  };
}

/**
 * Return the frame which best matches an annotation.
 */
function frameForAnnotation(frames, ann) {
  var _frames$;
  // Choose frame with an exact URL match if possible. In the unlikely situation
  // where multiple frames have the same URL, we'll use whichever connected first.
  const uriMatch = frames.find(f => f.uri === ann.uri);
  if (uriMatch) {
    return uriMatch;
  }

  // If there is no exact URL match, choose the main/host frame for consistent results.
  const mainFrame = frames.find(f => f.id === null);
  if (mainFrame) {
    return mainFrame;
  }

  // If there is no main frame (eg. in VitalSource), fall back to whichever
  // frame connected first.
  return (_frames$ = frames[0]) !== null && _frames$ !== void 0 ? _frames$ : null;
}

/**
 * Service that handles communication between the sidebar and guest and host
 * frames.
 *
 * The service's main responsibility is to synchronize annotations between the
 * sidebar and guests. New annotations created in guest frames are added to the
 * store in the sidebar and persisted to the backend.  Annotations fetched from
 * the API and added to the sidebar's store are sent to the appropriate guest
 * to display highlights in the document.
 *
 * Only a minimal subset of annotation data is sent from the sidebar to guests.
 * This is a security/privacy feature to prevent guest frames (which often
 * contain third-party JavaScript) from observing the contents or authors of
 * annotations.
 *
 * In addition to annotation data, this service also handles:
 *
 *  - Synchronizing the selection and hover states of annotations between the
 *    sidebar and guest frames
 *  - Triggering scrolling or navigation of guest frames when an annotation is
 *    clicked in the sidebar
 *  - Sending feature flags to host and guest frames
 *  - Various other interactions with guest and host frames
 *
 * @inject
 */
class FrameSyncService {
  /**
   * Map of guest frame ID to channel for communicating with guest.
   *
   * The ID will be `null` for the "main" guest, which is usually the one in
   * the host frame.
   */

  /** Whether highlights are visible in guest frames. */

  /**
   * Channel for sidebar-host communication.
   */

  /**
   * Tags of annotations that are currently loaded into guest frames.
   */

  /**
   * Tag of an annotation that should be scrolled to after anchoring completes.
   *
   * This is set when {@link scrollToAnnotation} is called and the document
   * needs to be navigated to a different URL. This can happen in EPUBs.
   */

  /**
   * Tag of an annotation that should be hovered after anchoring completes.
   *
   * See notes for {@link _pendingScrollToTag}.
   */

  /**
   * Map of annotation tag to anchoring status. This holds status updates
   * which have been received from guest frames but not yet committed to the store.
   *
   * Commits are batched to reduce the reduce the overhead from re-rendering
   * etc. triggered by `SidebarStore.updateAnchorStatus` calls.
   */

  /**
   * Schedule a commit of the anchoring status updates in
   * {@link _pendingAnchorStatusUpdates} to the store.
   */

  // Test seam

  constructor($window, annotationsService, store) {
    _defineProperty(this, "_annotationsService", void 0);
    _defineProperty(this, "_guestRPC", void 0);
    _defineProperty(this, "_highlightsVisible", void 0);
    _defineProperty(this, "_hostRPC", void 0);
    _defineProperty(this, "_inFrame", void 0);
    _defineProperty(this, "_listeners", void 0);
    _defineProperty(this, "_portFinder", void 0);
    _defineProperty(this, "_store", void 0);
    _defineProperty(this, "_pendingScrollToTag", void 0);
    _defineProperty(this, "_pendingHoverTag", void 0);
    _defineProperty(this, "_pendingAnchorStatusUpdates", void 0);
    _defineProperty(this, "_scheduleAnchorStatusUpdate", void 0);
    _defineProperty(this, "_window", void 0);
    this._window = $window;
    this._annotationsService = annotationsService;
    this._store = store;
    this._portFinder = new PortFinder({
      hostFrame: this._window.parent,
      source: 'sidebar'
    });
    this._listeners = new ListenerCollection$1();
    this._hostRPC = new PortRPC();
    this._guestRPC = new Map();
    this._inFrame = new Set();
    this._highlightsVisible = false;
    this._pendingScrollToTag = null;
    this._pendingHoverTag = null;
    this._pendingAnchorStatusUpdates = new Map();
    this._scheduleAnchorStatusUpdate = lodash_debounce(() => {
      const records = Object.fromEntries(this._pendingAnchorStatusUpdates.entries());
      this._store.updateAnchorStatus(records);
      this._pendingAnchorStatusUpdates.clear();
    }, 10);
    this._setupSyncToGuests();
    this._setupHostEvents();
    this._setupFeatureFlagSync();
  }

  /**
   * Watch for changes to the set of annotations loaded in the sidebar and
   * notify connected guests about new/updated/deleted annotations.
   */
  _setupSyncToGuests() {
    let prevPublicAnns = 0;

    /**
     * Handle annotations or frames being added or removed in the store.
     */
    const onStoreAnnotationsChanged = (annotations, frames, prevAnnotations) => {
      let publicAnns = 0;
      const inSidebar = new Set();
      const added = [];

      // Determine which annotations have been added or deleted in the sidebar.
      annotations.forEach(annot => {
        if (isReply(annot)) {
          // The frame does not need to know about replies
          return;
        }
        if (isPublic(annot)) {
          ++publicAnns;
        }
        inSidebar.add(annot.$tag);
        if (!this._inFrame.has(annot.$tag)) {
          added.push(annot);
        }
      });
      const deleted = prevAnnotations.filter(annot => !inSidebar.has(annot.$tag));

      // Send added annotations to matching frame.
      if (added.length > 0) {
        const addedByFrame = new Map();

        // List of annotations to immediately mark as anchored, as opposed to
        // waiting for the guest to report the status. This is used for
        // annotations associated with content that is different from what is
        // currently loaded in the guest frame (eg. different EPUB chapter).
        //
        // For these annotations, we optimistically assume they will anchor
        // when the appropriate content is loaded.
        const anchorImmediately = [];
        for (const annotation of added) {
          var _addedByFrame$get;
          const frame = frameForAnnotation(frames, annotation);
          if (!frame || frame.segment && !annotationMatchesSegment(annotation, frame.segment)) {
            anchorImmediately.push(annotation.$tag);
            continue;
          }
          const anns = (_addedByFrame$get = addedByFrame.get(frame.id)) !== null && _addedByFrame$get !== void 0 ? _addedByFrame$get : [];
          anns.push(annotation);
          addedByFrame.set(frame.id, anns);
        }
        if (anchorImmediately.length > 0) {
          this._updateAnchorStatus(anchorImmediately, 'anchored');
        }
        for (const [frameId, anns] of addedByFrame) {
          const rpc = this._guestRPC.get(frameId);
          if (rpc) {
            rpc.call('loadAnnotations', anns.map(formatAnnot));
          }
        }
        added.forEach(annot => {
          this._inFrame.add(annot.$tag);
        });
      }

      // Remove deleted annotations from frames.
      deleted.forEach(annot => {
        // Delete from all frames. If a guest is not displaying a particular
        // annotation, it will just ignore the request.
        this._guestRPC.forEach(rpc => rpc.call('deleteAnnotation', annot.$tag));
        this._inFrame.delete(annot.$tag);
      });

      // Update elements in host page which display annotation counts.
      if (frames.length > 0) {
        if (frames.every(frame => frame.isAnnotationFetchComplete)) {
          if (publicAnns === 0 || publicAnns !== prevPublicAnns) {
            this._hostRPC.call('publicAnnotationCountChanged', publicAnns);
            prevPublicAnns = publicAnns;
          }
        }
      }
    };
    watch(this._store.subscribe, () => [this._store.allAnnotations(), this._store.frames()], ([annotations, frames], [prevAnnotations]) => onStoreAnnotationsChanged(annotations, frames, prevAnnotations), shallowequal);
    watch(this._store.subscribe, () => this._store.getContentInfo(), contentInfo => {
      // We send the content info to all guests, even though it is only needed
      // by the main one. See notes in `_connectGuest`.
      this._guestRPC.forEach(guest => {
        guest.call('showContentInfo', contentInfo);
      });
    });
  }

  /**
   * Schedule an update of the anchoring status of annotation(s) in the store.
   */
  _updateAnchorStatus(tag, state) {
    const tags = Array.isArray(tag) ? tag : [tag];
    for (const tag of tags) {
      this._pendingAnchorStatusUpdates.set(tag, state);
    }
    this._scheduleAnchorStatusUpdate();
  }

  /**
   * Set up a connection to a new guest frame.
   *
   * @param port - Port for communicating with the guest
   * @param sourceId - Identifier for the guest frame
   */
  _connectGuest(port, sourceId) {
    const guestRPC = new PortRPC();
    this._guestRPC.set(sourceId, guestRPC);

    // Update document metadata for this guest. The guest will call this method
    // immediately after it connects to the sidebar. It may call it again
    // later if the document in the guest frame is navigated.
    guestRPC.on('documentInfoChanged', info => {
      this._store.connectFrame({
        id: sourceId,
        metadata: info.metadata,
        uri: info.uri,
        segment: info.segmentInfo,
        persistent: info.persistent
      });
    });

    // TODO - Close connection if we don't receive a "connect" message within
    // a certain time frame.

    guestRPC.on('close', () => {
      const frame = this._store.frames().find(f => f.id === sourceId);
      if (frame && !frame.persistent) {
        this._store.destroyFrame(frame);
      }

      // Mark annotations as no longer being loaded in the guest, even if
      // the frame was marked as `persistent`. In that case if a new guest
      // connects with the same ID as the one that just went away, we'll send
      // the already-loaded annotations to the new guest.
      this._inFrame.clear();
      guestRPC.destroy();
      this._guestRPC.delete(sourceId);
    });

    // A new annotation, note or highlight was created in the frame
    guestRPC.on('createAnnotation', annot => {
      // If user is not logged in, we can't really create a meaningful highlight
      // or annotation. Instead, we need to open the sidebar, show an error,
      // and delete the (unsaved) annotation so it gets un-selected in the
      // target document
      if (!this._store.isLoggedIn()) {
        this._hostRPC.call('openSidebar');
        this._store.openSidebarPanel('loginPrompt');
        this._guestRPC.forEach(rpc => rpc.call('deleteAnnotation', annot.$tag));
        return;
      }
      this._inFrame.add(annot.$tag);

      // Open the sidebar so that the user can immediately edit the draft
      // annotation.
      if (!annot.$highlight) {
        this._hostRPC.call('openSidebar');
      }

      // Ensure that the highlight for the newly-created annotation is visible.
      // Currently we only support a single, shared visibility state for all highlights
      // in all frames, so this will make all existing highlights visible too.
      this._hostRPC.call('showHighlights');

      // Create the new annotation in the sidebar.
      this._annotationsService.create(annot);
    });

    // Anchoring an annotation in the frame completed
    guestRPC.on('syncAnchoringStatus', ({
      $tag,
      $orphan
    }) => {
      this._inFrame.add($tag);
      this._updateAnchorStatus($tag, $orphan ? 'orphan' : 'anchored');
      if ($tag === this._pendingHoverTag) {
        this._pendingHoverTag = null;
        guestRPC.call('hoverAnnotations', [$tag]);
      }
      if (this._pendingScrollToTag) {
        if ($tag === this._pendingScrollToTag) {
          this._pendingScrollToTag = null;
          guestRPC.call('scrollToAnnotation', $tag);
        }
      }
    });
    guestRPC.on('showAnnotations', (tags, focusFirstInSelection = false) => {
      // Since annotations are selected by ID rather than tag, this logic
      // currently only supports saved annotations.
      const ids = this._store.findIDsForTags(tags);
      this._store.selectAnnotations(ids);
      this._store.selectTab('annotation');

      // Attempt to transfer keyboard focus to the first selected annotation.
      //
      // To do this we need to focus both the annotation card and the frame
      // itself. It doesn't matter in which order.
      if (ids.length > 0 && focusFirstInSelection) {
        // Request the annotation card to be focused. This is handled asynchronously.
        this._store.setAnnotationFocusRequest(ids[0]);

        // Focus the sidebar frame. This may fail in WebKit-based browsers
        // if the user has no interacted with the frame since it loaded.
        window.focus();
      }
    });
    guestRPC.on('hoverAnnotations', tags => {
      this._store.hoverAnnotations(tags || []);
    });
    guestRPC.on('toggleAnnotationSelection', tags => {
      this._store.toggleSelectedAnnotations(this._store.findIDsForTags(tags));
    });
    guestRPC.on('openSidebar', () => {
      this._hostRPC.call('openSidebar');
    });
    guestRPC.on('closeSidebar', () => {
      this._hostRPC.call('closeSidebar');
    });
    guestRPC.connect(port);

    // Synchronize highlight visibility in this guest with the sidebar's controls.
    guestRPC.call('setHighlightsVisible', this._highlightsVisible);
    guestRPC.call('featureFlagsUpdated', this._store.profile().features);

    // If we have content banner data, send it to the guest. If there are
    // multiple guests the banner is likely only appropriate for the main one.
    // Current contexts that use the banner only have one guest, so we can get
    // the data to the guest faster by sending it immediately, rather than
    // waiting for the `documentInfoChanged` event to tell us which is the main
    // guest.
    const contentInfo = this._store.getContentInfo();
    if (contentInfo) {
      guestRPC.call('showContentInfo', contentInfo);
    }
  }

  /**
   * Listen for messages coming from the host frame.
   */
  _setupHostEvents() {
    this._hostRPC.on('sidebarOpened', () => {
      this._store.setSidebarOpened(true);
    });

    // When user toggles the highlight visibility control in the sidebar container,
    // update the visibility in all the guest frames.
    this._hostRPC.on('setHighlightsVisible', visible => {
      this._highlightsVisible = visible;
      this._guestRPC.forEach(rpc => rpc.call('setHighlightsVisible', visible));
    });
  }

  /**
   * Set up synchronization of feature flags to host and guest frames.
   */
  _setupFeatureFlagSync() {
    const getFlags = () => this._store.profile().features;
    const sendFlags = flags => {
      this._hostRPC.call('featureFlagsUpdated', flags);
      for (const guest of this._guestRPC.values()) {
        guest.call('featureFlagsUpdated', flags);
      }
    };

    // Send current flags to host when it connects, and any already-connected
    // guests.
    sendFlags(getFlags());

    // Watch for future flag changes.
    watch(this._store.subscribe, getFlags, sendFlags);
  }

  /**
   * Connect to the host frame and guest frame(s) in the current browser tab.
   */
  async connect() {
    // Create channel for sidebar-host communication.
    const hostPort = await this._portFinder.discover('host');
    this._hostRPC.connect(hostPort);

    // Listen for guests connecting to the sidebar.
    this._listeners.add(hostPort, 'message', event => {
      const {
        data,
        ports
      } = event;
      const message = data;
      if (!isMessage(message)) {
        return;
      }
      if (isMessageEqual(message, {
        frame1: 'guest',
        frame2: 'sidebar',
        type: 'offer'
      })) {
        var _message$sourceId;
        this._connectGuest(ports[0], (_message$sourceId = message.sourceId) !== null && _message$sourceId !== void 0 ? _message$sourceId : null);
      }
    });
  }

  /**
   * Send an RPC message to the host frame.
   */
  notifyHost(method, ...args) {
    this._hostRPC.call(method, ...args);
  }

  /**
   * Mark annotation as hovered.
   *
   * This is used to indicate the highlights in the document that correspond
   * to a hovered annotation in the sidebar.
   *
   * This function only accepts a single annotation because the user can only
   * hover one annotation card in the sidebar at a time. Hover updates in the
   * other direction (guest to sidebar) support multiple annotations since a
   * user can hover multiple highlights in the document at once.
   */
  hoverAnnotation(ann) {
    this._pendingHoverTag = null;
    const tags = ann ? [ann.$tag] : [];
    this._store.hoverAnnotations(tags);
    if (!ann) {
      this._guestRPC.forEach(rpc => rpc.call('hoverAnnotations', []));
      return;
    }

    // If annotation is not currently anchored in a guest, schedule hover for
    // when annotation is anchored. This can happen if an annotation is for a
    // different chapter of an EPUB than the currently loaded one. See notes in
    // `scrollToAnnotation`.
    const frame = frameForAnnotation(this._store.frames(), ann);
    if (!frame || frame.segment && !annotationMatchesSegment(ann, frame.segment)) {
      this._pendingHoverTag = ann.$tag;
      return;
    }
    this._guestRPC.forEach(rpc => rpc.call('hoverAnnotations', tags));
  }

  /**
   * Scroll the frame to the highlight for an annotation.
   */
  scrollToAnnotation(ann) {
    const frame = frameForAnnotation(this._store.frames(), ann);
    if (!frame) {
      return;
    }
    const guest = this._guestRPC.get(frame === null || frame === void 0 ? void 0 : frame.id);
    if (!guest) {
      return;
    }

    // If this annotation is for a different segment of a book than is loaded
    // in the guest, then ask the guest to navigate to the appropriate segment.
    //
    // In EPUBs, this will cause the guest to disconnect and a new guest will
    // connect when the new content has loaded. We will then need to wait for
    // the annotation to anchor in the new guest frame before we can actually
    // scroll to it.
    if (frame.segment && !annotationMatchesSegment(ann, frame.segment)) {
      // Schedule scroll once anchoring completes.
      this._pendingScrollToTag = ann.$tag;
      guest.call('navigateToSegment', formatAnnot(ann));
      return;
    }
    guest.call('scrollToAnnotation', ann.$tag);
  }

  // Only used to cleanup tests
  destroy() {
    this._portFinder.destroy();
    this._listeners.removeAll();
  }
}
FrameSyncService.$inject = ["$window", "annotationsService", "store"];

/** @typedef {import('redux').Store} Store */

/**
 * Return an object where each key in `updateFns` is mapped to the key itself.
 *
 * @template {Record<string,Function>} T
 * @param {T} reducers - Object containing reducer functions
 * @return {{ [index in keyof T]: string }}
 */
function actionTypes(reducers) {
  return Object.keys(reducers).reduce((types, key) => {
    types[key] = key;
    return types;
  }, /** @type {any} */{});
}

/**
 * Return a value from app state when it meets certain criteria.
 *
 * `await` returns a Promise which resolves when a selector function,
 * which reads values from a Redux store, returns non-null.
 *
 * @template T
 * @param {import('redux').Store} store
 * @param {(s: Store) => T|null} selector - Function which returns a value from the
 *   store if the criteria is met or `null` otherwise.
 * @return {Promise<T>}
 */
function awaitStateChange(store, selector) {
  const result = selector(store);
  if (result !== null) {
    return Promise.resolve(result);
  }
  return new Promise(resolve => {
    const unsubscribe = store.subscribe(() => {
      const result = selector(store);
      if (result !== null) {
        unsubscribe();
        resolve(result);
      }
    });
  });
}

/** @typedef {import('../../types/api').Group} Group */

const DEFAULT_ORG_ID = '__default__';

/**
 * FIXME: There is almost assuredly a better way to handle a fallback, default logo
 */
const DEFAULT_ORGANIZATION = {
  id: DEFAULT_ORG_ID,
  name: '__DEFAULT__',
  logo: 'data:image/svg+xml;utf8,' + encodeURIComponent(logo)
};

/**
 * For any group that does not have an associated organization, populate with
 * the default Hypothesis organization.
 *
 * Mutates group objects in place
 *
 * @param {Group[]} groups
 */
function injectOrganizations(groups) {
  groups.forEach(group => {
    if (!group.organization || typeof group.organization !== 'object') {
      group.organization = DEFAULT_ORGANIZATION;
    }
  });
}

/**
 * @param {any} value
 * @return {value is Promise<unknown>}
 */
function isPromise(value) {
  return typeof (value === null || value === void 0 ? void 0 : value.then) === 'function';
}

// `expand` parameter for various groups API calls.
const expandParam = ['organization', 'scopes'];

/**
 * Service for fetching groups from the API and adding them to the store.
 *
 * The service also provides a `focus` method for switching the active group
 * and `leave` method to remove the current user from a private group.
 *
 * @inject
 */
class GroupsService {
  /**
   * @param {import('../store').SidebarStore} store
   * @param {import('./api').APIService} api
   * @param {import('./auth').AuthService} auth
   * @param {import('./session').SessionService} session
   * @param {import('../../types/config').SidebarSettings} settings
   * @param {import('./toast-messenger').ToastMessengerService} toastMessenger
   */
  constructor(store, api, auth, session, settings, toastMessenger) {
    this._store = store;
    this._api = api;
    this._auth = auth;
    this._settings = settings;
    this._toastMessenger = toastMessenger;
    this._serviceConfig = serviceConfig(settings);
    this._reloadSetUp = false;
  }

  /**
   * Return the main document URI that is used to fetch groups associated with
   * the site that the user is on.
   */
  _mainURI() {
    var _this$_store$mainFram, _this$_store$mainFram2;
    return (_this$_store$mainFram = (_this$_store$mainFram2 = this._store.mainFrame()) === null || _this$_store$mainFram2 === void 0 ? void 0 : _this$_store$mainFram2.uri) !== null && _this$_store$mainFram !== void 0 ? _this$_store$mainFram : null;
  }

  /**
   * Filter the returned list of groups from the API.
   *
   * `filterGroups` performs client-side filtering to hide the "Public" group
   * for logged-out users under certain conditions.
   *
   * @param {Group[]} groups
   * @param {boolean} isLoggedIn
   * @param {string|null} directLinkedAnnotationGroupId
   * @param {string|null} directLinkedGroupId
   * @return {Promise<Group[]>}
   */
  async _filterGroups(groups, isLoggedIn, directLinkedAnnotationGroupId, directLinkedGroupId) {
    // Filter the directLinkedGroup out if it is out of scope and scope is enforced.
    if (directLinkedGroupId) {
      const directLinkedGroup = groups.find(g => g.id === directLinkedGroupId);
      if (directLinkedGroup && !directLinkedGroup.isScopedToUri && directLinkedGroup.scopes && directLinkedGroup.scopes.enforced) {
        groups = groups.filter(g => g.id !== directLinkedGroupId);
        this._store.setDirectLinkedGroupFetchFailed();
        directLinkedGroupId = null;
      }
    }

    // Logged-in users always see the "Public" group.
    if (isLoggedIn) {
      return groups;
    }

    // If the main document URL has no groups associated with it, always show
    // the "Public" group.
    const pageHasAssociatedGroups = groups.some(g => g.id !== '__world__' && g.isScopedToUri);
    if (!pageHasAssociatedGroups) {
      return groups;
    }

    // If directLinkedGroup or directLinkedAnnotationGroupId is the "Public" group,
    // always return groups.
    if (directLinkedGroupId === '__world__' || directLinkedAnnotationGroupId === '__world__') {
      return groups;
    }

    // Return non-world groups.
    return groups.filter(g => g.id !== '__world__');
  }

  /**
   * Set up automatic re-fetching of groups in response to various events
   * in the sidebar.
   */
  _setupAutoReload() {
    if (this._reloadSetUp) {
      return;
    }
    this._reloadSetUp = true;

    // Reload groups when main document URI changes.
    watch(this._store.subscribe, () => this._mainURI(), () => this.load());

    // Reload groups when user ID changes. This is a bit inefficient since it
    // means we are not fetching the groups and profile concurrently after
    // logging in or logging out.
    watch(this._store.subscribe, () => /** @type {const} */[this._store.hasFetchedProfile(), this._store.profile().userid], (_, [prevFetchedProfile]) => {
      if (!prevFetchedProfile) {
        // Ignore the first time that the profile is loaded.
        return;
      }
      this.load();
    }, shallowequal);
  }

  /**
   * Add groups to the store and set the initial focused group.
   *
   * @param {Group[]} groups
   * @param {string|null} groupToFocus
   */
  _addGroupsToStore(groups, groupToFocus) {
    // Add a default organization to groups that don't have one. The organization
    // provides the logo to display when the group is selected and is also used
    // to order groups.
    injectOrganizations(groups);
    const isFirstLoad = this._store.allGroups().length === 0;
    const prevFocusedGroup = this._store.getDefault('focusedGroup');
    this._store.loadGroups(groups);
    if (isFirstLoad) {
      if (groupToFocus && groups.some(g => g.id === groupToFocus)) {
        this.focus(groupToFocus);
      } else if (prevFocusedGroup && groups.some(g => g.id === prevFocusedGroup)) {
        this.focus(prevFocusedGroup);
      }
    }
  }

  /**
   * Fetch a specific group.
   *
   * @param {string} id
   * @return {Promise<Group>}
   */
  _fetchGroup(id) {
    return this._api.group.read({
      id,
      expand: expandParam
    });
  }

  /**
   * Fetch the groups associated with the current user and document, as well
   * as any groups that have been direct-linked to.
   *
   * @return {Promise<Group[]>}
   */
  async _loadGroupsForUserAndDocument() {
    var _this$_serviceConfig;
    const getDocumentUriForGroupSearch = () => awaitStateChange(this._store, () => this._mainURI());

    // Step 1: Get the URI of the active document, so we can fetch groups
    // associated with that document.
    let documentUri = null;
    if (this._store.route() === 'sidebar') {
      documentUri = await getDocumentUriForGroupSearch();
    }
    this._setupAutoReload();

    // Step 2: Concurrently fetch the groups the user is a member of,
    // the groups associated with the current document and the annotation
    // and/or group that was direct-linked (if any).

    // If there is a direct-linked annotation, fetch the annotation in case
    // the associated group has not already been fetched and we need to make
    // an additional request for it.
    const directLinkedAnnId = this._store.directLinkedAnnotationId();
    let directLinkedAnnApi = null;
    if (directLinkedAnnId) {
      directLinkedAnnApi = this._api.annotation.get({
        id: directLinkedAnnId
      }).catch(() => {
        // If the annotation does not exist or the user doesn't have permission.
        return null;
      });
    }

    // If there is a direct-linked group, add an API request to get that
    // particular group since it may not be in the set of groups that are
    // fetched by other requests.
    const directLinkedGroupId = this._store.directLinkedGroupId();
    let directLinkedGroupApi = null;
    if (directLinkedGroupId) {
      directLinkedGroupApi = this._fetchGroup(directLinkedGroupId).then(group => {
        this._store.clearDirectLinkedGroupFetchFailed();
        return group;
      }).catch(() => {
        // If the group does not exist or the user doesn't have permission.
        this._store.setDirectLinkedGroupFetchFailed();
        return null;
      });
    }

    /** @type {{ authority?: string, expand: string[], document_uri?: string }} */
    const listParams = {
      expand: expandParam
    };
    const authority = (_this$_serviceConfig = this._serviceConfig) === null || _this$_serviceConfig === void 0 ? void 0 : _this$_serviceConfig.authority;
    if (authority) {
      listParams.authority = authority;
    }
    if (documentUri) {
      listParams.document_uri = documentUri;
    }
    const [myGroups, featuredGroups, token, directLinkedAnn, directLinkedGroup] = await Promise.all([this._api.profile.groups.read({
      expand: expandParam
    }), this._api.groups.list(listParams), this._auth.getAccessToken(), directLinkedAnnApi, directLinkedGroupApi]);

    // Step 3. Add the direct-linked group to the list of featured groups,
    // and if there was a direct-linked annotation, fetch its group if we
    // don't already have it.

    // If there is a direct-linked group, add it to the featured groups list.
    if (directLinkedGroup && !featuredGroups.some(g => g.id === directLinkedGroup.id)) {
      featuredGroups.push(directLinkedGroup);
    }

    // If there's a direct-linked annotation it may require an extra API call
    // to fetch its group.
    let directLinkedAnnotationGroupId = null;
    if (directLinkedAnn) {
      // Set the directLinkedAnnotationGroupId to be used later in
      // the filterGroups method.
      directLinkedAnnotationGroupId = directLinkedAnn.group;

      // If the direct-linked annotation's group has not already been fetched,
      // fetch it.
      const directLinkedAnnGroup = myGroups.concat(featuredGroups).find(g => g.id === directLinkedAnn.group);
      if (!directLinkedAnnGroup) {
        try {
          const directLinkedAnnGroup = await this._fetchGroup(directLinkedAnn.group);
          featuredGroups.push(directLinkedAnnGroup);
        } catch (e) {
          this._toastMessenger.error('Unable to fetch group for linked annotation');
        }
      }
    }

    // Step 4. Combine all the groups into a single list and set additional
    // metadata on them that will be used elsewhere in the app.
    const isLoggedIn = token !== null;
    const groups = await this._filterGroups(combineGroups(myGroups, featuredGroups, documentUri, this._settings), isLoggedIn, directLinkedAnnotationGroupId, directLinkedGroupId);
    const groupToFocus = directLinkedAnnotationGroupId || directLinkedGroupId || null;
    this._addGroupsToStore(groups, groupToFocus);
    return groups;
  }

  /**
   * Load the specific groups configured by the annotation service.
   *
   * @param {string[]} groupIds - `id` or `groupid`s of groups to fetch
   */
  async _loadServiceSpecifiedGroups(groupIds) {
    // Fetch the groups that the user is a member of in one request and then
    // fetch any other groups not returned in that request directly.
    //
    // This reduces the number of requests to the backend on the assumption
    // that most or all of the group IDs that the service configures the client
    // to show are groups that the user is a member of.
    const userGroups = await this._api.profile.groups.read({
      expand: expandParam
    });
    let error;
    /** @param {string} id */
    const tryFetchGroup = async id => {
      try {
        return await this._fetchGroup(id);
      } catch (e) {
        error = e;
        return null;
      }
    };

    /** @param {string} id */
    const getGroup = id => userGroups.find(g => g.id === id || g.groupid === id) || tryFetchGroup(id);
    const groupResults = await Promise.all(groupIds.map(getGroup));
    const groups = /** @type {Group[]} */
    groupResults.filter(g => g !== null);

    // Optional direct linked group id. This is used in the Notebook context.
    const focusedGroupId = this._store.directLinkedGroupId();
    this._addGroupsToStore(groups, focusedGroupId);
    if (error) {
      // @ts-ignore - TS can't track the type of `error` here.
      this._toastMessenger.error(`Unable to fetch groups: ${error.message}`, {
        autoDismiss: false
      });
    }
    return groups;
  }

  /**
   * Fetch groups from the API, load them into the store and set the focused
   * group.
   *
   * There are two main scenarios:
   *
   * 1. The groups loaded depend on the current user, current document URI and
   *    active direct links. This is the default.
   *
   *    On startup, `load()` must be called to trigger the initial groups fetch.
   *    Subsequently groups are automatically reloaded if the logged-in user or
   *    main document URI changes.
   *
   * 2. The annotation service specifies exactly which groups to load via the
   *    configuration it passes to the client.
   *
   * @return {Promise<Group[]>}
   */
  async load() {
    var _this$_serviceConfig2;
    // The `groups` property may be a list of group IDs or a promise for one,
    // if we're in the LMS app and the group list is being fetched asynchronously.
    const groupIdsOrPromise = (_this$_serviceConfig2 = this._serviceConfig) === null || _this$_serviceConfig2 === void 0 ? void 0 : _this$_serviceConfig2.groups;
    if (Array.isArray(groupIdsOrPromise) || isPromise(groupIdsOrPromise)) {
      /** @type {string[]} */
      let groupIds = [];
      try {
        groupIds = await groupIdsOrPromise;
      } catch (e) {
        this._toastMessenger.error(`Unable to fetch group configuration: ${e.message}`);
      }
      return this._loadServiceSpecifiedGroups(groupIds);
    } else {
      return this._loadGroupsForUserAndDocument();
    }
  }

  /**
   * Update the focused group. Update the store, then check to see if
   * there are any new (unsaved) annotations—if so, update those annotations
   * such that they are associated with the newly-focused group.
   *
   * @param {string} groupId
   */
  focus(groupId) {
    const prevGroupId = this._store.focusedGroupId();
    this._store.focusGroup(groupId);
    const newGroupId = this._store.focusedGroupId();
    const groupHasChanged = prevGroupId !== newGroupId && prevGroupId !== null;
    if (groupHasChanged && newGroupId) {
      // Move any top-level new annotations to the newly-focused group.
      // Leave replies where they are.
      const updatedAnnotations = this._store.newAnnotations().filter(ann => !isReply(ann)).map(ann => ({
        ...ann,
        group: newGroupId
      }));
      if (updatedAnnotations.length) {
        this._store.addAnnotations(updatedAnnotations);
      }

      // Persist this group as the last focused group default
      this._store.setDefault('focusedGroup', newGroupId);
    }
  }

  /**
   * Request to remove the current user from a group.
   *
   * @param {string} id - The group ID
   * @return {Promise<void>}
   */
  leave(id) {
    // The groups list will be updated in response to a session state
    // change notification from the server. We could improve the UX here
    // by optimistically updating the session state
    return this._api.group.member.delete({
      pubid: id,
      userid: 'me'
    });
  }
}
GroupsService.$inject = ["store", "api", "auth", "session", "settings", "toastMessenger"];

/**
 * @typedef {import('../../types/api').Annotation} Annotation
 * @typedef {import('../search-client').SortBy} SortBy
 * @typedef {import('../search-client').SortOrder} SortOrder
 */

/**
 * @typedef LoadAnnotationOptions
 * @prop {string} groupId
 * @prop {string[]} [uris]
 * @prop {number} [maxResults] - If number of annotations in search results
 *   exceeds this value, do not load annotations (see: `SearchClient`)
 * @prop {SortBy} [sortBy] - Together with `sortOrder`, this controls in what
 *   order annotations are loaded. To minimize visible content changing as
 *   annotations load, `sortBy` and `sortOrder` should be chosen to correlate
 *   with the expected presentation order of annotations/threads in the current
 *   view.
 * @prop {SortOrder} [sortOrder]
 * @prop {(error: Error) => void} [onError] - Optional error handler for
 *   SearchClient. Default error handling logs errors to console.
 * @prop {'uri'|'group'} [streamFilterBy] - Set the websocket stream
 *   to filter by either URIs or groupIds.
 */

/**
 * A service for fetching annotations via the Hypothesis API and loading them
 * into the store.
 *
 * In addition to fetching annotations it also handles configuring the
 * WebSocket connection so that appropriate real-time updates are received
 * for the set of annotations being displayed.
 *
 * @inject
 */
class LoadAnnotationsService {
  /**
   * @param {import('./api').APIService} api
   * @param {import('../store').SidebarStore} store
   * @param {import('./streamer').StreamerService} streamer
   * @param {import('./stream-filter').StreamFilter} streamFilter
   */
  constructor(api, store, streamer, streamFilter) {
    this._api = api;
    this._store = store;
    this._streamer = streamer;
    this._streamFilter = streamFilter;

    /** @type {SearchClient|null} */
    this._searchClient = null;
  }

  /**
   * Load annotations from Hypothesis.
   *
   * The existing set of loaded annotations is cleared before the new set
   * is fetched. If an existing annotation fetch is in progress it is canceled.
   *
   * @param {LoadAnnotationOptions} options
   */
  load({
    groupId,
    uris,
    onError,
    maxResults,
    sortBy,
    sortOrder,
    streamFilterBy = 'uri'
  }) {
    this._store.removeAnnotations(this._store.savedAnnotations());

    // Cancel previously running search client.
    //
    // This will emit the "end" event for the existing client and trigger cleanup
    // associated with that client (eg. resetting the count of in-flight
    // annotation fetches).
    if (this._searchClient) {
      this._searchClient.cancel();
    }

    // Set the filter for the websocket stream
    switch (streamFilterBy) {
      case 'group':
        this._streamFilter.resetFilter().addClause('/group', 'equals', groupId, true);
        this._streamer.setConfig('filter', {
          filter: this._streamFilter.getFilter()
        });
        break;
      case 'uri':
      default:
        if (uris && uris.length > 0) {
          this._streamFilter.resetFilter().addClause('/uri', 'one_of', uris);
          this._streamer.setConfig('filter', {
            filter: this._streamFilter.getFilter()
          });
        }
        break;
    }
    const searchOptions = {
      incremental: true,
      separateReplies: false,
      maxResults,
      // Annotations are fetched in order of creation by default. This is expected
      // to roughly correspond to the order in which threads end up being sorted
      // because:
      //
      // 1. The default thread sort order in the sidebar is by document location
      // 2. When users annotate a document, they will tend to annotate content in
      //    document order. Annotations near the top of the document will
      //    tend to have earlier creation dates.
      //
      // If the backend would allow us to sort on document location, we could do even better.

      sortBy,
      sortOrder
    };
    this._searchClient = new SearchClient(this._api.search, searchOptions);
    this._searchClient.on('resultCount', /** @param {number} count */
    count => {
      this._store.setAnnotationResultCount(count);
    });
    this._searchClient.on('results', /** @param {Annotation[]} results */results => {
      if (results.length) {
        this._store.addAnnotations(results);
      }
    });
    this._searchClient.on('error', /** @param {Error} error */error => {
      if (typeof onError === 'function') {
        onError(error);
      } else {
        console.error(error);
      }
    });
    this._searchClient.on('end', () => {
      // Remove client as it's no longer active.
      this._searchClient = null;
      if (uris && uris.length > 0) {
        this._store.frames().forEach(frame => {
          if (uris.indexOf(frame.uri) >= 0) {
            this._store.updateFrameAnnotationFetchStatus(frame.uri, true);
          }
        });
      }
      this._store.annotationFetchFinished();
    });
    this._store.annotationFetchStarted();
    this._searchClient.get({
      group: groupId,
      uri: uris
    });
  }

  /**
   * Fetch all annotations in the same thread as `id` and add them to the store.
   *
   * @param {string} id - Annotation ID. This may be an annotation or a reply.
   * @return Promise<Annotation[]> - The annotation, followed by any replies.
   */
  async loadThread(id) {
    let annotation;
    let replySearchResult;

    // Clear out any annotations already in the store before fetching new ones
    this._store.clearAnnotations();
    try {
      this._store.annotationFetchStarted();
      // 1. Fetch the annotation indicated by `id` — the target annotation
      annotation = await this._api.annotation.get({
        id
      });

      // 2. If annotation is not the top-level annotation in its thread,
      //    fetch the top-level annotation
      if (isReply(annotation)) {
        annotation = await this._api.annotation.get({
          id: /** @type {string[]} */annotation.references[0]
        });
      }

      // 3. Fetch all of the annotations in the thread, based on the
      //    top-level annotation
      replySearchResult = await this._api.search({
        references: annotation.id
      });
    } finally {
      this._store.annotationFetchFinished();
    }
    const threadAnnotations = [annotation, ...replySearchResult.rows];
    this._store.addAnnotations(threadAnnotations);

    // If we've been successful in retrieving a thread, with a top-level annotation,
    // configure the connection to the real-time update service to send us
    // updates to any of the annotations in the thread.
    if (!isReply(annotation)) {
      const id = /** @type {string} */annotation.id;
      this._streamFilter.addClause('/references', 'one_of', id, true).addClause('/id', 'equals', id, true);
      this._streamer.setConfig('filter', {
        filter: this._streamFilter.getFilter()
      });
      this._streamer.connect();
    }
    return threadAnnotations;
  }
}
LoadAnnotationsService.$inject = ["api", "store", "streamer", "streamFilter"];

/**
 * Fallback in-memory store if `localStorage` is not read/writable.
 */
class InMemoryStorage {
  constructor() {
    this._store = new Map();
  }

  /** @param {string} key */
  getItem(key) {
    var _this$_store$get;
    return (_this$_store$get = this._store.get(key)) !== null && _this$_store$get !== void 0 ? _this$_store$get : null;
  }

  /**
   * @param {string} key
   * @param {string} value
   */
  setItem(key, value) {
    this._store.set(key, value);
  }

  /** @param {string} key */
  removeItem(key) {
    this._store.delete(key);
  }
}

/**
 * A wrapper around the `localStorage` API which provides a fallback to
 * in-memory storage in browsers that block access to `window.localStorage`.
 * in third-party iframes.
 *
 * This service also provides convenience methods set and fetch JSON-serializable
 * values.
 */
// @inject
class LocalStorageService {
  /**
   * @param {Window} $window
   */
  constructor($window) {
    let testKey = 'hypothesis.testKey';
    try {
      // Test whether we can read/write localStorage.
      this._storage = $window.localStorage;
      $window.localStorage.setItem(testKey, testKey);
      $window.localStorage.getItem(testKey);
      $window.localStorage.removeItem(testKey);
    } catch (e) {
      this._storage = new InMemoryStorage();
    }
  }

  /**
   * Look up a value in local storage.
   *
   * @param {string} key
   * @return {string|null}
   */
  getItem(key) {
    return this._storage.getItem(key);
  }

  /**
   * Look up and deserialize a value from storage.
   *
   * @param {string} key
   */
  getObject(key) {
    const item = this._storage.getItem(key);
    return item ? JSON.parse(item) : null;
  }

  /**
   * Set a value in local storage.
   *
   * @param {string} key
   * @param {string} value
   */
  setItem(key, value) {
    this._storage.setItem(key, value);
  }

  /**
   * Serialize `value` to JSON and persist it.
   *
   * @param {string} key
   * @param {any} value
   */
  setObject(key, value) {
    const repr = JSON.stringify(value);
    this._storage.setItem(key, repr);
  }

  /**
   * Remove an item from storage.
   *
   * @param {string} key
   */
  removeItem(key) {
    this._storage.removeItem(key);
  }
}
LocalStorageService.$inject = ["$window"];

/**
 * @typedef {import('../store/modules/defaults').Key} Key
 */

/** @type {Record<Key, string>} */
const DEFAULT_KEYS = {
  annotationPrivacy: 'hypothesis.privacy',
  focusedGroup: 'hypothesis.groups.focus'
};

/**
 * A service for reading and persisting convenient client-side defaults for
 * the (browser) user.
 *
 * @inject
 */
class PersistedDefaultsService {
  /**
   * @param {import('./local-storage').LocalStorageService} localStorage
   * @param {import('../store').SidebarStore} store
   */
  constructor(localStorage, store) {
    this._storage = localStorage;
    this._store = store;
  }

  /**
   * Initially populate the store with any available persisted defaults,
   * then subscribe to the store in order to persist any changes to
   * those defaults.
   */
  init() {
    /**
     * Store subscribe callback for persisting changes to defaults. It will only
     * persist defaults that it "knows about" via `DEFAULT_KEYS`.
     *
     * @param {Record<Key, any>} defaults
     * @param {Record<Key, any>} prevDefaults
     */
    const persistChangedDefaults = (defaults, prevDefaults) => {
      for (let [defaultKey, newValue] of entries(defaults)) {
        if (prevDefaults[defaultKey] !== newValue && defaultKey in DEFAULT_KEYS) {
          this._storage.setItem(DEFAULT_KEYS[defaultKey], newValue);
        }
      }
    };

    // Read persisted defaults into the store
    for (let [defaultKey, key] of entries(DEFAULT_KEYS)) {
      // `localStorage.getItem` will return `null` for a non-existent key
      const defaultValue = this._storage.getItem(key);
      this._store.setDefault(defaultKey, defaultValue);
    }

    // Listen for changes to those defaults from the store and persist them
    watch(this._store.subscribe, () => this._store.getDefaults(), persistChangedDefaults);
  }
}
PersistedDefaultsService.$inject = ["localStorage", "store"];

/**
 * @typedef {'annotation'|'notebook'|'stream'|'sidebar'} RouteName
 * @typedef {Record<string,string>} RouteParams
 */

/**
 * A service that manages the association between the route and route parameters
 * implied by the URL and the corresponding route state in the store.
 */
// @inject
class RouterService {
  /**
   * @param {Window} $window
   * @param {import('../store').SidebarStore} store
   */
  constructor($window, store) {
    this._window = $window;
    this._store = store;
    this._didRegisterPopstateListener = false;
  }

  /**
   * Return the name and parameters of the current route.
   *
   * @return {{ route: RouteName, params: RouteParams }}
   */
  currentRoute() {
    const path = this._window.location.pathname;
    const pathSegments = path.slice(1).split('/');
    const searchParams = new URLSearchParams(this._window.location.search);

    /** @type {Record<string, string>} */
    const params = {};
    for (let [key, value] of searchParams) {
      params[key] = value;
    }

    // The extension puts client resources under `/client/` to separate them
    // from extension-specific resources. Ignore this part.
    if (pathSegments[0] === 'client') {
      pathSegments.shift();
    }

    // Routes loaded from h have no file extensions (eg. `/a/:id`, `/notebook`).
    //
    // Routes loaded from custom builds or the Chrome extension may have a '.html'
    // extension.
    const mainSegment = pathSegments[0].replace(/\.html$/, '');

    /** @type {RouteName} */
    let route;
    switch (mainSegment) {
      case 'a':
        route = 'annotation';
        params.id = pathSegments[1] || '';
        break;
      case 'notebook':
        route = 'notebook';
        break;
      case 'stream':
        route = 'stream';
        break;
      default:
        route = 'sidebar';
        break;
    }
    return {
      route,
      params
    };
  }

  /**
   * Generate a URL for a given route.
   *
   * @param {RouteName} name
   * @param {RouteParams} params
   */
  routeUrl(name, params = {}) {
    let url;
    const queryParams = {
      ...params
    };
    switch (name) {
      case 'annotation':
        {
          const id = params.id;
          delete queryParams.id;
          url = `/a/${id}`;
        }
        break;
      case 'notebook':
        url = '/notebook';
        break;
      case 'stream':
        url = '/stream';
        break;
      default:
        throw new Error(`Cannot generate URL for route "${name}"`);
    }
    let hasParams = false;
    const searchParams = new URLSearchParams();
    for (let [key, value] of Object.entries(queryParams)) {
      hasParams = true;
      searchParams.set(key, value);
    }
    if (hasParams) {
      url += '?' + searchParams.toString();
    }
    return url;
  }

  /**
   * Synchronize the route name and parameters in the store with the current
   * URL.
   *
   * The first call to this method also registers a listener for future back/forwards
   * navigation in the browser.
   */
  sync() {
    const {
      route,
      params
    } = this.currentRoute();
    this._store.changeRoute(route, params);

    // Set up listener for back/forward navigation. We do this in `sync()` to
    // avoid the route being changed by a "popstate" emitted by the browser on
    // document load (which Safari and Chrome do).
    if (!this._didRegisterPopstateListener) {
      this._window.addEventListener('popstate', () => {
        // All the state we need to update the route is contained in the URL, which
        // has already been updated at this point, so just sync the store route
        // to match the URL.
        this.sync();
      });
      this._didRegisterPopstateListener = true;
    }
  }

  /**
   * Navigate to a given route.
   *
   * @param {RouteName} name
   * @param {RouteParams} params
   */
  navigate(name, params) {
    this._window.history.pushState({}, '', this.routeUrl(name, params));
    this.sync();
  }
}
RouterService.$inject = ["$window", "store"];

/**
 * Service for fetching the data needed to render URLs that point to the H
 * service.
 *
 * The H API has an `/api/links` endpoint that returns a map of link name to
 * URL template for URLs that point to the H API. This service fetches that
 * data and persists it in the store.
 *
 * To use a link within a UI component, use `store.getLink(name, params)`.
 *
 * @inject
 */
class ServiceURLService {
  /**
   * @param {import('./api-routes').APIRoutesService} apiRoutes
   * @param {import('../store').SidebarStore} store
   */
  constructor(apiRoutes, store) {
    this._apiRoutes = apiRoutes;
    this._store = store;
  }

  /**
   * Fetch URL templates for links from the API and persist them in the store.
   */
  async init() {
    try {
      const links = await this._apiRoutes.links();
      this._store.updateLinks(links);
    } catch (error) {
      console.warn(`Failed to fetch Hypothesis links: ${error.message}`);
    }
  }
}
ServiceURLService.$inject = ["apiRoutes", "store"];

const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

/** @typedef {import('../../types/api').Profile} Profile */

/**
 * This service handles fetching the user's profile, updating profile settings
 * and logging out.
 *
 * @inject
 */
class SessionService {
  /**
   * @param {import('../store').SidebarStore} store
   * @param {import('./api').APIService} api
   * @param {import('./auth').AuthService} auth
   * @param {import('../../types/config').SidebarSettings} settings
   * @param {import('./toast-messenger').ToastMessengerService} toastMessenger
   */
  constructor(store, api, auth, settings, toastMessenger) {
    var _serviceConfig$author, _serviceConfig;
    this._api = api;
    this._auth = auth;
    this._store = store;
    this._toastMessenger = toastMessenger;
    this._authority = (_serviceConfig$author = (_serviceConfig = serviceConfig(settings)) === null || _serviceConfig === void 0 ? void 0 : _serviceConfig.authority) !== null && _serviceConfig$author !== void 0 ? _serviceConfig$author : null;

    /** @type {Promise<Profile>|null} */
    this._lastLoad = null;

    /** @type {number|null} */
    this._lastLoadTime = null;

    // Re-fetch profile when user logs in or out in another tab.
    auth.on('oauthTokensChanged', () => this.reload());
  }

  /**
   * Fetch the user's profile from the annotation service.
   *
   * If the profile has been previously fetched within `CACHE_TTL` ms, then this
   * method returns a cached profile instead of triggering another fetch.
   *
   * @return {Promise<Profile>} A promise for the user's profile data.
   */
  load() {
    if (!this._lastLoad || !this._lastLoadTime || Date.now() - this._lastLoadTime > CACHE_TTL) {
      // The load attempt is automatically retried with a backoff.
      //
      // This serves to make loading the app in the extension cope better with
      // flakey connectivity but it also throttles the frequency of calls to
      // the /app endpoint.
      this._lastLoadTime = Date.now();
      this._lastLoad = retryPromiseOperation(() => {
        const opts = this._authority ? {
          authority: this._authority
        } : {};
        return this._api.profile.read(opts);
      }).then(session => {
        this.update(session);
        this._lastLoadTime = Date.now();
        return session;
      }).catch(err => {
        this._lastLoadTime = null;
        throw err;
      });
    }
    return this._lastLoad;
  }

  /**
   * Store the preference server-side that the user dismissed the sidebar
   * tutorial and then update the local profile data.
   */
  async dismissSidebarTutorial() {
    const updatedProfile = await this._api.profile.update({}, {
      preferences: {
        show_sidebar_tutorial: false
      }
    });
    this.update(updatedProfile);
  }

  /**
   * Update the local profile data.
   *
   * This method can be used to update the profile data in the client when new
   * data is pushed from the server via the real-time API.
   *
   * @param {Profile} profile
   * @return {Profile} The updated profile data
   */
  update(profile) {
    const prevProfile = this._store.profile();
    const userChanged = profile.userid !== prevProfile.userid;
    this._store.updateProfile(profile);
    this._lastLoad = Promise.resolve(profile);
    this._lastLoadTime = Date.now();
    if (userChanged) {
      // Associate error reports with the current user in Sentry.
      if (profile.userid) {
        setUserInfo({
          id: profile.userid
        });
      } else {
        setUserInfo(null);
      }
    }
    return profile;
  }

  /**
   * Log the user out of the current session and re-fetch the profile.
   */
  async logout() {
    try {
      await this._auth.logout();
      return this.reload();
    } catch (err) {
      this._toastMessenger.error('Log out failed');
      throw new Error(err);
    }
  }

  /**
   * Clear the cached profile information and re-fetch it from the server.
   *
   * This can be used to refresh the user's profile state after logging in.
   *
   * @return {Promise<Profile>}
   */
  reload() {
    this._lastLoad = null;
    this._lastLoadTime = null;
    return this.load();
  }
}
SessionService.$inject = ["store", "api", "auth", "settings", "toastMessenger"];

/**
 * Filter clause against which annotation updates are tested before being
 * sent to the client.
 *
 * @typedef FilterClause
 * @prop {'/group'|'/id'|'/references'|'/uri'} field
 * @prop {'equals'|'one_of'} operator
 * @prop {string|string[]} value
 * @prop {boolean} case_sensitive - TODO: Backend doesn't use this at present,
 *   but it seems important for certain fields (eg. ID).
 */

/**
 * @typedef Filter
 * @prop {string} match_policy - TODO: Remove this, the backend doesn't use it any more.
 * @prop {FilterClause[]} clauses
 * @prop {object} actions - TODO: Remove this, the backend doesn't use it any more.
 *  @prop {boolean} [actions.create]
 *  @prop {boolean} [actions.update]
 *  @prop {boolean} [actions.delete]
 */

/**
 * Return a filter which matches every update that is visible to the current user.
 *
 * @return {Filter}
 */
function defaultFilter() {
  return {
    match_policy: 'include_any',
    clauses: [],
    actions: {
      create: true,
      update: true,
      delete: true
    }
  };
}

/**
 * StreamFilter generates JSON-serializable configuration objects that
 * control which real-time updates are received from the annotation service.
 *
 * See https://github.com/hypothesis/h/blob/master/h/streamer/filter.py
 * for the schema.
 */
class StreamFilter {
  constructor() {
    this._filter = defaultFilter();
  }

  /**
   * Add a matching clause to the configuration.
   *
   * @param {FilterClause['field']} field - Field to filter by
   * @param {FilterClause['operator']} operator - How to filter
   * @param {FilterClause['value']} value - Value to match
   * @param {FilterClause['case_sensitive']} caseSensitive - Whether matching should be case sensitive
   */
  addClause(field, operator, value, caseSensitive = false) {
    this._filter.clauses.push({
      field,
      operator,
      value,
      case_sensitive: caseSensitive
    });
    return this;
  }

  /** Return the JSON-serializable filtering configuration. */
  getFilter() {
    return this._filter;
  }

  /** Reset the configuration to return all updates. */
  resetFilter() {
    this._filter = defaultFilter();
    return this;
  }
}

// Status codes indicating the reason why a WebSocket connection closed.
// See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent and
// https://tools.ietf.org/html/rfc6455#section-7.4.

// "Normal" closures.
const CLOSE_NORMAL = 1000;
const CLOSE_GOING_AWAY = 1001;

// "Abnormal" closures.
const CLOSE_ABNORMAL = 1006;

// There are other possible close status codes not listed here. They are all
// considered abnormal closures.

/**
 * Socket is a minimal wrapper around WebSocket which provides:
 *
 * - Serialization of JSON messages (see {@link send})
 * - An EventEmitter API
 * - Queuing of messages passed to send() whilst the socket is
 *   connecting
 */
class Socket extends TinyEmitter {
  /**
   * Connect to the WebSocket endpoint at `url`.
   *
   * @param {string} url
   */
  constructor(url) {
    super();

    /**
     * Queue of JSON objects which have not yet been submitted
     *
     * @type {object[]}
     */
    const messageQueue = [];

    /**
     * The active `WebSocket` instance
     *
     * @type {WebSocket}
     */
    let socket;
    const sendMessages = () => {
      while (messageQueue.length > 0) {
        const messageString = JSON.stringify(messageQueue.shift());
        socket.send(messageString);
      }
    };

    /**
     * Connect the WebSocket.
     */
    const connect = () => {
      socket = new WebSocket(url);
      socket.onopen = event => {
        sendMessages();
        this.emit('open', event);
      };
      socket.onclose = event => {
        if (event.code === CLOSE_NORMAL || event.code === CLOSE_GOING_AWAY) {
          this.emit('close', event);
          return;
        }
        const err = new Error(`WebSocket closed abnormally, code: ${event.code}`);
        console.warn(err);
        this.emit('disconnect');
      };
      socket.onerror = event => {
        this.emit('error', event);
      };
      socket.onmessage = event => {
        this.emit('message', event);
      };
    };

    /** Close the underlying WebSocket connection */
    this.close = () => {
      // nb. Always sent a status code in the `close()` call to work around
      // a problem in the backend's ws4py library.
      //
      // If no status code is provided in the `close()` call, the browser will
      // send a close frame with no payload, which is allowed by the spec.
      // ws4py however, will respond by sending back a close frame with a 1005
      // status code, which is not allowed by the spec. What ws4py should do in
      // that scenario is send back a close frame with no payload itself. This
      // invalid close frame causes browsers to report an abnormal WS
      // termination, even though nothing really went wrong.
      //
      // To avoid the problem, we just explicitly send a "closed normally"
      // status code here and ws4py will respond with the same status.
      socket.close(CLOSE_NORMAL);
    };

    /**
     * Send a JSON object via the WebSocket connection, or queue it
     * for later delivery if not currently connected.
     *
     * @param {object} message
     */
    this.send = message => {
      messageQueue.push(message);
      if (this.isConnected()) {
        sendMessages();
      }
    };

    /** Returns true if the WebSocket is currently connected. */
    this.isConnected = () => {
      return socket.readyState === WebSocket.OPEN;
    };
    connect();
  }
}

/**
 * `StreamerService` manages the WebSocket connection to the Hypothesis Real-Time
 * API [1]
 *
 * This service is responsible for opening the WebSocket connection and sending
 * messages to configure what notifications are delivered to the client.
 * Other services call `setConfig` to specify the filtering configuration.
 *
 * When notifications are received via the WebSocket, this service adds them to
 * the store. Depending on the update they may be applied immediately or added
 * to the "pending real time updates" state so that they can be applied by the
 * user at a convenient time.
 *
 * [1] https://h.readthedocs.io/en/latest/api/realtime/
 *
 * @inject
 */
class StreamerService {
  /**
   * @param {import('../store').SidebarStore} store
   * @param {import('./api-routes').APIRoutesService} apiRoutes
   * @param {import('./auth').AuthService} auth
   * @param {import('./groups').GroupsService} groups
   * @param {import('./session').SessionService} session
   */
  constructor(store, apiRoutes, auth, groups, session) {
    this._auth = auth;
    this._groups = groups;
    this._session = session;
    this._store = store;
    this._websocketURL = apiRoutes.links().then(links => links.websocket);

    /** The randomly generated session ID */
    this.clientId = generateHexString(32);

    /** @type {Socket|null} */
    this._socket = null;

    /**
     * Flag that controls whether to apply updates immediately or defer them
     * until "manually" applied via `applyPendingUpdates`
     */
    this._updateImmediately = true;

    /**
     * Client configuration messages, to be sent each time a new connection is
     * established.
     *
     * @type {Record<string, object>}
     */
    this._configMessages = {};

    /**
     * Number of automatic reconnection attempts that have been made following
     * an unexpected disconnection.
     */
    this._reconnectionAttempts = 0;
    this._reconnectSetUp = false;
  }

  /**
   * Apply updates to annotations which have been received but not yet
   * applied.
   */
  applyPendingUpdates() {
    const updates = Object.values(this._store.pendingUpdates());
    if (updates.length) {
      this._store.addAnnotations(updates);
    }
    const deletions = Object.keys(this._store.pendingDeletions()).map(id => ({
      id
    }));
    if (deletions.length) {
      this._store.removeAnnotations(deletions);
    }
    this._store.clearPendingUpdates();
  }

  /**
   * @param {string} websocketURL
   * @param {ErrorEvent} event
   */
  _handleSocketError(websocketURL, event) {
    warnOnce('Error connecting to H push notification service:', event);

    // In development, warn if the connection failure might be due to
    // the app's origin not having been whitelisted in the H service's config.
    //
    // Unfortunately the error event does not provide a way to get at the
    // HTTP status code for HTTP -> WS upgrade requests.
    const websocketHost = new URL(websocketURL).hostname;
    if (['localhost', '127.0.0.1'].indexOf(websocketHost) !== -1) {
      /* istanbul ignore next */
      warnOnce('Check that your H service is configured to allow ' + 'WebSocket connections from ' + window.location.origin);
    }
  }

  /** @param {MessageEvent} event */
  _handleSocketMessage(event) {
    const message = JSON.parse(event.data);
    if (!message) {
      return;
    }
    if (message.type === 'annotation-notification') {
      const annotations = message.payload;
      switch (message.options.action) {
        case 'create':
        case 'update':
        case 'past':
          this._store.receiveRealTimeUpdates({
            updatedAnnotations: annotations
          });
          break;
        case 'delete':
          this._store.receiveRealTimeUpdates({
            deletedAnnotations: annotations
          });
          break;
      }
      if (this._updateImmediately) {
        this.applyPendingUpdates();
      }
    } else if (message.type === 'session-change') {
      this._session.update(message.model);
      this._groups.load();
    } else if (message.type === 'whoyouare') {
      const userid = this._store.profile().userid;
      if (message.userid !== userid) {
        console.warn('WebSocket user ID "%s" does not match logged-in ID "%s"', message.userid, userid);
      }
    } else {
      warnOnce('Received unsupported notification', message.type);
    }
  }

  /** @param {Socket} socket */
  _sendClientConfig(socket) {
    Object.keys(this._configMessages).forEach(key => {
      if (this._configMessages[key]) {
        socket.send(this._configMessages[key]);
      }
    });
  }

  /**
   * Send a configuration message to the push notification service.
   * Each message is associated with a key, which is used to re-send
   * configuration data to the server in the event of a reconnection.
   *
   * @param {string} key
   * @param {object} configMessage
   */
  setConfig(key, configMessage) {
    var _this$_socket;
    this._configMessages[key] = configMessage;
    if ((_this$_socket = this._socket) !== null && _this$_socket !== void 0 && _this$_socket.isConnected()) {
      this._socket.send(configMessage);
    }
  }
  async _reconnect() {
    var _this$_socket2;
    const websocketURL = await this._websocketURL;
    if (!websocketURL) {
      return;
    }
    (_this$_socket2 = this._socket) === null || _this$_socket2 === void 0 ? void 0 : _this$_socket2.close();
    let token;
    try {
      token = await this._auth.getAccessToken();
    } catch (err) {
      console.error('Failed to fetch token for WebSocket authentication', err);
      throw err;
    }
    let url;
    if (token) {
      // Include the access token in the URL via a query param. This method
      // is used to send credentials because the `WebSocket` constructor does
      // not support setting the `Authorization` header directly as we do for
      // other API requests.
      const parsedURL = new URL(websocketURL);
      parsedURL.searchParams.set('access_token', token);
      url = parsedURL.toString();
    } else {
      url = websocketURL;
    }
    const newSocket = new Socket(url);
    newSocket.on('open', () => {
      this._reconnectionAttempts = 0;
      this._sendClientConfig(newSocket);
    });
    newSocket.on('disconnect', () => {
      ++this._reconnectionAttempts;
      if (this._reconnectionAttempts < 10) {
        // Reconnect with a delay that doubles on each attempt.
        // This reduces the stampede of requests if the WebSocket server has a
        // problem.
        const delay = 1000 * 2 ** this._reconnectionAttempts;
        setTimeout(() => this._reconnect(), delay);
      } else {
        console.error('Gave up trying to reconnect to Hypothesis real time update service');
      }
    });
    newSocket.on('error', /** @param {ErrorEvent} event */event => this._handleSocketError(websocketURL, event));
    newSocket.on('message', /** @param {MessageEvent} event */event => this._handleSocketMessage(event));
    this._socket = newSocket;

    // Configure the client ID
    this.setConfig('client-id', {
      messageType: 'client_id',
      value: this.clientId
    });

    // Send a "whoami" message. The server will respond with a "whoyouare"
    // reply which is useful for verifying that authentication worked as
    // expected.
    this.setConfig('auth-check', {
      type: 'whoami',
      id: 1
    });
  }

  /**
   * Connect to the Hypothesis real time update service.
   *
   * If the service has already connected this does nothing.
   *
   * @param {object} [options]
   *   @param {boolean} [options.applyUpdatesImmediately] - true if pending updates should be applied immediately
   * @return {Promise<void>} Promise which resolves once the WebSocket connection
   *    process has started.
   */
  async connect(options = {}) {
    var _options$applyUpdates;
    this._updateImmediately = (_options$applyUpdates = options.applyUpdatesImmediately) !== null && _options$applyUpdates !== void 0 ? _options$applyUpdates : true;

    // Setup reconnection when user changes, as auth token will have changed.
    if (!this._reconnectSetUp) {
      this._reconnectSetUp = true;
      watch(this._store.subscribe, () => this._store.profile().userid, () => this._reconnect());
    }
    if (this._socket) {
      return;
    }
    await this._reconnect();
  }
}
StreamerService.$inject = ["store", "apiRoutes", "auth", "groups", "session"];

/**
 * @typedef Tag
 * @prop {string} text - The label of the tag
 * @prop {number} count - The number of times this tag has been used.
 * @prop {number} updated - The timestamp when this tag was last used.
 */

const TAGS_LIST_KEY = 'hypothesis.user.tags.list';
const TAGS_MAP_KEY = 'hypothesis.user.tags.map';

/**
 * Service for fetching tag suggestions and storing data to generate them.
 *
 * The `tags` service stores metadata about recently used tags to local storage
 * and provides a `filter` method to fetch tags matching a query, ranked based
 * on frequency of usage.
 */
// @inject
class TagsService {
  /**
   * @param {import('./local-storage').LocalStorageService} localStorage -
   *   Storage used to persist the tags
   */
  constructor(localStorage) {
    this._storage = localStorage;
  }

  /**
   * Return a list of tag suggestions matching `query`.
   *
   * @param {string} query
   * @param {number|null} limit - Optional limit of the results.
   * @return {string[]} List of matching tags
   */
  filter(query, limit = null) {
    /** @type {string[]} */
    const savedTags = this._storage.getObject(TAGS_LIST_KEY) || [];
    let resultCount = 0;
    // Match any tag where the query is a prefix of the tag or a word within the tag.
    return savedTags.filter(tag => {
      if (limit !== null && resultCount >= limit) {
        // limit allows a subset of the results
        // See https://github.com/hypothesis/client/issues/1606
        return false;
      }
      // Split the string on words. An improvement would be to use a unicode word boundary
      // algorithm implemented by the browser (when available).
      // https://unicode.org/reports/tr29/#Word_Boundaries
      const words = tag.split(/\W+/);
      const regex = new RegExp(`^${escapeStringRegexp(query)}`, 'i'); // Only match the start of the string
      const matches = words.some(word => word.match(regex)) || tag.match(regex);
      if (matches) {
        ++resultCount;
        return true;
      }
      return false;
    });
  }

  /**
   * Update the list of stored tag suggestions based on the tags that a user has
   * entered for a given annotation.
   *
   * @param {string[]} tags - List of tags.
   */
  store(tags) {
    // Update the stored (tag, frequency) map.
    const savedTags = this._storage.getObject(TAGS_MAP_KEY) || {};
    tags.forEach(tag => {
      if (savedTags[tag]) {
        savedTags[tag].count += 1;
        savedTags[tag].updated = Date.now();
      } else {
        savedTags[tag] = {
          text: tag,
          count: 1,
          updated: Date.now()
        };
      }
    });
    this._storage.setObject(TAGS_MAP_KEY, savedTags);

    // Sort tag suggestions by frequency.
    const tagsList = Object.keys(savedTags).sort((t1, t2) => {
      if (savedTags[t1].count !== savedTags[t2].count) {
        return savedTags[t2].count - savedTags[t1].count;
      }
      return t1.localeCompare(t2);
    });
    this._storage.setObject(TAGS_LIST_KEY, tagsList);
  }
}
TagsService.$inject = ["localStorage"];

/**
 * @typedef {import('../helpers/build-thread').Thread} Thread
 */

/**
 * A service for performing operations related to the current set of threads.
 */
// @inject
class ThreadsService {
  /**
   * @param {import('../store').SidebarStore} store
   */
  constructor(store) {
    this._store = store;
  }

  /**
   * Make this thread and all of its children "visible". This has the effect of
   * "unhiding" a thread which is currently hidden by an applied search filter
   * (as well as its child threads). Only threads that are not currently visible
   * will be forced visible.
   *
   * @param {Thread} thread
   */
  forceVisible(thread) {
    thread.children.forEach(child => {
      this.forceVisible(child);
    });
    if (!thread.visible) {
      this._store.setForcedVisible(thread.id, true);
    }
  }
}
ThreadsService.$inject = ["store"];

// How long toast messages should be displayed before they are dismissed, in ms
const MESSAGE_DISPLAY_TIME = 5000;
// Delay before removing the message entirely (allows animations to complete)
const MESSAGE_DISMISS_DELAY = 500;

/**
 * Additional control over the display of a particular message.
 *
 * @typedef MessageOptions
 * @prop {boolean} [autoDismiss=true] - Whether the toast message automatically disappears.
 * @prop {string} [moreInfoURL=''] - Optional URL for users to visit for "more info"
 * @prop {boolean} [visuallyHidden=false] - When `true`, message will be visually
 *   hidden but still available to screen readers.
 */

/**
 * A service for managing toast messages. The service will auto-dismiss and
 * remove toast messages created with `#success()` or `#error()`. Added
 * messages may be manually dismissed with the `#dismiss()` method.
 */
// @inject
class ToastMessengerService {
  /**
   * @param {import('../store').SidebarStore} store
   */
  constructor(store) {
    this._store = store;
  }

  /**
   * Update a toast message's dismiss status and set a timeout to remove
   * it after a bit. This allows effects/animations to happen before the
   * message is removed entirely.
   *
   * @param {string} messageId - The value of the `id` property for the
   *                             message that is to be dismissed.
   */
  dismiss(messageId) {
    const message = this._store.getToastMessage(messageId);
    if (message && !message.isDismissed) {
      this._store.updateToastMessage({
        ...message,
        isDismissed: true
      });
      setTimeout(() => {
        this._store.removeToastMessage(messageId);
      }, MESSAGE_DISMISS_DELAY);
    }
  }

  /**
   * Add a new toast message to the store and set a timeout to dismiss it
   * after some time. This method will not add a message that is already
   * extant in the store's collection of toast messages (i.e. has the same
   * `type` and `message` text of an existing message).
   *
   * @param {('error'|'success'|'notice')} type
   * @param {string} messageText - The message to be rendered
   * @param {MessageOptions} options
   */
  _addMessage(type, messageText, {
    autoDismiss = true,
    moreInfoURL = '',
    visuallyHidden = false
  } = {}) {
    // Do not add duplicate messages (messages with the same type and text)
    if (this._store.hasToastMessage(type, messageText)) {
      return;
    }
    const id = generateHexString(10);
    const message = {
      type,
      id,
      message: messageText,
      moreInfoURL,
      visuallyHidden
    };
    this._store.addToastMessage({
      isDismissed: false,
      ...message
    });
    if (autoDismiss) {
      // Attempt to dismiss message after a set time period. NB: The message may
      // have been removed by other mechanisms at this point; do not assume its
      // presence.
      setTimeout(() => {
        this.dismiss(id);
      }, MESSAGE_DISPLAY_TIME);
    }
  }

  /**
   * Add an error toast message with `messageText`
   *
   * @param {string} messageText
   * @param {MessageOptions} [options]
   */
  error(messageText, options) {
    this._addMessage('error', messageText, options);
  }

  /**
   * Add a success toast message with `messageText`
   *
   * @param {string} messageText
   * @param {MessageOptions} [options]
   */
  success(messageText, options) {
    this._addMessage('success', messageText, options);
  }

  /**
   * Add a warn/notice toast message with `messageText`
   *
   * @param {string} messageText
   * @param {MessageOptions} [options]
   */
  notice(messageText, options) {
    this._addMessage('notice', messageText, options);
  }
}
ToastMessengerService.$inject = ["store"];

/**
 * @typedef Provider
 * @prop {unknown} [value] - The value for the object
 * @prop {Function} [class] - A class that should be instantiated to create the object
 * @prop {Function} [factory] - Function that should be called to create the object
 */

/**
 * @param {Provider} provider
 */
function isValidProvider(provider) {
  if (typeof provider !== 'object' || provider === null) {
    return false;
  }
  return 'value' in provider || typeof provider.class === 'function' || typeof provider.factory === 'function';
}

/**
 * `Injector` is a dependency injection container.
 *
 * It provides a convenient way to instantiate a set of named objects with
 * dependencies. Objects are constructed using a _provider_, which can be a
 * factory function, class constructor or value.
 *
 * If the provider is a factory function or constructor it may have dependencies
 * which are indicated by a `$inject` property on the function/class which
 * is a list of the names of the dependencies. The `$inject` property can be
 * added manually or by a compiler plugin (eg. `babel-plugin-angularjs-annotate`).
 *
 * To construct an object, call the `register` method with the name and provider
 * for the object and each of its dependencies, and then call
 * the `get` method to construct the object and its dependencies and return it.
 *
 * To run a function with arguments provided by the container, without registering
 * the function in the container for use by other factories or classes,
 * use the `run` method.
 */
class Injector {
  constructor() {
    // Map of name to object specifying how to create/provide that object.
    this._providers = new Map();

    // Map of name to existing instance.
    this._instances = new Map();

    // Set of instances already being constructed. Used to detect circular
    // dependencies.
    this._constructing = new Set();
  }

  /**
   * Construct or return the existing instance of an object with a given `name`
   *
   * @param {string} name - Name of object to construct
   * @return {unknown} - The constructed object
   */
  get(name) {
    if (this._instances.has(name)) {
      return this._instances.get(name);
    }
    const provider = this._providers.get(name);
    if (!provider) {
      throw new Error(`"${name}" is not registered`);
    }
    if ('value' in provider) {
      this._instances.set(name, provider.value);
      return provider.value;
    }
    if (this._constructing.has(name)) {
      throw new Error(`Encountered a circular dependency when constructing "${name}"`);
    }
    this._constructing.add(name);
    try {
      const resolvedDependencies = [];
      const dependencies = 'class' in provider && provider.class.$inject || 'factory' in provider && provider.factory.$inject || [];
      for (const dependency of dependencies) {
        try {
          resolvedDependencies.push(this.get(dependency));
        } catch (e) {
          const resolveErr = new Error(`Failed to construct dependency "${dependency}" of "${name}": ${e.message}`);
          // @ts-ignore - `cause` is a custom property
          resolveErr.cause = e;
          throw resolveErr;
        }
      }
      let instance;
      if (provider.class) {
        // eslint-disable-next-line new-cap
        instance = new provider.class(...resolvedDependencies);
      } else {
        const factory = provider.factory;
        instance = factory(...resolvedDependencies);
      }
      this._instances.set(name, instance);
      return instance;
    } finally {
      this._constructing.delete(name);
    }
  }

  /**
   * Register a provider for an object in the container.
   *
   * If `provider` is a function, it is treated like a class. In other words
   * `register(name, SomeClass)` is the same as `register(name, { class: SomeClass })`.
   *
   * @param {string} name - Name of object
   * @param {Function|Provider} provider -
   *   The class or other provider to use to create the object.
   * @return {this}
   */
  register(name, provider) {
    if (typeof provider === 'function') {
      provider = {
        class: provider
      };
    } else if (!isValidProvider(provider)) {
      throw new Error(`Invalid provider for "${name}"`);
    }
    this._providers.set(name, provider);
    return this;
  }

  /**
   * Run a function which uses one or more dependencies provided by the
   * container.
   *
   * @template T
   * @param {(...args: any[]) => T} callback -
   *   A callback to run, with dependencies annotated in the same way as
   *   functions or classes passed to `register`.
   * @return {any} - Returns the result of running the function.
   */
  run(callback) {
    const tempName = 'Injector.run';
    this.register(tempName, {
      factory: callback
    });
    try {
      return this.get(tempName);
    } finally {
      this._instances.delete(tempName);
      this._providers.delete(tempName);
    }
  }
}

var _jsxFileName = "/Users/abbander/dev/ksaa-nlp/hypothesis-client/src/sidebar/index.js";

// Read settings rendered into sidebar app HTML by service/extension.
const configFromSidebar = /** @type {import('../types/config').ConfigFromSidebar} */
parseJsonConfig(document);

// Check for known issues which may prevent the client from working.
//
// If any checks fail we'll log warnings and disable error reporting, but try
// and continue anyway.
const envOk = checkEnvironment(window);
if (configFromSidebar.sentry && envOk) {
  // Initialize Sentry. This is required at the top of this file
  // so that it happens early in the app's startup flow
  init(configFromSidebar.sentry);
}

// Prevent tab-jacking.
disableOpenerForExternalLinks(document.body);

/**
 * @param {import('./services/api').APIService} api
 * @param {import('./services/streamer').StreamerService} streamer
 * @inject
 */
function setupApi(api, streamer) {
  api.setClientId(streamer.clientId);
}

/**
 * Perform the initial fetch of groups and user profile and then set the initial
 * route to match the current URL.
 *
 * @param {import('./services/groups').GroupsService} groups
 * @param {import('./services/session').SessionService} session
 * @param {import('./services/router').RouterService} router
 * @inject
 */
setupApi.$inject = ["api", "streamer"];
function setupRoute(groups, session, router) {
  groups.load();
  session.load();
  router.sync();
}

/**
 * Initialize background processes provided by various services.
 *
 * These processes include persisting or synchronizing data from one place
 * to another.
 *
 * @param {import('./services/autosave').AutosaveService} autosaveService
 * @param {import('./services/persisted-defaults').PersistedDefaultsService} persistedDefaults
 * @param {import('./services/service-url').ServiceURLService} serviceURL
 * @inject
 */
setupRoute.$inject = ["groups", "session", "router"];
function initServices(autosaveService, persistedDefaults, serviceURL) {
  autosaveService.init();
  persistedDefaults.init();
  serviceURL.init();
}

/**
 * @param {import('./services/frame-sync').FrameSyncService} frameSync
 * @param {import('./store').SidebarStore} store
 * @inject
 */
initServices.$inject = ["autosaveService", "persistedDefaults", "serviceURL"];
function setupFrameSync(frameSync, store) {
  if (store.route() === 'sidebar') {
    frameSync.connect();
  }
}

// Register icons used by the sidebar app (and maybe other assets in future).
setupFrameSync.$inject = ["frameSync", "store"];
registerIcons(sidebarIcons);
function startApp(settings, appEl) {
  const container = new Injector();

  // Register services.
  container.register('annotationsService', AnnotationsService).register('annotationActivity', AnnotationActivityService).register('api', APIService).register('apiRoutes', APIRoutesService).register('auth', AuthService).register('autosaveService', AutosaveService).register('frameSync', FrameSyncService).register('groups', GroupsService).register('loadAnnotationsService', LoadAnnotationsService).register('localStorage', LocalStorageService).register('persistedDefaults', PersistedDefaultsService).register('router', RouterService).register('serviceURL', ServiceURLService).register('session', SessionService).register('streamer', StreamerService).register('streamFilter', StreamFilter).register('tags', TagsService).register('threadsService', ThreadsService).register('toastMessenger', ToastMessengerService).register('store', {
    factory: createSidebarStore
  });

  // Register utility values/classes.
  //
  // nb. In many cases these can be replaced by direct imports in the services
  // that use them, since they don't depend on instances of other services.
  container.register('$window', {
    value: window
  }).register('settings', {
    value: settings
  });

  // Initialize services.
  container.run(initServices);
  container.run(setupApi);
  container.run(setupRoute);
  container.run(startServer);
  container.run(setupFrameSync);

  // Render the UI.
  P$1(o(ServiceContext.Provider, {
    value: container,
    children: o(HypothesisApp$1, {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 180,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 179,
    columnNumber: 5
  }, this), appEl);
}

/**
 * @param {Error} error
 * @param {HTMLElement} appEl
 */
function reportLaunchError(error, appEl) {
  // Report error. In the sidebar the console log is the only notice the user
  // gets because the sidebar does not appear at all if the app fails to start.
  console.error('Failed to start Hypothesis client: ', error);

  // For apps where the UI is visible (eg. notebook, single-annotation view),
  // show an error notice.
  P$1(o(LaunchErrorPanel, {
    error: error
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 197,
    columnNumber: 10
  }, this), appEl);
}
const appEl = /** @type {HTMLElement} */
document.querySelector('hypothesis-app');

// Start capturing RPC requests before we start the RPC server (startRPCServer)
preStartServer();
buildSettings(configFromSidebar).then(settings => {
  startApp(settings, appEl);
}).catch(err => reportLaunchError(err, appEl));
//# sourceMappingURL=sidebar.bundle.js.map
